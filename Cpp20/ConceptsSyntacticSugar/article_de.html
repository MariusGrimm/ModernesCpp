<div class="vorspann">In meinem Blogbeitrag geht es nicht um ein neues Feature von Concepts, sondern um Syntactic Sugar. Ich beschäftige mich heute mit Abbreviated Function Templates, die es auf "sehr süße" Art erlauben, Templates zu definieren.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185533360_c22f69ca04.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">So lautet Wikipedias Definition von <a alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Syntactic%20Sugar%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSyntactic_sugar%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSyntactic_sugar%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://en.wikipedia.org/wiki/Syntactic_sugar" class="" href="https://en.wikipedia.org/wiki/Syntactic_sugar">Syntactic Sugar</a>: </div>
<div class="text">"In computer science, <b>syntactic sugar</b> is syntax within a programming language that is designed to make things easier to read or to express. It makes the language "sweeter" for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer." </div>
<div class="ztitel">Abbreviated Function Templates</div>
<div class="text">In meinem letzten Artikel zu <a href="/exec/mainmenu.pl?sid=74d958269856cac65617fd51b004fde6&amp;rm=open_article_id&amp;bid=2803441" class="" alt="%7B%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A2803441%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Concepts%20C%2B%2B20%3A%20Concepts%20-%20die%20Placeholder%20Syntax%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22B%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D74d958269856cac65617fd51b004fde6%26rm%3Dopen_article_id%26bid%3D2803441%22%2C%22user_params%22%3A%22%22%7D" title="Link auf Beitrag 2803441">Concepts C++20: Concepts - die Placeholder Syntax</a> ging ich darauf ein, dass wir seit C++14 eine starke Asymmetrie in C++ besitzen: Generische Lambda erlauben auf eine neue Art, Funktions-Templates zu definieren. Dazu muss lediglich <span class="tx_code">auto</span> als Parameter verwendet werden. Im Gegensatz dazu, lässt sich <span class="tx_code">auto</span> aber nicht als Parameter einer Funktion verwenden, um ein Funktions-Template zu erzeugen.</div>
<div class="pre">// genericLambdaFunction.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>auto addLambda = [](auto fir, auto sec){ return fir + sec; }; // (1)<br><br>auto addFunction(auto fir, auto sec){ return fir + sec; }&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(1, 5) &lt;&lt; " " &lt;&lt; addFunction(1, 5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(true, 5) &lt;&lt; " " &lt;&lt; addFunction(true, 5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(1, 5.5) &lt;&lt; " " &lt;&lt; addFunction(1, 5.5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; const std::string fir{"ge"};<br>&nbsp;&nbsp;&nbsp; const std::string sec{"neric"};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(fir, sec) &lt;&lt; " " &lt;&lt; addFunction(fir, sec) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Der Clang-Compiler spricht in diesem Fall eine eindeutige Sprache.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185533365_c8537497d8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wie seltsam! Ich kann zwar <span class="tx_code">auto</span> als Rückgabetyp und als Funktionsparameter eines Lambda-Ausdruckes (Zeile 1) verwenden, bei einer Funktion kann ich es aber nur als Rückgabetyp einsetzen. </div>
<div class="text">Nun kommt die gute Nachricht. Dieses inkonsistente Verhalten verschwindet mit C++20 und die Konsistenz geht mit Concepts weiter.</div>
<div class="pre">// conceptsIntegralVariationsDraft.cpp<br><br>#include &lt;type_traits&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>concept Integral = std::is_integral&lt;T&gt;::value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>requires Integral&lt;T&gt;<br>T gcd(T a, T b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ) return a;<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>T gcd1(T a, T b) requires Integral&lt;T&gt;{<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>template&lt;Integral T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>T gcd2(T a, T b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>Integral auto gcd3(Integral auto a, Integral auto b){ // (5)<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>auto gcd4(auto a, auto b){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd(100, 10)= "&nbsp; &lt;&lt;&nbsp; gcd(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd1(100, 10)= " &lt;&lt;&nbsp; gcd1(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd2(100, 10)= " &lt;&lt;&nbsp; gcd2(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd3(100, 10)= " &lt;&lt;&nbsp; gcd3(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd4(100, 10)= " &lt;&lt;&nbsp; gcd3(100, 10)&nbsp; &lt;&lt; std::endl; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Ich möchte zuerst kompakt die Fakten aus meinem vorherigen Artikel zu Concepts zusammenfassen. In der Zeile 1 definiere ich das Concept <span class="tx_code">Integral.</span> <span class="tx_code">gcd - gcd2</span> (Zeilen 2 - 4) wenden das Concept in verschiedenen Arten an. <span class="tx_code">gcd</span> besitzt eine Requires Clause, <span class="tx_code">gcd1</span> die sogenannte Trailing Requires Clause und <span class="tx_code">gcd2 </span>Constrained Template Parameters. </div>
<div class="text">Mit <span class="tx_code">gcd3</span> beginnt der Syntactic Sugar. Die Funktionsdeklaration Integral auto <span class="tx_code">gcd3(Integral auto a, Integral auto b) </span>fordert von seinen Typ-Parametern, dass diese das Concept <span class="tx_code">Integral</span> unterstützen. Aus der Anwendung des Concepts entsteht ein Funktions-Template, dass äquivalent zu den vorherigen Funktions-Templates <span class="tx_code">gcd - gcd2 ist.</span> </div>
<div class="text">Die neue syntaktische Form von <span class="tx_code">gcd</span>3 und <span class="tx_code">gcd4</span> heißt Abbreviated Function Templates.<span class="tx_code"> Integral auto</span> in der Deklaration von <span class="tx_code">gcd3</span> ist ein Constrained Placeholder (Concept). Es lässt sich aber auch ein Unconstrained Placeholder (<span class="tx_code">auto</span>) in der Funktionsdeklartion wie im Falle von <span class="tx_code">gcd4</span> (Zeile 4) einsetzen. Bevor ich ein paar Anmerkungen zur neuen Syntax mache, ist hier zuerst die Ausgabe des Programms: <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185533368_3e146c7192.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Durch die Verwendung eines Unconstrained Placeholders (<span class="tx_code">auto</span>) in der Funktionsdeklaration wird eine Funktions-Template erzeugt. Die zwei folgenden Funktionen sind äquivalent. </div>
<div class="pre">template&lt;typename T, typename T2&gt;<br>auto add(T fir, T2 sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}<br><br>auto add(auto fir, auto sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}</div>
<div class="text">Die entscheidende Beobachtung bei dem Beispiel ist es, dass die Argumente verschiedene Datentypen besitzen können. Das gleiche gilt für Concepts.</div>
<div class="pre">template&lt;Arithmetic T, Arithmetic T2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>auto sub(T fir, T2 sec){<br>&nbsp;&nbsp;&nbsp; return fir - sec;<br>}<br><br>Arithmetic auto sub(Arithmetic auto fir, Arithmetic auto sec){ // (2)<br>&nbsp;&nbsp;&nbsp; return fir - sec;<br>}<br></div>
<div class="text">Die Funktion <span class="tx_code">sub</span> fordert von ihren Argument <span class="tx_code">fir</span> und <span class="tx_code">sec,</span> dass beide das Concept Arithmetic unterstützen. Das heißt, du kannst <span class="tx_code">sub(5.5, 5)</span> aufrufen und dies ist für das Funktions-Template (Zeile 1) und die Funktion (Zeile 2) gültig. In beiden Fällen wird der Rückgabetyp gemäß den Regeln zur <a title="Link auf https://en.cppreference.com/w/c/language/conversion" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22arithmetischen%20Konvertierung%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2Flanguage%2Fconversion%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2Flanguage%2Fconversion%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="" href="https://en.cppreference.com/w/c/language/conversion">arithmetischen Konvertierung</a> bestimmt. Das Concept Arithmetic fordert von <span class="tx_code">fir</span> und <span class="tx_code">sec,</span> dass diese entweder Ganzzahlen oder Fließkommazahlen sind. Hier ist eine naheliegende Definition mithilfe der Type-Traits Funktions <a class="" href="https://en.cppreference.com/w/c/language/conversion" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2Flanguage%2Fconversion%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2Flanguage%2Fconversion%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22std%3A%3Ais_arithmetic%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://en.cppreference.com/w/c/language/conversion">std::is_arithmetic</a>.<br></div>
<div class="pre">template&lt;typename T&gt; <br>concept Arithmetic = std::is_arithmetic&lt;T&gt;::value; <br></div>
<div class="ztitel_kleiner">Ein Unterschied zwischen dem Concepts TS und dem Concepts Draft</div>
<div class="text">Ich bin explizit darauf eingegangen, dass beide Argumente verschiedene Datentypen in dem Concepts Draft besitzen können, denn darin unterscheidet sich die ursprüngliche Concepts-Syntax, die von dem GCC umgesetzt wurde. Die ursprüngliche Syntax basierte auf dem Concepts TS (Technical Specification). In dieser Syntax mussten die Datentypen von <span class="tx_code">fir</span> und <span class="tx_code">sec</span> identisch sein, sodass ein Aufruf der Funktion <span class="tx_code">sub(5.5, 5)</span> zum Compilerfehler führte. Zusätzlich verwendete die ursprüngliche Syntax kein zusätzliches <span class="tx_code">auto</span> bei der Verwendung von Concepts und die Definition des Concepts war ein wenig wortreicher.<br></div>
<div class="pre">// conceptsArithmeticTS.cpp<br><br>#include &lt;type_traits&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>concept bool Arithmetic(){<br>&nbsp;&nbsp;&nbsp; return std::is_arithmetic&lt;T&gt;::value;<br>}<br><br>Arithmetic sub(Arithmetic fir, Arithmetic sec){<br>&nbsp;&nbsp;&nbsp; return fir - sec;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sub(6, 5): " &lt;&lt; sub(6, 5) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sub(5.5, 5): " &lt;&lt; sub(5.5, 5) &lt;&lt; std::endl;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Aufgrund der Zeile 2 schlägt die Kompilierung des Programms mit dem Concepts TS fehl.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185533376_1f5fd4c5ab.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel_kleiner">Überladung<br></div>
<div class="text">Die Abbreviated-Function-Templates-Syntax verhält sich vollkommen intuitiv. Sie unterstützt das Überladen von Funktionen. Wie gewohnt, wählt der Compiler die am Besten passende Funktion aus.</div>
<div class="pre">// conceptsOverloading.cpp<br><br>#include &lt;type_traits&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>concept Integral = std::is_integral&lt;T&gt;::value;<br><br>void overload(auto t){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "auto : " &lt;&lt; t &lt;&lt; std::endl;<br>}<br><br>void overload(Integral auto t){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Integral : " &lt;&lt; t &lt;&lt; std::endl;<br>}<br><br>void overload(long t){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "long : " &lt;&lt; t &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; overload(3.14);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; overload(2010);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; overload(2020l);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Wenn die Funktion mit einem <span class="tx_code">double</span> (Zeile 1), einem <span class="tx_code">int</span> (Zeile 2) oder mit einem<span class="tx_code"> long int</span> aufgerufen wird (Zeile 3), wählt der Compiler die am besten passende Funktion aus. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Zwei Komponenten der Conceps fehlen noch in meiner Miniserie zu Concepts: Concepts definieren und die sogenannte Template Introduction, die lediglich Bestandteil des Concepts TS ist. Beide Komponenten sind natürlich das Thema meines nächsten Artikels. <br></div>
