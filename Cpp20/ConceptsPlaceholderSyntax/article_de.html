<div class="vorspann">Heute gebe ich eine einfache Antwort auf eine herausfordernde Frage: Wann lassen sich Concepts einsetzen? Sie lassen sich an den Stellen einsetzen, an den auto verwendet werden kann. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185095132_3eb597071a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Bevor ich über die Placeholder-Syntax und die neue Syntax für Funktions-Templates schreibe, möchte ich ein wenig ausholen. In C++11/14 gibt es einige Asymmetrien.</div>
<div class="ztitel">Von Asymmetrien in C++11/14 zu Symmetrien in C++20<br></div>
<div class="text">Ich habe öfters in meinem Seminar Diskussionen der folgenden Art:</div>
<div class="text">Was ist die Standard Template Library aus der Vogelperspektive? Generische Container die sich mit generischen Algorithmen manipulieren lassen. Das Bindeglied zwischen den beiden disjunkten Komponenten sind Iteratoren. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185095136_466464452e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Generische Container und generische Algorithmen bedeuten, dass sie nicht an einen speziellen Datentyp gebunden sind. Viele der Algorithmen lassen sich durch eine aufrufbare Einheit parametrisieren. So besitzt zum Beispiel <span class="tx_code">std::sort</span> eine Überladung, die ein binäres Prädikat (aufrufbare Einheit) annimmt. Das binäre Prädikat wird dabei auf die Elemente des Containers angewandt. Ein binäres Prädikat ist eine Funktion, die zwei Parameter besitzt und einen Wahrheitswert zurückgibt. Du kannst dafür eine Funktion, ein Funktionsobjekt oder mit C++11 einen Lambda-Ausdruck als binäres Prädikat verwenden.</div>
<div class="ztitel_kleiner">Eine leicht Asymmetrie in C++11<br></div>
<div class="text">Welchen konzeptionellen Fehler besitzt das folgende Programm? (Ich weiß, dass wir ein vordefiniertes Prädikat <span class="tx_code">std::greater</span> in C++ besitzen.)<br></div>
<div class="pre">// lambdaCpp11.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;array&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename Cont, typename Pred&gt;<br>void sortDescending(Cont&amp; cont, Pred pred){<br>&nbsp;&nbsp;&nbsp; std::sort(cont.begin(), cont.end(), pred);<br>}<br><br>template &lt;typename Cont&gt;<br>void printMe(const Cont&amp; cont){<br>&nbsp;&nbsp;&nbsp; for (auto c: cont) std::cout &lt;&lt; c &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std:: cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 10&gt; myArray{5, -10, 3, 2, 7, 8, 9, -4, 3, 4};<br>&nbsp;&nbsp;&nbsp; std::vector&lt;double&gt; myVector{5.1, -10.5, 3.1, 2.0, 7.2, 8.3};<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; myVector2{"Only", "for", "testing", "purpose"};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; sortDescending(myArray, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int fir, int sec){ return fir &gt; sec; });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; sortDescending(myVector, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](double fir, double sec){ return fir &gt; sec; }); &nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; sortDescending(myVector2,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const std::string&amp; fir, const std::string&amp; sec){ // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir &gt; sec; <br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; printMe(myArray);<br>&nbsp;&nbsp;&nbsp; printMe(myVector);<br>&nbsp;&nbsp;&nbsp; printMe(myVector2);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das Program besitzt ein <span class="tx_code">std::array</span> von<span class="tx_code"> int</span>s, einen <span class="tx_code">std::vector</span> von <span class="tx_code">double</span><i>s</i> und einen <span class="tx_code">std::vector</span> von <span class="tx_code">std::string</span>s. Alle Container sollen in absteigender Ordnung sortiert und ausgegeben werden. Um mir meinen Job möglichst einfach zu machen, verwendete ich die zwei Funktions-Templates <span class="tx_code">sortDescending</span> und <span class="tx_code">printMe</span>. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185095139_a92e8b9819.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Obwohl Conainter und Algorithmen generisch sind, besitzt C++11 lediglich typgebundene Lambdas. Daher muss ich ein binäres Prädikat für jeden Datentyp implementieren (Zeile 1 -3) und breche daher meinen generischen Weg. Mit C++14 verschwindet diese Asymmetrie. Container und Algorithmen sind generisch und Lambdas lassen sich generisch anwenden.</div>
<div class="ztitel_kleiner">Die starke Asymmetrie in C++20</div>
<div class="text">Mit C++14 wird die neue Implementierung des vorherigen Programms <i>lambdaCpp11.cpp</i> deutlich einfacher.</div>
<div class="pre">// lambdaCpp14.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;array&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename Cont&gt;<br>void sortDescending(Cont&amp; cont){<br>&nbsp;&nbsp;&nbsp; std::sort(cont.begin(), cont.end(), [](auto fir, auto sec){&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir &gt; sec; <br>&nbsp;&nbsp;&nbsp; });<br>}<br><br>template &lt;typename Cont&gt;<br>void printMe(const Cont&amp; cont){<br>&nbsp;&nbsp;&nbsp; for (auto c: cont) std::cout &lt;&lt; c &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std:: cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 10&gt; myArray{5, -10, 3, 2, 7, 8, 9, -4, 3, 4};<br>&nbsp;&nbsp;&nbsp; std::vector&lt;double&gt; myVector{5.1, -10.5, 3.1, 2.0, 7.2, 8.3};<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; myVector2{"Only", "for", "testing", "purpose"};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; sortDescending(myArray);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; sortDescending(myVector);&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; sortDescending(myVector2);&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; printMe(myArray);<br>&nbsp;&nbsp;&nbsp; printMe(myVector);<br>&nbsp;&nbsp;&nbsp; printMe(myVector2);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Alles gut? Ja und nein. Ja, da ich einen generischen Lambda-Ausdruck (Zeile 1) für jeden Datentyp in Zeile 2 verwenden kann. Nein, da ich die leichte Asymmetrie in C++11 mit einer starken Asymmetrie in C++14 ersetzt habe. Die leicht Asymmetrie in C++11 war, dass der Lambda-Ausdruck typgebunden war. Die starke Asymmetrie in C++14 ist es, dass generische Lambdas eine neue syntaktische Form definieren, um generische Funktion (Funktions-Templates) zu schreiben. Hier ist der Beweis.</div>
<div class="pre">// genericLambdaTemplate.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>auto addLambda = [](auto fir, auto sec){ return fir + sec; }; // (1)<br><br>template &lt;typename T, typename T2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>auto addTemplate(T fir, T2 sec){ return fir + sec; }<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(1, 5) &lt;&lt; " " &lt;&lt; addTemplate(1, 5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(true, 5) &lt;&lt; " " &lt;&lt; addTemplate(true, 5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(1, 5.5) &lt;&lt; " " &lt;&lt; addTemplate(1, 5.5) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; const std::string fir{"ge"};<br>&nbsp;&nbsp;&nbsp; const std::string sec{"neric"};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; addLambda(fir, sec) &lt;&lt; " " &lt;&lt; addTemplate(fir, sec) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Der generische Lambda-Ausdruck in Zeile 1 produziert die gleichen Ergebnisse wie das Funktions-Template in Zeile 2. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185095150_9ca26efbb1.png" title="<ir_inline itemname=bilder_mvp_bild:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Dies ist genau die Asymmetrie in C++14. Generische Lambdas führen eine neue Art Funktions-Template zu definieren ein. </div>
<div class="text">Wenn ich dies in meinen Seminaren erkläre, bekomme ich fast immer die Frage: Können wir <span class="tx_code">auto</span> in Funktionsdeklaration verwenden um Funktions-Templates zu erhalten? Nein, nicht mit C++17, aber mit C++20. In C++20 können Constrained Placeholders (Concepts) oder Unconstrained Placeholder (<span class="tx_code">auto</span>) in Funktionsdeklaration verwendet werden. Damit wird aus der Funktion ein Funktions-Template. Das heißt natürlich auch, dass die Asymmetrie in C++20 überwunden ist.</div>
<div class="ztitel_kleiner">Die Lösung in C++20</div>
<div class="text">Bevor ich mich mit der neuen Art Funktions-Templates zu definieren beschäftigen will, möchte ich mich ursprüngliche Frage beantworten: Wann lassen sich Concepts einsetzen? Concepts lassen sich an den Stellen einsetzen, an den <span class="tx_code">auto</span> verwendet werden kann. </div>
<div class="pre">// placeholdersDraft.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br>#include &lt;vector&gt;<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>concept Integral = std::is_integral&lt;T&gt;::value;<br><br>Integral auto getIntegral(int val){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; return val;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp; for (Integral auto i: vec) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp; // (3)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Integral auto b = true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; b &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Integral auto integ = getIntegral(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; integ &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; auto integ1 = getIntegral(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; integ1 &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Das Concept <span class="tx_code">Integral</span> in Zeile 1 lässt sich als Rückgabetyp (Zeile 2), in einer Range-base <span class="tx_code">for</span>-Schleife (Zeile 3), oder als Datentyp für die Variable<i> b</i> (Zeile 3) oder die Variable <span class="tx_code">integ</span> (Zeile 5) verwenden. Um die Symmetrie auf den Punkt zu bringen, wende ich in Zeile 6 Typdeduktion mit <span class="tx_code">auto</span> an. Ich muss zugeben, dass es zum jetzigen Zeitpunkt keinen Compiler gibt, der die für die Standardisierung vorgeschlagene Syntax, die ich in meinem Beispiel verwendete, vollständig unterstützt. Die folgende Ausgabe geht daher auf den GCC und die vorläufige Syntax des Concepts TS (Technical Specification) zurück.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185095156_5c4413596f.png" title="<ir_inline itemname=bilder_mvp_bild:7 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mein nächster Artikel beschäftigt sich mit dem Syntactic Sugar, den wir mit Constrained Placeholders (Concepts) und Unconstrained Placeholders (<span class="tx_code">auto</span>) in C++20 erhalten. Ich denke, die Funktion (das Funktions-Template) <span class="tx_code">getIntegral</span> gibt einen ersten Vorgeschmack. </div>
