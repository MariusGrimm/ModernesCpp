<div class="vorspann"><a title="Link auf Beitrag 2670989" alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A2670989%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dfb40bf5e6298a6128775fffa7deeb101%26rm%3Dopen_article_id%26bid%3D2670989%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22%22%2C%22text%22%3A%22Der%20letzter%20Blogbeitrag%20f%C3%BChrte%20Module%20ein%22%2C%22type%22%3A%22B%22%7D" href="/exec/mainmenu.pl?sid=fb40bf5e6298a6128775fffa7deeb101&amp;rm=open_article_id&amp;bid=2670989">Der letzter Blogbeitrag führte Module ein</a>, die C++20 erhalten wird. Nun wird gezeigt, wie sich bestehende Module verwenden lassen. <br></div><div class="text">Bevor ich den Artikel beginne, möchte ich zum Anschluss den letzten Artikels zu Modulen kurz zusammenfassen.</div><div class="ztitel">Eine kompakte Wiederholung<br></div><div class="text">Ich erzeugte im letzten Artikel das Modul <i>math1,</i> das aus einer Module-Interface-Unit und einer Module-Implementation-Unit bestand. Es wurde von einem Client verwendet. Dies sind die drei Dateien.</div><div class="ztitel_kleiner">Module-Interface-Unit</div><div class="pre">// math1.cppm<br><br>export module math1;<br><br>export int add(int fir, int sec);</div><div class="ztitel_kleiner">Module-Implementation-Unit</div><div class="pre">// math1.cpp<br><br>module math1;<br><br>int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}</div><div class="ztitel_kleiner">Client</div><div class="pre">// main1.cpp<br><br>import math1;<br><br>int main(){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; add(2000, 20);<br>&nbsp;&nbsp; <br>}</div><div class="text">Das Programm hatte ich mit einem aktuellen Clang- und cl.exe-Compiler übersetzt. Von nun an werde ich mich auf den cl.exe-Compiler einschränken, denn die Kommandozeile zum Übersetzen des Sourcecodes ist kürzer zu schreiben als die des Clang-Compilers. Wie ich in meinen letzten Artikel angekündigt habe, möchte ich nun die Ausgabe des Programms vorstellen.</div><div class="ztitel">Verwendung eins Standard-Moduls</div><div class="text">Im Wesentlichen hat sich weder die Module-Interface- noch die Module-Implementation-Unit im Modul math2 geändert.</div><div class="ztitel_kleiner">Module-Interface-Unit</div><div class="pre">// math2.cppm<br><br>export module math2;<br><br>export int add(int fir, int sec);</div><div class="ztitel_kleiner">Module-Implementation-Unit</div><div class="pre">// math2.cpp<br><br>module math2;<br><br>int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}</div><div class="ztitel_kleiner">Client</div><div class="pre">// main2.cpp<br><br>//#include &lt;iostream&gt;<br><br>import std.core;<br><br>import math2;<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "add(2000, 20): " &lt;&lt; add(2000, 20) &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>}</div><div class="text">Dank des Moduls <i>std.core</i> kann ich das Ergebnis der Addition ausgeben. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173873857_5e025a73ad.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Natürlich hätte ich auch die Header-Datei <i>&lt;iostream&gt;</i> verwenden können. Ich ahne die Frage schon: Welche Module stehen bereits zur Verfügung? Hier ist die Antwort direkt aus dem Artikel "<a href="https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fcpp-modules-in-visual-studio-2017%2F%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Using%20C%2B%2B%20Modules%20in%20Visual%20Studio%202017%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fcpp-modules-in-visual-studio-2017%2F%22%7D" title="Link auf https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/">Using C++ Modules in Visual Studio 2017</a>" des Microsoft C++-Team-Blogs.</div><div class="ztitel">C++ Modules in Visual Studio 2017 </div><div class="text"><ul><li><i>std.regex</i> bietet den Inhalt der Header-Datei <i>&lt;regex&gt; </i>an.<i><br></i></li><li><i>std.filesystem</i>&nbsp; bietet den Inhalt der Header-Datei <i>&lt;experimental/filesystem&gt; </i>an<i>.<br></i></li><li><i>std.memory</i> bietet den Inhalt der Head-Drdatei<i> &lt;memory&gt; </i>an.<i><br></i></li><li><i>std.threading</i> bietet den Inhalt der Header-Dateien <i>&lt;atomic&gt;, &lt;condition_variable&gt;, &lt;future&gt;, &lt;mutex&gt;, &lt;shared_mutex&gt; und &lt;thread&gt;</i> an<i>.<br></i></li><li><i>std.core</i> bietet den Rest der C++-Standard-Bibliothek an.</li></ul></div><div class="text">Module stellen eine höhere Abstraktion als Header-Dateien dar. Daher sind sie angenehm zu verwenden. Zusätzlich lässt sich explizit angeben, welcher Name eines Moduls exportiert werden soll.<br></div><div class="ztitel">Exportieren oder nicht exportieren</div><div class="text">Das nächste Modul <i>math3</i> ist ein wenig komplizierter als der vorherige. Hier ist das Interface:</div><div class="ztitel_kleiner">Module-Interface-Unit</div><div class="pre">// math3.cppm<br><br>import std.core;<br><br>export module math3;<br><br>int add(int fir, int sec);<br><br>export int mult(int fir, int sec);<br><br>export void doTheMath();</div><div class="text">Es enthält die exportierende Modul-Deklaration: <i>export module math3</i>;. Hier genau beginnt die Modul-Deklaration. Formal auch <b>module purview</b> genannt. Nur Namen, die nach der module purview mit <i>export</i> deklariert werden, werden exportiert. Falls nicht, sind die Namen außerhalb des Moduls nicht sichtbar und besitzen daher Modul-Bindung. Dies gilt insbesondere für die Funkion <i>add</i>, aber nicht für die Funktionen mult und <i>doTheMath</i>.&nbsp; <br></div><div class="ztitel_kleiner">Module-Implementation-Unit</div><div class="pre">// main3.cpp<br><br>// #include &lt;iostream&gt;&nbsp;&nbsp;&nbsp; // (1)<br>// #include &lt;numeric&gt;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>// #include &lt;string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>// #include &lt;vector&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>import std.core;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>import math3;<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "add(2000, 20): " &lt;&lt; add(2000, 20) &lt;&lt; std::endl;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; myVec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::string doc = "std::accumulate(myVec.begin(), myVec.end(), mult): "; <br>&nbsp;&nbsp; &nbsp;auto prod = std::accumulate(myVec.begin(), myVec.end(), 1, mult);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::cout &lt;&lt; doc &lt;&lt; prod &lt;&lt; std::endl; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;doTheMath();<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Ich habe nichts zu der Module-Imlementation-Unit hinzuzufügen. Das Hauptprogramm ist deutlich interessanter. <br></div><div class="ztitel_kleiner">Client</div><div class="pre">// main3.cpp<br><br>// #include &lt;iostream&gt;<br>// #include &lt;numeric&gt;<br>// #include &lt;string&gt;<br>// #include &lt;vector&gt;<br>import std.core;<br><br>import math3;<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // std::cout &lt;&lt; "add(2000, 20): " &lt;&lt; add(2000, 20) &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; myVec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::string doc = "std::accumulate(myVec.begin(), myVec.end(), mult): "; <br>&nbsp;&nbsp; &nbsp;auto prod = std::accumulate(myVec.begin(), myVec.end(), 1, mult);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::cout &lt;&lt; doc &lt;&lt; prod &lt;&lt; std::endl; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;doTheMath();<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Das kleine Programm zeigt bereits, dass Module angenehm anzuwenden sind. Anstelle der vier HeaderDdateien in den Zeilen (1) reicht ein einfacher <i>import std.core</i> Aufruf in der Zeile 2 aus. Das war es bereits. Hier ist die Ausgabe des Programms.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173873860_e46b11770a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Nun drängt sich natürlich die Frage auf: Was passiert, wenn ich die Zeile (3) verwende. Zur Erinnerung, die Funktion <i>add</i> wird nicht exportiert und besitzt daher Modul-Bindung. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173873868_a5f20e6604.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Der Compiler beschwert sich in diesem Fall, dass die Funkiton <i>add</i> verwendet wird, ihr Name aber nicht bekannt ist. <br></div><div class="ztitel">Weitere Details</div><div class="text">Zuerst einmal gibt es mehrere Möglichkeiten, Namen eines Moduls zu exportieren.</div><div class="ztitel_kleiner">Export<br></div><div class="text">Das Exportieren von Namen mit dem Export-Spezifizierer wie im Module <i>math3.cppm</i> ist aufwendig:</div><div class="text"><ul><li><b>Export-Spezifier</b></li></ul></div><div class="pre">// math3.cppm<br><br>import std.core;<br><br>export module math3;<br><br>int add(int fir, int sec);<br><br>export int mult(int fir, int sec);<br><br>export void doTheMath()</div><div class="text">Anstelle des Export-Specifiers lässt sich auch eine Exported-Gruppe verwenden:<br></div><div class="text"><ul><li><b>Exported-Gruppe</b></li></ul></div><div class="pre">// math3.cppm<br><br>import std.core;<br><br>export module math3;<br><br>int add(int fir, int sec);<br><br>export { <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; int mult(int fir, int sec);<br>&nbsp;&nbsp;&nbsp; void doTheMath();<br><br>}</div><div class="text">Die dritte Variation ist es, einen Exported-Namensraum einzusetzen:</div><div class="text"><ul><li><b>Exported-Namensraum</b></li></ul></div><div class="pre">// math3.cppm<br><br>import std.core;<br><br>export module math3;<br><br>namespace math3 {<br><br>&nbsp;&nbsp;&nbsp; int add(int fir, int sec);<br><br>}<br><br>export namespace math3 { <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; int mult(int fir, int sec);<br>&nbsp;&nbsp;&nbsp; void doTheMath();<br><br>}</div><div class="text">Alle drei Variationen sind äquivalent.</div><div class="text">Oft ist es praktisch, ein Modul zu reexportieren. </div><div class="ztitel_kleiner">Ein Modul reexportieren</div><div class="text">Manchmal möchtest du etwas aus einem Modul exportieren, dass du selbst importiert hast. Falls du das importierte Modul nicht exportierst, besitzt dieses konsequenterweise Modul-Bindung und seine Namen sind nicht außerhalb des Moduls sichtbar. Jetzt kommt ein konkretes Beispiel:</div><div class="text"><ul><li><b>Sichtbar versus nicht sichtbar</b></li></ul></div><div class="text">Stelle dir vor, ich möchte die Module <i>math.core</i> und <i>math.core2</i> in dem neuen Modul <i>math</i> verwenden. Hier sind die Module-Interface-Units der Module <i>math.core </i>und <i>math.core2</i>.</div><div class="text"><ul><li>Die reexportierten Module</li></ul></div><div class="pre">// module interface unit of math.core<br><br>export math.core<br><br>export int mult(int fir, int sec); </div><div class="pre">// module interface unit of math.core2<br><br>export math.core2<br><br>export int add(int fir, int sec); </div><div class="text">Weiter geht es. Dies ist da neue Modul <i>math</i>. </div><div class="text"><ul><li>Das neue Modul <i>math</i></li></ul></div><div class="pre">// module interface unit of math<br><br>export module math;<br><br>import math.core;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not exported with mult<br>export import math.core2;&nbsp;&nbsp; // exported with add<br><br><br>// module implementation unit of math<br><br>mult(1100, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fine<br>add(2000, 20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fine<br></div><div class="text">Wie es das Beispiel schön zeigt, ist es durchaus möglich; exportierte und nichtexportierte Namen im Modul <i>math</i> zu verwenden. Aber das Modul <i>math.core</i> wird nicht exportiert. Nur ein Client, der das Module <i>math</i> nutzt, bemerkt den Unterschied.</div><div class="text"><ul><li>Client</li></ul></div><div class="pre">// Client<br><br>import math<br><br>mult(1100, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ERROR<br>add(2000, 20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fine</div><div class="text">Die Funktion <i>mult</i> besitzt Modul-Bindung und ist daher nicht außerhalb des Moduls sichtbar. Lediglich die Funktion <i>add</i> ist sichtbar. </div><div class="text"><ul><li><b>Module umpacken</b></li></ul></div><div class="text">C++20 bietet eine komfortable Art, Module umzupacken. Stecke sie einfach in eine exportierende Gruppe:</div><div class="pre">export module math;<br><br>export{<br><br>&nbsp;&nbsp;&nbsp; import math.core;<br>&nbsp;&nbsp;&nbsp; import math.core2;<br>&nbsp;&nbsp;&nbsp; import math.basics;<br>&nbsp;&nbsp;&nbsp; <br>}</div><div class="text">Dadurch werden alle Namen für einen Client sichtbar, der das Modul <i>math</i> importiert. </div><div class="ztitel">Wie geht's weiter?</div><div class="text">Mit meinem nächsten Artikel beginne ich das letzte Hauptkapitel der C++ Core Guidelines: Regeln zur Standard Template Library. Glaube es oder auch nicht, viele professionelle C++-Entwickler setzen nicht die Standard Template Library ein. Dies gilt insbesondere für die Algorithmen der STL.<br></div>
