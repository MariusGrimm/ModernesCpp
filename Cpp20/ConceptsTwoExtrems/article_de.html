<div class="vorspann"><a alt="%7B%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22destination%22%3A2787777%2C%22subject%22%3A%22%22%2C%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Im%20letzten%20Blog-Artikel%20habe%20ich%20meinen%20%C3%9Cberblick%20zu%20C%2B%2B20%20abgeschlossen%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D3e5b1132d0305e7fbaa40d89a459f265%26rm%3Dopen_article_id%26bid%3D2787777%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf Beitrag 2787777" href="/exec/mainmenu.pl?sid=3e5b1132d0305e7fbaa40d89a459f265&amp;rm=open_article_id&amp;bid=2787777">Im letzten Blog-Artikel habe ich meinen Überblick zu C++20 abgeschlossen</a>. Jetzt ist es an der Zeit, die Features genauer unter die Lupe zu nehmen. Hierfür gibt es keinen besseren Einstieg als Concepts.</div>
<div class="text">Zugegebenermaßen, bin ich ein großer Fan von Concepts und daher parteiisch. Zuerst möchte ich Concepts motivieren.</div>
<div class="ztitel">Zwei Extreme<br></div>
<div class="text">Bis C++20 hatten wir in C++ zwei diametrale Optionen, mithilfe von Funktionen und Klassen Abstraktionen zu schaffen. Funktionen oder Klassen ließen sich für konkrete Datentypen oder generische Datentypen definieren. Im zweiten Fall nennen wir diese Funktions- oder Klassen-Templates. Warum sind beide Wege falsch? <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199474_dd65dd5bf1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel_kleiner">Zu spezifisch</div>
<div class="text">Es ist nahezu eine Herkulesaufgabe, für jeden konkreten Datentyp eine Funktion oder Klasse zu definieren. Um diese Last von unseren Schultern zu nehmen, kommen Typkonvertierungen ins Spiel. Doch was wie eine Rettung scheint, entpuppt sich oft als Fluch:<br></div>
<div class="pre">// tooSpecific.cpp<br><br>#include &lt;iostream&gt;<br><br>void needInt(int i){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "int: " &lt;&lt; i &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; double d{1.234};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "double: " &lt;&lt; d &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; needInt(d);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; bool b{true};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "bool: " &lt;&lt; b &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; needInt(b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Im ersten Fall (Zeile 1), starte ich mit einem <span class="tx_code">double</span>- und ende mit einem <span class="tx_code">int</span>-Wert (Zeile 2). Im zweiten Fall (Zeile 3) starte ich mit einem <span class="tx_code">bool</span>- und ende wieder mit einem <span class="tx_code">int</span>-Wert (Zeile 4).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199484_e6ffba8c61.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><ul><li><b>Narrowing Conversion</b></li></ul></div>
<div class="text">Der Aufruf von <span class="tx_code">getInt(int a)</span> mit einem <span class="tx_code">double</span>-Wert verursacht "narrowing conversion". Dieses ist eine Konvertierung mit Verlust der Datengenauigkeit. Das war sicherlich nicht die Absicht des Autors.<br></div>
<div class="text"><ul><li><b>Integral Promotion</b></li></ul></div>
<div class="text">Anders herum ist es aber auch nicht besser. Wird <span class="tx_code">getInt(int a)</span> mit einem <span class="tx_code">bool</span>-Wert aufgerufen, wird dieser auf einen <span class="tx_code">int</span>-Wert aufgeblasen. Überrascht? Viele C++ Entwickler wissen nicht, was passiert, wenn zwei Wahrheitswerte addiert werden:</div>
<div class="pre">template &lt;typename T&gt;<br>auto add(T first, T second){<br>&nbsp;&nbsp;&nbsp; return first + second;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; add(true, false);<br>}</div>
<div class="text"><a href="https://cppinsights.io/s/22249b6a" title="Link auf https://cppinsights.io/s/22249b6a" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F22249b6a%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F22249b6a%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" class="">C++ Insights</a> zeigt die ganze Wahrheit:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199490_4687b99c0e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Template-Instanziierung des Funktions-Templates <span class="tx_code">add</span> erzeugt eine vollständige Spezialisierung (Zeilen 6 bis 12), die den Rückgabetyp <span class="tx_code">int</span> besitzt.</div>
<div class="text">Meine feste Überzeugung ist es, dass wir nur aus praktischen Gründen die ganze Magie der Typkonvertierungen in C/C++ besitzen, um mit der Unzulänglichkeit umgehen zu können, dass Funktionen nur spezifische Datentypen annehmen können. </div>
<div class="text">Wenden wir nun die zweite Option an und nutzen keine spezifischen, sondern generische Datentypen. Vielleicht sind ja gerade Templates unsere Rettung.</div>
<div class="ztitel_kleiner">Zu generisch</div>
<div class="text">Hier ist mein erster Versuch: Sortieren ist ein ganz allgemeine Idee. Daher sollte sie auf jeden Container anwendbar sein, falls sich die Elemente des Containers sortieren lassen. Lasse mich <span class="tx_code">std::sort</span> auf eine <span class="tx_code">std::list</span> anwenden:<br></div>
<div class="pre">// sortList.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;list&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::list&lt;int&gt; myList{1, 10, 3, 2, 5};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::sort(myList.begin(), myList.end());<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Wow! Dies passiert, wenn du versuchst, das kleine Programm zu übersetzen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199494_6b5af8106d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Diese Fehlermeldung will ich nicht dechiffrieren. Was läuft hier falsch? Vielleicht hilft ein genauerer Blick auf die verwendete Überladung von <span class="tx_code">std::sort</span><i>.</i></div>
<div class="pre">template&lt; class RandomIt &gt;<br>void sort( RandomIt first, RandomIt last );</div>
<div class="text"><span class="tx_code">std::sort </span>verwendet den seltsam klingenden Name <i>RandomIt. </i>Es steht für einen random access iterator. Dies ist der Grund für die überwältigende Fehlermeldung, für die Templates berühmt-berüchtigt sind. Eine <span class="tx_code">std::list</span> bietet nur einen bidirectional iterator an, aber <span class="tx_code">std::sort</span> benötigt einen random access iterator. Die Struktur einer <span class="tx_code">std::list</span> macht diese Einschränkung offensichtlich. <br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199500_67aaf957ae.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wenn du genauer die Dokumentation zu <span class="tx_code">std::sort</span> auf <a href="https://en.cppreference.com/w/cpp/algorithm/sort" title="Link auf https://en.cppreference.com/w/cpp/algorithm/sort" class="" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fsort%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fsort%22%2C%22text%22%3A%22cppreference.com%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">cppreference.com</a> studierst, findest du etwas sehr Interessantes: Typanforderungen an <span class="tx_code">std::sort</span>.</div>
<div class="ztitel_kleiner">Concepte als Rettung</div>
<div class="text">Concepts sind die Rettung, denn sie definieren semantische Einschränkungen auf Template-Parametern.</div>
<div class="text">Hier sind die bereits erwähnten Typanforderungen zu <span class="tx_code">std::sort</span><i>.</i></div>
<div class="text"><ul><li>RandomIt must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/ValueSwappable" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FValueSwappable%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ValueSwappable%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FValueSwappable%22%2C%22alias%22%3A%22%22%7D" class="" title="Link auf https://en.cppreference.com/w/cpp/named_req/ValueSwappable">ValueSwappable</a> and <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="Link auf https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" class="" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FRandomAccessIterator%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FRandomAccessIterator%22%2C%22text%22%3A%22LegacyRandomAccessIterator.%22%7D">LegacyRandomAccessIterator.</a> </li><li>The type of dereferenced RandomIt must meet the requirements of <a title="Link auf https://en.cppreference.com/w/cpp/named_req/MoveAssignable" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FMoveAssignable%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22MoveAssignable%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FMoveAssignable%22%7D" class="" href="https://en.cppreference.com/w/cpp/named_req/MoveAssignable">MoveAssignable</a> and <a class="" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22MoveConstructible%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FMoveConstructible%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FMoveConstructible%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/named_req/MoveConstructible" href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible">MoveConstructible</a>.</li><li>Compare must meet the requirements of <a title="Link auf https://en.cppreference.com/w/cpp/named_req/Compare" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FCompare%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FCompare%22%2C%22text%22%3A%22Compare%22%7D" class="" href="https://en.cppreference.com/w/cpp/named_req/Compare">Compare</a>.</li></ul></div>
<div class="text">Die Typanforderungen an <span class="tx_code">std::sort</span> sind Concepte. Mein Artikel "<a title="Link auf Beitrag 2776536" alt="%7B%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%3A%20Die%20vier%20gro%C3%9Fen%20Neuerungen%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D3e5b1132d0305e7fbaa40d89a459f265%26rm%3Dopen_article_id%26bid%3D2776536%22%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22destination%22%3A2776536%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="" href="/exec/mainmenu.pl?sid=3e5b1132d0305e7fbaa40d89a459f265&amp;rm=open_article_id&amp;bid=2776536">C++20: Die vier großen Neuerungen</a>" gibt eine kompakte Einführung zu Concepts. Insbesondere fordert <span class="tx_code">std::sort</span> einen <a title="Link auf https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FRandomAccessIterator%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22%5Bcode%5DLegacyRandomAccessIterator%5B%2Fcode%5D.%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FRandomAccessIterator%22%7D" href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">[code]LegacyRandomAccessIterator[/code].</a> Darauf will ich gerne einen&nbsp; genaueren Blick werfen. Das Beispiel von <a class="" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22cppreference.com%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FRandomAccessIterator%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%2FRandomAccessIterator%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">cppreference.com</a> habe ich ein wenig poliert:<br></div>
<div class="pre">template&lt;typename It&gt;<br>concept LegacyRandomAccessIterator =<br>&nbsp; LegacyBidirectionalIterator&lt;It&gt; &amp;&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::totally_ordered&lt;It&gt; &amp;&amp;<br>&nbsp; requires(It i, typename std::incrementable_traits&lt;It&gt;::difference_type n) {<br>&nbsp;&nbsp;&nbsp; { i += n } -&gt; std::same_as&lt;It&amp;&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; { i -= n } -&gt; std::same_as&lt;It&amp;&gt;;<br>&nbsp;&nbsp;&nbsp; { i +&nbsp; n } -&gt; std::same_as&lt;It&gt;;<br>&nbsp;&nbsp;&nbsp; { n +&nbsp; i } -&gt; std::same_as&lt;It&gt;;<br>&nbsp;&nbsp;&nbsp; { i -&nbsp; n } -&gt; std::same_as&lt;It&gt;;<br>&nbsp;&nbsp;&nbsp; { i -&nbsp; i } -&gt; std::same_as&lt;decltype(n)&gt;;<br>&nbsp;&nbsp;&nbsp; {&nbsp; i[n]&nbsp; } -&gt; std::convertible_to&lt;std::iter_reference_t&lt;It&gt;&gt;;<br>&nbsp; };<br></div>
<div class="text">Dies ist die entscheidende Beobachtung. Ein Datentyp <span class="tx_code">It</span> unterstützt das Concept <span class="tx_code">LegacyRandomAccessIterator</span> genau dann, wenn er das Concept <span class="tx_code">LegacyBidirectionalIterator</span> (Zeile 1) und die weiteren Anforderungen unterstützt. Zum Beispiel sagt die Anforderung in Zeile 2 für einen Wert des Datentyps <span class="tx_code">It</span> aus: <span class="tx_code">{ i += n }</span> muss gültig sein und eine Referenz auf <span class="tx_code">It</span> zurückgeben. Um mit meiner Story zum Abschluss zu kommen. <span class="tx_code">std::list</span> unterstützt nur einen <span class="tx_code">LegacyBidirectionalIterator</span><i>.</i></div>
<div class="text">Zugegeben, dieser Abschnitt war sehr technisch. Jetzt folgt die Praxis. Mit Concepts wirst du eine einfache Fehlermeldung wie die folgende erhalten, wenn du <span class="tx_code">std::sort</span> mit einer <span class="tx_code">std::list</span> erhältst: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199521_e329973439.png" title="<ir_inline itemname=bilder_mvp_bild:9 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Sorry, die Fehlermeldung war eine Ente, denn kein Compiler setzt zum jetzigen Zeitpunkt die C++20-Syntax für Concepts vollständig um. MSVC 19.23 unterstützt Concepts teilweise, GCC eine vorherige Version von Concepts. <a href="https://en.cppreference.com/w/cpp/compiler_support" title="Link auf https://en.cppreference.com/w/cpp/compiler_support" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22text%22%3A%22cppreference.com%22%2C%22target%22%3A%22_blank%22%7D" class="">cppreference.com</a> liefert mehr Details zur aktuellen Compilerunterstützung von Concepts. </div>
<div class="text">Habe ich gesagt, dass GCC ein vorherige Version von Conceps unterstützt? </div>
<div class="ztitel">Die lange, lange Geschichte</div>
<div class="text">Das erste Mal, als ich um 2005/2006 mit Concepts in Berührung kam, erinnerten sie mich an Haskells Typklassen. Typklassen in Haskell sind Interface für ähnliche Datentypen. Das Bild zeigt einen Ausschnitt aus Haskells Typklassenhierachie: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184199528_dc022358ab.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Doch C++ Concepts unterscheiden sich von Haskells Typklassen. Hier sind ein paar Beobachtungen.</div>
<div class="text"><ul><li> In Haskell muss ein Datentyp eine Instanz einer Typklasse sein. In C++20 muss ein Datentyp die Anforderungen eines Concepts erfüllen.</li><li>Concepts lassen sich auch auf "non-type parameter" anwenden. Zum Beispiel kann die Zahl 5 als non-type parameter verwendet werden. Wenn du ein <span class="tx_code">std::array</span> von <span class="tx_code">int</span>s mit 5 Elementen haben möchtest, wendest du diesen non-type parameter an: <span class="tx_code">std::array&lt;int, 5&gt; myVec</span><i>. <br></i></li><li>Concepts besitzen keine Laufzeitkosten.</li></ul></div>
<div class="text">Ursprünlich sollten Concepts bereits das große Feature von C++11 sein. In dem Standardisierungsmeeting in Frankfurt wurden sie aber im Juli 2009 entfernt. Das Zitat von Bjarne Stroustrup spricht für sich selbst: "The C++Ox concept design evolved into a monster of complexity." Ein paar Jahre später war der nächste Versuch, Concepts zu standardisieren, wieder erfolglos. Concept lite wurden aus C++17 entfernt. Nun bekommen wir sie aber mit C++20.</div>
<div class="utitel">Wie geht's weiter? </div>
<div class="text">Mit meinem nächsten Artikel knüpfe ich natürlich an Concepts an. Ich werde viele Beispiele zu semantischen Einschränkungen auf Template-Parameter vorstellen.<br></div>