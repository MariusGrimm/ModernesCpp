<div class="vorspann">Module sind eines der fünf großen Features von C++20. Sie sollen die Einschränkungen von Header-Dateien überwinden. Sie versprechen aber noch mehr.</div><div class="text">Mit Modulen soll die Trennung von Header-Dateien und Implementierungsdateien genauso der Vergangenheit angehören wie der Präprozessor. Letztlich soll das Übersetzen der Software deutlich schneller werden und es soll einfacher werden, Pakete zu schnüren.</div><div class="text">Module aus der Perspektive des Anwenders vorzustellen, ist relativ einfach. Das gilt aber nicht für die Perspektive des Implementierers. Mein Plan für den heutigen Artikel ist es, mit einem einfachen Programm zu beginnen und sukzessive mehr Features hinzuzufügen.</div><div class="ztitel">Ein erstes Beispiel</div><div class="text">Hier ist bereits das erste Modul <i>math</i>:</div><div class="pre">// math.cppm<br><br>export module math;<br><br>export int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>} </div><div class="text">Der Ausdruck <i>export module math </i>steht für die Moduldeklaration. Dank des Schlüsselworts <i>export </i>vor der Funktion <i>add</i> wird diese Funktion exportiert und kann damit von einem Anwender verwendet werden:</div><div class="pre">// main.cpp<br><br>import math;<br><br>int main(){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; add(2000, 20);<br>&nbsp;&nbsp; <br>}</div><div class="text"><i>import math </i>importiert das Modul <i>math </i>und bewirkt, dass die exportierten Namen in der Datei <i>main.cpp </i>sichtbar werden. Das war der einfache Teil meiner Aufgabe. Die Herausforderung beginnt dann, wenn ich das Programm übersetze. </div><div class="ztitel_kleiner">Die Modul-Deklarationsdatei<br></div><div class="text">Ist dir der seltsame Namen <i>math.cppm</i> des Modules aufgefallen? </div><div class="text"><ul><li> Das Suffix <i>cppm</i> steht wohl für cpp-Moduldeklaration und ist das Akronym, das Clang verwendet.</li><li><i>cl.exe</i> verwende das Suffix <i>ixx</i>. Ich nehme an, in diesem Fall steht das <i>i </i>für Interface.</li><li>Für den GCC kenne ich kein Suffix. <br></li></ul></div><div class="ztitel_kleiner">Das Modul <i>math</i> übersetzen<br></div><div class="text">Um das Modul zu übersetzen, solltest du einen sehr aktuellen Clang order <i>cl.exe</i>-Compiler verwenden. Es ist auch möglich, den GCC einzusetzen. In meinen Artikel werde ich mich aber auf den Clang- und <i>cl.exe</i>-Compiler beschränken. Hier sind mehr Details zu meinen Compilern:</div><div class="text"><ul><li> Clang</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173454990_13f2215d4c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li><i>cl.exe</i></li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173454994_6484143e5f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Genau hier ist der Punkt, an dem der Spaß losging: Die Kommandozeile für Clang++ und <i>cl.exe</i> zu bestimmen:</div><div class="pre">clang++ -std=c++2a -fmodules-ts --precompile math.cppm -o math.pcm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>clang++ -std=c++2a -fmodules-ts -c math.pcm -o math.o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>clang++ -std=c++2a -fmodules-ts -fprebuilt-module-path=. math.o main.cpp -o math&nbsp;&nbsp;&nbsp;&nbsp; // 3<br><br><br>cl.exe /std:c++latest /experimental:module /TP /EHsc /MD /c math.cppm /module:interface /Fo: math.obj /module:output math.pcm // 1<br>cl.exe /std:c++latest /experimental:module /TP /EHsc /MD /c main.cpp /module:reference math.pcm /Fo: main.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>cl.exe math.obj main.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br></div><div class="text"><ol><li>Erzeugt aus der Moduledeklaration <i>math.cppm</i> ein vorcompiliertes Modul <i>math.pcm</i>.</li><li>Erzeugt eine Übersetzungseinheit <i>math.o</i>, die kein Modul darstellt.</li><li>Erzeugt eine ausführbare Datei <i>math</i> oder <i>math.exe</i>. clang++ benötigt hier noch den Pfad zum Modul.</li></ol></div><div class="text">Naheliegenderweise zeige ich nicht die Ausgabe des Programms. Das hole ich später nach, wenn es etwas zu zeigen gibt.</div><div class="text">Aus Sicht des Implementierers kann die Moduldefinition in ein Interface und eine Implementierung separiert werden. Bevor ich auf diesen Punkt genauer eingehen, möchte ich erst einen Schritt rückwärts gehen und die folgende Frage beantworten.<br></div><div class="ztitel">Was sind die Vorteile von Modulen?</div><div class="text"><ul><li><b>Schnellere Übersetzungszeiten</b>: Ein Modul wird nur einmal importiert. Dies sollte buchstäblich nichts kosten. Vergleiche dies mit M Header-Dateien, die in N Übersetzungseinheiten inkludiert werden. Die kombinatorische Explosion bedeutet in diesem Fall, dass die Header-Datei <i>M * N</i>-mal evaluiert werden muss. <br></li><li><b>Isolation von Makros:</b> Falls es einen Konsens in der C++-Community gibt, dann der, dass wir die Präprozessor-Makros loswerden sollten. Warum? Die Verwendung eines Makros ist nur Textersetzung ohne Verständnis der C++-Semantik. Das hat viele negative Konsequenzen. Zum Beispiel kann das Verhalten davon abhängig sein, in welcher Reihenfolge Makros inkludiert werden oder Makros können mit bereits definierten Makros oder Namen deiner Applikation kollidieren. Im Gegensatz dazu ist es unerheblich, in welcher Reihenfolge Module importiert werden.</li><li><b>Ausdruck der logischen Struktur deines Codes:</b> Module erlauben es auszudrücken, welcher Name exportiert oder nicht exportiert werden soll. Du kannst auch ein paar Module in einem Modul verpacken und sie deinem Kunde als ein logisches Paket anbieten.</li><li><b>Keine Header-Dateien notwendig</b>: Es gibt keine Notwendigkeit mehr, deine Quelldateien in Interface- und Implementierungseinheiten zu trennen. Das bedeutet, dank Modulen wird die Anzahl der Quelldateien halbiert. <br></li><li><b>Hässliche Workarounds loswerden</b>: Wir haben uns bereits an hässliche Workarounds wie "verpacke deine Header-Datei in einen Include-Guard" oder "schreibe Makros mit LONG_UPPERCASE_NAMES" gewöhnt. Im Gegensatz dazu führen identische Namen in Modulen zu keiner Namenskollision.<br></li></ul></div><div class="text">Mein erstes Modul <i>math</i> habe ich in einem Modul <i>math.cppm</i> definiert. Es gibt neue Einheiten für Module.<br></div><div class="ztitel">Modul-Interface-Einheit und Modulimplementierungseinheit<br></div><div class="text">Zuerst mal besteht das neue Modul <i>math1</i> aus einer Modul-Interface-Einheit und einer Modulimplementierungseinheit.</div><div class="ztitel_kleiner">Modul-Interface-Einheit<br></div><div class="pre">// math1.cppm<br><br>export module math1;<br><br>export int add(int fir, int sec);<br></div><div class="text"><ul><li>Die Modul-Interace-Einheit enthält die exportierende Moduldeklaration: <i>export module math1</i>.</li><li>Namen wie <i>add</i> können nur in der Modul-Interface-Einheit exportiert werden.</li><li>Namen, die nicht exportiert werden, sind außerhalb des Moduls nicht sichtbar. Auf diesen Punkt werde ich noch genauer in meinem nächsten Artikel eingehen.</li><li>Ein Modul kann nur eine Modul-Interface-Einheit besitzen.<br></li></ul></div><div class="ztitel_kleiner">Modulimplementierungseinheit</div><div class="pre">// math1.cpp<br><br>module math1;<br><br>int add(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; return fir + sec;<br>}</div><div class="text"><ul><li> Die Modulimplementierungseinheit enthält die nicht exportierende Moduldeklaration: <i>module math1;</i></li><li>Ein Modul kann mehr als eine Modulimplementierungseinheit besitzen.</li></ul></div><div class="ztitel_kleiner"><i>main</i>-Programm<br></div><div class="pre">// main1.cpp<br><br>import math1;<br><br>int main(){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; add(2000, 20);<br>&nbsp;&nbsp; <br>}</div><div class="text"><ul><li> Aus der Sicht des Anwenders hat sich nichts durch das neue Modul geändert. Lediglich der Name des Moduls ist nun <i>math1</i>.</li></ul></div><div class="text">Das Übersetzen des Programms ist wieder deutlich anspruchsvoller.</div><div class="ztitel_kleiner">Übersetzen des Moduls <i>math1</i><br></div><div class="pre">clang++ -std=c++2a -fmodules-ts --precompile math1.cppm -o math1.pcm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>clang++ -std=c++2a -fmodules-ts&nbsp; -c math1.pcm -o math1.pcm.o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>clang++ -std=c++2a -fmodules-ts -c math1.cpp -fmodule-file=math1.pcm -o math1.o&nbsp;&nbsp;&nbsp; // 2<br>clang++ -std=c++2a -fmodules-ts -c main1.cpp -fmodule-file=math1.pcm -o main1.o&nbsp;&nbsp;&nbsp; // 3<br>clang++&nbsp; math1.pcm main1.o math1.o -o math&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4<br><br>cl.exe /std:c++latest /experimental:module /TP /EHsc /MD /c math1.cppm /module:interface /Fo: math1.pcm.obj /module:output math1.pcm&nbsp; // 1<br>cl.exe /std:c++latest /experimental:module /TP /EHsc /MD /c math1.cpp /module:reference math1.pcm /Fo: math1.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>cl.exe /std:c++latest /experimental:module /TP /EHsc /MD /c main1.cpp /module:reference math1.pcm /Fo: main1.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>cl.exe math1.obj main1.obj math1.pcm.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4<br></div><div class="text"><ol><li>Erzeugt aus der Moduldeklaration <i>math1.cppm</i> ein vorkompiliertes Modul <i>math1.pcm</i>.</li><li>Übersetzt das vorkompilierte Modul <i>math1.pcm</i>. Übersetzt die Quelldatei <i>math1.cpp</i>: <i>math1.o</i>. <i>cl.exe</i> führt beides in einem Schritt aus.<br></li><li>Übersetzt das <i>main</i>-Programm: <i>math1.o</i> oder <i>math.obj.</i><br></li><li>Erzeugt eine ausführbare Datei<i> math</i>1 oder <i>math1.exe</i>. <br></li></ol></div><div class="ztitel">Wie geht's weiter? </div><div class="text">Wie versprochen, stellt dieser Artikel nur die Einleitung zu Modulen dar. In meinem nächsten Artikel werde ich mehr in die Untiefen abtauen. Insbesondere werde ich die Ausgabe des Programms darstellen. Dazu muss ich aber die Header-Datei <i>&lt;iostream&gt;</i> inkludieren oder das Modul <i>std.core </i>importieren. </div><div class="ztitel">C++-Schulungen im Großraum Stuttgart</div><div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div><div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" alt="%7B%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438">Embedded-Programmierung mit modernem C++</a>: 21.bis 23.05.19 </li><li> <a href="https://www.modernescpp.de/index.php/c/2-c/20-c-11-und-c-1420190311073407" alt="%7B%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F20-c-11-und-c-1420190311073407%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F20-c-11-und-c-1420190311073407%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://www.modernescpp.de/index.php/c/2-c/20-c-11-und-c-1420190311073407">C++11 und C++14</a>: 25. bis 27.06.19 <br></li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/21-generische-programmierung-templates-mit-c20190311073743" href="https://www.modernescpp.de/index.php/c/2-c/21-generische-programmierung-templates-mit-c20190311073743" alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F21-generische-programmierung-templates-mit-c20190311073743%22%2C%22text%22%3A%22Generische%20Programmierung%20%28Templates%29%20mit%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F21-generische-programmierung-templates-mit-c20190311073743%22%7D">Generische Programmierung (Templates) mit C++</a>: 13. bis 15.08.19 </li></ul></div><div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://www.modernescpp.de/" title="Link auf https://www.modernescpp.de/">www.ModernesCpp.de</a>. </div>