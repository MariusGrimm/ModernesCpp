<div class="vorspann">C++20 wird der nächste große C++-Standard nach C++11 sein. Wie C++11, wird C++20 die Art und Weise ändern, wie wir in modernem C++ programmieren. Dies gilt vor allem für Ranges, Coroutinen, Concepts und Module. Um den nächsten großen Evolutionsschritt in C++ besser zu verstehen, möchte ich zuerst C++20 in den Kontext der bestehenden C++-Standards stellen. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182095771_7565e98409.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Die C++-Standards<br></div>
<div class="ztitel_kleiner">C++98</div>
<div class="text">Ende der 80er-Jahre gab es mehrere unabhängige C++-Implementierungen. Daher legten Bjarne Stroustrup und Margaret A. Ellis 1989 in ihrem Buch <a title="Link auf http://www.stroustrup.com/arm.html" class="" href="http://www.stroustrup.com/arm.html" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.stroustrup.com%2Farm.html%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.stroustrup.com%2Farm.html%22%2C%22text%22%3A%22The%20Annotated%20C%2B%2B%20Reference%20Manual%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D">The Annotated C++ Reference Manual</a> (ARM C++) den Funktionsumfang von C++ fest. Darüber hinaus erfüllte ARM C++ noch eine zweite, wichtige Aufgabe. Er bildete die Grundlage für den ersten ISO-C++-Standard ISO/IEC 14882:1998 (C++98). C++98 besitzt sehr wichtige Features: Templates, die Standard Template Library (STL) mit ihren Containern und Algorithmen, Strings und IO-Streams.</div>
<div class="ztitel_kleiner">C++03</div>
<div class="text">Mit C++03 (ISO/IEC 14882:2003) erfuhr C++98 eine technische Korrektur, die so marginal ist, dass ich sie auf meinem Zeitstrahl nicht berücksichtige. In der Community wird C++03, das C++98 einschließt, schlicht Legacy C++ genannt. </div>
<div class="ztitel_kleiner">TR1</div>
<div class="text">Technical Report 1 (TR1) ist zwar kein offizieller Standard, beschreibt aber viele Komponenten, die in den offiziellen Standard C++11 aufgenommen wurden. Die neuen Bibliotheken zu regulären Ausdrücken, Smart Pointern, Hash-Tabellen oder Zufallszahlengeneratoren basieren alle auf TR1 und somit auf den entsprechenden Boost-Bibliotheken. Das Boost-Projekt, das von Mitgliedern des C++-Standardisierungskomitees gegründet wurde, ist die eigentliche Ideenwerkstatt für die aktuellen Erweiterungen der C++-Bibliothek. TR1 enthielt 13 Bibliotheken. Lediglich die speziellen mathematischen Funktionen mussten bis C++17 warten.<br></div>
<div class="ztitel_kleiner">C++11</div>
<div class="text">C++11 steht für den nächsten C++-Standard. Wir nennen diesen Standard schlicht Modern C++. Dieser Name steht auch für C++14 und C++17. C++11 besitzt viele Features, die fundamental die Art und Weise ändern, wie wir C++ programmieren. Zum Beispiel enthält C++11 die TR1-Komponenten, aber auch Move-Semantik, Perfect Forwarding, Variadic Templates, Lambdas oder <i>constexpr.</i> Das ist noch nicht alles. Mit C++11 besitzt C++11 ein Speichermodell als die fundamentale Grundlage von Concurrency und eine Multithreading-Schnittstelle. Falls du neugierig bist, hier sind meine Artikel zum <a alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Speichermodell%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fspeichermodell%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fspeichermodell%22%7D" href="https://www.grimm-jaud.de/index.php/blog/category/speichermodell" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/speichermodell">Speichermodell</a> und zur <a alt="%7B%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fmultithreading%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Multithreading%20%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fmultithreading%22%7D" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/multithreading" href="https://www.grimm-jaud.de/index.php/blog/category/multithreading">Multithreading </a>im Allgemeinen.<br></div>
<div class="ztitel_kleiner">C++14</div>
<div class="text">C++14 ist ein kleiner Standard. Mit C++14 wurde C++ um Reader-Writer Locks, verallgemeinerte Lambdas und verallgemeinerte <i>constexpr</i>-Funktionen erweitert.<br></div>
<div class="ztitel_kleiner">C++17</div>
<div class="text">C++17 ist weder groß noch klein. Dieser Standard besitzt zwei herausragenden Features: die parallele STL und die Dateisystembibliothek. Über 80 Algorithmen der STL können nun mit einer sogenannten Ausführungsstrategie (execution policy). ausgeführt werden. Das heißt, das ein Aufruf der Form <span class="tx_code">std::sort(std::execute::par, vec.begin(), vec.end())</span><i> </i>ein Hinweis für die C++-Implementierung ist parallel zu sortieren. Zusätzlich lässt sich spezifizieren, ob die Sortierung sequentiell (<span class="tx_code">std::execute::seq</span>) oder vektorisiert (<span class="tx_code">std::execute::par_unseq</span>) ausgeführt werden soll. Entsprechend zu C++11, besaß Boost sehr starken Einfluss auf diesen C++-Standard. Boost erweiterte C++ um ein Dateisystem und die neuen Datentypen <span class="tx_code">std::optional, std::variant</span> und <span class="tx_code">std::any</span>. Hier sind meine Artikel zu <a alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-17%22%2C%22text%22%3A%22C%2B%2B17%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fc-17%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="https://www.grimm-jaud.de/index.php/blog/category/c-17" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/c-17" class="">C++17</a>. <br></div>
<div class="ztitel_kleiner">C++20<br></div>
<div class="text">C++20 wird die Art und Weise wie wir C++ programmieren ähnlich fundamental ändern wie C++11. Dies gilt insbesondere für die großen Vier: Ranges, Coroutinen, Concepts und Module. Vor einem halben Jahr hätte ich noch von den großen 5 geschrieben. Leider wurden Contracts aus dem C++20 Standard in diesem Jahr in Köln entfernt. Ein Contract spezifiziert in einer exakten und überprüfbaren Weise eine Schnittstelle zu einer Softwarekomponente. Mein Artikel <a alt="%7B%22destination%22%3A2469479%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Ein%20kleiner%20Umweg%20%C3%BCber%20Kontrakte%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D8d1e0db50275efe39358735d81168a5a%26rm%3Dopen_article_id%26bid%3D2469479%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22target%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=8d1e0db50275efe39358735d81168a5a&amp;rm=open_article_id&amp;bid=2469479" class="" title="Link auf Beitrag 2469479">C++ Core Guidelines: Ein kleiner Umweg über Kontrakte</a> liefert weitere Details. Ich sollte aber nicht über die Vergangenheit schreiben. Hier ist die strahlende Zukunft von C++. </div>
<div class="text">Die Ranges-Bibliothek erlaubt es, die Algorithmen der Standard Template Library direkt auf den Container anzuwenden, diese mit dem aus der Unix-Shell bekannten Pipe-Operator zu verknüpfen und diese auf unendlichen Datenstörmen zu definieren.</div>
<div class="text">Mit Couroutinen unterstützt C++20 die asynchrone Programmierung. Damit werden sich in C++20 kooperatives Multitasking, unendliche Datenströme, Event-Schleifen oder auch Pipelines elegant umsetzen lassen.</div>
<div class="text">Concepts sind eine Erweiterung von Templates von C++, mit denen sich semantische Kategorien für die Menge der zulässigen Datentypen definieren lassen. Dank Concepts wird das Anwenden und Definieren von Templates deutlich einfacher und ausdrucksreicher.</div>
<div class="text">Module stellen eine Alternative zu Header-Dateien dar und versprechen viele Verbesserungen. Die Trennung von Header- und Sourcecodedateien aufzulösen, Präprozessor-Anweisungen zu eliminieren, bessere Kompilierungszeiten zu erzielen und einfacher Pakete zu schnüren.</div>
<div class="text">Natürlich ist das bei weitem nicht der vollständige Inhalt von C++20. Hier kommen noch weitere Höhepunkte:</div>
<div class="text"><ul><li>der Drei-Weg Vergleichsoperator: <i>&lt;=&gt;</i></li><li>Stringliterale als Templateparameter</li><li>Kalender- und Zeitzonenerweiterungen für die <i>chrono</i>-Bibliothek</li><li><span class="tx_code">std::span</span><i> </i>als ein View auf ein zusammenhängendes Array</li><li><i>constexpr </i>virtuelle Funktionen</li><li>Neudefinition von <i>volatile</i></li><li>Erweiterungen zu atomaren Variablen: <span class="tx_code">std::atomic_ref&lt;T&gt;</span> und <span class="tx_code">std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;&gt;</span><span class="tx_code">;</span> warten mit atomaren Variablen</li><li>neue Synchronisationsmechanismen wie Semaphoren, Latches und Barriers</li><li><i>constexpr</i> Container wie <span class="tx_code">std::string</span> und <span class="tx_code">std::vector</span></li><li>ein verbesserter Thread mit <span class="tx_code">std::jthread</span>, der automatisch den <span class="tx_code">join</span>-Aufruf anstößt und gestoppt werden kann<br></li></ul></div>
<div class="ztitel">Namensgebung</div>
<div class="text">Okay, wie sollen wir das neue Kind nennen? Alle bestehenden C++-Standards besitzen bereits eine informellen Namen.</div>
<div class="text"><ul><li> Legacy C++: C++98 und C++03</li><li>Modern C++: C++11, C++14 und C++17</li><li>&lt;Platzhalter&gt;: C++20, C++23, ...</li></ul></div>
<div class="text">Die Namensfindung ist schwierig. Im April stellte ich dieselbe Frage auf Twitter. Dies ist der Tweet,</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182095768_b40bf3cdba.png" title="<ir_inline itemname=bilder_mvp_bild:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">und dies sind einige der mehr als 50 Antworten. Ich habe jeweils den Twitternamen des Vorschlagenden hinzugefügt.</div>
<div class="text"><ul><li>indifferent penguin: Postmodern</li><li>Ricardo: next generation</li><li>Robert Ramey: The end of days</li><li>Daniel Oliveira: C++ Reloaded/Revolution/Exoteric</li><li>Michele Adduci: postmodern, post-postmodern, post-post-postmodern and so on</li><li>Thomas Rodgers: C++ Endgame</li><li>phlo81: new C++</li><li>Eric Niebler: co_modular C++</li><li>Martin Moene: Simple C++</li><li>Andrey Upadyshev: C++ 2</li><li>Joel F: Neon Genesis C++</li><li>Breno G: C+=2</li><li>Rasmus 'Elg' Bons: Futuristic C++</li><li>Sebastian Rampe: new c++</li><li>Dr James Smith: C++ Plus, C++ The Next Generation, C+++</li><li>Richard Robinson: ++C</li><li>Saurabh Purnaye: Ultra Modern cpp</li><li>Alican Gültekin: C+++</li><li>Alfonso Guerra: Neo-Futuris</li><li>Improv: now C++</li><li>Chris Blume Moderner C++</li><li>Satay Das: New modern C++</li><li>JustXtofl: post-20</li><li>Adem Budak: Postconceptual C++</li></ul></div>
<div class="text">Du siehst, es gibt eine leichte Tendenz für Postmodern. Vielleicht hast du ja eine bessere Idee.</div>
<div class="ztitel">Wie geht's weiter</div>
<div class="text">Nun aber zu der Frage, die mich am meisten beschäftigt hat. Ich habe bereits rund zehn Artikel in den letzten Jahren geschrieben, die C++20 zum Thema hatten. Meine Frage war: Solch ich meine bestehenden Artikel einfach referenzieren oder soll ich sie nochmals veröffentlichen? Die erste Strategie ist unvollständig, die zweite Strategie überflüssig. Ich entschied mich dafür, einen dritten Weg einzuschlagen. Wenn möglich, werde ich daher bestehende Artikel als Startpunkt für einen neuen Artikel verwenden. Der Grund ist ganz einfach. Zuerst einmal nehme ich an, dass viele Leser meiner Artikel, die älter als ein Jahr sind, nicht kennen. Zum anderen haben sich viele Features verändert, seit ich meinen Artikel geschrieben habe. Meine entscheidende Idee ist es, dir eine vollständige Serie zu C++20 anzubieten. Natürlich beginne ich mit den großen Vier.</div>
<div class="text">Der Button <br></div>
<div class="text">&nbsp;<img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182095774_ed3a4b69a9.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=0>" style="max-height: 25px; max-width: 25px;">&nbsp;</div>
<div class="text"> im rechten Eck meines Blogs führt dich direkt zur Übersichtsseite meiner entstehenden und neuen Artikeln zu C++20.<br></div>
