<div class="vorspann">Dieser Artikel stellt die großen vier Neuerungen von C++20 im Überblick vor: Concepts, Ranges, Coroutinen und Module. <br></div>
<div class="text">Bevor ich dir aber einen ersten Eindruck gebe, möchte ich dir einen Überblick zu C++20 liefern. Der Zeitstrahl unten sollte für den ersten Überblick ausreichen. Neben den großen vier gibt es viele Features, die die Kernsprache, die Bibliothek und Concurrency betreffen. <br></div>
<div class="ztitel">Compiler-Unterstützung für C++20<br></div>
<div class="text">Die einfachste Art, sich mit den neuen Features vertraut zu machen, ist es, mit ihnen herumzuspielen. Damit stellt sich gleich die Frage: Welche C++20-Features werden durch welchen Compiler unterstützt? Wie so oft gibt dir <a href="https://en.cppreference.com/w/cpp/compiler_support" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22cppreference.com%2Fcompiler_support%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://en.cppreference.com/w/cpp/compiler_support" class="">cppreference.com/compiler_support</a> die aussagekräftige Antwort zur Kernsprache und zur Bibliothek.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182602109_a52e89ed94.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um es einfach zu machen: Die brandneuen GCC-, Clang- und EDG-Compiler bieten die breiteste Unterstützung für die Kernsprache an. Zusätzlich unterstützen der MSVC und der Apple Clang Compiler viele C++20-Features.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182602098_859542b834.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Die Geschichte zur Bibliothek ist ähnlich. GCC besitzt die breiteste Unterstützung für die Bibliothek, gefolgt vom Clang-Compiler und dem MSVC. <br> </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182602105_ef75c0cc10.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Screenshots zeigen dir nur den Anfang der Tabellen. Dies ist leider eine Antwort, die nicht zufrieden stellen kann. Selbst wenn du alle aktuellen Compiler einsetzt, gibt es viele Features, die noch keine Unterstützung durch irgendeinen Compiler besitzen. </div>
<div class="text">Oft gibt es aber Workarounds, um die neuen Feature auszuprobieren. Hier sind zwei Beispiele:</div>
<div class="text"><ul><li>Concepts: GCC unterstützt eine vorherige Version der Concepts.</li><li><i>std::jthread</i>: Es gibt eine Entwurfsimplementierung auf GitHub von Nicolai Josuttis.<br></li></ul></div>
<div class="text">Um meine Geschichte abzukürzen: Die Unterstützung der C++20-Features ist nicht so dünn. Mit ein wenig Bastelarbeit lassen sich viele neue Features ausprobieren. Wenn notwendig, werde ich auf die Bastelarbeit eingehen. </div>
<div class="text">Nun möchte ich aber mit einem Blick aus der Vogelperspektive auf die neuen Feature beginnen. <br></div>
<div class="ztitel">The Big Four</div>
<div class="ztitel_kleiner">Concepts<br></div>
<div class="text">Die zentrale Idee der generischen Programmierung mit Templates ist es, Funktionen und Klassen zu definieren, die sich mit verschiedenen Datentypen verwenden lassen. Oft passiert es aber, dass du ein Template mit einem falschen Datentyp instanziierst. Das typische Ergebnis sind ein paar Seiten voll von kryptischen Fehlermeldungen. Diese traurige Geschichte endet mit Concepts. Concepts erlauben es dir, Bedingungen an deine Templates zu stellen, die der Compiler verifiziert. Concepts revolutionieren die Art und Weise, wie wir über generischen Code denken und diesen implementieren. Hier sind Gründe:</div>
<div class="text"><ul><li>Die Anforderungen an die Templates sind Bestandteil des Interfaces.</li><li>Das Überladen von Templates oder die Spezialisierung von Templates ist aufgrund von Concepts möglich.</li><li>Wir erhalten verbesserte Fehlermeldungen, denn der Compiler kann die Bedingungen an die Template-Parameter mit den Template-Argumenten vergleichen.</li></ul></div>
<div class="text">Das ist aber noch nicht&nbsp; das Ende der Geschichte.</div>
<div class="text"><ul><li>Du kannst vordefinierte Concepts verwenden oder deine eigenen Concepts definieren.</li><li>Die Verwendung von <span class="tx_code">auto</span> und Concepts wird vereinheitlicht. Daher lässt sich anstelle von <span class="tx_code">auto</span> einfach ein Concept verwenden. <br> </li><li>Wenn eine Funktionsdeklaration ein Concept verwendet, wird die Funktion automatisch zum Funktions-Template. Das Schreiben von Funktions-Templates wird damit so einfach wie das Schreiben von Funktionen.</li></ul></div>
<div class="text">Das folgende Codebeispiel zeigt die Definition und die Anwendung des Concept <span class="tx_code">Integral</span>:</div>
<div class="pre">template&lt;typename T&gt;<br>concept bool Integral(){<br>&nbsp;&nbsp;&nbsp; return std::is_integral&lt;T&gt;::value;<br>}<br><br>Integral auto gcd(Integral auto a,&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integral auto b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ) return a; <br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br></div>
<div class="text"><span class="tx_code">Integral</span> ist eine Concept, das von seinem Type-Parameter fordert, dass <span class="tx_code">std::is_integral&lt;T&gt;::value true </span>ergibt. <span class="tx_code">std::is_integral&lt;T&gt;::value</span> ist eine Funktion aus der Type-Traits Bibliothek, die ihre Prüfung genau zur Compilezeit ausführt. Wenn <span class="tx_code">std::is_integral&lt;T&gt;::value</span><i> true</i> ergibt, ist alles gut. Falls nicht, erhältst du einen Fehler zur Compilezeit. Für meine neugierigen Leser [--] du solltest neugierig sein [--] sind hier meine Artikel zur <a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/type-traits" class="" alt="%7B%22version%22%3A1%2C%22text%22%3A%22Type-Traits%20Bibliothek%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftype-traits%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftype-traits%22%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/type-traits">Type-Traits Bibliothek</a>. </div>
<div class="text">Der <i>gcd</i>-Algorithmus bestimmt den größten gemeinen Teiler zweiter Zahlen, basierend auf dem <a href="https://de.wikipedia.org/wiki/Euklidischer_Algorithmus" alt="%7B%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEuklidischer_Algorithmus%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEuklidischer_Algorithmus%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Euklid-Algorithmus.%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://de.wikipedia.org/wiki/Euklidischer_Algorithmus" class="">Euklid-Algorithmus.</a> Ich habe die sogenannte <i>abbreviated function template syntax</i> verwendet, um <span class="tx_code">gcd</span> zu definieren. <span class="tx_code">gcd</span> fordert von seinen Argumenten und seinem Rückgabewert, das diese das Concept <span class="tx_code">Integral</span><i> </i>unterstützen. <span class="tx_code">gcd</span><i> ist</i> eine Art Funktions-Template, das Bedingungen an seine Argumente und seinen Rückgabewert stellt. Wenn ich den <a alt="%7B%22text%22%3A%22Syntactic%20Sugar%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FSyntaktischer_Zucker%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FSyntaktischer_Zucker%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://de.wikipedia.org/wiki/Syntaktischer_Zucker" class="" href="https://de.wikipedia.org/wiki/Syntaktischer_Zucker">Syntactic Sugar</a> entferne, siehst du die wahre Natur der <span class="tx_code">gcd</span><i>-</i>Funktion.</div>
<div class="pre">template&lt;typename T&gt;<br>requires Integral&lt;T&gt;()<br>T gcd(T a, T b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ) return a; <br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br></div>
<div class="text">Wenn du die wahre Natur der <span class="tx_code">gcd</span>-Funktion nicht siehst, muss ich dich auf meine Artikel zu Concepts vertrösten, die ich in ein paar Wochen verfassen werde. </div>
<div class="ztitel_kleiner">Ranges Bibliothek<br></div>
<div class="text">Die Ranges Bibliothek ist der erste Kunde von Concepts. Sie bietet Algorithmen an, die</div>
<div class="text"><ul><li> auf den ganzen Container arbeiten. Daher musst du keinen Bereich mehr mittels Iteratoren angeben.</li><li>lazy evaluiert werden.</li><li>komponiert werden können.</li></ul></div>
<div class="text">Um es kurz zu machen, die Ranges-Bibliothek bietet funktionale Pattern an.</div>
<div class="text">Okay, Code sagt mehr als Worte. Das folgende Beispiel zeigt die Funktionskomposition mit dem Pipe-Symbol</div>
<div class="pre">#include &lt;vector&gt;<br>#include &lt;ranges&gt;<br>#include &lt;iostream&gt;<br>&nbsp;<br>int main(){<br>&nbsp; std::vector&lt;int&gt; ints{0, 1, 2, 3, 4, 5};<br>&nbsp; auto even = [](int i){ return 0 == i % 2; };<br>&nbsp; auto square = [](int i) { return i * i; };<br>&nbsp;<br>&nbsp; for (int i : ints | std::view::filter(even) | <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::view::transform(square)) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; ' ';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0 4 16<br>&nbsp; }<br>}</div>
<div class="text"><span class="tx_code">even</span> ist eine&nbsp; Lambda-Funftion, die ermittelt, ob<i> </i><span class="tx_code">i</span> gerade ist. Die Lambda-Funktion <span class="tx_code">square</span> bildet ihr Argument auf das Quadrat ab. Der Rest des Codes ist Funktionskomposition, die du von links nach rechts lesen musst: <span class="tx_code">for (int i : ints | std::view::filter(even) | std::view::transform(square))</span><i>.</i> Wende auf jedes Argument von <span class="tx_code">ints</span> den Filter <span class="tx_code">even</span> an und bilde die verbleibenden Argumente auf ihr Quadrat ab. Wenn du mit funktionaler Programmierung vertraut bist, liest sich dies wie Prosa.</div>
<div class="ztitel_kleiner">Coroutinen</div>
<div class="text">Couroutinen sind verallgemeinerte Funktionen, die ihre Ausführung anhalten und wieder aufnehmen können. Dabei behalten sie ihren Zustand. Coroutinen stellen die typische Art dar, Event-getriebenen Applikationen zu schreiben. Event-getriebenen Applikationen können Simulationen, Spiele, Server, Benutzerinterface und selbst Algorithmen sein. Couroutinen werden auch gerne für <a title="Link auf https://en.wikipedia.org/wiki/Cooperative_multitasking" class="" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCooperative_multitasking%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCooperative_multitasking%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22kooperatives%20Multitasking%20%22%7D" href="https://en.wikipedia.org/wiki/Cooperative_multitasking">kooperatives Multitasking </a>verwendet. </div>
<div class="text">Wir bekommen mit C++20 keine konkreten Coroutinen, sondern eine Framework für das Schreiben von Coroutinen. Dieses Framework besteht aus mehr als 20 Funktionen, die teilweise implementiert werden müssen oder können. Daher lässt sich das Verhalten von Coroutinen auf seine eigenen Anforderungen genau zuschneiden. </div>
<div class="text">Der Verständlichkeit halber möchte ich eine einfache Coroutine zeigen. Das folgende Programm verwendet ein Erzeuger für einen unendlichen Datenstrom:</div>
<div class="pre">Generator&lt;int&gt; getNext(int start = 0, int step = 1){<br>&nbsp;&nbsp;&nbsp; auto value = start;<br>&nbsp;&nbsp;&nbsp; for (int i = 0;; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; co_yield value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value += step;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getNext():";<br>&nbsp;&nbsp;&nbsp; auto gen = getNext();<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 10; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen.next();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; " " &lt;&lt; gen.getValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getNext(100, -10):";<br>&nbsp;&nbsp;&nbsp; auto gen2 = getNext(100, -10);<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 20; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen2.next();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; " " &lt;&lt; gen2.getValue();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Dazu benötigst du eine paar Erläuterungen. Dies ist nur eine Codeschnipsel. Die Funktion <span class="tx_code">getNext</span> ist eine Coroutine, da sie das Schlüsselwort <span class="tx_code">co_yield</span> verwendet. <span class="tx_code">getNext</span> besitzt eine Endlosschleife, die den Wert nach <span class="tx_code">co_yield</span> zurückgibt. Ein Aufruf <span class="tx_code">next()</span> in den Zeilen 2 und 3 weckt die Coroutine auf, der anschließende <span class="tx_code">getValue</span>-Aufruf erlaubt es, den Wert abzuholen. Nach dem <span class="tx_code">getNext</span>-Aufruf pausiert die Coroutine wieder. Sie pausiert bis zum nächsten<i> </i><span class="tx_code">next()</span><i>-</i>Aufruf. Natürlich gibt es noch eine große Unbekannte in meinem Beispiel. Diese Unbekannte ist der Rückgabewert <span class="tx_code">Generator&lt;int&gt;</span><i> </i>des <span class="tx_code">getNext</span>-Funktion. Hier starten die komplizierten Aspekte von Coroutinen, die ich in weiteren Artikel genau erkläre.<br></div>
<div class="text">Dank dem <a title="Link auf https://wandbox.org/" class="" alt="%7B%22version%22%3A1%2C%22text%22%3A%22Wandbox%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2F%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2F%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://wandbox.org/">Wandbox</a> Online Compiler, kann ich die Ausgabe des Programms zeigen.<br></div>
<div class="ztitel_kleiner">Module<br></div>
<div class="text">Zu Modulen halte ich mich jetzt sehr kurz, da mein Artikel bereits zu lange ist.</div>
<div class="text">Module versprechen:</div>
<div class="text"><ul><li> schnellere Compilierungszeiten</li><li>Isolation von Makros</li><li>die logische Struktur des Codes auszudrücken</li><li>Headerdateien überflüssig zu machen</li><li>eklige Makro-Tricks zu vermeiden</li></ul></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Nach dem Überblick zu den großen vier werde ich mir in meinem nächsten Artikel die Neuerungen der Kernsprache genauer anschauen.<br></div>
