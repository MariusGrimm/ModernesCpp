<div class="vorspann">Mein letzter Artikel "<a title="Link auf https://heise.de/-4568956" alt="%7B%22text%22%3A%22C%2B%2B20%3A%20Die%20vier%20gro%C3%9Fen%20Neuerungen%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4568956%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4568956%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" href="https://heise.de/-4568956" class="">C++20: Die vier großen Neuerungen</a>" hat einen ersten Überblick zu Concepts, der Ranges-Bibliothek, Coroutinen und Module gegeben. Natürlich hat C++20 mehr zu bieten. Heute möchte ich meinen Überblick mit der Kernsprache fortsetzen.</div>
<div class="text">Auf dem Bild sind die Features dieses Artikels dargestellt::<br></div>
<div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182892948_90b1bdffb7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Der Drei-Weg-Vergleichsoperator <i>&lt;=&gt;</i></div>
<div class="text">Der Drei-Weg-Vergleichsoperator<i> &lt;=&gt;</i> wird auch gerne Spaceship Operator genannt. Er bestimmt für zwei Werte A und B, ob A &lt; B, A = B oder A &gt; B ist. <br></div>
<div class="text">Der Compiler kann den Drei-Weg-Vergleichsoperator automatisch erzeugen. Dazu muss er nur freundlich mit <i>default</i> aufgefordert werden. In diesem Fall spendiert er alle sechs Vergleichsoperatoren: <i>==, !=, &lt;, &lt;=, &gt; </i>und <i>&gt;=.&nbsp; </i></div>
<div class="pre">#include &lt;compare&gt;<br><br>struct MyInt {<br>&nbsp; int value;<br>&nbsp; MyInt(int value): value{value} { }<br>&nbsp; auto operator&lt;=&gt;(const MyInt&amp;) const = default;<br>};</div>
<div class="text">Der angeforderte Operator &lt;=&gt; vergleicht lexikografisch, indem er zuerst die Basisklassen von links nach rechts und dann die nichtstatischen Mitglieder in ihrer Deklarationsreihenfolge berücksichtigt. Hier ist ein deutlich anspruchsvolleres Programm aus dem Microsoft-Blog: "<a class="" title="Link auf https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/" href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Simplify%20Your%20Code%20with%20Rocket%20Science%3A%20C%2B%2B%2020%27s%20Spaceship%20Operator%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fsimplify-your-code-with-rocket-science-c20s-spaceship-operator%2F%22%2C%22href%22%3A%22https%3A%2F%2Fdevblogs.microsoft.com%2Fcppblog%2Fsimplify-your-code-with-rocket-science-c20s-spaceship-operator%2F%22%2C%22version%22%3A1%7D">Simplify Your Code with Rocket Science: C++ 20's Spaceship Operator</a>".<br></div>
<div class="pre">struct Basics {<br>&nbsp; int i;<br>&nbsp; char c;<br>&nbsp; float f;<br>&nbsp; double d;<br>&nbsp; auto operator&lt;=&gt;(const Basics&amp;) const = default;<br>};<br>&nbsp;<br>struct Arrays {<br>&nbsp; int ai[1];<br>&nbsp; char ac[2];<br>&nbsp; float af[3];<br>&nbsp; double ad[2][2];<br>&nbsp; auto operator&lt;=&gt;(const Arrays&amp;) const = default;<br>};<br>&nbsp;<br>struct Bases : Basics, Arrays {<br>&nbsp; auto operator&lt;=&gt;(const Bases&amp;) const = default;<br>};<br>&nbsp;<br>int main() {<br>&nbsp; constexpr Bases a = { { 0, 'c', 1.f, 1. },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { 1 }, { 'a', 'b' }, { 1.f, 2.f, 3.f }, { { 1., 2. }, { 3., 4. } } } };<br>&nbsp; constexpr Bases b = { { 0, 'c', 1.f, 1. },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { 1 }, { 'a', 'b' }, { 1.f, 2.f, 3.f }, { { 1., 2. }, { 3., 4. } } } };<br>&nbsp; static_assert(a == b);<br>&nbsp; static_assert(!(a != b));<br>&nbsp; static_assert(!(a &lt; b));<br>&nbsp; static_assert(a &lt;= b);<br>&nbsp; static_assert(!(a &gt; b));<br>&nbsp; static_assert(a &gt;= b);<br>}</div>
<div class="text">Ich nehme an, der komplizierte Teil des Codeschnipsels ist nicht der Spaceship Operator, sondern die Initialisierung von <span class="tx_code">Base</span> mittels Aggregate-Initialisierung. Diese bedeutet im Wesentlichen, dass sich die Mitglieder eines Klassentyps <i>(</i><span class="tx_code">class</span><i>,</i> <span class="tx_code">struct</span> oder <span class="tx_code">union</span><i>)</i> direkt initialisieren lassen, wenn diese all <span class="tx_code">public</span> sind. In diesem Fall ist eine geschweift-geklammerte Initialisierungsliste (brace-initialisation list) einsetzbar. Natürlich war dies eine Vereinfachung. Die Details lassen sich schön hier nachlesen: "<a class="" alt="%7B%22text%22%3A%22Aggregate%20Initialisation%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Faggregate_initialization%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Faggregate_initialization%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" title="Link auf https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate Initialisation</a>". <br></div>
<div class="ztitel">String-Literale als Template-Parameter</div>
<div class="text">Vor C++20 konntest du keinen String als Nicht-Typ-Template-Parameter einsetzen. Mit C++20 ist dies möglich. Dazu bietet es sich an, den im Standard definierten <span class="tx_code">basic_fixed_string</span> zu verwenden, da dieser einen <span class="tx_code">constexpr-</span>Konstruktor besitzt. Dank des Konstruktors ist es möglich, den String zur Übersetzungszeit zu instanziieren: </div>
<div class="pre">template&lt;std::basic_fixed_string T&gt;<br>class Foo {<br>&nbsp;&nbsp;&nbsp; static constexpr char const* Name = T;<br>public:<br>&nbsp;&nbsp;&nbsp; void hello() const;<br>};<br><br>int main() {<br>&nbsp;&nbsp;&nbsp; Foo&lt;"Hello!"&gt; foo;<br>&nbsp;&nbsp;&nbsp; foo.hello();<br>}<br></div>
<div class="ztitel"><i>constexpr</i> virtuelle Funktionen</div>
<div class="text">Virtuelle Funktionen konnten nicht in konstaten Ausdrücken aufgerufen werden, da der dynamische Typ nicht bekannt. Diese Einschränkung wird mit C++20 fallen. <br></div>
<div class="ztitel">Designated Initialisierer</div>
<div class="text">Beginnen möchte ich mit der bereits zitierten Aggregat-Initialisierung. Hier ist ein einfaches Beispiel:</div>
<div class="pre">// aggregateInitialisation.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Point2D{<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>};<br><br>class Point3D{<br>public:<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; int z;<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point2D point2D {1, 2};<br>&nbsp;&nbsp;&nbsp; Point3D point3D {1, 2, 3};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point2D: " &lt;&lt; point2D.x &lt;&lt; " " &lt;&lt; point2D.y &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point3D: " &lt;&lt; point3D.x &lt;&lt; " " &lt;&lt; point3D.y &lt;&lt; " " &lt;&lt; point3D.z &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Ich denke, es ist nicht notwendig, das Programm zu erklären. Hier ist bereits seine Ausgabe: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_182892955_9fb872d85c.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Initialisierung in dem Programm <span class="tx_code">aggregateInitialisation.cpp</span> ist sehr fehleranfällig, da es leicht passieren kann, dass der Aufrufer die Argumente vertauscht. Leider fällt dieser Fehler nicht so schnell auf. In diesem Fall helfen Designated Initialisierer aus <a title="Link auf https://en.wikipedia.org/wiki/C99" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FC99%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FC99%22%2C%22text%22%3A%22C99%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://en.wikipedia.org/wiki/C99" class="">C99</a>, denn explizit ist besser als implizit:<br></div>
<div class="pre">// designatedInitializer.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Point2D{<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>};<br><br>class Point3D{<br>public:<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; int z;<br>};<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Point2D point2D {.x = 1, .y = 2};<br>&nbsp;&nbsp;&nbsp; // Point2D point2d {.y = 2, .x = 1};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) error<br>&nbsp;&nbsp;&nbsp; Point3D point3D {.x = 1, .y = 2, .z = 2};&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // Point3D point3D {.x = 1, .z = 2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp; {1, 0, 2}<br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point2D: " &lt;&lt; point2D.x &lt;&lt; " " &lt;&lt; point2D.y &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "point3D: " &lt;&lt; point3D.x &lt;&lt; " " &lt;&lt; point3D.y &lt;&lt; " " &lt;&lt; point3D.z &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Die Namen der Argumente für <span class="tx_code">Point2d</span> und <span class="tx_code">Point3d</span> besitzen explizite Namen. Die Ausgabe des Programms ist identisch zu der des Programms <span class="tx_code">aggregateInitialisation.cpp</span><i>.</i> Die auskommentierte Zeilen (1) und (2) sind sehr interessant. Zeile (1) würde einen Fehler hervorrufen, da die Reihenfolge der Designatoren nicht ihrer Deklarationsreihenfolge entspricht. In Zeile (3) fehlt hingegen der Designator für <span class="tx_code">y</span><i>.</i> In diesem Fall wird <span class="tx_code">y</span> auf 0 initialisiert. Dies entspricht einer geschweift-geklammerten Initialisierungsliste <span class="tx_code">{1, 0, 3}</span>.<br></div>
<div class="ztitel">Verbesserungen rund um Lambdas</div>
<div class="text">Lambdas erfahren viele Verbesserungen in C++20. Falls du mehr Details als in diesem Artikel benötigst, lies "<a title="Link auf https://www.bfilipek.com/2019/02/lambdas-story-part1.html" href="https://www.bfilipek.com/2019/02/lambdas-story-part1.html" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.bfilipek.com%2F2019%2F02%2Flambdas-story-part1.html%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.bfilipek.com%2F2019%2F02%2Flambdas-story-part1.html%22%2C%22text%22%3A%22Bartoks%20Artikel%20%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" class="">Bartoks Artikel </a>zu Lambda-Verbesserung in C++17 und C++20 durch oder warte auf meinen tiefergehenden Artikel. Hier sind zwei interessante Änderungen, die wir erhalten werden. </div>
<div class="text"><ul><li>&nbsp; <b>Verbiete die implizite Bindung von this mit<i> </i></b><span class="tx_code">[=]</span></li></ul></div>
<div class="pre">struct Lambda {<br>&nbsp;&nbsp;&nbsp; auto foo() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; };<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::string s;<br>};<br><br>struct LambdaCpp20 {<br>&nbsp;&nbsp;&nbsp; auto foo() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [=, this] { std::cout &lt;&lt; s &lt;&lt; std::endl; };<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; std::string s;<br>};</div>
<div class="text">Die implizite Bindung von <span class="tx_code">this</span> mit <span class="tx_code">[=]</span> in dem Lambda-Ausdruck wird in C++20 eine Deprecation-Warnung provozieren. Die Warnung gibt es nicht, wenn du explizt mit Copy<i> </i><span class="tx_code">[=, this]</span> bindest.</div>
<div class="text"><ul><li><b>Template-Lambdas<br></b></li></ul></div>
<div class="text">Du stellst dir sicherlich auch die Frage: Warum benötigen wir Template-Lambdas? Wenn ein generisches Lambda mit C++14 instanziiert wird, erzeugt der Compiler automatisch einen Aufrufoperator, der selbst ein Template ist: </div>
<div class="pre">template &lt;typename T&gt;<br>T operator(T x) const {<br>&nbsp;&nbsp;&nbsp; return x;<br>}</div>
<div class="text">Manchmal ist es notwendig, eine Lambda-Funktion zu definieren, die nur für bestimmte Datentypen wie zum Beispiel <span class="tx_code">std::vector</span> verwendet werden kann. In diesem Fall heißt die Rettung Template-Lambdas. Statt eines Typeparameters kann auch ein Concept angewandt werden. </div>
<div class="pre">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do vector specific stuff<br>&nbsp;&nbsp;&nbsp; };<br></div>
<div class="ztitel">Neue Attribute<i> </i><span class="tx_code">[[likely]]</span><i> </i>and <span class="tx_code">[[unlikely]]</span></div>
<div class="text">Mit C++20 erhalten wir die neuen Attribute <span class="tx_code">[[likely]]</span> und <span class="tx_code">[[unlikely]]</span>. Beide Attribute erlauben es dem Optimierer, einen Hinweis zu geben, welcher Codepfad mit höherer Wahrscheinlichkeit ausgeführt wird oder nicht. </div>
<div class="pre">for(size_t i=0; i &lt; v.size(); ++i){<br>&nbsp; if (unlikely(v[i] &lt; 0)) sum -= sqrt(-v[i]);<br>&nbsp; else sum += sqrt(v[i]);<br>}</div>
<div class="ztitel"><span class="tx_code">consteval</span><i>- </i>und <span class="tx_code">consinit</span>-Bezeichner</div>
<div class="text">Der neue Bezeichner <span class="tx_code">consteval</span> erzeugt eine sogenannte Immediate-Funktion. Für sie gilt, dass jeder Aufruf einen konstanten Ausdruck erzeugt, der zur Compilezeit ausgeführt wird. Eine Immediate-Funktion ist implizit eine <span class="tx_code">constexpr</span>-Funktion. </div>
<div class="pre">consteval int sqr(int n) {<br>&nbsp; return n*n;<br>}<br>constexpr int r = sqr(100);&nbsp; // OK<br>&nbsp;<br>int x = 100;<br>int r2 = sqr(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error</div>
<div class="text">Die letzte Zuweisung führt zu einem Fehler, da <span class="tx_code">x</span> kein konstanter Ausdruck ist. Damit kann <span class="tx_code">sqr(x)</span><i> </i>nicht zur Compilezeit ausgeführt werden.</div>
<div class="text"><span class="tx_code">constinit</span> gibt die Garantie, dass eine Variable mit statischer Speicherdauer (static storage duration) zur Compilezeit initialisiert wird. Statische Speicherdauer bedeutet, dass das Objekt zum Programmstart allokiert und zum Programende deallokiert wird. Globale Objekte (namespace scope) oder Objekte, die mit <span class="tx_code">static</span> oder <span class="tx_code">extern</span> deklariert sind, besitzen statische Speicherdauer.<br></div>
<div class="ztitel"><span class="tx_code">std::source_location</span></div>
<div class="text">C++11 besitzt die zwei Makros <span class="tx_code">__LINE__</span> und <span class="tx_code">__FILE__</span>, um notwendige Information zur Zeilennummer und dem Dateinamen dann zu erhalten, wenn die Makros eingesetzt werden. Mit C++20 gibt die Klasse <span class="tx_code">source_location</span> den Dateinamen, die Zeilen- und die Spaltennummer und den Funktionsnamen zurück. Das einfache Beispiel von <a class="" title="Link auf https://en.cppreference.com/w/cpp/utility/source_location" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22cppreference.com%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fsource_location%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fsource_location%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" href="https://en.cppreference.com/w/cpp/utility/source_location">cppreference.com</a> zeigt eine erste Anwendung. </div>
<div class="pre">#include &lt;iostream&gt;<br>#include &lt;string_view&gt;<br>#include &lt;source_location&gt;<br>&nbsp;<br>void log(std::string_view message,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::source_location&amp; location = std::source_location::current())<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "info:"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; location.file_name() &lt;&lt; ":"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; location.line() &lt;&lt; " "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; message &lt;&lt; '\n';<br>}<br>&nbsp;<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; log("Hello world!");&nbsp; // info:main.cpp:15 Hello world!<br>}<i><br></i></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Dieser Artikel gab den ersten Überblick der unbekannteren Feature der neuen Kernsprache. Mein nächster Artikel setzt den Überblick zu C++20 fort und widmet sich inbesondere den verbesserten Bibliotheken.<br></div>
