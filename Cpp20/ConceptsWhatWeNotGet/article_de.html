<div class="vorspann">Die Template Introduction des Concepts TS (Technical Spezification) stellt eine neue Art dar, Concepts anzuwenden. Die syntaktische Variante ist nicht Bestandteil des Concepts Draft und damit auch nicht des C++20 -Standards. Ich treffe aber keine Annahmen darüber, was die nicht so nahe Zukunft bringen wird.</div><div class="ztitel">Template Introduction<br></div><div class="text">Diesen Artikel möchte ich mit einem kleinen Rätsel beginnen. Welche der folgenden syntaktischen Variationen ist mit dem Concepts Draft nicht möglich?<br></div><div class="pre">template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>requires Integral&lt;T&gt;<br>T gcd(T a, T b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ) return a;<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>T gcd1(T a, T b) requires Integral&lt;T&gt;{<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>template&lt;Integral T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>T gcd2(T a, T b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>Integral auto gcd3(Integral auto a, Integral auto b){ // (4)<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else return gcd(b, a % b);<br>}<br><br>Integral{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>Integral gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185959027_dd1bf76097.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Ich nehme an, du kennst nicht jede dieser Techniken. Unter diesen Namen sind sie bekannt:</div><div class="text"><ol><li> Requires Clause</li><li>Trailing Requires Clause</li><li>Constrained Template Parameters</li><li>Abbreviated Function Templates</li><li>Template Introduction</li></ol></div><div class="text">Welche Variante wird in dem Concepts Draft nicht unterstützt? Ich denke, die obskurste Form hat die Wahl gewonnen: Template Introduction. Stimmt! Eventuell erhalten wir diese Variante mit einem späteren C++-Standard. Ich bin aber sehr skeptisch. In meinen persönlichen Gesprächen hörte ich kein Wehklagen, dass diese Variante kein Bestandteil von C++20 sei. Ich bin auch kein großer Fan der Template Introduction, denn sie führt eine Asymmetrie ein. Ich bin kein Freund von Asymmetrien.</div><div class="ztitel_kleiner">Die Asymmetrie<br></div><div class="text">Statt ein eingeschränktes Template mit <span class="tx_code">template&lt;typename Integral&gt;</span> zu erklären, erlaubt es Template Introduction direkt mit<span class="tx_code"> Integral{T}</span>. Hier ist schon die Asymmetrie. Template Introduction lässt sich nur mit Concepts (constrained placeholders), aber nicht mit <span class="tx_code">auto</span> (unconstrained placeholders) verwenden. Das folgende Beispiel bringt die Asymmetrie auf den Punkt. Dieses und das nächste Beispiel basieren auf der vorläufigen Concepts-TS-Spezifikation und sind mit dem GCC übersetzt: </div><div class="pre">// templateIntroduction.cpp<br><br>#include &lt;type_traits&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>concept bool Integral(){<br>&nbsp; return std::is_integral&lt;T&gt;::value;<br>}<br><br>Integral{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>Integral gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br><br>Integral{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>class ConstrainedClass{};<br><br>/*<br><br>auto{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>auto gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br><br>auto{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>class ConstrainedClass{};<br><br>*/<br><br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; auto res= gcd(100, 10); <br><br>&nbsp; ConstrainedClass&lt;int&gt; constrainedClass;<br>&nbsp; ConstrainedClass&lt;double&gt; constrainedClass1;&nbsp; // (3)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div><div class="text">Ich wende Template Introduction bei dem Funktions-Template <span class="tx_code">gcd</span> (Zeile 1) und dem Klassen-Template (Zeile 2) an. Wie erwartet, meldet sich das Concept zur Compilezeit, da <span class="tx_code">ConstrainedClass</span> (Zeile 3) nicht instanziiert werden kann. <br></div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185959037_7bc9bdb486.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Die Asymmetrie besteht darin, dass ich nicht einfach <span class="tx_code">Integral</span> durch <span class="tx_code">a</span><span class="tx_code">uto</span> in den Zeilen 4 und 5 ersetzen kann. Bis zum jetzigen Zeitpunkt zog es sich wie ein roter Faden durch meine Artikel zu Concepts: Concepts (constrained placeholders) können dort eingesetzt werden, wo <span class="tx_code">auto</span> (unconstrained placeholders) erlaubt ist. Dies gilt auch in die andere Richtung. Dieses einfache Prinzip gilt mit Template Introduction nicht mehr. </div><div class="text">Natürlich kann ich diese Restriktion überwinden, indem ich ein Concept definiere, dass immer <span class="tx_code">true</span> zurückgibt:</div><div class="pre">// templateIntroductionGeneric.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;utility&gt;<br><br>struct NoDefaultConstructor{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; NoDefaultConstructor() = delete;<br>};<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>concept bool Generic(){<br>&nbsp; return true;<br>}<br><br>Generic{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>Generic gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br><br>Generic{T}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>class ConstrainedClass{<br>public:<br>&nbsp; ConstrainedClass(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; typeid(decltype(std::declval&lt;T&gt;())).name()&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "gcd(100, 10): " &lt;&lt; gcd(100, 10) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; ConstrainedClass&lt;int&gt; genericClassInt;<br>&nbsp; ConstrainedClass&lt;std::string&gt; genericClassString;<br>&nbsp; ConstrainedClass&lt;double&gt; genericClassDouble;<br>&nbsp; ConstrainedClass&lt;NoDefaultConstructor&gt; genericNoDefaultConstructor;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text"><span class="tx_code">Generic</span> in Zeile 1 ist ein Concept, dass für alle Datentypen <span class="tx_code">true</span> zurückgibt. Nun kann ich die Syntax wieder vereinheitlichen und ein uneingeschränktes Funktions-Template (Zeile 2) und ein uneingeschränktes Klassen-Template (Zeile 3) definieren. Ehrlich gesagt sind die Ausdrücke uneingeschränkte Funktions-Template oder Klassen-Templates keine offiziellen Begriffe. Ich habe sie der Einfachheit halber eingeführt.</div><div class="text">Der Ausdruck <span class="tx_code">typeid(decltype(std::declval&lt;T&gt;())).name()</span> in Zeile 4 löst vermutlich ein wenig Unbehagen aus. <span class="tx_code">std::declvar&lt;T&gt;</span> (C++11) konvertiert den Typ-Parameter <span class="tx_code">T</span> in einen Referenztyp. Dank dieses Referenztyps lässt sich jede Memberfunktion von T aufrufen, ohne dass dazu <span class="tx_code">T</span> erzeugt werden muss. Dies gilt selbst für Datentypen<span class="tx_code"> T</span>, die wie in Zeile 5 keinen Defaultkonstruktor besitzen. In meinem Beispiel (Zeile 4) verwende ich den Konstruktor auf dem Referenztyp&nbsp; um seine String-Repräsentierung zu erhalten. Hier ist des Ausgabe des Programms mit GCC:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_185959050_a82d4b62f9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter? </div><div class="text">Auf ein mächtiges Feature von Concepts bin ich noch nicht eingegangen: die Definition von Concepts. Meist ist dies nicht notwendig, da du in den meisten Fällen das Rad neu erfinden willst. C++20 hat bereits viele Concepts vordefiniert. Ich werde in meinem nächsten Artikel die vordefinierten Concepts vorstellen und zeigen, wie sich eigene Concepts definieren lassen.</div><div class="text">Dies ist mein letzter Artikel für 2019. Ich veröffentliche meinen nächsten Artikel am 12. Januar 2020. Wenn deine hoffentlich besinnliche Zeit zu besinnlich wird, kann ich nur auf meine Übersicht zu den 300 Artikeln meines Blogs <a title="Link auf https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c" href="https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%22%2C%22text%22%3A%22Modernes%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D">Modernes C++</a> verweisen.<br></div><div class="simple-translate-result-contents"><br> <br></div><div class="simple-translate-result-contents"><br> <br></div>
