<div class="vorspann">Mein letzter Artikel "<a alt="%7B%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D261d9348b1cea7f7d747a1ec351385c5%26rm%3Dopen_article_id%26bid%3D2780355%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22text%22%3A%22C%2B%2B20%3A%20%C3%9Cberblick%20zur%20Kernsprache%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A2780355%2C%22subject%22%3A%22%22%7D" title="Link auf Beitrag 2780355" class="" href="/exec/mainmenu.pl?sid=261d9348b1cea7f7d747a1ec351385c5&amp;rm=open_article_id&amp;bid=2780355">C++20: Überblick zur Kernsprache</a>" stellte kurz und kompakt die neuen Features der C++20-Kernsprache vor. Heute geht meine Geschichte zu C++20 mit dem Überblick der Bibliothek weiter.</div>
<div class="text">Wie gewohnt zeigt die Grafik, um welche Feture sich der heutige Artikel dreht:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_183398785_611e2db998.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel">Kalender und Zeitzonen<br></div>
<div class="text">Die Chrono-Bibliothek von C++11/14 wurde um einen Kalender und Zeitzonen erweitert.<br></div>
<div class="text"><ul><li><b>Kalender</b>: Er besteht aus Datentypen, die ein Jahr, einen Monat, ein Wochentag und den n-ten Tag der Woche repräsentieren. Diese elementaren Datentypen können zu komplexen Datentypen wie <span class="tx_code">year_month</span>, <span class="tx_code">year_month_day</span>, <span class="tx_code">year_month_day_last</span>, <span class="tx_code">years_month_weekday</span> und <span class="tx_code">year_month_weekday_last</span> verknüpft werden. Der "/" Operator erlaubt den einfache Umgang mit Zeitpunkten. Zusätzlich gib es noch zwei neue Literale in C++20: <span class="tx_code">d</span> für einen Tag und <span class="tx_code">y</span> für ein Jahr. <br></li></ul></div>
<div class="text"><ul><li><b>Zeitzonen</b>: Zeitpunkte lassen sich in verschiedenen Zeitzonen darstellen. </li></ul></div>
<div class="text">Dank der erweiterten Chrono-Bibliothek, lassen sich die folgenden Anwendungen umsetzen:<br></div>
<div class="text"><ul><li>ein Datum in verschiedenen Formaten repräsentieren:</li></ul></div>
<div class="pre">auto d1 = 2019y/oct/28;<br>auto d2 = 28d/oct/2019;<br>auto d3 = oct/28/2019; </div>
<div><ul><li>bestimme den letzten Tag eines Monats</li><li>bestimme die Anzahl der Tage zwischen zwei Daten</li><li>die Ausgabe der aktuellen Zeit in verschiedenen Zeitzonen</li></ul></div>
<div class="text">Um erste Erfahrung mit der erweiterten Bibliothek zu sammeln, bietet sich Howard Hinnards Implementierung auf <a class="" href="https://github.com/HowardHinnant/date" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FHowardHinnant%2Fdate%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22GitHub%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FHowardHinnant%2Fdate%22%7D" title="Link auf https://github.com/HowardHinnant/date">GitHub</a> an. Er ist der Autor des Proposals für die Kalender- und Zeitzonenerweiterung. Auf <a title="Link auf https://wandbox.org/permlink/vqwMyTphHJv5iXX7" alt="%7B%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FvqwMyTphHJv5iXX7%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Wandbox%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwandbox.org%2Fpermlink%2FvqwMyTphHJv5iXX7%22%7D" href="https://wandbox.org/permlink/vqwMyTphHJv5iXX7" class="">Wandbox</a> hat er eine Spielwiese für die neuen Features erzeugt: <br></div>
<div class="pre">#include "date.h"<br>#include &lt;iostream&gt;<br><br>int<br>main()<br>{<br>&nbsp;&nbsp;&nbsp; using namespace date;<br>&nbsp;&nbsp;&nbsp; using namespace std::chrono;<br>&nbsp;&nbsp;&nbsp; auto now = system_clock::now();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "The current time is " &lt;&lt; now &lt;&lt; " UTC\n";<br>&nbsp;&nbsp;&nbsp; auto current_year = year_month_day{floor&lt;days&gt;(now)}.year();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "The current year is " &lt;&lt; current_year &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; auto h = floor&lt;hours&gt;(now) - sys_days{jan/1/current_year};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "It has been " &lt;&lt; h &lt;&lt; " since New Years!\n";<br>}<br></div>
<div class="text">Es ist offensichtlich, C++20 wird den Namensraum <span class="tx_code">std::chrono</span> anstelle des Namensraums <span class="tx_code">date</span> verwenden. Hier ist die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_183398788_bba48f9e50.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel"><i>std::span</i><br></div>
<div class="text"><span class="tx_code">std::span</span> steht für ein Objekt, das sich auf einen zusammenhängende Sequenz von Objekten bezieht. Ein <span class="tx_code">std::span</span>, manchmal auch View genannt, ist niemals ein Besitzer. Der zusammenhängende Speicherbereich kann ein Array, ein Zeiger mit einer Länge oder ein <span class="tx_code">std::vector</span> sein. Eine typische Implementierung eines <span class="tx_code">std::span</span> benötigt einen Zeiger auf das erste Element der Sequenz und seine Länge. Der wichtigste Grund, dass <span class="tx_code">std::span</span> im C++20 Standards enthalten ist, ist der Tatsache geschuldet, dass ein C-Array zu einem Zeiger vereinfacht wird (<a href="https://en.cppreference.com/w/cpp/types/decay" class="" title="Link auf https://en.cppreference.com/w/cpp/types/decay" alt="%7B%22text%22%3A%22decay%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fdecay%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Fdecay%22%7D">decay</a>), wenn dieses an eine Funktion übergeben wird. Daher bestimmt <span class="tx_code">std::span&lt;T&gt;</span> automatisch die Länge eines einfaches C-Arrays oder eines <span class="tx_code">std::vector</span><i>. Um </i>einen Zeiger zum Initialisieren eines <span class="tx_code">std::span&lt;T&gt;</span> zu verwenden, benötigt der Konstruktor seine Länge:</div>
<div class="pre">template &lt;typename T&gt;<br>void copy_n(const T* p, T* q, int n){}<br><br>template &lt;typename T&gt;<br>void copy(std::span&lt;const T&gt; src, std::span&lt;T&gt; des){}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; int arr1[] = {1, 2, 3};<br>&nbsp; int arr2[] = {3, 4, 5};<br>&nbsp; <br>&nbsp; copy_n(arr1, arr2, 3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; copy(arr1, arr2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Im Unterschied zu der Funktion <span class="tx_code">copy_n (1)</span> benötigt die Funktion <span class="tx_code">copy (2)</span> nicht die Anzahl der Elemente. Daher wird eine große Fehlerquelle mit <span class="tx_code">std::span&lt;T&gt;</span> beseitigt.<br></div>
<div class="ztitel"><i>constexpr-</i>Container</div>
<div class="text">Das <span class="tx_code">constexpr</span>-Schlüsselwort wird immer dominanter in C++. Zum Beispiel werden viele Algorithmen der Standard Template Library eine neue Überladung mit <span class="tx_code">constexpr</span> erhalten. Es steht für eine Funktion oder ein Funktions-Template und bedeutet, dass die Funktion oder das Funktions-Template potenziell zur Compilezeit ausgeführt werden können. Natürlich stellt sich jetzt die Frage, welche Container zur Compilezeit verwendet werden können? Mit C++20 heißt die Antwort <span class="tx_code">std::string</span> und <span class="tx_code">std::vector</span>. </div>
<div class="text">Vor C++20 konnten beide Container nicht in einem Kontext verwendet werden, der <span class="tx_code">constexpr</span>-Container voraussetzt, da beide drei Einschränkungen besaßen:</div>
<div class="text"><ol><li> Destruktoren konnten nicht <span class="tx_code">constexpr</span> sein.</li><li>Dynamische Memory-Allokation war zur Compilezeit nicht möglich.</li><li>Das Erzeugen von Objekten an Ort und Stelle mit <span class="tx_code">placement-new</span> war nicht möglich.</li></ol></div>
<div class="text">Diese Einschränkungen sind mit C++20 verschwunden.<br></div>
<div class="text">Der Punkt 3 bezieht sich auf das relativ unbekannte <span class="tx_code">placement-new</span>. Es wird gerne verwendet, um ein Objekt in einem vorreservierten Speicherbereich zu instanziieren. Darüber hinaus kann <span class="tx_code">placement-new</span> global und für eigene Datentypen überladen werden. <br></div>
<div class="pre">char* memory = new char[sizeof(Account)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocate memory<br>Account* account = new(memory) Account;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // construct in-place<br>account-&gt;~Account();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // destruct<br>delete account;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // free memory<br></div>
<div class="text">Diese Schritte sind notwendig für <span class="tx_code">placement-new</span>. In der ersten Zeile wird der Speicher für Account angefordert, der in der folgenden Zeile direkt verwendet wird. Zugegeben, der Ausdruck <span class="tx_code">account-&gt;~Account</span> schaut befremdlich aus. Dieser Aufruf stellt eine der Ausnahmen dar, in der der Anwender den Konstruktor direkt aufrufen muss. Zum Abschluss gibt die letzte Zeile den Speicher wieder frei.</div>
<div class="text">Ich werde nicht tiefer in die Details zu <span class="tx_code">constexpr</span>-Container abtauchen. Falls du mehr Details lesen willst, hier ist das Proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0784r1.html" class="" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0784r1.html" alt="%7B%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0784r1.html%22%2C%22text%22%3A%22784R1%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0784r1.html%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D">784R1</a>. <br></div>
<div class="ztitel">std::format<br></div>
<div class="text"><a class="" href="https://en.cppreference.com/w/cpp/utility/format" alt="%7B%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fformat%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22cppreference.com%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fformat%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/utility/format">cppreference.com</a> beschreibt kurz und bündig die neue Bibliothek <span class="tx_code">std::format</span>: "The text formatting library offers a safe and extensible alternative to the printf family of functions. It is intended to complement the existing C++ I/O streams library and reuse some of its infrastructure such as overloaded insertion operators for user-defined types." Diese Beschreibung umfasst ein einfaches Beispiel:</div>
<div class="pre">std::string message = std::format("The answer is {}.", 42);</div>
<div class="text">Diese Syntax erinnert mich sehr an die Formatstrings von Python. Es gibt bereits eine Implementierung von <span class="tx_code">std::format</span> auf Github: <a href="https://github.com/fmtlib/fmt" class="" title="Link auf https://github.com/fmtlib/fmt" alt="%7B%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Ffmtlib%2Ffmt%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Ffmtlib%2Ffmt%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22fmt%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D">fmt</a>. Gerne möchte ich noch ein paar Beispiele aus der erwähnten Implementierung vorstellen. In den Beispiel kommt der Namensraum <span class="tx_code">fmt</span> anstelle des Namensraums <span class="tx_code">std</span> zum Einsatz.&nbsp; </div>
<div class="text"><ul><li>Formatiere und verwende Positionsargumente:</li></ul></div>
<div class="pre">std::string s = fmt::format("I'd rather be {1} than {0}.", "right", "happy");<br>// s == "I'd rather be happy than right."</div>
<div class="text"><ul><li>Konvertiere eine Ganzzahl auf sichere Weise in einen String:</li></ul></div>
<div class="pre">fmt::memory_buffer buf;<br>format_to(buf, "{}", 42);&nbsp;&nbsp;&nbsp; // replaces itoa(42, buffer, 10)<br>format_to(buf, "{:x}", 42);&nbsp; // replaces itoa(42, buffer, 16)<br>// access the string with to_string(buf) or buf.data()</div>
<div class="text"><ul><li>Formatiere benutzerdefinierte Datentypen:</li></ul></div>
<div class="pre">struct date {<br>&nbsp; int year, month, day;<br>};<br><br>template &lt;&gt;<br>struct fmt::formatter&lt;date&gt; {<br>&nbsp; template &lt;typename ParseContext&gt;<br>&nbsp; constexpr auto parse(ParseContext &amp;ctx) { return ctx.begin(); }<br><br>&nbsp; template &lt;typename FormatContext&gt;<br>&nbsp; auto format(const date &amp;d, FormatContext &amp;ctx) {<br>&nbsp;&nbsp;&nbsp; return format_to(ctx.out(), "{}-{}-{}", d.year, d.month, d.day);<br>&nbsp; }<br>};<br><br>std::string s = fmt::format("The date is {}", date{2012, 12, 9});<br>// s == "The date is 2012-12-9"</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wie versprochen, werde ich mich in weiteren Artikeln genauer mit der C++20-Bibliothek beschäftigen. Zuerst möchte ich aber meinen Überblick zu C++20 abschließen. Der nächste Artikel setzt sich mit den neuen Featuren rund um Concurrency auseinander.<br></div>
