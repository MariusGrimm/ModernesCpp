<div class="vorspann">Mit diesem Artikel schließe ich meinen Überblick zu C++20 ab. Heute geht es um die Concurrency-Features im nächsten C++ Standard.<br></div>
<div class="text">C++20 besitzt einige Verbesserungen rund um Concurrency.</div>
<div class="ztitel">std::atomic_ref&lt;T&gt;</div>
<div class="text">Das Klassen-Template <span class="tx_code">std::atomic_ref</span> bietet atomare Operationen auf das referenzierte, nichtatomare Objekt an. Gleichzeitiges Lesen und Schreiben des referenzierten Objekts ist damit kein Data Race. Die Lebenszeit des referenzierten Objekts muss natürlich länger als die Lebenszeit des <span class="tx_code">atomic_ref</span>-Objekts sein. Der Zugriff auf Unterobjekte des referenzierten Objekts ist nicht Thread-sicher.&nbsp; </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_183742695_abc01dd045.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Entsprechend zu <span class="tx_code">std::atomic</span> lässt sich <span class="tx_code">std::atomic_ref</span> spezialisieren und bietet auch die Spezialisierung für benutzerdefinierte Datentypen an: <br></div>
<div class="pre">struct Counters {<br>&nbsp;&nbsp;&nbsp; int a;<br>&nbsp;&nbsp;&nbsp; int b;<br>};<br><br>Counter counter;<br><br>std::atomic_ref&lt;Counters&gt; cnt(counter);</div>
<div class="ztitel"><i>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</i> und <i>std::atomic&lt;std::weak_ptr&lt;T&gt;&gt;</i><br></div>
<div class="text"><span class="tx_code">std::shared_ptr</span> ist der einzige nichtatomare Datentyp, auf den atomare Operationen angewandt werden können. Zuerst möchte ich diese Ausnahme begründen. Das C++-Komitee sah es als Notwendigkeit an, das Instanzen von <span class="tx_code">std::shared_ptr</span> minimale atomare Zusicherungen in Multithreading-Programmen anbieten sollten. Was ist nun diese minimale Garantie, die ein <span class="tx_code">std::shared_ptr</span> anbietet? Der Kontrollblock eines <span class="tx_code">std::shared_ptr</span> ist Thread-sicher. Das heißt, dass das Inkrementieren und das Dekrementieren des Referenzzählers eine atomare Operation ist. Das heißt zusätzlich, dass die Ressource genau einmal gelöscht wird. </div>
<div class="text">Die Zusicherungen eines <span class="tx_code">std::shared_ptr</span> bringt <a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22%C2%B2http%3A%2F%2Fwww.boost.org%2Fdoc%2Flibs%2F1_57_0%2Flibs%2Fsmart_ptr%2Fshared_ptr.htm%23ThreadSafety%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22%C2%B2http%3A%2F%2Fwww.boost.org%2Fdoc%2Flibs%2F1_57_0%2Flibs%2Fsmart_ptr%2Fshared_ptr.htm%23ThreadSafety%22%2C%22text%22%3A%22Boost%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="²http://www.boost.org/doc/libs/1_57_0/libs/smart_ptr/shared_ptr.htm#ThreadSafety" class="" title="Link auf ²http://www.boost.org/doc/libs/1_57_0/libs/smart_ptr/shared_ptr.htm#ThreadSafety">Boost</a> exakt auf den Punkt: </div>
<div class="text"><ul><li>A <span class="tx_code">shared_ptr</span> instance can be "read" (accessed using only constant operations) simultaneously by multiple threads.</li><li>Different <span class="tx_code">shared_ptr</span> instances can be "written to" (accessed using mutable operations such as operator= or reset) simultaneously by multiple threads (even when these instances are copies, and share the same reference count underneath).</li></ul></div>
<div class="text">Mit C++20 erhalten wir zwei neue Smart Pointer: <span class="tx_code">std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</span> und <span class="tx_code">std::atomic&lt;std::weak_ptr&lt;T&gt;&gt;</span>.</div>
<div class="ztitel">Atomare Gleitkommazahlen</div>
<div class="text">Zusätzlich zu atomaren Ganzzahlen in C++11 lassen sich mit C++20 atomare Gleitkommazahlen erzeugen. Dies ist sehr angenehm, wenn du eine Gleitkommazahl hast, die gleichzeitig von mehreren Threads inkrementiert wird. Mit einer atomaren Gleitkommazahl muss diese nicht mehr geschützt werden.<br></div>
<div class="ztitel">Warten mit atomaren Variablen<br></div>
<div class="text"><span class="tx_code">std::atomic_flag</span> ist ein einfacher atomarer Wahrheitswert. Er besitzt einen <span class="tx_code">clear-</span> und einen <span class="tx_code">set</span>-Zustand. Der Einfachheit halber bezeichne ich den <span class="tx_code">clear</span>-Zustand als <span class="tx_code">false</span> und den <span class="tx_code">set</span>-Zustand als <span class="tx_code">true</span>. Mit der <span class="tx_code">clear</span>-Method ist es möglich, die Variable auf <span class="tx_code">false</span> zu setzen. Die <span class="tx_code">test_and_set</span>-Method erlaubt es dir hingegen, den Zustand auf <span class="tx_code">true</span> zu setzen. Zusätzlich erhältst du noch den alten Wert. Das <span class="tx_code">std::atomic_flag</span> besitzt keine Methode, um den aktuellen Wert abzufragen. Das ändert sich mit C++20. Mit C++20 besitzt <span class="tx_code">std::atomic_flag</span> eine <span class="tx_code">test</span>-Methode.&nbsp;</div>
<div class="text">Darüber hinaus unterstützt <span class="tx_code">std::atomic_flag</span> mit C++20 Thread-Synchronisation mittels der Methoden <span class="tx_code">notify_one</span>, <span class="tx_code">notify_all</span> und <span class="tx_code">wait</span>. Darüber hinaus ist das Benachrichtigen und Warten mit C++20 für alle teilweise und partielle Spezialisierungen von <span class="tx_code">std::atomic</span> (Wahrheitswerte, Ganzzahlen, Gleitkommazahlen und Zeiger) und für <span class="tx_code">std::atomic_ref</span> möglich. <br></div>
<div class="ztitel">Semaphoren, Latches und Barriers</div>
<div class="text">Alle drei neue Datentypen helfen, Threads zu synchronisieren.</div>
<div class="ztitel_kleiner">Semaphoren<br></div>
<div class="text">Semaphoren werden typischerweise dazu verwendet, um den gleichzeitigen Zugriff auf eine geteilte Ressource zu koordinieren. Eine zählende Semaphore (counting semaphore) wie in C++20 ist eine spezielle Semaphore, die einen Zähler besitzt, der größer als null ist. Der Zähler wird im Konstruktor der Semaphore gesetzt. Das Anfordern der Semaphore reduziert den Zähler und die Freigabe der Semaphore erhöht den Zähler. Wenn ein Thread versucht, die Semaphore anzufordern, die den Wert null besitzt, wird dieser Thread geblockt. Dieser Thread bleibt so lange geblockt, bis ein anderer Thread die Semaphore wieder freigibt und damit den Zähler erhöht. <br></div>
<div class="ztitel_kleiner">Latches und Barries<br></div>
<div class="text">Latches und Barries sind einfache Synchronisationsmechanismen, die es erlauben, Threads zu blockieren bis ein Zähler den Wert null besitzt. Worin unterscheiden sich die beiden Mechanismen? Du kannst einen <span class="tx_code">std::latch</span> nur einmal verwenden, ein <span class="tx_code">std::barrier</span> lässt sich jedoch mehrmals verwenden. Daher ist der Einsatzbereich eines <span class="tx_code">std::latch</span> dann gegeben, wenn eine Aufgabe genau einmal koordiniert werden muss; mit einem <span class="tx_code">std::barrier</span> lassen sich hingegen wiederholende Aufgaben mehrerer Threads koordinieren. Zusätzlich erlaubt es <span class="tx_code">std::barrier</span>, den Zähler in jeder Iteration anzupassen. Das folgende einfache Codebeispiel ist aus dem Proposal <a class="" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4204.html" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4204.html" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4204.html%22%2C%22text%22%3A%22N4204%3A%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4204.html%22%2C%22version%22%3A1%7D">N4204:</a><br></div>
<div class="pre">void DoWork(threadpool* pool) {<br><br>&nbsp;&nbsp;&nbsp; latch completion_latch(NTASKS);&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; NTASKS; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool-&gt;add_task([&amp;] {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // perform work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; completion_latch.count_down();// (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Block until work is done<br>&nbsp;&nbsp;&nbsp; completion_latch.wait();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>}<br></div>
<div class="text">Der<span class="tx_code"> std::latch completion_latch</span> wird in seinem Konstruktor auf <span class="tx_code">NTASK</span> (Zeile 1) gesetzt. Der Threadpool führt <span class="tx_code">NTASKS</span> (Zeile 2 - 3) Arbeitspakete aus. Am Ende jedes Arbeitspakets (Zeile 4) wird der Zähler dekrementiert. Zeile 5 stellt die Barriere für die Threads, die die Funktion <span class="tx_code">DoWork</span> ausführen, dar. Dieser Thread wird geblockt, bis alle Arbeitspakete fertig sind.&nbsp; <br></div>
<div class="ztitel">std::jthread</div>
<div class="text"><span class="tx_code">std::jthread</span> steht für einen Joining-Thread. Zusätzlich zum <span class="tx_code">std::thread</span> (C++11) joint <span class="tx_code">std::jthread</span> (C++20) automatisch und er kann auch unterbrochen werden. </div>
<div class="text">Dies ist das überraschende Verhalten des <span class="tx_code">std::thread</span>. Wenn ein <span class="tx_code">std::thread</span> noch joinable ist, wird in seinem Destruktor <span class="tx_code">std::terminate</span> aufgerufen. Ein Thread <span class="tx_code">thr</span> ist joinable, wenn auf ihm weder <span class="tx_code">thr.join()</span> noch <span class="tx_code">thr.detach()</span> aufgerufen wurde: <br></div>
<div class="pre">// threadJoinable.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; std::thread thr{[]{ std::cout &lt;&lt; "Joinable std::thread" &lt;&lt; std::endl; }};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "thr.joinable(): " &lt;&lt; thr.joinable() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>}</div>
<div class="text">Wenn ich das Programm ausführe, beendet es sich mit einer Ausnahme.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_183742702_1593ee305a.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Beide Ausführungen des Programms beenden sich mit einer Ausnahme. Im zweiten Fall besitzt der Thread <span class="tx_code">thr</span> noch genügend Zeit um seine Ausgabe "Joinable std::thread" darzustellen.</div>
<div class="text">Im nächsten Beispiel ersetze ich lediglich die Headerdatei <span class="tx_code">&lt;thread&gt;</span><i> </i>mit der Headerdatei<i> "jthread.hpp" </i>und verwende dadurch automatisch<i> </i><span class="tx_code">std::jthread</span> aus dem C++20-Standard:</div>
<div class="pre">// jthreadJoinable.cpp<br><br>#include &lt;iostream&gt;<br>#include "jthread.hpp"<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; std::jthread thr{[]{ std::cout &lt;&lt; "Joinable std::thread" &lt;&lt; std::endl; }};<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "thr.joinable(): " &lt;&lt; thr.joinable() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>}</div>
<div class="text">Jetzt joint den Thread <span class="tx_code">thr</span> dann automatisch in seinem Destruktor, wenn er noch joinable ist. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_183742711_d2fbc3dd9f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">In den letzten vier Artikeln habe ich einen Überblick zu den neuen Featuren in C++20 gegeben. Nach diesem Überblick will ich nun die Details vorstellen. Mein nächster Artikel beschäftigt sich mit Concepts.<br></div>
