<div class="vorspann">Im letzten Artikel "<a alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B20%3A%20Zwei%20Extreme%20und%20die%20Rettung%20durch%20Concepts%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22destination%22%3A2794242%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D2ee1fb57bcdda5322779aab877850b4b%26rm%3Dopen_article_id%26bid%3D2794242%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf Beitrag 2794242" class="" href="/exec/mainmenu.pl?sid=2ee1fb57bcdda5322779aab877850b4b&amp;rm=open_article_id&amp;bid=2794242">C++20: Zwei Extreme und die Rettung durch Concepts</a>" bin ich auf die Motivation für Concepts eingegangen. Concepts erlauben es, semantische Einschränkungen auf Template-Parametern auszudrücken. Heute stelle ich viele kleine Anwendungsfälle zu Concepts kurz und bündig vor.</div>
<div class="text">Zuerst möchte ich an die Vorteile von Concepts erinnern.</div>
<div class="text"><ul><li>Die Anforderungen an die Templates sind Bestandteil des Interfaces.</li><li>Das Überladen von Templates oder die Spezialisierung von Templates ist aufgrund von Concepts möglich.</li><li>Wir erhalten verbesserte Fehlermeldungen, denn der Compiler kann die Bedingungen an die Template-Parameter mit den Template-Argumenten vergleichen.</li><li>Du kannst vordefinierte Concepts verwenden oder deine eigenen Concepts definieren.</li><li>Die Verwendung von <span class="tx_code">auto</span> und Concepts wird vereinheitlicht. Daher lässt sich anstelle von <span class="tx_code">auto</span> einfach ein Concept verwenden. <br> </li><li>Wenn eine Funktionsdeklaration ein Concept verwendet, wird die Funktion automatisch zum Funktions-Template. Das Schreiben von Funktions-Templates wird damit so einfach wie das Schreiben von Funktionen.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184608068_352d7a6f75.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">In diesem Artikel werde ich mich mit den ersten drei Punkten der obigen Zusammenstellung genauer beschäftigen. Los geht es mit verschiedenen Anwendungen von Concepts:<br></div>
<div class="ztitel">Drei Arten<br></div>
<div class="text">Auf drei Arten lässt sich das Concept <span class="tx_code">Sortable</span> einsetzen. Ich stelle lediglich die Deklaration eines Funktions-Templates vor:<br></div>
<div><ul><li><b>Requires Clause</b></li></ul></div>
<div class="pre">template&lt;typename Cont&gt;<br>&nbsp;&nbsp;&nbsp; requires Sortable&lt;Cont&gt;<br>void sort(Cont&amp; container);<br></div>
<div><ul><li><b>Trailing Requires Clause</b></li></ul></div>
<div class="pre">template&lt;typename Cont&gt;<br>void sort(Cont&amp; container) requires Sortable&lt;Cont&gt;;<br></div>
<div><ul><li><b>Constrained Template Parameter</b></li></ul></div>
<div class="pre">template&lt;Sortable Cont&gt;<br>void sort(Cont&amp; container)</div>
<div class="text">Der Algorithmus <span class="tx_code">sort</span> fordert, dass der Container sortierbar ist. <span class="tx_code">Sortable</span> muss ein konstanter Ausdruck und ein Prädikat sein.</div>
<div class="ztitel">Klassen</div>
<div class="text">Du kannst ein Klassen-Template definieren, das nur Objekte annimmt:</div>
<div class="pre">template&lt;Object T&gt;<br>class MyVector{};<br><br>MyVector&lt;int&gt; v1;&nbsp;&nbsp; // OK<br>MyVector&lt;int&amp;&gt; v2;&nbsp; // ERROR: int&amp; does not satisfy the constraint Object</div>
<div class="text">Der Compiler beschwert sich in diesem Fall, dass eine Referenz kein Objekt ist. Du fragst dich vermutlich: Was ist ein Objekt? Ein mögliche Implementierung der Typ-Traits Funktion <span class="tx_code">std::is_object</span> gibt die Antwort: </div>
<div class="pre">template&lt; class T&gt;<br>struct is_object : std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_scalar&lt;T&gt;::value ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_array&lt;T&gt;::value&nbsp; ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_union&lt;T&gt;::value&nbsp; ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_class&lt;T&gt;::value&gt; {};</div>
<div class="text">Ein Objekt ist entweder ein Skalar, ein Array, eine Union oder eine Klasse.</div>
<div class="ztitel">Member-Funktionen</div>
<div class="pre">template&lt;Object T&gt;<br>class MyVector{<br>&nbsp;&nbsp;&nbsp; ... <br>&nbsp;&nbsp;&nbsp; void push_back(const T&amp; e) requires Copyable&lt;T&gt;{}<br>&nbsp;&nbsp;&nbsp; ...<br>};</div>
<div class="text">In diesem Fall fordert die Member-Funktion<i> </i><span class="tx_code">push_back</span>, dass der Template-Parameter <span class="tx_code">T</span> kopierbar sein muss.</div>
<div class="ztitel">Variadic Templates</div>
<div class="pre">&nbsp;// allAnyNone.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>template&lt;typename T&gt;<br>concept Arithmetic = std::is_arithmetic&lt;T&gt;::value;<br><br>template&lt;Arithmetic... Args&gt;<br>bool all(Args... args) { return (... &amp;&amp; args); }<br><br>template&lt;Arithmetic... Args&gt;<br>bool any(Args... args) { return (... || args); }<br><br>template&lt;Arithmetic... Args&gt;<br>bool none(Args... args) { return !(... || args); }<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "all(5, true, 5.5, false): " &lt;&lt; all(5, true, 5.5, false) &lt;&lt; std::endl;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "any(5, true, 5.5, false): " &lt;&lt; any(5, true, 5.5, false) &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "none(5, true, 5.5, false): " &lt;&lt; none(5, true, 5.5, false) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Concepts können auch in Variadic Templates angewandt werden. Die Definitionen der Funktions-Temples verwenden <a class="" title="Link auf https://www.grimm-jaud.de/index.php/44-blog/funktional/190-fold-expressions" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22Fold%20Expressions%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2F44-blog%2Ffunktional%2F190-fold-expressions%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2F44-blog%2Ffunktional%2F190-fold-expressions%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/44-blog/funktional/190-fold-expressions">Fold Expressions</a>. <span class="tx_code">all</span><i>, </i><span class="tx_code">any</span> und <span class="tx_code">none</span> verlangen von ihrem Typ-Parameter, dass er das Concept Arithmetic unterstützt. <span class="tx_code">Arithmetic</span> ist <span class="tx_code">T</span> dann, wenn es eine Ganzzahl oder eine Fließkommazahl ist. </div>
<div class="text">Der aktuelle Microsoft-Compiler 19.23 unterstützt als einziger teilweise die neue Syntax für Concepts:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_184608075_ac5abdc825.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Mehrere Anforderungen</div>
<div class="text">Natürlich lässt sich an einen Templater-Parameter mehr als eine Anforderung stellen:</div>
<div class="pre">template &lt;SequenceContainer S,&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EqualityComparable&lt;value_type&lt;S&gt;&gt; T&gt;<br>Iterator_type&lt;S&gt; find(S&amp;&amp; seq, const T&amp; val){<br>&nbsp;&nbsp;&nbsp; ...<br>}</div>
<div class="text">Das Funktions-Template <span class="tx_code">find</span> fordert: </div>
<div class="text"><ul><li>Sein Container <span class="tx_code">S</span> soll ein <span class="tx_code">SequenceContainer</span> sein.<br></li><li>Die Elemente <span class="tx_code">T</span> des Container <span class="tx_code">S</span> sollen <span class="tx_code">EqualityComparable</span><i> </i>sein</li></ul></div>
<div class="ztitel">Überladen</div>
<div class="text"><span class="tx_code">std::advance(iter, n)</span> setzt seinen Iterator <span class="tx_code">iter n</span> Positionen weiter. Abhängig von dem Iterator kann die Implementierung Zeigerarithmetik anwenden oder lediglich <i>n</i> Schritte weiter gehen. Im ersten Fall ist die Ausführungszeit konstant; im zweiten Fall hängt die Ausführungszeit von der Schrittweite <i>n</i> ab. Dank Concepts kann <span class="tx_code">std::advance</span> aufgrund der Iterator-Kategorie überladen werden: </div>
<div class="pre">template&lt;InputIterator I&gt;<br>void advance(I&amp; iter, int n){...}<br><br>template&lt;BidirectionalIterator I&gt;<br>void advance(I&amp; iter, int n){...}<br><br>template&lt;RandomAccessIterator I&gt;<br>void advance(I&amp; iter, int n){...}<br><br>// usage<br><br>std::vector&lt;int&gt; vec{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>auto vecIt = vec.begin();<br>std::advance(vecIt, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; RandomAccessIterator<br><br>std::list&lt;int&gt; lst{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>auto lstIt = lst.begin();<br>std::advance(lstIt, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; BidirectionalIterator<br><br>std::forward_list&lt;int&gt; forw{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>auto forwIt = forw.begin();<br>std::advance(forwIt, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; InputIterator<br></div>
<div class="text">Basierend auf der Iterator-Kategorie, die die Container <span class="tx_code">std::vector</span><i>, </i><span class="tx_code">std::list</span> und <span class="tx_code">std::forward_list </span>anbieten, kommt die am besten passende Implementierung von <span class="tx_code">std::advance</span> zum Einsatz. </div>
<div class="ztitel">Spezialisierung</div>
<div class="text">Concepts unterstützen natürlich auch die Template-Spezialisierung: </div>
<div class="pre">template&lt;typename T&gt;<br>class MyVector{};<br><br>template&lt;Object T&gt;<br>class MyVector{};<br><br>MyVector&lt;int&gt; v1;&nbsp;&nbsp;&nbsp;&nbsp; // Object T<br>MyVector&lt;int&amp;&gt; v2;&nbsp;&nbsp;&nbsp; // typename T</div>
<div class="text"><ul><li> <span class="tx_code">MyVector&lt;int&amp;&gt;</span> führt zum Aufruf des Klassen-Templates mit dem uneingeschränkten Template-Parameter.</li><li><span class="tx_code">MyVector&lt;int&gt;</span> führt zum Aufruf des Klassen-Templates mit dem eingeschränkten Template-Parameter.</li></ul></div>
<div class="ztitel">Wie geht't weiter?</div>
<div class="text">In meinem nächsten Artikel schreibe ich über syntaktische Vereinheitlichung in C++20. Mit C++20 lässt sich an jeder Stelle ein constrained placeholder (Concept) verwenden, an der sich mit C++11 ein unconstrained placeholer (auto) einsetzen lässt. Dies ist aber noch nicht der Endpunkt der Vereinheitlichung. Die Definition von Templates wird in C++20 ein Kinderspiel. Verwende dazu einfach einen constrained oder einen unconstrained placeholder in der Deklaration einer Funktion.<br></div>
