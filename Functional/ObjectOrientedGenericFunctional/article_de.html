<p>C++ ist keine funktionale Programmiersprache. C++ hat seine Wurzeln in der prozeduralen und objektorientierten Programmierung. Um so verwunderlicher ist es, dass die Programmierung im funktionalen Stil in modernem C++ immer wichtiger wird. Dies Phänomen trifft aber nicht nur auf C++ zu. Auch Python hat schon sehr viele funktionalen Feature angenommen und selbst Java besitzt mittlerweile Lamba-Funktionen.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<h2>Am Anfang stand(en) die Frage(n)</h2>
<p>Am Anfang stehen zuerst einmal viele Fragen zur funktionalen Programmierung in C++:</p>
<ul>
<li>Welche funktionalen Feature bietet C++ an?</li>
<li>Warum sind rein funktionale Programmiersprachen wie Haskell so einflussreich auf C++?</li>
<li>Welchen Weg schlägt modernes C++ ein?&nbsp;</li>
<li>Welche Vorteile besitzt die funktionale Programmierung?</li>
<li>Was ist funktionale Programmierung?</li>
<li>Worin zeichnet sich funktionale Programmierung aus?</li>
</ul>
<p>Fragen über Fragen, die ich natürlich nicht alle in diesem Artikel beantworten kann. Diese Fragen und noch einige Fragen mehr werde ich in den nächsten Artikel beantworten.&nbsp;</p>
<p>Los geht es mit der ersten nicht gestellten Frage. Welche Programmierparadigmen unterstützt C++?</p>
<h2>Eine starke Vereinfachung</h2>
<p><br />30 Jahre sind eine sehr lange Zeit in der Softwareentwicklung. Da ist es nicht verwunderlich, dass C++ mit seinen Wurzeln in C mehrere Metamorphosen vollzogen hat.</p>
<p>C startete in den frühen 70er des letzten Jahrhunderts, 1998 wurde&nbsp;der erste C++ Standard C++98 verabschiedet. 13 Jahre später beginnt modernes C++ mit dem zweiten, großen C++ Standard C++11. Viel interessanter als die nackten Zahlen ist aber die Tatsache, dass jeder der drei Schritte auch für die Art und Weise steht, wie Probleme gelöst werden.In C wurden Probleme durch die prozedurale und strukturelle Denkweise gelöst. C++ führte mit der objektorientierten und generischen Programmierung neue Abstraktionen ein. Mit C++11 kam die funktionale Denkweise hinzu.</p>
<p><img src="images/blog/FunktionaleProgrammierung/ObjektorientiertGenerischFunktional/images/evolution.png" alt="evolution" style="margin: 15px;" /></p>
<p>&nbsp;</p>
<p>Bevor ich mich aber fast&nbsp;ausschließlich der funktionalen Programmierung widme, möchte ich die Ideen der objektorientierten, generischen und funktionalen Programmierung kurz skizzieren.&nbsp;</p>
<h3>Objektorientierten Programmierung</h3>
<p>Objektorientierte Programmierung basiert auf den drei Konzepten Kapselung, Vererbung und Polymorphie.</p>
<dl><dt>Kapselung</dt><dd>
<p style="padding-left: 30px;">Ein Objekt kapselt seine Attribute und Methoden und bietet sie durch ein Interface der Außenwelt an. Für diese Eigenschaft, dass sich Instanzen einer Klasse ihre Internas verbergen, hat sich auch der Name <em>data hiding</em> etabliert.&nbsp;</p>
</dd><dt>Vererbung</dt><dd>
<p style="padding-left: 30px;">Eine abgeleitete Klasse erbt alle Eigenschaften ihrer Basisklasse. Eine Instanz einer abgeleiteten Klasse kann auch als eine Instanz seiner Basisklasse verwendet werden. Da eine Klasse automatisch alle Eigenschaft ihrer Basisklasse erbt, wird in dem Zusammenhang gerne der Name <em>code reuse</em> verwendet.</p>
</dd><dt>Polymorphie</dt><dd>
<p style="padding-left: 30px;">Objekte einer Instanz verändern zu Laufzeit ihr Verhalten. Polymorphie kommt aus dem altgriechischen und steht für Vielgestaltigkeit.</p>
</dd><dd></dd><dd></dd></dl><!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;"><span style="color: #0000ff;">template</span> &lt;<span style="color: #0000ff;">typename</span> T&gt; <span style="color: #2b91af;">void</span> xchg(T&amp; x, T&amp; y){   
  T t= x;
  x= y;
  y= t;
};

<span style="color: #2b91af;">int</span> i= 10;
<span style="color: #2b91af;">int</span> j= 20;
Man huber;
Man maier;

xchg(i,j);
xchg(huber,maier);
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>In dem konkreten Beispiel lässt sich der Name des <span style="font-family: courier new,courier;">HumanBeing</span> nur über die Methode <span style="font-family: courier new,courier;">getName </span>in Zeile 4 ermitteln (Kapselung)<span style="font-family: courier new,courier;">. </span>Darüber hinaus ist <span style="font-family: courier new,courier;">getName</span> als virtual deklariert. Damit können abgeleitete Klassen die Methode und somit das Verhalten ihrer Objekte verändern (Polymorphie). Sowohl <span style="font-family: courier new,courier;">Man</span> als auch <span style="font-family: courier new,courier;">Woman</span> sind von <span style="font-family: courier new,courier;">HumanBeing</span> abgeleitet.</p>
<h3>Generische Programmierung</h3>
<p>Die zentrale Idee der generischen Programmierung oder auch der Programmierung mit Templates ist es, Familien von Funktionen und Klassen zu definieren. Durch die Verwendung eines konkreten Typs erzeugt der Compiler automatisch eine Funktion oder auch eine Klasse für diesen Typ. Generische Programmierung erlaubt ähnlich Abstraktionen wie die objektorientierte Programmierung. Ein großer Unterschied besteht darin, dass die Polymorphie bei der objektorientierten Programmierung zur Laufzeit, bei der generischen Programmierung zur Compilezeit stattfindet. Das ist der Grund, dass die Polymorphie zur Laufzeit als dynamische Polymorphie, die Polymorphie zur Compilezeit als statische Polymorphie bezeichnet wird.</p>
<p>Mit dem Funktions-Template lassen sich Objekte tauschen.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;"><span style="color: #0000ff;">template</span> &lt;<span style="color: #0000ff;">typename</span> T&gt; <span style="color: #2b91af;">void</span> xchg(T&amp; x, T&amp; y){   
  T t= x;
  x= y;
  y= t;
};
<span style="color: #2b91af;">int</span> i= 10;
<span style="color: #2b91af;">int</span> j= 20;
Man huber;
Man maier;

xchg(i,j);
xchg(huber,maier);
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>&nbsp;Für das Funktions-Template ist es unerheblich, ob es Zahlen oder Männer vertauschen soll (Zeile 11 und 12). Selbst der Typ-Parameter T (Zeile 1) muss nicht spezifiziert werden, da der Compiler diesen aus den Funktionsargumenten (Zeile 11 und 12) ableiten kann.</p>
<p>Dies gilt nicht für das Klassen-Template. In diesem Fall muss sowohl der Typ-Parameter T als auch der Nichttyp-Parameter N (Zeile 1) angegeben werden.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;"><span style="color: #0000ff;">template</span> &lt;<span style="color: #0000ff;">typename</span> T, <span style="color: #2b91af;">int</span> N&gt;
<span style="color: #0000ff;">class</span> <span style="color: #2b91af;">Array</span>{
public:
  <span style="color: #2b91af;">int</span> getSize() <span style="color: #0000ff;">const</span>{
    <span style="color: #0000ff;">return</span> N;
  }
private:
  T elem[N];
};
 
Array&lt;<span style="color: #2b91af;">double</span>,10&gt; doubleArray;
std::cout &lt;&lt; doubleArray.getSize() &lt;&lt; std::endl;

Array&lt;Man,5&gt; manArray;
std::cout &lt;&lt; manArray.getSize() &lt;&lt; std::endl;
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>Die Anwendung des Klassen-Template <span style="font-family: courier new,courier;">Array</span> ist wieder unabhängig davon, ob <span style="font-family: courier new,courier;">doubles</span> oder <span style="font-family: courier new,courier;">Männer</span> zum Einsatz kommen.</p>
<h3>Funktionale Programmierung</h3>
<p>Bei den Konzepten der funktionalen Programmierung halte ich mich noch bewusst bedeckt in diesem Artikel. Denn die Konzepte der funktionalen Programmierung lassen sich nicht in einer kleinen Randbemerkung erklären. Nur soviel. In dem kleinen Codeschnipsel kommen die Pendants zu den typischen Funktionen der funktionalen Programmierung map, filter und reduce zum Einsatz. Dies sind die Funktionen <span style="font-family: courier new,courier;">std::transform, std::remove_if</span> und <span style="font-family: courier new,courier;">std::accumulate </span>in C++.</p>
<p>&nbsp;</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;">std::vector&lt;<span style="color: #2b91af;">int</span>&gt; vec{1,2,3,4,5,6,7,8,9};
std::vector&lt;std::string&gt; str{<span style="color: #a31515;">"Programming"</span>,<span style="color: #a31515;">"in"</span>,<span style="color: #a31515;">"a"</span>,<span style="color: #a31515;">"functional"</span>,<span style="color: #a31515;">"style."</span>};

std::transform(vec.begin(),vec.end(),vec.begin(),
              [](<span style="color: #2b91af;">int</span> i){ <span style="color: #0000ff;">return</span> i*i; }); <span style="color: #008000;">// {1,4,9,16,25,36,49,64,81}</span>

<span style="color: #0000ff;">auto</span> it= std::remove_if(vec.begin(),vec.end(),
                        [](<span style="color: #2b91af;">int</span> i){ <span style="color: #0000ff;">return</span> ((i &lt; 3) or (i &gt; 8)) }); <span style="color: #008000;">// {3,4,5,6,7,8}</span>
<span style="color: #0000ff;">auto</span> it2= std::remove_if(str.begin(),str.end(),
                         [](string s){ <span style="color: #0000ff;">return</span> (std::lower(s[0])); }); <span style="color: #008000;">// "Programming"</span>


std::accumulate(vec.begin(),vec.end(),[](<span style="color: #2b91af;">int</span> a,<span style="color: #2b91af;">int</span> b){<span style="color: #0000ff;">return</span> a*b;}); <span style="color: #008000;">// 362880</span>
std::accumulate(str.begin(),str.end(),
                [](std::string a,std::string b){<span style="color: #0000ff;">return</span> a + <span style="color: #a31515;">":"</span>+ b;});
                <span style="color: #008000;">// "Programming:in:a:functional:style."</span>
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>In dem kleinen Codebeispiel wende ich noch zwei mächtige Feature aus der funktionalen Programmierung an. Diese sind mittlerweile zum Mainstream in modernem C++ geworden. Automatische Typableitung mit <span style="font-family: courier new,courier;">auto</span> und Lambda-Funktionen.</p>
<h2>Wie geht's weiter?</h2>
<p>Welche funktionalen Feature bietet C++ bereits? Welche Feature kommen mit C++17 und C++20 hinzu? Genau diesen beiden Fragen werde ich im <a href="index.php/blog/funktional-in-c98">nächsten Artikel </a>beantworten.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>{tooltip} <img src="images/books/title_page_small.png" alt="title page small" width="166" height="212" />{end-texte}<img src="images/books/title_page_small.png" alt="title page small" style="margin: 3px;" /> Go to <a href="https://leanpub.com/cpplibrary"> </a><a href="https://leanpub.com/cpplibrary">Leanpub/cpplibrary</a> <a href="https://leanpub.com/cpplibrary"> </a><strong>"What every professional C++ programmer should know about the C++ standard library".</strong> <a href="https://leanpub.com/cpplibrary"></a>{end-tooltip} &nbsp; <strong><span class="h3">Hole dir dein E-Book. Unterstütze meinen Blog.</span></strong></p>
<p>&nbsp;</p>
