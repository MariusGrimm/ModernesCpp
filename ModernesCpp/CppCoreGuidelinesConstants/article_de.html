<div class="vorspann">Das Deklarieren von Objekten und Methoden als const besitzt zwei große Vorteile. Zuerst einmal beschwert sich der Compiler, wenn der Vertrag bricht. Dann teilt man damit dem Anwender des Interfaces mit, dass die Funktion ihre Argumente nicht verändert.</div>
<div class="text">Die C++ Core Guidelines bieten fünf Regeln zu konstanten Objekten oder Methoden und konstanten Ausdrücken an. Hier sind sie:<br></div>
<div class="text"><ul><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-immutable" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Con.1%3A%20By%20default%2C%20make%20objects%20immutable%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-immutable%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-immutable%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-immutable">Con.1: By default, make objects immutable</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-fct" alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22Con.2%3A%20By%20default%2C%20make%20member%20functions%20const%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-fct%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-fct%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-fct" class="">Con.2: By default, make member functions const</a> </li><li>C<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-ref" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-ref%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22on.3%3A%20By%20default%2C%20pass%20pointers%20and%20references%20to%20consts%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-ref%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-ref" class="">on.3: By default, pass pointers and references to consts</a> </li><li><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-const" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-const" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Con.4%3A%20Use%20const%20to%20define%20objects%20with%20values%20that%20do%20not%20change%20after%20construction%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-const%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-const%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D">Con.4: Use const to define objects with values that do not change after construction</a></li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-constexpr" alt="%7B%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Con.5%3A%20Use%20constexpr%20for%20values%20that%20can%20be%20computed%20at%20compile%20time%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-constexpr%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-constexpr%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-constexpr">Con.5: Use constexpr for values that can be computed at compile time</a></li></ul></div>
<div class="text">Bevor ich mich genau mit den Regeln beschäftige, möchte ich einen Ausdruck klären, der häufig im Zusammenhang mit Konstantheit und Unveränderlichkeit genannt wird: "const correctness". Entsprechend der C++-FAQ heißt dies: </div>
<div class="text"><ul><li>What is const correctness? It means using the keyword&nbsp;const&nbsp;to prevent&nbsp;const&nbsp;objects from getting mutated.</li></ul></div>
<div class="text">Heute geht es also um "const correctness". <br></div>
<div class="ztitel"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-immutable%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Con.1%3A%20By%20default%2C%20make%20objects%20immutable%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-immutable%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-immutable" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-immutable">Con.1: By default, make objects immutable</a> <br> </div>
<div class="text">Diese Regel ist recht einfach. Du kannst einen Wert eines Built-in-Typs oder eine Instanz eines benutzerdefinierten Typs als konstant deklarieren. Das Ergebnis ist das gleiche. Wenn du versuchst, diesen zu ändern, erhältst du das, was du verdienst: einen Compile-Fehler:</div>
<div class="pre">struct Immutable{<br>&nbsp;&nbsp;&nbsp; int val{12};<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; const int val{12};<br>&nbsp;&nbsp;&nbsp; val = 13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // assignment of read-only variable 'val'<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; const Immutable immu;<br>&nbsp;&nbsp;&nbsp; immu.val = 13; // assignment of member 'Immutable::val' in read-only object<br>}</div>
<div class="text">Die Fehlermeldung des GCC, eingebettet im Listing, ist sehr überzeugend. <br></div>
<div class="ztitel"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-fct" alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22Con.2%3A%20By%20default%2C%20make%20member%20functions%20const%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-fct%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-fct%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-fct">Con.2: By default, make member functions const</a> <br></div>
<div class="text">Methoden einer Klasse als "const" zu erklären, besitzt doppelten Mehrwert. In diesem Fall kann nur ein konstantes Objekt die Methode aufrufen und die konstante Methode kann das zugrunde liegende Objekte nicht modifizieren. Und nochmals. Hier ist ein einfaches Beispiel, das die Fehlermeldung des GCC eingebettet enthält: <br></div>
<div class="pre">struct Immutable{<br>&nbsp;&nbsp;&nbsp; int val{12};<br>&nbsp;&nbsp;&nbsp; void canNotModify() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = 13;&nbsp; // assignment of member 'Immutable::val' in read-only object<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; void modifyVal() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = 13;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; const Immutable immu;<br>&nbsp;&nbsp;&nbsp; immu.modifyVal();&nbsp; // passing 'const Immutable' as 'this' argument discards qualifiers <br>}</div>
<div class="text">Dies war nur die halbe Wahrheit. Manchmal gilt es, zwischen der logischen und physikalischen Konstantheit eines Objekts zu unterscheiden. Klingt komisch. Oder?</div>
<div><ul><li>Physikalische Konstantheit: Dein Objekt ist als konstant deklariert und kann daher nicht verändert werden.</li><li>Logische Konstantheit: Dein Objekt ist als konstant deklariert und kann trotzdem verändert werden.</li></ul></div>
<div class="text">Die physikalische Konstantheit ist einfach zu verdauen, die logische Konstantheit hingegen nicht. Lasse mich das vorherige Programm ein wenig verändern. Nimm dazu an, dass ich das Attribut [i]val[/i] in einer konstanten Methode verändern will: <br></div>
<div class="pre">// mutable.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Immutable{<br>&nbsp;&nbsp;&nbsp; mutable int val{12};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; void canNotModify() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = 13;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; const Immutable immu;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "val: " &lt;&lt; immu.val &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; immu.canNotModify();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "val: " &lt;&lt; immu.val &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Dank des Bezeichners [i]mutable[/i] (1) ist die Magie möglich. Das konstante Objekt kann daher die konstante Methode (2) aufrufen, die [i]val[/i] verändet.</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_157862419_51378f2804.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wozu ist [i]mutable[/i] nützlich? Hier kommt ein netter Anwendungsfall Stelle dir vor, deine Klasse hat eine "constant read"-Funktion. Da du Instanzen der Klasse [i]concurrent[/i] verwendest, musst du die Funktion durch einen Mutex schützen. Daher erhält die Klasse einen Mutex und du lockst diesen in der [i]read[/i] Methode. Jetzt hast du ein Problem. Deine [i]read[/i]-Methode kann nicht konstant sein, den in ihr wird der Mutex gelockt. Die Lösung besteht nun darin, den Mutex als [i]mutable[/i] zu erklären.</div>
<div class="text">Die Klasse [i]Immutable[/i] erhält eine einfache Umsetzung der Idee. Ohne [i]mutable[/i] würde der Code nicht kompilieren:<br></div>
<div class="text"><span class="tx_code">struct Immutable{<br>&nbsp;&nbsp;&nbsp; mutable std::mutex m;<br>&nbsp;&nbsp;&nbsp; int read() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(m);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // critical section<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; }<br>};</span></div>
<div class="ztitel"><a alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Con.3%3A%20By%20default%2C%20pass%20pointers%20and%20references%20to%20consts%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-ref%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-ref%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-ref" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-ref">Con.3: By default, pass pointers and references to consts</a> <br></div>
<div class="text">Wenn du einen Zeiger oder eine Refererenz auf ein konstantes Datum übergibst, ist die Absicht der Funktion eindeutig. Das referenzierte Objekt kann nicht verändert werden: </div>
<div class="pre">void getCString(const char* cStr);<br>void getCppString(const std::string&amp; cppStr);</div>
<div class="text">Sind beide Deklarationen äquivalent? Nicht hundertprozentig. Im Falle der Funktion [i]getCString[/i] kann der Zeiger ein Nullzeiger sein. Das heißt, du musst ihn immer vor seiner Verwendung prüfen: [i]if (cStr ...[/i].<br></div>
<div class="text">Aber das ist noch nicht alles. Sowohl der Zeiger als auch das Objekt, auf das der Zeiger verweist, kann konstant sein. Hier sind die Variationen:</div>
<div class="text"><ul><li><b>[i]const char* cStr</b>[/i]: [i]cStr[/i] verweist auf ein [i]char[/i], das konstant ist: Das referenzierte Objekte kann nicht verändert werden.<br></li><li><b>[i]char* const cStr</b>[/i]: [i]cStr[/i] ist ein konstanter Zeiger; der Zeiger kann nicht verändert werden. <br></li><li>[i]const char* const cStr[/i]: [i]cStr[/i] ist ein konstanter Zeiger auf ein [i]char[/i]<span class="tx_code">,</span> das selbst konstant ist; weder der Zeiger noch das referenziert Objekt können verändert werden.</li></ul></div>
<div class="text">Zu kompliziert? Lies die Ausdrücke von rechts nach links. Immer noch zu kompliziert. Verwende eine Referenz auf [i]const[/i]<span class="tx_code">.</span></div>
<div class="text">Die nächsten zwei Regeln möchte ich aus dem Blickwinkel der Concurrency betrachten. Daher fasse ich beide Regeln zusammen.<br></div>
<div class="ztitel"><ul><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-const" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-const%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-const%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Con.4%3A%20Use%20const%20to%20define%20objects%20with%20values%20that%20do%20not%20change%20after%20construction%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-const" class="">Con.4: Use const to define objects with values that do not change after construction</a>, und</li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-constexpr" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-constexpr%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Con.5%3A%20Use%20constexpr%20for%20values%20that%20can%20be%20computed%20at%20compile%20time%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconst-constexpr%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-constexpr" class="">Con.5: Use constexpr for values that can be computed at compile time</a> </li></ul></div>
<div class="text">Wenn du eine Variable [i]immutable[/i] zwischen Threads teilen willst und diese Variable ist als konstant deklariert, bist du fertig. Du kannst [i]immutable[/i] ohne Synchronisation verwenden und erhältst die maximale Performanz aus deiner Maschine. Der Grund ist naheliegend. Die notwendige Voraussetzung für ein Data Race ist ein geteilter, veränderlicher Zustand.</div>
<div class="text"><ul><li><b>Data</b> <b>Race:</b> Zumindest zwei Threads greifen gleichzeitig auf eine Variable zu. Mindestens ein Thread versucht, sie dabei zu verändern.&nbsp; </li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_157862440_eb8662449c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Jetzt gibt es nur noch ein Problem zu lösen. Du musst die Variable in einer thread-sicheren Weise initialisieren. Mir fallen dazu vier Möglichkeiten ein.</div>
<div class="text"><ol><li> Initialisieren den gemeinsamen Zustand, bevor du einen Thread gestartet hast.</li><li>Verwende die Funktion [i]std::call_once[/i] in Kombination mit dem Flag [i]std::once_flag[/i].</li><li>Verwende eine statische Variable mit Blockgültigkeit.</li><li>Verwende eine [i]constexpr[/i]-Variable.</li></ol></div>
<div class="text">Viele Entwickler übersehen die Variante 1, die am einfachsten umzusetzen ist. Du kannst mehr zur thread-sicheren Initialisierung einer Variable in dem Artikel "<a class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/sicheres-initialisieren-der-daten" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fsicheres-initialisieren-der-daten%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Sichere%20Initialisierung%20einer%20Variable%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fsicheres-initialisieren-der-daten%22%7D" href="https://www.grimm-jaud.de/index.php/blog/sicheres-initialisieren-der-daten">Sichere Initialisierung einer Variable</a>" nachlesen. <br></div>
<div class="text">In der Regel Con.5 geht es um den Punkt 4. Wenn du eine Variable als konstanten Ausdruck [i]constexpr double totallyConst = 5.5;[/i] erklärst, wird er zum Compilezeit initialisiert und ist damit thread-sicher.</div>
<div class="text">Das war noch nicht alles zu&nbsp;<span class="tx_code">[i]constexpr[/i].</span> Die C++ Core Guidelines erwähnen einen wichtigen Aspekt von [i]constexpr[/i] in Concurrent-Umgebungen nicht.&nbsp;<span class="tx_code">[i]constexpr[/i]-</span>Funktionen sind reinen Funktionen sehr ähnlich. Hier kommt ein Beispiel für einen [i]constexpr gcd[/i]: <br></div>
<div class="text"><span class="tx_code">constexpr int gcd(int a, int b){<br>&nbsp; while (b != 0){<br>&nbsp;&nbsp;&nbsp; auto t= b;<br>&nbsp;&nbsp;&nbsp; b= a % b;<br>&nbsp;&nbsp;&nbsp; a= t;<br>&nbsp; }<br>&nbsp; return a;<br>}</span></div>
<div class="text">Zuerst einmal, was heißt "pure" und was heißt vor allem eine "Art pure". </div>
<div class="text">Eine&nbsp; [i]constexpr[/i]-Funktion kann potentiell zur Compilezeit ausgeführt werden. Zur Compilezeit gibt es keinen Zustand. Insbesondere bedeutet dies, dass zur Compilezeit ausgeführte [i]constexpr[/i]-Funktionen reine Funktionen sein müssen. Reine Funktionen sind Funktionen,&nbsp;die immer den gleichen Wert zurückgeben, wenn sie mit den gleichen Argumenten aufgerufen werden. Reine Funktionen verhalten sich wie unendlich große Tabellen, in denen der Wert einfach nur nachgeschlagen wird. Diese Zusicherung, dass ein Ausdruck immer den gleichen Wert zurückgibt, wenn er mit den gleichen Argumenten bedient wird, nennt sich <a alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FReferenzielle_Transparenz%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FReferenzielle_Transparenz%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Referenzielle%20Transparenz%22%2C%22user_params%22%3A%22%22%7D" href="https://de.wikipedia.org/wiki/Referenzielle_Transparenz" class="" title="Link auf https://de.wikipedia.org/wiki/Referenzielle_Transparenz">Referenzielle Transparenz</a>. Reine Funktionen besitzen viele Vorteile:</div>
<div class="text"><ol><li>Der Funktionsaufruf kann&nbsp;durch sein Ergebnis ersetzt werden.</li><li>Die Ausführung der Funktion kann automatisch auf andere Threads verteilt werden.</li><li>Funktionsaufrufe können umsortiert werden.</li><li>Sie können einfach refaktoriert oder in Isolation getestet werden.</li></ol></div>
<div class="text">Insbesondere der Punkt 2 macht reine Funktionen zu solch wertvollen Funktionen in Concurrent-Programmen. Die folgende Tabelle bringt die Charakteristiken von reinen Funktionen explizit auf den Punkt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_157862433_761eea4d1e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich will es gerne noch explizit betonen. [i]constexpr[/i]-Funktionen sind nicht per se rein. Sie sind nur rein, wenn sie zur Compilezeit ausgeführt werden.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Das war es schon. Ich habe in diesem Artikel alle Regeln zur Konstantheit und Unveränderlichkeit der C++ Core Guidelines vorgestellt. In nächsten Artikel schreibe ich über die Zukunft von C++: Templates und generische Programmierung.</div>
<div class="ztitel">C++-Schulungen im Großraum Stuttgart</div>
<div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen. </div>
<div class="text"><ul><li>&nbsp;<a title="Link auf https://www.modernescpp.de/index.php/c/2-c/4-c-11-und-c-1420160101184722" class="" href="https://www.modernescpp.de/index.php/c/2-c/4-c-11-und-c-1420160101184722" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F4-c-11-und-c-1420160101184722%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F4-c-11-und-c-1420160101184722%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D">C++11 und C++14</a>: 11. bis 13. 09. (Termingarantie)</li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F14-multithreading-mit-c20160404172352%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F14-multithreading-mit-c20160404172352%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Multithreading%20mit%20modernem%20C%2B%2B%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/14-multithreading-mit-c20160404172352" class="" title="Link auf https://www.modernescpp.de/index.php/c/2-c/14-multithreading-mit-c20160404172352">Multithreading mit modernem C++</a>: 13. bis 14. 11. <br></li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/17-embedded-programmierung-mit-modernem-c20170911213829" class="" href="https://www.modernescpp.de/index.php/c/2-c/17-embedded-programmierung-mit-modernem-c20170911213829" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F17-embedded-programmierung-mit-modernem-c20170911213829%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F17-embedded-programmierung-mit-modernem-c20170911213829%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D">Embedded-Programmierung mit modernem C++</a>: 15. bis 17. 01.</li></ul></div>
<div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22www.ModernesCpp.de.%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%22%2C%22anchor%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php" class="" title="Link auf https://www.modernescpp.de/index.php">www.ModernesCpp.de.</a> </div>
