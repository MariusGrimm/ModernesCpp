<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_142562554_3b1e37eb22.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="vorspann">Hier geht es um Klassenhierarchien im Allgemeinen und im Speziellen. Die C++ Core Guidelines bieten gut 30 Regeln dazu an. Es gibt also viel zu erzählen.<br></div>
<div class="text">Aber zuerst einmal was ist eine Klassenhierarchie? Die Guidelines geben eine eindeutige Antwort: Sie repräsentiert eine Menge hierarchisch organisierter Konzepte. Die Basisklassen stellen typischerweise das Interface dar. Es gibt zwei Typen von Interfaces. Die erste Form wird gerne als Schnittstellenvererbung (interface inheritance), die zweite als Implementierungsvererbung (implementation interface) bezeichnet.</div>
<div class="text">Die ersten drei Regeln besitzen einen sehr allgemeinen Fokus. Sie sind quasi die Zusammenfassung für die deutlich konkreteren Regeln, die im Anschluss folgen.</div>
<div class="ztitel">Class hierarchy rule summary:</div>
<div class="text"><ul><li> <a alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.120%3A%20Use%20class%20hierarchies%20to%20represent%20concepts%20with%20inherent%20hierarchical%20structure%20%28only%29%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-domain%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-domain%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-domain" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-domain">C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.121%3A%20If%20a%20base%20class%20is%20used%20as%20an%20interface%2C%20make%20it%20a%20pure%20abstract%20class%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" class="">C.121: If a base class is used as an interface, make it a pure abstract class</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-separation" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.122%3A%20Use%20abstract%20classes%20as%20interfaces%20when%20complete%20separation%20of%20interface%20and%20implementation%20is%20needed%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-separation%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-separation%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-separation" class="">C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed</a> </li></ul></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-domain" alt="%7B%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.120%3A%20Use%20class%20hierarchies%20to%20represent%20concepts%20with%20inherent%20hierarchical%20structure%20%28only%29%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-domain%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-domain%22%2C%22target%22%3A%22_blank%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-domain">C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)</a></b></div>
<div class="text">Diese Regel ist recht einleuchtend. Falls du etwas in Code modellierst, das eine inhärent hierarchische Struktur besitzt, solltest du es als Hierarchie modellieren. Für mich ist die einfachste Art, mir zu meinem Code Gedanken zu machen, die, wenn es gelingt, eine Analogie zwischen der Welt und meinem Code herzustellen. </div>
<div class="text">Zum Beispiel kann die Aufgabe eines Softwarearchitekts darin bestehen, ein komplexes System zu modellieren, das aus einer Menge von Subsystemen besteht. Dieses komplexe System war in meinem konkreten Fall eine Familie von Defibrillatoren dar. Ein exemplarisches Subsystem stellt die Schnittstelle zum Benutzer dar. Damit gab es die Anforderung, verschiedene Benutzerschnittstellen wie Tastatur, Touchscreen oder einfach auch nur Buttons zu unterstützen. Solch ein System von Subsystemen besitzt eine inhärent hierarchische Struktur. Meine Modellierung bildete daher die physikalische Struktur ab und war damit relativ leicht im Top-down-Ansatz zu erfassen.<br></div>
<div class="text">Selbstverständlich ist das exemplarische Beispiel für die Anwendung eine Hierarchie der Entwurf einer grafischen Beschnutzerschnittstelle (GUI). Genau dies Beispiel verwendet die C++ Core Guidelines:</div>
<div class="pre">class DrawableUIElement {<br>public:<br>&nbsp; virtual void render() const = 0;<br>// ...<br>};<br>class AbstractButton : public DrawableUIElement {<br>public:<br>&nbsp; virtual void onClick() = 0;<br>// ...<br>};<br>class PushButton : public AbstractButton {<br>&nbsp; virtual void render() const override;<br>&nbsp; virtual void onClick() override;<br>// ...<br>};<br>class Checkbox : public AbstractButton {<br>// ...<br>};<br></div>
<div class="text">Wenn hingegen das zu modellierende System nicht inhärent hierarchisch ist, solltest du es auch nicht hierarchisch modellieren. Genau das bringt das Codefragment auf den Punkt.<br></div>
<div class="pre">template&lt;typename T&gt;<br>class Container {<br>public:<br>&nbsp;&nbsp;&nbsp; // list operations:<br>&nbsp;&nbsp;&nbsp; virtual T&amp; get() = 0;<br>&nbsp;&nbsp;&nbsp; virtual void put(T&amp;) = 0;<br>&nbsp;&nbsp;&nbsp; virtual void insert(Position) = 0;<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; // vector operations:<br>&nbsp;&nbsp;&nbsp; virtual T&amp; operator[](int) = 0;<br>&nbsp;&nbsp;&nbsp; virtual void sort() = 0;<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; // tree operations:<br>&nbsp;&nbsp;&nbsp; virtual void balance() = 0;<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Warum ist das Beispiel schlecht? Die Antwort steht direkt im Sourcecode. Das Klassen-Template <i>Container</i> besteht nur aus rein virtuellen Funktionen, um eine Liste, einen Vektor und einen Baum zu modellieren. Das bedeutet, falls du Container als Interface verwendest, musst du drei vollkommen verschiedene Konzepte implementieren.</div>
<div class="text"><b><a class="" alt="%7B%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract%22%2C%22text%22%3A%22C.121%3A%20If%20a%20base%20class%20is%20used%20as%20an%20interface%2C%20make%20it%20a%20pure%20abstract%20class%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract">C.121: If a base class is used as an interface, make it a pure abstract class</a></b></div>
<div class="text">Eine abstrakte Klasse ist eine Klasse, die zumindestens eine rein virtuelle Funktion besitzt. Ein rein virtuelle Funktion (<i>virtual void function() = 0</i>) ist eine Funktion, die durch eine abgeleitete Klasse implementiert werden muss, falls die Klasse selbst nicht abstrakt sein soll. </div>
<div class="text">Nur der Vollständigkeit halber. Eine abstrakte Klasse kann bereits Implementierungen für die rein virtuellen Funktionen anbieten. Diese Implementierungen lassen sich von abgeleiteten Klassen verwenden.<br></div>
<div class="text">Interfaces sollten aus öffentlichen rein virtuellen Funktionen bestehen und einen default/leeren virtuellen Destruktor (<i>virtual ~My_interface() = defaul</i>t) besitzen. Falls du dieser Regel nicht folgst, kann es zu bösen Überraschungen kommen.</div>
<div class="pre">class Goof {<br>public:<br>// ...only pure virtual functions here ...<br>// no virtual destructor<br>};<br>class Derived : public Goof {<br>string s;<br>// ...<br>};<br>void use()<br>{<br>&nbsp; unique_ptr&lt;Goof&gt; p {new Derived{"here we go"}};<br>&nbsp; f(p.get()); // use Derived through the Goof interface <br>} // leak<br></div>
<div class="text">Falls<i> p</i> seinen Gültigkeitsbereich verlässt, wird es automatisch destruiert. <i>Goof</i> besitzt keinen virtuellen Destruktor. Daher wird der Destruktor von <i>Goof</i> und nicht von <i>Derived</i> aufgerufen. Die böse Überraschung ist, dass der Destruktor des Strings<i> s </i> nicht automatisch aufgerufen wird. Damit gibt es ein Speicherleck.<br></div>
<div class="text"><b><a class="" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.122%3A%20Use%20abstract%20classes%20as%20interfaces%20when%20complete%20separation%20of%20interface%20and%20implementation%20is%20needed%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-separation%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-separation%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-separation" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-separation">C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed</a></b></div>
<div class="text">Bei abstrakten Klassen geht es um die Trennung von Interface und Implementierung. Wenn dein Client nur vom Interface abhängst, ist das Ergebnis, dass du verschiedene Implementierung des Devices im folgenden Beispiel zur Laufzeit verwenden kannst.<br></div>
<div class="pre">struct Device {<br>&nbsp; virtual void write(span&lt;const char&gt; outbuf) = 0;<br>&nbsp; virtual void read(span&lt;char&gt; inbuf) = 0;<br>};<br>class D1 : public Device {<br>// ... data ...<br>void write(span&lt;const char&gt; outbuf) override;<br>&nbsp; void read(span&lt;char&gt; inbuf) override;<br>};<br>class D2 : public Device {<br>// ... different data ...<br>&nbsp; void write(span&lt;const char&gt; outbuf) override;<br>&nbsp; void read(span&lt;char&gt; inbuf) override;<br>};</div>
<div class="text">Ich nenne diese Regel gerne das Meta Design Pattern. Das Konzept, Interface und Implementeriung zu trennen und gegen das Interface zu programmieren, ist die Grundlage für viele der Design Pattern des wohl einflussreichsten Buch der Softwareentwicklung: <a href="https://en.wikipedia.org/wiki/Design_Patterns" class="" alt="%7B%22text%22%3A%22Design%20Patterns%3A%20Elements%20of%20Reusable%20Object-Oriented%20Software.%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDesign_Patterns%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDesign_Patterns%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software.</a></div>
<div class="ztitel">Designing rules for classes in a hierarchy summary</div>
<div class="text">Jetzt kommen die detallierten Regeln zur Klassenhierarchien. Die Guidelines besitzen fünfzehn davon.</div>
<div class="text"><ul><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract-ctor" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract-ctor%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract-ctor%22%2C%22text%22%3A%22C.126%3A%20An%20abstract%20class%20typically%20doesn%C2%92t%20need%20a%20constructor%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract-ctor">C.126: An abstract class typically doesn’t need a constructor</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dtor" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dtor%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dtor%22%2C%22text%22%3A%22C.127%3A%20A%20class%20with%20a%20virtual%20function%20should%20have%20a%20virtual%20or%20protected%20destructor%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dtor">C.127: A class with a virtual function should have a virtual or protected destructor</a> <br></li><li> <a alt="%7B%22text%22%3A%22C.128%3A%20Virtual%20functions%20should%20specify%20exactly%20one%20of%20virtual%2C%20override%2C%20or%20final%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-override%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-override%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override">C.128: Virtual functions should specify exactly one of virtual, override, or final</a> <br></li><li>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance<br></li><li>C.130: Redefine or prohibit copying for a base class; prefer a virtual clone function instead<br></li><li>C.131: Avoid trivial getters and setters<br></li><li>C.132: Don’t make a function virtual without reason<br></li><li>C.133: Avoid protected data<br></li><li>C.134: Ensure all non-const data members have the same access level<br></li><li>C.135: Use multiple inheritance to represent multiple distinct interfaces<br></li><li>C.136: Use multiple inheritance to represent the union of implementation attributes<br></li><li>C.137: Use virtual bases to avoid overly general base classes<br></li><li>C.138: Create an overload set for a derived class and its bases with using<br></li><li>C.139: Use final sparingly<br></li><li>C.140: Do not provide different default arguments for a virtual function and an overrider</li></ul></div>
<div class="text">In diesem Artikel geht es um die ersten drei Regeln.</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract-ctor" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-abstract-ctor" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract-ctor%22%2C%22text%22%3A%22C.126%3A%20An%20abstract%20class%20typically%20doesn%C2%92t%20need%20a%20constructor%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-abstract-ctor%22%2C%22target%22%3A%22_blank%22%7D">C.126: An abstract class typically doesn’t need a constructor</a></b></div>
<div class="text">Eine abstrakte Klasse besitzt typischerweise keine Daten. Damit benötigt sie natürlich auch keinen Konstruktor um diese zu initialisieren. <br></div>
<div class="text"><b><a class="" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dtor%22%2C%22text%22%3A%22C.127%3A%20A%20class%20with%20a%20virtual%20function%20should%20have%20a%20virtual%20or%20protected%20destructor%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dtor%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dtor" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dtor">C.127: A class with a virtual function should have a virtual or protected destructor</a></b></div>
<div class="text">Eine Klasse mit virtuellen Funktionen wird meist mittels eines Zeigers oder einer Referenz auf ihre Basisklasse verwendet. Falls du die abgeleitete Klasse explizit mit einem Zeiger oder einer Referenz auf die Basisklasse oder implizit mit einem Smart Pointer löschst, willst du sicher gehen, dass auch der Destruktor der abgeleiteten Klasse aufgerufen wird. Diese Regel ist sehr ähnlich zur Regel C.121, die sich mit rein virtuellen Funktionen beschäftigt. </div>
<div class="text">Du kannst die Destruktionsherausforderung aber auch dadurch lösen, dass die Basisklasse einen protected und nichtvirtuellen Destruktor besitzt. Dieser Destruktor stellt sicher, dass sich ein abgeleitetes Objekt nicht mittels eines Zeigers oder einer Referenz auf die Basisklasse löschen lässt. </div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override" alt="%7B%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.128%3A%20Virtual%20functions%20should%20specify%20exactly%20one%20of%20virtual%2C%20override%2C%20or%20final%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-override%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-override%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%7D" class="">C.128: Virtual functions should specify exactly one of virtual, override, or final</a></b></div>
<div class="text">In C++11 gibt es drei Schlüsselworte, die sich mit dem Überschreiben von Funktionen beschäftigen. </div>
<div class="text"><ul><li><b>virtual:</b> erklärt eine Funktion, die in einer abgeleiteten Klasse überschrieben werden kann.</li><li><b>override:</b> stellt sicher, dass die Funktion virtuell ist und ein virtuelle Funktion einer Basisklasse überschreibt.<br></li><li><b>final:</b> stellt sicher, dass die Funktion virtuell ist und sie nicht durch eine abgeleitete Klasse überschrieben werden kann. <br></li></ul></div>
<div class="text">Die Guidelines sind sehr eindeutig, wenn es um die richtige Verwendung der drei Schlüsselwörter geht. </div>
<div class="text"><ul><li>Verwende <b>virtual</b> nur, wenn du eine neue, virtuelle Funktion definierst.</li><li>Verwende <b>override</b> nur, wenn du eine überschreibende Funktion erklärst.</li><li>Verwende <b>final</b> nur, wenn du eine überschreibende Funktion erklärst, die selbst nicht mehr überschrieben werden soll.<br></li></ul></div>
<div class="pre">struct Base{<br>&nbsp;&nbsp;&nbsp; virtual void testGood(){}<br>&nbsp;&nbsp;&nbsp; virtual void testBad(){}<br>};<br><br>struct Derived: Base{<br>&nbsp;&nbsp;&nbsp; void testGood() final {}<br>&nbsp;&nbsp;&nbsp; virtual void testBad() final override {}<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; Derived d;<br>}<br></div>
<div class="text">Die Methode <i>testBad() </i>in der Klasse<i> Derived </i>besitzt sehr viel überflüssige Informationen. </div>
<div class="text"><ul><li>Du sollst nur <i>final</i> oder <i>override</i> verwenden, falls die Funktion virtuell ist. Entferne <i>virtual: void testBad() final override{}</i></li><li>Das Schlüsselwort <i>final</i> ohne das Schlüsselwort <i>virtual</i> zu verwenden, ist nur gültig, falls die Funktion bereits virtuell ist. Daher muss die Funktion eine Funktion einer Basisklasse überschreiben. Entferne <i>override: void testBad() final {}</i></li></ul></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Die verbleibenden zwölf Regeln zu Klassenhierarchien habe ich noch nicht vorgestellt. Mein nächster Artikel wird dieses Loch schließen.</div>
<div class="ztitel">Weitere Informationen</div>
<div class="text"><ul><li> Bei der Umfrage, welches PDF-Päckchen ich als Nächstes zusammenstellen soll, hat C++17 deutlich die Nase vorn.</li><li><i>default</i>,<i> delete, override</i> und <i>final</i>: <a alt="%7B%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2014%2F08%2FC-11%22%2C%22text%22%3A%22Automatik%20mit%20Methode%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2014%2F08%2FC-11%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf http://www.linux-magazin.de/Ausgaben/2014/08/C-11" class="" href="http://www.linux-magazin.de/Ausgaben/2014/08/C-11">Automatik mit Methode</a> (freier Artikel für das Linux-Magazin)<br></li></ul></div>
