<div class="vorspann">Die Interfaces von Templates sind nach dem Wortlaut der C++ Core Guidelines ein "kritisches Konzept", denn das Interface eines Templates ist ein "ein Vertrag zwischen einem Anwender und einem Implementierer – und sollte sorgfältig designt werden".</div>
<div class="text">Dies sind die vier Regeln für den heutigen Artikel: </div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-essential" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-essential" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22T.41%3A%20Require%20only%20essential%20properties%20in%20a%20template%C2%92s%20concepts%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-essential%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-essential%22%2C%22version%22%3A1%7D">T.41: Require only essential properties in a template’s concepts</a> </li><li> <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-alias%22%2C%22text%22%3A%22T.42%3A%20Use%20template%20aliases%20to%20simplify%20notation%20and%20hide%20implementation%20details%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-alias%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-alias" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-alias">T.42: Use template aliases to simplify notation and hide implementation details</a> </li><li> <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-using%22%2C%22text%22%3A%22T.43%3A%20Prefer%20using%20over%20typedef%20for%20defining%20aliases%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-using%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-using" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-using" class="">T.43: Prefer using over typedef for defining aliases</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-deduce" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-deduce" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-deduce%22%2C%22text%22%3A%22T.44%3A%20Use%20function%20templates%20to%20deduce%20class%20template%20argument%20types%20%28where%20feasible%29%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-deduce%22%7D">T.44: Use function templates to deduce class template argument types (where feasible)</a></li></ul></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-essential" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-essential" alt="%7B%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-essential%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-essential%22%2C%22text%22%3A%22T.41%3A%20Require%20only%20essential%20properties%20in%20a%20template%C2%92s%20concepts%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">T.41: Require only essential properties in a template’s concepts</a> <br> </div>
<div class="text">Was bedeutet es, lediglich die wesentlichen Eigenschaften zu spezifizieren? Die Guidelines beantworten diese Frage mit einem Sort-Algorithmus, der Debug-Unterstützung anbietet:</div>
<div class="pre">template&lt;Sortable S&gt;<br>&nbsp;&nbsp;&nbsp; requires Streamable&lt;S&gt;<br>void sort(S&amp; s)&nbsp; // sort sequence s<br>{<br>&nbsp;&nbsp;&nbsp; if (debug) cerr &lt;&lt; "enter sort( " &lt;&lt; s &lt;&lt;&nbsp; ")\n";<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; if (debug) cerr &lt;&lt; "exit sort( " &lt;&lt; s &lt;&lt;&nbsp; ")\n";<br>}</div>
<div class="text">Jetzt gilt es, noch eine Frage zu beantworten: Welche Probleme können auftreten, wenn unwesentliche Eigenschaften spezifiziert werden? Das bedeutet, dass das Concept zu stark an die Implementierung gebunden ist. Die Auswirkung kann sein, dass eine leichte Veränderung der Implementierung eine Anpassung der Concepts nach sich zieht. Letztlich wird dadurch das Interface sehr unstabil. <br></div>
<div class="ztitel"><a alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-alias%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.42%3A%20Use%20template%20aliases%20to%20simplify%20notation%20and%20hide%20implementation%20details%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-alias%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-alias" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-alias" class="">T.42: Use template aliases to simplify notation and hide implementation details</a> <br> </div>
<div class="text">Seit C++11 unterstützt C++ Template Aliase. Ein Template Alias ist ein Name, der für eine Familie von Typen steht. Werden diese verwendet, wird der Code lesbarer und er kann oft Type Traits vermeiden. In dem Artikel "<a alt="%7B%22destination%22%3A2529732%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Definition%20von%20Concepts%2C%20die%20Zweite%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Db8b1c6f0fa5809ce91a98ae12496674a%26rm%3Dopen_article_id%26bid%3D2529732%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=b8b1c6f0fa5809ce91a98ae12496674a&amp;rm=open_article_id&amp;bid=2529732" class="" title="Link auf Beitrag 2529732">C++ Core Guidelines: Definition von Concepts, die Zweite</a>" gehe ich auf Type Traits genauer ein.</div>
<div class="text">Was meinen die Guidelines, wenn sie von besserer Lesbarkeit sprechen? Das erste Beispiel verwendet Type Traits:<br></div>
<div class="pre">template&lt;typename T&gt;<br>void user(T&amp; c)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; typename container_traits&lt;T&gt;::value_type x; // bad, verbose<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Im Vergleich setzt das folgende Beispiel Template Aliase ein.</div>
<div class="pre">template&lt;typename T&gt;<br>using Value_type = typename container_traits&lt;T&gt;::value_type;<br><br>void user2(T&amp; c)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; Value_type&lt;T&gt; x;<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="text">Lesbarkeit ist auch das Argument, das für die nächste Regel gilt.<br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-using" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-using" alt="%7B%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-using%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.43%3A%20Prefer%20using%20over%20typedef%20for%20defining%20aliases%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-using%22%7D">T.43: Prefer using over typedef for defining aliases</a> <br> </div>
<div class="text">Aus der Perspektive der Lesbarkeit betrachtet gibt es zwei Argumente, die für <i>using</i> anstelle von <i>typedef</i> sprechen. Erstens wird <i>using </i>direkt am Anfang des Ausdrucks verwendet. Zweitens fühlt sich <i>using </i>sehr ähnlich an wie <i>auto</i>. Darüber hinaus gilt, das [i]using[/i] einfach für Template Aliase verwendet werden kann: <br></div>
<div class="pre">typedef int (*PFI)(int);&nbsp;&nbsp;&nbsp;&nbsp; // OK, but convoluted<br><br>using PFI2 = int (*)(int);&nbsp;&nbsp; // OK, preferred<br><br>template&lt;typename T&gt;<br>typedef int (*PFT)(T);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error (1) <br><br>template&lt;typename T&gt;<br>using PFT2 = int (*)(T);&nbsp;&nbsp;&nbsp;&nbsp; // OK<br></div>
<div class="text">Die ersten zwei Zeilen definieren einen Zeiger auf eine Funktion (<i>PFI </i>und <i>PFI2)</i>, der ein<i> int</i> annimmt und ein <i>int </i>zurückgibt. Im ersten Fall kommt <i>typedef</i> zum Einsatz und im zweiten Fall <i>using</i>. Die letzten zwei Zeilen definieren ein Funktions-Template (<i>PFT2</i>), das einen Typ-Parameter<i> T</i> annimmt und ein <i>int </i>zurückgibt. Die Zeile (1) ist hingegen nicht gültig. <br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-deduce" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-deduce" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-deduce%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-deduce%22%2C%22text%22%3A%22T.44%3A%20Use%20function%20templates%20to%20deduce%20class%20template%20argument%20types%20%28where%20feasible%29%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D">T.44: Use function templates to deduce class template argument types (where feasible)</a> <br> </div>
<div class="text">Der entscheidende Grund dafür, dass wir so viele <i>make_</i>-Funktionen in C++ wie <i>std::make_tuple</i> oder <i>std::make_unique </i>besitzen, ist, dass Funktions-Templates ihre Template-Argumente aus den Funktionsargumenten ableiten können. Während dieses Vorgangs wendet der Compiler nur einfache Konvertierungen an. So entfernt er den äußersten <i>const/volatile-</i>Qualifizierer und vereinfacht C-Arrays und Funktionen zu Zeigern auf das erste Element des C-Arrays oder einen Zeiger auf die Funktion. </div>
<div class="text">Mit dieser automatischen Bestimmung der Template-Argumente wird unser Leben als Programmierer deutlich einfacher. </div>
<div class="text">Anstelle eins Ausdrucks</div>
<div class="pre">std::tuple&lt;int, double, std::string&gt; myTuple = {2011, 20.11, "C++11"};<br></div>
<div class="text">lässt sich einfach die Fabrikfunktion [i]std::make_tuple[/i] anwenden.<br></div>
<div class="pre">auto myTuple = std::make_tuple(2011, 20.11, "C++11");</div>
<div class="text">Traurig, aber die automatische Bestimmung der Template-Argumente gibt es in C++ nur für Funktions-Templates. Warum? Konstruktoren von Klassen-Templates sind doch auch nur spezielle, statische Funktionen. Genau! Mit C++17 kann der Compiler die Template-Argumente direkt von seinen Konstruktorargumenten ableiten. </div>
<div class="text">Das folgende Beispiel stellt die Vereinfachung vor, dank der sich <i>myTuple</i> in C++17 definieren lässt: <br></div>
<div class="pre">std::tuple myTuple = {2017, 20.17, "C++17"};</div>
<div class="text">Eine offensichtliche Auswirkung dieses C++17-Features ist es, dass die meisten der <i>make_</i>-Funktionen in C++17 obsolet werden. </div>
<div class="text">Falls du die Details zur automatischen Ableitung der Template-Argumente lesen willst und dich darüber hinaus den Argument Deduction Guide interessierst, lege ich dir den Artikel "<a alt="%7B%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Farne-mertz.de%2F2017%2F06%2Fclass-template-argument-deduction%2F%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Farne-mertz.de%2F2017%2F06%2Fclass-template-argument-deduction%2F%22%2C%22text%22%3A%22Modern%20C%2B%2B%20Features%20%5B--%5D%20Class%20Template%20Argument%20Deduction%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://arne-mertz.de/2017/06/class-template-argument-deduction/" class="" href="https://arne-mertz.de/2017/06/class-template-argument-deduction/">Modern C++ Features [--] Class Template Argument Deduction</a>" von Arne Mertz ans Herz.<br></div>
<div class="ztitel_kleiner">C++ schulen<br></div>
<div class="text">Ich muss zugeben, dass ich dieses C++17-Feature sehr gerne mag. Als C++-Trainer ist es meine Aufgabe, die komplexe Sprache C++ zu vermitteln. Je symmetrische C++ wird, desto leichter ist es für mich, die allgemeinen Konzepte hinter C++ zu schulen. Jetzt kann ich einfach sagen: "Ein Template kann seine Template-Argumente automatisch aus seinen Funktionsargumenten ableiten." In der Vergangenheit musste ich hingegen hinzufügen, dass dies nur für Funkions-Template möglich ist. </div>
<div class="text">Hier ist ein einfaches Beispiel:</div>
<div class="pre">// templateArgumentDeduction.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>void showMe(const T&amp; t){<br>&nbsp; std::cout &lt;&lt; t &lt;&lt; std::endl;<br>}<br><br>template &lt;typename T&gt;<br>struct ShowMe{<br>&nbsp; ShowMe(const T&amp; t){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; t &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; showMe(5.5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not showMe&lt;double&gt;(5.5);<br>&nbsp; showMe(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not showMe&lt;int&gt;(5);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; ShowMe(5.5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not ShowMe&lt;double&gt;(5.5);<br>&nbsp; ShowMe(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not ShowMe&lt;int&gt;(5);<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Die Anwendung des Funktions-Templates <i>showMe</i> unterscheidet sich nicht von der des Klassen-Templates <i>ShowMe.</i> Der Anwender weiß nicht, dass er ein Template einsetzt.</div>
<div class="text">Mit dem aktuellen GCC 8.2 lässt sich das Programm übersetzen und ausführen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161950523_a34d174e11.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Um ein wenig genauer zu sein. Die automatische Bestimmung der Template-Argumente steht mit GCC 7, Clang 5 und MSVC 19.14 zu Verfügung. <a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%2C%22text%22%3A%22cppreference.com%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcompiler_support%22%7D" title="Link auf https://en.cppreference.com/w/cpp/compiler_support" class="" href="https://en.cppreference.com/w/cpp/compiler_support">cppreference.com</a> liefert die Details zur Compilerunterstützung. <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Weißt du, was <i>Regular</i> und <i>SemiRegular</i> Datentypen sind? Falls nicht, dann ist mein nächster Artikel zu den Interfaces von Templates genau der richtige für dich. Die Regel T.47 lautet: "Require template arguments to be at last <i>Regular </i>or <i>SemiRegular.</i>"</div>
