<div class="vorspann">Da sich die verbleibenden Regeln zu Templates nicht unter einem gemeinsamen Begriff zusammenfassen lassen, sind die heterogenen Regeln in dem Abschnitt "other" der C++ Core Guidelines gelandet. Diese beschäftigen sich mit Best Practices und Überraschungen.</div>
<div class="text">Hier ist meine Plan für heute.</div>
<div class="text"><ul><li> <a alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.140%3A%20Name%20all%20operations%20with%20potential%20for%20reuse%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-name%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-name%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-name" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-name">T.140: Name all operations with potential for reuse</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-lambda" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-lambda" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-lambda%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-lambda%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.141%3A%20Use%20an%20unnamed%20lambda%20if%20you%20need%20a%20simple%20function%20object%20in%20one%20place%20only%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D">T.141: Use an unnamed lambda if you need a simple function object in one place only</a> </li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22T.143%3A%20Don%C2%92t%20write%20unintentionally%20nongeneric%20code%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nongeneric%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nongeneric%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nongeneric" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nongeneric">T.143: Don’t write unintentionally nongeneric code</a></li></ul></div>
<div class="text">Bei der ersten Regel geht es gleich um Bewährtes.<br></div>
<div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-name" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-name" class="" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-name%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-name%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.140%3A%20Name%20all%20operations%20with%20potential%20for%20reuse%22%2C%22anchor%22%3A%22%22%7D">T.140: Name all operations with potential for reuse</a> <br> </div>
<div class="text">Ehrlich gesagt, weiß ich nicht, warum diese Regeln zu den Regeln für Templates gehört. Vielleicht, da es bei Templates um Wiederverwendung geht oder da das Beispiel den <i>std::find_if</i>-Algorithmus der Standard Template Library verwendet. Egal! Diese Regel ist entscheidend für guten Code.<br></div>
<div class="text">Stelle dir vor, du besitzt einen Vektor von einfachen Datensätzen. Jeder Datensatz besteht aus einem Namen, einer Adresse und einer ID. Oft stehst du vor dem Problem, einen bestimmten Datensatz mit einem spezifischen Namen zu finden. Die Aufgabe ist noch schwieriger, denn du achtest bei dem Name nicht auf dessen Groß- oder Kleinschreibung:</div>
<div class="pre">// records.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;cctype&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>struct Rec {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::string name;<br>&nbsp;&nbsp;&nbsp; std::string addr;<br>&nbsp;&nbsp;&nbsp; int id;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;Rec&gt; vr{ {"Grimm", "Munich", 1},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"huber", "Stuttgart", 2},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"Smith", "Rottenburg", 3},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"black", "Hanover", 4} };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string name = "smith";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto rec = std::find_if(vr.begin(), vr.end(), [&amp;](Rec&amp; r) {&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r.name.size() != name.size()) return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; r.name.size(); ++i){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (std::tolower(r.name[i]) != std::tolower(name[i])) return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (rec != vr.end()){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; rec-&gt;name &lt;&lt; ",&nbsp; " &lt;&lt; rec-&gt;addr &lt;&lt; ", " &lt;&lt; rec-&gt;id &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Die Struktur<i> rec</i> (Zeile 1) besitzt nur öffentliche Mitglieder. Daher lässt sie sich direkt mit <a alt="%7B%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Aggregat-Initialisierung%20%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Faggregate_initialization%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Faggregate_initialization%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" class="" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" title="Link auf https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregat-Initialisierung </a>in Zeile 2 initialisieren. In der Zeile suche ich mithilfe der Lambda-Funktion nach dem Datensatz, der den Namen "<i>smith</i>" besitzt. Daher prüfe ich zuerst, ob beide Namen gleich lang sind und dann vergleiche ich die Buchstaben unabhängig von ihrer Groß- oder Kleinschreibung.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167056106_98d6d66921.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Welches Problem besitzt der Sourcecode? Die Anforderung, Strings unabhängig von dessen Groß- oder Kleinschreibung zu vergleichen, tritt sehr häufig auf. Daher sollte die Lösung der Anforderung in eine Einheit verpackt werden und einen Namen erhalten:</div>
<div class="pre">bool compare_insensitive(const std::string&amp; a, const std::string&amp; b) // (1)<br>{<br>&nbsp;&nbsp;&nbsp; if (a.size() != b.size()) return false;<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; a.size(); ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (std::tolower(a[i]) != std::tolower(b[i])) return false;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return true;<br>}<br><br>std::string name = "smith";<br><br>auto res = std::find_if(vr.begin(), vr.end(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; [&amp;](Rec&amp; r) { compare_insensitive(r.name, name); }<br>);<br><br>std::vector&lt;std::string&gt; vs{"Grimm", "huber", "Smith", "black"};&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>auto res2 = std::find_if(vs.begin(), vs.end(),<br>&nbsp;&nbsp;&nbsp; [&amp;](std::string&amp; r) { compare_insensitive(r, name); }<br>);</div>
<div class="text">Die Funktion <i>compare_insensitive</i> (Zeile 1) gibt der typischen Anforderung einen Namen. Nun lässt sie sich auf einen Vektor von Strings in Zeile 2 anwenden.<br></div>
<div class="ztitel"><a alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.141%3A%20Use%20an%20unnamed%20lambda%20if%20you%20need%20a%20simple%20function%20object%20in%20one%20place%20only%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-lambda%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-lambda%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-lambda" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-lambda">T.141: Use an unnamed lambda if you need a simple function object in one place only</a> <br> </div>
<div class="text">Zugegeben, ich habe häufig eine Diskussion in meinen Schulungen zu der Frage: Wann soll eine Funktion (Funktionsobjekt) oder eine Lambda-Funktion eingesetzt werden? Ehrlich gesagt, ich habe keine einfache Antwort auf diese Frage. Hier widersprechen sich zwei wichtigen Regeln zur Codequalität:</div>
<div class="text"><ol><li>Don't repeat yourself. (<a title="Link auf https://en.wikipedia.org/wiki/Don't_repeat_yourself" class="" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" alt="%7B%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22DRY%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D">DRY</a>)</li><li>Explicit is better than implicit. (<a alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22The%20Zen%20of%20Python%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0020%2F%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0020%2F%22%7D" href="https://www.python.org/dev/peps/pep-0020/" class="" title="Link auf https://www.python.org/dev/peps/pep-0020/">The Zen of Python</a>)</li></ol></div>
<div class="text">Die zweite Regel musste ich mir von Python ausleihen. Für was steht diese Regel. Stelle dir vor, du hast einen altbackenen Fortran-Programmierer in deinem Team. Dieser entgegnet dir: "Jeder Bezeichner muss genau drei Buchstaben lang sein." Daher kann dein Sourcecode zeitweise das folgende Aussehen besitzen:</div>
<div class="pre">auto eUE = std::remove_if(use.begin(), use.end(), igh); </div>
<div class="text">Für was steht zum Beispiel die Funktion <i>igh</i>? <i>Sie </i>steht für eine "id greater hundred". Nun bist du gezwungen, diesen Funktionsaufruf zu dokumentieren. </div>
<div class="text">Wenn du hingegen eine Lambda-Funktion verwendest, dokumentiert sich der Code selbst:</div>
<div class="pre">auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const User &amp;user) { return user.id &gt; 100; }); </div>
<div class="text">Glaube mir, ich hatte Diskussionen mit Fortran-Programmierern zu Bezeichnern. Zugegeben, mehr Argumente wie Codelokalität oder Codegröße sprechen für oder gegen Lambda-Funktionen. Die zwei Argumente "Don't repeat yourself" versus "Explicit is better than implicit" sind für mich die zwei entscheidenden Argumente.<br></div>
<div class="ztitel"><a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.143%3A%20Don%C2%92t%20write%20unintentionally%20nongeneric%20code%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nongeneric%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nongeneric%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nongeneric" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nongeneric" class="">T.143: Don’t write unintentionally nongeneric code</a></div>
<div class="text">Ein einfaches Beispiel sagt mehr als eine lange Erläuterung. In dem folgenden Beispiel iteriere ich durch einen <i>std::vector,</i> eine <i>std::deque</i> und eine <i>std::list:</i></div>
<div class="pre">// notGeneric.cpp<br><br>#include &lt;deque&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename Cont&gt;<br>void justIterate(const Cont&amp; cont){<br>&nbsp;&nbsp;&nbsp; const auto itEnd = cont.end();<br>&nbsp;&nbsp;&nbsp; for (auto it = cont.begin(); it &lt; itEnd; ++it) {&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do something<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;&nbsp;&nbsp; <br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vecInt{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp; justIterate(vecInt);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::deque&lt;int&gt; deqInt{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp; justIterate(deqInt);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::list&lt;int&gt; listInt{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp; justIterate(listInt);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Der Code wirkt unschuldig. Wenn ich aber das Programm übersetze, bricht dieser Prozess mit einer Fehlermeldung von circa 100 Zeilen ab:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167056113_6881fad155.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Anfang der Fehlermeldung ist sehr präzise: "<i>notGeneric.cpp:10:37: error: no match for ‘operator&lt;’ (operand types are ‘std::_List_const_iterator</i>".</div>
<div class="text">Was ist das Problem? Das Problem ist in der Zeile 1. Der Iteratorvergleich (&lt;) ist für den <i>std::vector</i> (Zeile 2) und für die <i>std::deque</i> (Zeile 3) okay, bricht aber für die <i>std::list</i> (Zeile 4). Jeder Container gibt einen Iterator zurück, der seine Struktur repräsentiert. Das ist im Falle des <i>std::vector</i> und der <i>std::deque</i> ein Random Access Iterator und im Falle der <i>std::list </i>ein Bidirectional Iterator. Ein Blick auf die Iteratorkategorien schafft Aufklärung:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167056117_c042c5195f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Die Random-Access-Iterator-Kategorie ist eine Obermenge der Bidirectional-Iterator-Kategorie und Letztere ist eine Obermenge der Forward-Iterator-Kategorie. Nun ist das Problem offensichtlich. Ein Iterator, der von einer Liste erzeugt wird, unterstützt den Kleiner-Vergleich nicht. Die Lösung des Problems ist einfach. Iteratoren aller Kategorien unterstützen den !=-Vergleich. Hier ist das generische <i>justIterate</i>-Funktions-Template, das mit den Container der Standard Template Library kann.<br></div>
<div class="pre">template &lt;typename Cont&gt;<br>void justIterate(const Cont&amp; cont){<br>&nbsp;&nbsp;&nbsp; const auto itEnd = cont.end();<br>&nbsp;&nbsp;&nbsp; for (auto it = cont.begin(); it != itEnd; ++it) {&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do something<br>&nbsp;&nbsp;&nbsp; }<br>}</div>
<div class="text">Eine Bemerkung kann ich mir nicht verkneifen. Es ist meist eine schlechte Idee, händisch durch einen Container wie in der Funktion <i>justIterate</i> zu iterieren. Dies ist die Aufgabe eines passenden Algorithmus der Standard Template Library. <br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Mein ursprünglicher Plan war es, in diesem Artikel auf die Regel "<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.144%3A%20Don%C2%92t%20specialize%20function%20templates%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D">T.144: Don’t specialize function templates</a>" einzugehen. Die Regel besitzt ein großes Überraschungspotenzial. Mein nächster Artikel zeigt, warum.<br></div>
