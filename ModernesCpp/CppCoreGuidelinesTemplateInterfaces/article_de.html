<div class="vorspann">Ein Interface ist ein Vertrag zwischen einem Anwender und einem Implementierer. Daher sollte es mit großer Sorgfalt entworfen werden. Das gilt auch, wenn eine Operation als Argument zum Einsatz kommt. </div>
<div class="text">Heute beschäftige ich mich nur mit der Regel 40, denn Funktionsobjekte kommen sehr häufig in modernem C++ zum Einsatz.</div>
<div class="ztitel"><a class="" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fo%22%2C%22text%22%3A%22T.40%3A%20Use%20function%20objects%20to%20pass%20operations%20to%20algorithms%26nbsp%3B%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fo%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fo" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fo">T.40: Use function objects to pass operations to algorithms&nbsp;</a></div>
<div class="text">Zuerst einmal magst du irritiert sein, dass die Regel zwar Lambda-Funktionen verwendet, aber nicht explizit auf sie eingeht. Auf diesen Punkt werde ich noch detaillierter eingehen.<br></div>
<div class="text">Es gibt viele Möglichkeiten, einen Vektor von Strings zu sortieren: <br></div>
<div class="pre">// functionObjects.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>bool lessLength(const std::string&amp; f, const std::string&amp; s){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) <br>&nbsp;&nbsp;&nbsp; return f.length() &lt; s.length();<br>}<br><br>class GreaterLength{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator()(const std::string&amp; f, const std::string&amp; s) const{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f.length() &gt; s.length();<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; myStrVec = {"523345", "4336893456", "7234", <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "564", "199", "433", "2435345"};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "ascending with function object" &lt;&lt; std::endl; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::sort(myStrVec.begin(), myStrVec.end(), std::less&lt;std::string&gt;()); // (1)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; str: myStrVec) std::cout &lt;&lt; str &lt;&lt; " "; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "descending with function object" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::sort(myStrVec.begin(), myStrVec.end(), std::greater&lt;&gt;());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; str: myStrVec) std::cout &lt;&lt; str &lt;&lt; " "; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "ascending by length with function" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::sort(myStrVec.begin(), myStrVec.end(), lessLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; str: myStrVec) std::cout &lt;&lt; str &lt;&lt; " "; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "descending by length with function object" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::sort(myStrVec.begin(), myStrVec.end(), GreaterLength());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; str: myStrVec) std::cout &lt;&lt; str &lt;&lt; " "; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "ascending by length with lambda function" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::sort(myStrVec.begin(), myStrVec.end(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](const std::string&amp; f, const std::string&amp; s){ <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f.length() &lt; s.length(); <br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; str: myStrVec) std::cout &lt;&lt; str &lt;&lt; " "; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br><br>}</div>
<div class="text">Das Programm sortiert sowohl lexikografisch als auch basierend auf der Länge der Strings einen Vektor von Strings. In den Zeilen (1) und (2) verwende ich zwei Lambda-Funktionen aus der Standard Template Library. Ein Funktionsobjekt ist eine Instanz einer Klasse, für die der Aufrufeoperator (<i>operater ()</i>) überladen wurde. Diese werden oft fälschlicherweise <a title="Link auf https://en.wikipedia.org/wiki/Functor" href="https://en.wikipedia.org/wiki/Functor" alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFunctor%22%2C%22text%22%3A%22Funktoren%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFunctor%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="">Funktoren</a> genannt. Ich denke, du bemerkst den Unterschied zwischen dem Aufruf <i>std::sort(myStrVec.begin(), myStrVec.end(), std::less&lt;std::string&gt;()</i>) in Zeile (1) und <i>std::sort(myStrVec.begin(), myStrVec.end(), std::greater&lt;&gt;()</i>) in Zeile (2). Der zweite Ausdruck (<i>std::greater&lt;&gt;()</i>), in dem ich keinen Typ für das Prädikat angebe, ist erst seit C++14 gültig. In den Zeilen (3), (4) und (5) kommen eine Funktion (6),&nbsp; ein Funktionsobjekt (7) und eine Lambda-Funktion (5) zum Einsatz. In diesem Fall war die Länge des Strings das Sortierkriterium. </div>
<div class="text">Nur der Vollständigkeit halber die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511316_d813fcc280.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Regel lautet: "Use function objects to pass operations to algorithms".</div>
<div class="ztitel">Vorteile von Funktionsobjekten</div>
<div class="text">Meine Argumentation lässt sich auf drei Punkte reduzieren: Performanz, Ausdruckskraft und Zustand. Da Lambda-Funktionen unter der Decke Funktionsobjekte sind, wird meine Argumentation deutlich einfacher.<br></div>
<div class="text"><b>Performanz</b></div>
<div class="text">Je mehr Information der Compiler über den Code besitzt, desto optimierteren Code kann er erzeugen. Ein Funktionsobjekt (4) oder eine Lambda-Funktion (5) bietet maximale Transparenz an, da sie direkt an Ort und Stelle erzeugt werden können. Vergleiche dies doch mit einer Funktion, die in einer anderen Übersetzungseinheit definiert wurde. Falls du mir nicht glaubst, wende den<a alt="%7B%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22text%22%3A%22%20Compiler%20Explorer%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="" title="Link auf https://godbolt.org/" href="https://godbolt.org/"> Compiler Explorer</a> an und vergleiche die Assembler-Anweisungen. Natürlich musst du den Code optimiert übersetzen.</div>
<div class="text"><b>Ausdruckskraft</b></div>
<div class="text">"Explicit is better than implicit." Diese Metaregel von Python lässt sich auch auf C++ anwenden. Sie steht dafür, dass dein Sourcecode seine Intention explizit ausdrücken soll. Dies gilt vor allem für Lambda-Funktionen wie in der Zeile (5). Im Gegensatz dazu steht die Funktion <i>lessLength</i>&nbsp;in Zeile (6), die in der Zeile (3) zum Einsatz kommt. Stelle dir vor, dein Mitarbeiter gab der Funktion den Name <i>foo</i>. Natürlich hast du jetzt keine Idee, was die Aufgabe der Funktion ist. Das heißt, du musst ihre Anwendung wie in den folgenden Zeilen dokumentieren:</div>
<div class="pre">// sorts the vector ascending, based on the length of its strings <br>std::sort(myStrVec.begin(), myStrVec.end(), foo);&nbsp; </div>
<div class="text">Darüber hinaus kannst du nur hoffen, dass dein Kollege das Prädikat richtig implementiert hat. Falls du skeptisch bist, hilft dir nur die Implementierung weiter. Dies ist aber nicht möglich, wenn lediglich die Deklaration der Funktion zur Verfügung steht. Mit einer Lambda-Funktion kann dies nicht passieren. Der Sourcecode ist die Wahrheit. Lass es mich provokativer formulieren: <b>Dein Code soll so ausdruckreich sein, dass er keine Dokumentation benötigt.</b></div>
<div class="text"><b>Zustand</b></div>
<div class="text">Im Gegensatz zu einer Funktion kann ein Funktionsobjekt Zustand besitzen. Das Codebeispiel zeigt genau diesen Punkt:<br></div>
<div class="pre">// sumUp.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>class SumMe{<br>&nbsp; int sum{0};<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; SumMe() = default;<br><br>&nbsp;&nbsp;&nbsp; void operator()(int x){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += x;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; int getSum(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sum;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; intVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br><br>&nbsp;&nbsp;&nbsp; SumMe sumMe= std::for_each(intVec.begin(), intVec.end(), SumMe());<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sum of intVec= " &lt;&lt; sumMe.getSum() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n";<br><br>}<br></div>
<div class="text">Der <i>std::for_each-</i>Aufruf in Zeile (1) ist der entscheidende<i>. std::for_each</i>&nbsp;ist ein spezieller Algorithmus aus der Standard Template Library, denn er kann seine aufrufbare Einheit zurückgeben. Ich rufe<i> std::for_each</i> mit dem Funktionsobjekt<i> SumMe</i> auf und kann daher das Ergebnis des Aufrufs direkt in dem Funktionsobjekt speichern. In der Zeile (2) frage ich das Ergebnis der Summation ab. Dies ist der Zustand des Funktionsobjekts. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511321_2dfc70a845.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Nur der Vollständigkeit halber: Lamda-Funktion können auch Zustand besitzen. Du kannst eine Lambda-Funktion verwenden, um Werte aufzusummieren. </div>
<div class="pre">// sumUpLambda.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; intVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br><br>&nbsp;&nbsp;&nbsp; std::for_each(intVec.begin(), intVec.end(),<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [sum = 0](int i) mutable {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sum += i; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::cout &lt;&lt; sum &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n";<br><br>}<br></div>
<div class="text">Nicht dass ich das schön finde. Zuerst einmal repräsentiert die Variable <i>sum</i> den Zustand der Lambda-Funktion. Mit C++14 unterstützen Lambda-Funktion die sogenannte Initialisation Capture. <i>sum = 0 </i>erklärt und initalisiert eine Variable vom Datentyp <i>int</i>, die nur im Bereich der Lambda-Funktion gültig ist. Lambda-Funktionen sind per default konstant. Indem ich sie als <i>mutable </i>erklären, kann ich sukzessive die Zahlen auf <i>sum</i> addieren&nbsp;</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511328_bb7f619def.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich habe behauptet, das Lambda-Funktionen unter der Decke Funktionsobjekte sind. <a class="" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%7D" href="https://cppinsights.io/" title="Link auf https://cppinsights.io/">C++ Insights</a> machen meine Argumentation zu einem Kinderspiel.</div>
<div class="ztitel_kleiner">Lambda-Funktionen sind Funktionsobjekte<br></div>
<div class="text">Eine Lambda-Funktion ist lediglich <a title="Link auf https://en.wikipedia.org/wiki/Syntactic_sugar" href="https://en.wikipedia.org/wiki/Syntactic_sugar" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSyntactic_sugar%22%2C%22text%22%3A%22Syntactic%20Sugar%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSyntactic_sugar%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" class="">Syntactic Sugar</a> für ein Funktionsobjekt, das an Ort und Stelle instanziiert wird. C++ Insights bringen ans Tageslicht, welche Transformation der Compiler auf eine Lambda-Funktion anwendet.</div>
<div class="text">Hier ist ein einfaches Beispiel. Wenn ich das folgende Codebeispiel in C++ Insights ausführe,</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511335_51ac902a74.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">gibt mir das Werkzeug den Unsugared Syntactic Sugar:<br> </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511336_fd71b51454.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Compiler erzeugt das Funktionsobjekt object<i>&nbsp;__lamda_2_16&nbsp;</i>(Zeilen 4 bis 11), instanziiert es in Zeile 13 und wendet es in Zeile 14 an. Das war bereits die ganze Magie hinter Lambda-Funktionen.</div>
<div class="text">Das nächste Beispiel ist ein wenig anspruchsvoller. Nun fügt die Lambda-Funktion<i> addTo</i> die Summe zur Variable<i> c</i> hinzu, die per Copy gebunden wird:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511344_8ef9e2173f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">In diesem Fall erhält das automatisch erzeugte Funktionsobjekt ein Attribut c und einen Konstruktor. Dies ist der erzeugte Sourcecode von C++ Insights:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161511352_e6abb1c3b5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text"><a class="" alt="%7B%22version%22%3A1%2C%22text%22%3A%22T.40%3A%20Use%20function%20objects%20to%20pass%20operations%20to%20algorithms%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fo%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fo%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fo" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fo">T.40: Use function objects to pass operations to algorithms</a> war die erste Regel zu Interfaces von Templates. Mein nächster Artikel knüpft an diese Regeln an. </div>