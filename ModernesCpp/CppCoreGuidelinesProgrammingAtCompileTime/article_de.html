<div class="vorspann">Weiter geht es mit meiner Einführung zur Programmierung zur Compilezeit. Der letzte Artikel begann mit Template-Metaprogrammierung. Genau hier knüpfe ich an und schließe die Template-Metaprogrammierung ab.</div>
<div class="text">Bevor ich in die Untiefen abtauche, hier ist das große Bild:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165310529_77259109a2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Mit den Regeln der C++ Core Guidelines ging meine Einführung zur Programmierung zur Compilezeit los. </div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-metameta" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-metameta%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22T.120%3A%20Use%20template%20metaprogramming%20only%20when%20you%20really%20need%20to%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-metameta%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-metameta" class="">T.120: Use template metaprogramming only when you really need to</a> </li><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-emulate%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.121%3A%20Use%20template%20metaprogramming%20primarily%20to%20emulate%20concepts%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-emulate%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-emulate" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-emulate" class="">T.121: Use template metaprogramming primarily to emulate concepts</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tmp" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tmp%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tmp%22%2C%22text%22%3A%22T.122%3A%20Use%20templates%20%28usually%20template%20aliases%29%20to%20compute%20types%20at%20compile%20time%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tmp" class="">T.122: Use templates (usually template aliases) to compute types at compile time</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fct" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fct%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fct%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.123%3A%20Use%20constexpr%20functions%20to%20compute%20values%20at%20compile%20time%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fct" class="">T.123: Use constexpr functions to compute values at compile time</a> </li><li> <a class="" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.124%3A%20Prefer%20to%20use%20standard-library%20TMP%20facilities%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp">T.124: Prefer to use standard-library TMP facilities</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.125%3A%20If%20you%20need%20to%20go%20beyond%20the%20standard-library%20TMP%20facilities%2C%20use%20an%20existing%20library%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" class="">T.125: If you need to go beyond the standard-library TMP facilities, use an existing library</a></li></ul></div>
<div class="text">Wir befinden uns immer noch auf der untersten Ebene des Dreiecks.</div>
<div class="ztitel">Template-Metaprogrammierung<br></div>
<div class="text">Im letzten Artikel "<a title="Link auf Beitrag 2571605" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D70fec98d5320f89447cbb406ce865dc0%26rm%3Dopen_article_id%26bid%3D2571605%22%2C%22destination%22%3A2571605%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regel%20f%C3%BCr%20Template-Metaprogrammierung%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22B%22%7D" href="/exec/mainmenu.pl?sid=70fec98d5320f89447cbb406ce865dc0&amp;rm=open_article_id&amp;bid=2571605" class="">C++ Core Guidelines: Regel für Template-Metaprogrammierung</a>", stellte ich ein einfaches Template-Metaprogramm vor, das die Konstanz seiner Argumente entfernte: </div>
<div class="pre">template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>struct removeConst{ <br>&nbsp;&nbsp;&nbsp; typedef T type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>};<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>struct removeConst&lt;const T&gt; { <br>&nbsp;&nbsp;&nbsp; typedef T type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>};<br><br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, removeConst&lt;int&gt;::type&gt;::value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true (1)<br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, removeConst&lt;const int&gt;::type&gt;::value;&nbsp; // true (3)<br>&nbsp; <br>}</div>
<div class="text">Welche weiteren Erkenntnisse können wir aus dem Programm ziehen? </div>
<div class="text"><ul><li> Template-Spezialisierung, sei sie teilweise oder vollständig, ist eine Compilezeit<i> if</i>. Hier möchte ich gerne genauer sein: Wenn ich <i>removeConst</i> mit einer nicht konstanten<i> int </i>(Zeile 1) aufrufe, wendet der Compiler das primäre oder allgemeine Template (Zeile 2) an. Wenn ich eine Konstante<i> int </i>(Zeile 3) verwende, wendet der Compiler die partielle Spezialisierung für <i>const T </i>(Zeile 4) an.</li><li>Der Ausdruck<i> typedef T type </i>(Zeile 5) dient als Rückgabewert, der in diesem Fall ein Datentyp ist.<br></li></ul></div>
<div class="ztitel">Mehr Meta<br></div>
<div class="text">Zur Laufzeit kommen Daten und Funktionen zum Einsatz. Zur Compilezeit kommen Metadaten und Metafunktionen zum Einsatz. Das war einfach, denn Programmierung zur Compilezeit nennt sich Metaprogrammierung. Doch was sind genau Metadaten und Metafunktionen? Hier ist eine erste Definition:</div>
<div class="text"><ul><li> <b>Metadaten:</b> Datentypen, Nichtdatentypen und Templates, die zur Compilezeit verwendet werden.</li><li><b>Metafunktionen</b>: Funktionen, die zur Compilezeit ausgeführt werden.</li></ul></div>
<div class="text">Beide Begriffe muss ich natürlich genauer erläutern.<br></div>
<div class="text"><b>Metadaten</b></div>
<div class="text">Es gibt drei Arten von Metadaten:</div>
<div class="text"><ul><li>Datentypen wie <i>int</i> oder <i>double</i></li><li>Nichtdatentypen (non-types) wie Ganzzahlen, Aufzähler, Zeiger oder Referenzen</li><li>Templates wie <a class="" href="https://en.cppreference.com/w/cpp/container/stack" title="Link auf https://en.cppreference.com/w/cpp/container/stack" alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22std%3A%3Astack%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fstack%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fstack%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D">std::stack</a></li></ul></div>
<div class="text">In meinen einfachen Beispielen kommen nur Datentypen und Nicht-Datentypen zum Einsatz.<br></div>
<div class="text"><b>Metafunktionen</b><br></div>
<div class="text">Das klingt erst mal seltsam: Datentypen werden in der Template-Metaprogrammierung verwendet, um Funktionen zu simulieren. Basierend auf meiner Definition von Metafunktionen können <i>constexpr</i>-Funktionen auch zur Compilezeit ausgeführt werden und sind damit auch Metafunktionen. Auf diesen Punkt werde ich in einem späteren Artikel eingehen. </div>
<div class="text">Hier sind zwei Datentypen, die du bereits von meinem letzten Artikel <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D70fec98d5320f89447cbb406ce865dc0%26rm%3Dopen_article_id%26bid%3D2571605%22%2C%22destination%22%3A2571605%2C%22alias%22%3A%22%22%2C%22text%22%3A%22%5C%22C%2B%2B%20Core%20Guidelines%3A%20Regel%20f%C3%BCr%20Template-Metaprogrammierung%22%2C%22type%22%3A%22B%22%7D" title="Link auf Beitrag 2571605" href="/exec/mainmenu.pl?sid=70fec98d5320f89447cbb406ce865dc0&amp;rm=open_article_id&amp;bid=2571605">"C++ Core Guidelines: Regel für Template-Metaprogrammierung</a>" kennst: <i>Factorial</i> und <i>RemoveConst</i>:</div>
<div class="pre">template &lt;&gt; <br>struct Factorial&lt;1&gt;{ <br>&nbsp;&nbsp;&nbsp; static int const value = 1; <br>};<br><br>template&lt;typename T &gt; <br>struct removeConst&lt;const T&gt; { <br>&nbsp;&nbsp;&nbsp; typedef T type;&nbsp; <br>};</div>
<div class="text">Die erste Metafunktion gibt einen Wert und die zweite einen Datentyp zurück. Die Namen <i>value</i> und <i>type</i> sind lediglich Namenskonventionen für den Rückgabetyp. Wenn eine Metafunktion einen Wert zurückgibt, wird dieser <i>value</i> genannt; falls sie einen Datentyp zurückgibt, <i>type</i>. Die <a href="https://en.cppreference.com/w/cpp/header/type_traits" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%7D" class="">Type-Traits-Bibliothek</a>, auf die ich im nächsten Artikel eingehe, folgt genau dieser Namenskonvention.</div>
<div class="text">Es ist ziemlich aufschlussreich, Funktionen mit Metafunktionen zu vergleichen.</div>
<div class="ztitel">Funktionen versus Metafunktionen</div>
<div class="text">Die folgende <i>power</i> und die Metafunktion <i>Power</i> berechnen 2<sup>10 </sup>zur Laufzeit und zur Compilezeit:</div>
<div class="pre">// power.cpp<br><br>#include &lt;iostream&gt;<br><br>int power(int m, int n){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; int r = 1;<br>&nbsp;&nbsp;&nbsp; for(int k=1; k&lt;=n; ++k) r*= m;<br>&nbsp;&nbsp;&nbsp; return r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>}<br><br>template&lt;int m, int n&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>struct Power{<br>&nbsp;&nbsp;&nbsp; static int const value = m * Power&lt;m, n-1&gt;::value;&nbsp; // (4)<br>};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>template&lt;int m&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>struct Power&lt;m, 0&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp; <br>&nbsp;&nbsp;&nbsp; static int const value = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "power(2, 10)= " &lt;&lt; power(2, 10) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (A)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Power&lt;2,10&gt;::value= " &lt;&lt; Power&lt;2, 10&gt;::value &lt;&lt; std::endl; // (B)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>}</div>
<div class="text">Dies sind die offensichtlichsten Unterschiede:</div>
<div class="text"><ul><li><b>Argumente:</b> Die Funktionsargumente landen direkt in den runden Klammern ("( ... )"&nbsp; in Zeile A)), die Argumente der Metafunktion sind in den eckigen Klammern ("&lt; ...&gt;" in Zeile B). Das Gleiche gilt für die Definition der Funktion und der Metafunktion. Die Funktion verwendet runde und die Metafunktion spitze Klammern.</li><li><b>Rückgabewert:</b> Die Funktion verwendet eine Rückgabeanweisung (Zeile 3) und die Metafunktion die statische, konstante Ganzzahl.</li></ul></div>
<div class="text">Ich werde meinen Vergleich noch weiter fortsetzen, wenn ich über <i>constexpr</i>-Funktionen schreibe. Hier ist erst einmal die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165310530_750c1ad8e8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das war einfach! Oder? <i>power</i> wird zur Laufzeit und <i>Power</i> wird zur Compilezeit ausgeführt. Aber was passiert hier? <br></div>
<div class="pre">// powerHybrid.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;int n&gt;<br>int power(int m){<br>&nbsp;&nbsp;&nbsp; return m * power&lt;n-1&gt;(m);<br>}<br><br>template&lt;&gt;<br>int power&lt;1&gt;(int m){<br>&nbsp;&nbsp;&nbsp; return m;<br>}<br><br>template&lt;&gt;<br>int power&lt;0&gt;(int m){<br>&nbsp;&nbsp;&nbsp; return 1;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "power&lt;10&gt;(2): " &lt;&lt; power&lt;10&gt;(2) &lt;&lt; std::endl; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto power2 = power&lt;2&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;= 10; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "power2(" &lt;&lt; i &lt;&lt; ")= " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; power2(i) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Der Aufruf <i>power&lt;10&gt;(2)</i> in Zeile (1) verwendet spitze und runde Klammern und berechnet 2<sup>10</sup>. Anders ausgedrückt, <i>power</i> ist eine Funktion und eine Metafunktion. Das heißt, 10 ist das Compilezeit- und 2 das Laufzeit-Argument. Jetzt kann ich ein Klassen-Template für 2 aufrufen und ihm den Namen <i>power2 </i>(Zeile 2) geben. <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22CppInsight%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://cppinsights.io/" href="https://cppinsights.io/">CppInsight</a> verrät mir, dass der Compiler das Klassen-Template für 2 instanziiert. Nur das Funktionsargument wird noch nicht gebunden: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165310541_232251ef20.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das Funktionsargument ist ein Laufzeitargument und kann daher in einer for-Schleife verwendet werden (Zeile 3): </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165310543_a6235669b8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel springe ich Abstraktionsstufe höher in meinen Dreieck. Darin werde ich über die Type-Traits-Bibliothek schreiben. Template-Metaprogrammierung gibt es in C++ seit C++98, die Type-Traits-Bibliothek aber erst seit C++11. Ich denke, du ahnst es bereits. Die Type-Traits-Bibliothek stellt eine kultivierte Form der Template-Metaprogrammierung dar.</div>
