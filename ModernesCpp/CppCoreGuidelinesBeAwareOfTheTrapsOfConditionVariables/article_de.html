<div class="vorspann">Heute schreibe ich einen gruseligen Artikel zu Bedingungsvariablen. Du solltest dir ihrer Gefahren bewusst sein. Die Regel CP.42 der C++ Core Guidelines lautet schlicht: "Don't wait without a condition."</div>
<div class="text">Zuerst einmal gilt: Bedingungsvariablen setzen ein sehr einfaches Konzept um. Ein Thread bereitet eine Arbeit vor und sendet seine Benachrichtigung, auf die ein anderer Thread wartet. Das kann doch nicht so schwierig sein! Dachte ich auch zuerst. Hier ist die einzige Regel für den heutigen Artikel.</div>
<div class="ztitel"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-wait" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-wait" alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-wait%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-wait%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22CP.42%3A%20Don%C2%92t%26nbsp%3Bwait%26nbsp%3Bwithout%20a%20condition%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">CP.42: Don’t&nbsp;wait&nbsp;without a condition</a></div>
<div class="text">Gleich im ersten Satz präsentiert die Regel die Begründung: "A&nbsp;wait&nbsp;without a condition can miss a wakeup or wake up simply to find that there is no work to do." Was heißt das? Bedingungsvariablen können Opfer von zwei sehr ernsthaften Fallen sein: Lost Wakeup und Spurious Wakeup. Doch was ist ein Lost Wakeup und ein Spurious Wakeup? Lost Wakeup steht für eine Benachrichtigung, die verloren geht, und Spurious Wakeup stellt eine Benachrichtigung dar, die nicht vom erwarteten Sender stammt. Der Grund dafür ist naheliegend. Bedingungsvariablen besitzen kein Gedächtnis. </div>
<div class="text">Bevor ich auf die Fallen von Bedingungsvariablen eingehe, möchte ich sie zuerst einmal richtig einsetzen. Hier ist das Kochrezept, um Bedingunsvariablen richtig einzusetzen:<br></div>
<div class="pre">// conditionVariables.cpp<br><br>#include &lt;condition_variable&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>std::mutex mutex_;<br>std::condition_variable condVar;<br><br>bool dataReady{false};<br><br>void waitingForWork(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiting " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck, []{ return dataReady; });&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Running " &lt;&lt; std::endl;<br>}<br><br>void setDataReady(){<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataReady = true;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Data prepared" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::thread t1(waitingForWork);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::thread t2(setDataReady);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div>
<div class="text">Wie funktioniert die Synchronisation? Das Programm besitzt zwei Kind-Threads: <i>t1</i> und <i>t2</i>. Diese erhalten ihr Arbeitspaket <i>waitingForWork </i>und <i>setDataReady</i> in den Zeilen (1) und (2). <i>setDataReady</i> sendet seine Nachricht, dass er mit der Vorbereitung der Arbeit fertig ist mithilfe der Bedingungsvariable <i>condVar: condVar.notify_one()</i>(Zeile 3). Während der Thread <i>t1</i> den Lock besitzt, wartet er auf seine Benachrichtigung: <i>condVar.wait(lck,[] return dataReady; )</i> (Zeile 4). Sowohl der Sender als auch der Empfänger der Nachricht benötigen einen Lock. Im Falle des Senders ist ein einfacher <i>std::lock_guard&nbsp;</i> ausreichend, da er einen Mutex nur ein einziges Mal lockt und wieder freigibt. Der Empfänger benötigt hingegen ein <i>std::unique_lock</i>, da er gegebenenfalls einen Mutex mehrmals locken und wieder freigeben muss. </div>
<div class="text">Das Programm besitzt die erwartete Ausgabe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153708825_0a2120d094.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Vermutlich wunderst du dich: Warum benötigt der <i>wait</i>-Aufruf ein Prädikat, denn es lässt sich auch ohne diesen verwenden? Dieser Ablauf wirkt viel zu kompliziert für eine solch einfache Aufgabe wie die Synchronisation von Threads.</div>
<div class="text">Jetzt komme ich zu dem fehlenden Gedächtnis von Bedingungsvariablen und den zwei Phänomenen Lost Wakeup und Spurious Wakeup zurück. </div>
<div class="ztitel">Lost Wakeup und Spuriour Wakeup</div>
<div class="text"><ul><li><b>Lost Wakeup</b>: Das Phänomen des Lost Wakeup ist, dass der Sender seine Benachrichtigung schickt, bevor der Sender im Wartezustand ist. Als Konsequenz geht dadurch die Benachrichtigung verloren und der Empfänger wartet und wartet und ...<br></li><li><b>Spurious Wakeup</b>: Hier passiert es, dass der Empfänger der Nachricht aufwacht, obwohl der Sender keine Benachrichtigung geschickt hat. Zumindest <a class="" href="https://en.wikipedia.org/wiki/POSIX_Threads" title="Link auf https://en.wikipedia.org/wiki/POSIX_Threads" alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22POSIX%20Threads%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPOSIX_Threads%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPOSIX_Threads%22%2C%22version%22%3A1%7D">POSIX Threads</a> und die <a alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Windows%20API%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWindows_API%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWindows_API%22%2C%22version%22%3A1%7D" title="Link auf https://en.wikipedia.org/wiki/Windows_API" href="https://en.wikipedia.org/wiki/Windows_API" class="">Windows API</a> können Opfer dieses Phänomens sein. <br></li></ul></div>
<div class="text">Als Schutz gegen diese beiden Phänomene benötigt der Empfänger ein zusätzliches Prädikat als Gedächtnis, das er prüft. Damit beginnt die Komplexität.</div>
<div class="ztitel">Der wait-Arbeitsablauf</div>
<div class="text">Falls <i>wait</i> zum ersten Mal ausgeführt wird, finden die folgenden Schritte statt:<br> </div>
<div class="text"><ul><li>Der Aufruf <i>wait </i>lockt den Mutex und prüft, ob das Prädikat<i> [] return dataReady; true </i>ergibt.</li><ul><li>Falls das Prädikat<i> true</i> ergibt, fährt der Thread weiter fort.</li><li>Falls das Prädikat <i>false </i>ergibt, gibt die Bedingungsvariable den Mutex frei und begibt sich wieder in den Wartezustand.</li></ul></ul></div>
<div class="text">Anschließende <i>wait</i>-Aufrufe verhalten sich anders. </div>
<div class="text"><ul><li>Der wartende Thread erhält eine Benachrichtigung. <br></li><li>Er lockt seinen Mutex und prüft, ob das Prädikat <i>[] return dataReady; true </i>ergibt.</li><ul><li>Falls das Prädikat<i> true </i>ergibt, fährt der Thread weiter fort.</li><li>Falls das Prädikat<i> false </i>ergibt, gibt die Bedingungsvariable den Mutex frei und begibt sich wieder in den Wartezustand.<br></li></ul></ul></div>
<div class="text">Muss die Synchronisation mit Bedingungungsvariablen so kompliziert sein? Leider ja! </div>
<div class="ztitel_kleiner">Ohne ein Prädikat</div>
<div class="text">Was passiert, wenn ich das Prädikat (Condition) im letzten Beispiel entferne? <br></div>
<div class="pre">// conditionVariableWithoutPredicate.cpp<br><br>#include &lt;condition_variable&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>std::mutex mutex_;<br>std::condition_variable condVar;<br><br>void waitingForWork(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiting " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Running " &lt;&lt; std::endl;<br>}<br><br>void setDataReady(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Data prepared" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::thread t1(waitingForWork);<br>&nbsp; std::thread t2(setDataReady);<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}<br></div>
<div class="text">Nun kommt der <i>wait</i>-Aufruf in Zeile (1) gänzlich ohne Prädikat aus. Wenn das kein Fortschritt ist! Leider besitzt das Programm jetzt eine Race Condition, die sich bereits bei seiner ersten Ausführung als Deadlock entpuppt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153708832_aff012d80a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Sender sendet in Zeile (2) (<i>condVar.notify_one()</i>) seine Benachrichtigung, bevor der Empfänger bereit ist, diese anzunehmen. Damit wartet der Empfänger für immer.</div>
<div class="text">Okay. Lektion gelernt. Das Prädikat ist unbedingt notwendig. Das Programm <i>conditionVariables.cpp</i> muss sich doch vereinfachen lassen.</div>
<div class="ztitel">Ein atomares Prädikat</div>
<div class="text">Ein scharfer Blick auf <i>conditionVariable.cpp</i> verspricht Optimierungspotenzial. Die Variable <i>dataReady</i> ist ein Wahrheitswert. Daher sollte es ausreichen, diese als atomare Variable zu erklären. Sollte!</div>
<div class="text">Hier ist die nächste Variante:</div>
<div class="pre">// conditionVariableAtomic.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>std::mutex mutex_;<br>std::condition_variable condVar;<br><br>std::atomic&lt;bool&gt; dataReady{false};<br><br>void waitingForWork(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Waiting " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck, []{ return dataReady.load(); });&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Running " &lt;&lt; std::endl;<br>}<br><br>void setDataReady(){<br>&nbsp;&nbsp;&nbsp; dataReady = true;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Data prepared" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::thread t1(waitingForWork);<br>&nbsp; std::thread t2(setDataReady);<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}<br></div>
<div class="text">Das Programm ist bereits deutlich einfacher, denn <i>dataReady</i> muss nicht durch einen Lock geschützt werden. Leider ist es zu einfach, da eine Race Condition lauert, die zu einem Deadlock führen kann. Warum? <i>dataReady</i> ist doch eine atomare Variable! Stimmt. </div>
<div class="text">Der <i>wait</i>-Ausdruck in Zeile (1) (<i>condVar.wait(lck, []{ return dataReady.load(); });</i>) ist deutlich komplexer, als er scheint. Er ist äquivalent zu den folgenden Zeilen:</div>
<div class="pre">std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>while ( ![]{ return dataReady.load(); }() {<br>&nbsp;&nbsp;&nbsp; // time window&nbsp; (1)<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck);<br>}<br></div>
<div class="text">Falls Thread <i>t2 dataReady</i> modifiziert, obwohl es nicht durch einen Mutex geschützt ist, wird dies nicht richtig synchronisiert veröffentlicht. Was heißt das: veröffentlicht, aber nicht richtig synchronisiert. Dazu hilft es anzunehmen, dass die Benachrichtigung geschickt wird, obwohl die Bedingungsvariable <i>condVar</i> nicht im Wartezustand ist. Das bedeutet, dass der Thread sich zwischen den zwei Anweisungen in Zeile (1) befindet. Damit geht die Benachrichtigung verloren und der Thread in den Wartezustand zurück. In diesem Fall wartet er ewig. Falls <i>dataReady</i> durch einen Mutex wie im ersten Beispiel <i>conditionVariable.cpp</i> geschützt wird, kann die Benachrichtigung nicht verloren gehen, da der Empfänger diese nur in seinem Wartezustand erhält.</div>
<div class="text">Wenn das nicht ernüchternd war. Lässt sich das Programm <i>conditionVariables.cpp</i> nicht vereinfachen? Doch. Leider aber nicht mit Bedingungsvariablen, sondern mit einem Promise- und Future-Paar. Die Details dazu gibt es in meinen Artikel "<a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fbedingungsvariablen-versus-tasks-zur-synchronisation-von-threads%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22text%22%3A%22Bedingungsvariablen%20versus%20Tasks%20zur%20Synchronisation%20von%20Threads%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fbedingungsvariablen-versus-tasks-zur-synchronisation-von-threads%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="" href="https://www.grimm-jaud.de/index.php/blog/bedingungsvariablen-versus-tasks-zur-synchronisation-von-threads" title="Link auf https://www.grimm-jaud.de/index.php/blog/bedingungsvariablen-versus-tasks-zur-synchronisation-von-threads">Bedingungsvariablen versus Tasks zur Synchronisation von Threads</a>".<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nun bin ich fast fertig mit den Regeln zur Concurrency. Die Regeln zur Parallelität, Message Passing und Vektorisierung besitzen keinen Inhalt, daher werde ich sie übergehen und im nächsten Artikel hauptsächlich über die Lock-freie Programmierung schreiben. </div>
