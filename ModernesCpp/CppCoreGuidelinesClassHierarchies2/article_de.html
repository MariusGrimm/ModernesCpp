<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_142992864_453aa49440.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;">Im letzten Artikel ging unsere Reise mit den Regeln zu Klassenhierarchien los. Die ersten Regeln besaßen einen allgemeineren Fokus. Nun geht unsere Reise mit einem speziellerem Fokus weiter.</div>
<div class="text">Hier sind die Regeln zu Klassenhierarchien im Überblick.</div>
<div class="text"><ul><li>C.126: An abstract class typically doesn’t need a constructor<br></li><li>C.127: A class with a virtual function should have a virtual or protected destructor<br></li><li>C.128: Virtual functions should specify exactly one of virtual, override, or final<br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind" class="" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C.129%3A%20When%20designing%20a%20class%20hierarchy%2C%20distinguish%20between%20implementation%20inheritance%20and%20interface%20inheritance%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%7D">C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance</a> <br></li><li> <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.130%3A%20Redefine%20or%20prohibit%20copying%20for%20a%20base%20class%3B%20prefer%20a%20virtual%20clone%20function%20instead%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind">C.130: Redefine or prohibit copying for a base class; prefer a virtual clone function instead</a> <br></li><li> <a alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-get%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-get%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.131%3A%20Avoid%20trivial%20getters%20and%20setters%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-get" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-get">C.131: Avoid trivial getters and setters</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual" class="" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.132%3A%20Don%C2%92t%20make%20a%20function%20virtual%20without%20reason%22%2C%22version%22%3A1%7D">C.132: Don’t make a function virtual without reason</a> <br></li><li><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected" alt="%7B%22version%22%3A1%2C%22text%22%3A%22C.133%3A%20Avoid%20protected%20data%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-protected%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-protected%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" class="">C.133: Avoid protected data</a><br></li><li>C.134: Ensure all non-const data members have the same access level<br></li><li>C.135: Use multiple inheritance to represent multiple distinct interfaces<br></li><li>C.136: Use multiple inheritance to represent the union of implementation attributes<br></li><li>C.137: Use virtual bases to avoid overly general base classes<br></li><li>C.138: Create an overload set for a derived class and its bases with using<br></li><li>C.139: Use final sparingly<br></li><li>C.140: Do not provide different default arguments for a virtual function and an overrider</li></ul></div>
<div class="text">Weiter geht unsere Reise mit der vierten Regel.</div>
<div class="text"><b><a alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.129%3A%20When%20designing%20a%20class%20hierarchy%2C%20distinguish%20between%20implementation%20inheritance%20and%20interface%20inheritance%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind">C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance</a></b></div>
<div class="text">Am Anfang steht die Frage. Was ist der Unterschied zwischen der Implementierungs- und der Schnittstellenvererbung? Die Guidelines geben eine eindeutige Antwort. </div>
<div class="text"><ul><li> <b>Schnittstellenvererbung</b> stellt die Verwendung der Vererbung dar, um den Anwender von der Implementierung zu trennen. Insbesondere erlaubt sie es, neue abgeleitete Klassen hinzuzufügen oder zu modifizieren, ohne dass der Anwender der Basisklasse davon betroffen ist.<br></li><li> <b>Implementierungsvererbung</b> stellt Verwendung der Vererbung dar, um das Implementieren von neuer Funktionalität zu vereinfachen. Dies geschieht, in dem die bestehende neue Funktionalität mithilfe der bestehenden Funktionalität implementiert wird. Dies wird auch gerne "programming by difference" genannt.&nbsp;</li></ul></div>
<div class="text">Rein Schnittstellenvererbung ist es, wenn die Schnittstelle (Interface) nur aus rein virtuellen Funktionen besteht. Im Gegensatz dazu gilt. Falls die Basisklasse Daten und Funktionen anbietet, ist dies Implementierungsvererbung. </div>
<div class="text">Die Guidelines geben ein Beispiel für das Vermischen der Konzepte.</div>
<div class="pre">class Shape {&nbsp;&nbsp; // BAD, mixed interface and implementation<br>public:<br>&nbsp;&nbsp;&nbsp; Shape();<br>&nbsp;&nbsp;&nbsp; Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}<br><br>&nbsp;&nbsp;&nbsp; Point center() const { return cent; }<br>&nbsp;&nbsp;&nbsp; Color color() const { return col; }<br><br>&nbsp;&nbsp;&nbsp; virtual void rotate(int) = 0;<br>&nbsp;&nbsp;&nbsp; virtual void move(Point p) { cent = p; redraw(); }<br><br>&nbsp;&nbsp;&nbsp; virtual void redraw();<br><br>&nbsp;&nbsp;&nbsp; // ...<br>public:<br>&nbsp;&nbsp;&nbsp; Point cent;<br>&nbsp;&nbsp;&nbsp; Color col;<br>};<br><br>class Circle : public Shape {<br>public:<br>&nbsp;&nbsp;&nbsp; Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }<br><br>&nbsp;&nbsp;&nbsp; // ...<br>private:<br>&nbsp;&nbsp;&nbsp; int rad;<br>};<br><br>class Triangle : public Shape {<br>public:<br>&nbsp;&nbsp;&nbsp; Triangle(Point p1, Point p2, Point p3); // calculate center<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Warum ist dies ein schlechtes Klassendesign?</div>
<div class="text"><ul><li> Je größer und tiefer die Klassenhierarchie wird, desto schwieriger und damit auch fehleranfälliger wird es, die verschiedenen Konstruktoren zu pflegen.</li><li>Die Funktionen der Klasse <i>Shape</i> werden unter Umständen nie verwendet. <br></li><li>Falls du Daten zu der Klasse <i>Shape</i> hinzufügst, wirst du mit hoher Wahrscheinlichkeit den Code neu übersetzen müssen.</li></ul></div>
<div class="text">Falls <i>Shape</i> ein reines Interface wäre, das nur aus rein virtuellen Funktionen bestünde, würde es keinen Konstruktor benötigen. Klar, du musst nun die ganze Funktionalität in den abgeleiteten Klassen implementieren. </div>
<div class="text">Jetzt ist natürlich die Frage, wie lässt sich das Beste aus beiden Welten vereinen: ein stabiles Interface mit Schnittstellenvererbung und Code Wiederverwendung mit Implementierungsvererbung. Eine Antwort ist Mehrfachvererbung. Die Guidelines bieten ein ziemlich ausgefeiltes Rezept dafür an.</div>
<div class="text"><b>1. Definiere die Basisklasse <i>Shape</i> der Klassenhierarchie als reines Interface.</b></div>
<div class="pre">class Shape {&nbsp;&nbsp; // pure interface<br>public:<br>&nbsp;&nbsp;&nbsp; virtual Point center() const = 0;<br>&nbsp;&nbsp;&nbsp; virtual Color color() const = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual void rotate(int) = 0;<br>&nbsp;&nbsp;&nbsp; virtual void move(Point p) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual void redraw() = 0;<br><br>&nbsp;&nbsp;&nbsp; // ...<br>};<b><br></b></div>
<div class="text"><b>2. Leite ein reines Interface <i>Circle</i> von <i>Shap</i>e ab.</b></div>
<div class="pre">class Circle : public Shape {&nbsp;&nbsp; // pure interface<br>public:<br>&nbsp;&nbsp;&nbsp; virtual int radius() = 0;<br>&nbsp;&nbsp;&nbsp; // ...<br>};<b><br></b></div>
<div class="text"><b>3. Biete eine Implementierung<i> Impl::Shape</i> an.</b></div>
<div class="pre">class Impl::Shape : public Shape { // implementation<br>public:<br>&nbsp;&nbsp;&nbsp; // constructors, destructor<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; Point center() const override { /* ... */ }<br>&nbsp;&nbsp;&nbsp; Color color() const override { /* ... */ }<br><br>&nbsp;&nbsp;&nbsp; void rotate(int) override { /* ... */ }<br>&nbsp;&nbsp;&nbsp; void move(Point p) override { /* ... */ }<br><br>&nbsp;&nbsp;&nbsp; void redraw() override { /* ... */ }<br><br>&nbsp;&nbsp;&nbsp; // ...<br>};<b><br></b></div>
<div class="text"><b>4. Implementiere ein Klasse <i>Impl::Circle</i>, die von dem Interface und der Implementierung ableitest.</b></div>
<div class="pre">class Impl::Circle : public Circle, public Impl::Shape {&nbsp;&nbsp; // implementation<br>public:<br>&nbsp;&nbsp;&nbsp; // constructors, destructor<br><br>&nbsp;&nbsp;&nbsp; int radius() override { /* ... */ }<br>&nbsp;&nbsp;&nbsp; // ...<br>};<b><br></b></div>
<div class="text"><b>5. Falls du die Klassenhierarchie erweitern willst, musst du von dem Interface und der Implementierung ableiten.</b></div>
<div class="text">Die Klasse Smiley ist ein reines Interface, das von <i>Circle </i>abgeleitet ist. Die Klasse <i>Impl::Smiley</i> ist die neue Implementierung, die sowohl von <i>Smiley </i>als auch von I<i>mpl::Circle</i> erbt. </div>
<div class="pre">class Smiley : public Circle { // pure interface<br>public:<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>class Impl::Smiley : public Smiley, public Impl::Circle {&nbsp;&nbsp; // implementation<br>public:<br>&nbsp;&nbsp;&nbsp; // constructors, destructor<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Hier ist das große Bild zu der Klassenhierarchie nochmals.</div>
<div class="text"><ul><li>Interface: <i>Smiley -&gt; Circle -&gt; Shape</i></li><li>Implementierung: <i>Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</i></li></ul></div>
<div class="text">Hattest du vielleicht ein déjà vu? Ich schon. Eine ähnlliche Technik kommt gerne für das Adapter Pattern zum Einsatz, wenn es mit Mehrfachvererbung implementiert wird. Das Adapter Pattern ist ein Pattern aus dem berühmten <a title="Link auf https://de.wikipedia.org/wiki/Entwurfsmuster" href="https://de.wikipedia.org/wiki/Entwurfsmuster" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEntwurfsmuster%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEntwurfsmuster%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Design-Pattern%22%2C%22version%22%3A1%7D" class="">Design-Pattern</a>-Buch. </div>
<div class="text">Die Idee des Adapter Pattern ist es, ein Interface in ein anderes zu übersetzen. Du erreichst dies mit Mehrfachvererbung, indem du öffentlich von dem neuen und private von dem bestehenden Interface ableitest. Das bedeutet, dass das bestehende Interface als Implementierung zum Einsatz kommt.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_142992867_1fbd0ad878.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><b><a class="" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-kind%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22C.130%3A%20Redefine%20or%20prohibit%20copying%20for%20a%20base%20class%3B%20prefer%20a%20virtual%20clone%20function%20instead%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-kind">C.130: Redefine or prohibit copying for a base class; prefer a virtual clone function instead</a></b></div>
<div class="text">Die Erläuterung zu dieser Regel kann ich sehr kurz halten. Die Regel <a href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Regeln-fuer-das-Kopieren-und-Verschieben-3834288.html" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Regeln-fuer-das-Kopieren-und-Verschieben-3834288.html" class="" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Regeln-fuer-das-Kopieren-und-Verschieben-3834288.html%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Regeln-fuer-das-Kopieren-und-Verschieben-3834288.html%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C.67%22%7D">C.67</a> liefert die ganze Begründung.<br> </div>
<div class="text"><b><a alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C.131%3A%20Avoid%20trivial%20getters%20and%20setters%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-get%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-get%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-get" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-get">C.131: Avoid trivial getters and setters</a></b></div>
<div class="text">Falls ein einfacher <i>getter</i> oder <i>setter</i> keinen Mehrwert liefert, erkläre das Attribut als <i>public.</i> Hier sind zwei Beispiele für einfache <i>getter</i> und <i>setter. </i></div>
<div class="pre">class Point {&nbsp;&nbsp; // Bad: verbose<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; int y;<br>public:<br>&nbsp;&nbsp;&nbsp; Point(int xx, int yy) : x{xx}, y{yy} { }<br>&nbsp;&nbsp;&nbsp; int get_x() const { return x; }<br>&nbsp;&nbsp;&nbsp; void set_x(int xx) { x = xx; }<br>&nbsp;&nbsp;&nbsp; int get_y() const { return y; }<br>&nbsp;&nbsp;&nbsp; void set_y(int yy) { y = yy; }<br>&nbsp;&nbsp;&nbsp; // no behavioral member functions<br>};</div>
<div class="text"><i>x </i>oder <i>y</i> können beliebige Werte annehmen. Das bedeutet formaler: Instanzen der Klasse <i>Point </i>sichern keine Invariante für <i>x</i> oder<i> y</i> zu. <i>x</i> oder <i>y</i> sind einfach nur Werte. In diesem Fall ist eine <i>struct</i> als eine Sammlung von Werten deutlich angebrachter. </div>
<div class="pre">struct Point {<br>&nbsp;&nbsp;&nbsp; int x {0};<br>&nbsp;&nbsp;&nbsp; int y {0};<br>}; </div>
<div class="text"><b><a alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22C.132%3A%20Don%C2%92t%20make%20a%20function%20virtual%20without%20reason%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual">C.132: Don’t make a function virtual without reason</a></b></div>
<div class="text">Diese Regel ist einfach nachzuvollziehen. Eine virtuelle Funktion ist ein Feature in C++, dass du nicht umsonst bekommst. </div>
<div class="text">Eine virtuelle Funktion</div>
<div class="text"><ul><li> wirkt sich auf die Performanz des Programms und die Größe des Objekts aus.</li><li>ist empfänglich für Fehler, da sie in einer abgeleiteten Klasse überschrieben werden kann.</li></ul> </div>
<div class="text"><b><a class="" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-protected%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-protected%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22C.133%3A%20Avoid%20protected%20data%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-protected">C.133: Avoid protected data</a></b></div>
<div class="text">Daten, die <i>protected</i> deklariert sind, machen dein Programm anspruchsvoller und fehleranfälliger. Falls in der Basisklasse <i>protected</i>-Daten zum Einsatz kommen, lässt sich nicht mehr über abgeleiteten Klassen in Isolation nachdenken. Damit brichst du die Kapselung. Du musst dir immer Gedanken zu ganzen Klassenhierarchie machen. </div>
<div class="text">Das bedeutet, diese drei Fragen müssen in der Regel beantwortet werden.</div>
<div class="text"><ol><li> Muss ich einen Konstruktor implementieren um die <i>proteced</i>-Daten richtig zu initialisieren?</li><li>Welchen Wert besitzt das <i>protected-</i>Datum, wenn ich es verwende?</li><li>Welche Funktionalität wird in Mitleidenschaft gezogen, wenn ich das <i>proteced-</i>Datum verändere?<br></li></ol></div>
<div class="text">Natürlich wird die Beantwortung dieser Fragen immer anspruchsvoller, wenn die Klassenhierarchie vor allem in die Tiefe wächst. </div>
<div class="text">Genau genommen ist ein <i>protected</i>-Datum eine globale Variable in der Klassenhierarchie. Das erste Gebot der Softwareentwicklung lautet aber : Vermeide nicht konstante globale Daten. </div>
<div class="text">Zum Abschluss stellt die Guidelines noch das Interface <i>Shape</i> vor, das um <i>proteced-</i>Daten erweitert ist.</div>
<div class="pre">class Shape {<br>public:<br>&nbsp;&nbsp;&nbsp; // ... interface functions ...<br>protected:<br>&nbsp;&nbsp;&nbsp; // data for use in derived classes:<br>&nbsp;&nbsp;&nbsp; Color fill_color;<br>&nbsp;&nbsp;&nbsp; Color edge_color;<br>&nbsp;&nbsp;&nbsp; Style st;<br>};</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wir sind noch nicht fertig mit unserer Reise durch die Regeln für Klassenhierarchien. Daher geht die Reise im nächsten Artikel weiter.</div>
<div class="ztitel">Weitere Informationen</div>
<div class="text"><ul><li>Das PDF-Päckchen zu C++17 bekam mit Abstand die meisten Stimmen. Daher werde ich dies spätestens am Donnerstag veröffentlichen. Hier ist das Ergebnis der Abstimmung: <a title="Link auf http://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuzchen" href="http://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuzchen" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22Welches%20P%C3%A4ckchen%20soll%20ich%20zusammenstellen%3F%20Mache%20dein%20Kreuz%21%20%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuzchen%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuzchen%22%7D">Welches Päckchen soll ich zusammenstellen? Mache dein Kreuz! </a></li><li>Ich möchte ehrlich sein. Ich habe sehr viel gelernt, indem ich über die C++ Core Guidelines schreibe und noch zusätzliche Hintergrundinformationen anbiete, falls ich dies für notwendige erachte. Daher möchte ich diese Worte nutzen, um Feedback einzufordern. Gegebenenfalls werde ich gerne den Fokus und den Anspruch meiner Artikel anpassen.</li></ul></div>
