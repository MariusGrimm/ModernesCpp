<div class="vorspann">Die guideline support library (GSL) ist eine kleine Bibliothek um die Regeln der C++ core guidelines zu unterstützen. Ihr Ziel ist es besseren C++ Code zu schreiben. Daher geht es vor allem um Speichersicherheit und Typsicherheit. Es gibt bereits Implementierungen der GSL. </div>
<div class="text">Die GSL ist eine Bibliothek, die nur aus Headern besteht. Daher kannst du ihre Funktionen und Datentypen sehr leicht verwenden. Die bekannteste Implementierung ist von Microsoft und lässt sich direkt von Github herunterladen: <a alt="%7B%22href%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Microsoft%2FGSL%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%22%7D" class="" href="https://github.com/Microsoft/GSL" title="Link auf https://github.com/Microsoft/GSL">Microsoft/GSL</a>. Microsofts Implementierung setzen den C++14 Standard voraus und läuft auf vielen Plattformen. Hier sind die bekanntesten.</div>
<div class="text"><ul><li>Windows mit Visual Studio 2015</li><li>Windows mit Visual Studio 2017</li><li>GNU/Linux mit Clang/LLVM 3.6</li><li>GNU/Linux mit GCC 5.1</li></ul></div>
<div>Es gibt noch mehr Implementierungen auf GitHub. Ich will explizit die <a class="" href="https://github.com/martinmoene/gsl-lite" alt="%7B%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fmartinmoene%2Fgsl-lite%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22GSL-lite%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fmartinmoene%2Fgsl-lite%22%7D" title="Link auf https://github.com/martinmoene/gsl-lite">GSL-lite</a> von Martin Moene erwähnen, die bereits die Standards C++98 und C++03 unterstützt.<br></div>
<div>Bevor ich in die Details abtauche, möchte ich einen Punkt erwähnen, der meinen Schreibfluss empfindlich störte: der Mangel an guter Dokumentation oder Tutorials. Um eine detailiierte Vorstellung zu erhalten, welche Absicht die Datentypen und Funktionen der GSL besitzen, musst du die&nbsp; Bibliothek installieren und die Unit-Tests analysieren. Das ist nicht die Art der Dokumentation, die ich erwarte. Im Gegensatz dazu war die Installation und die Verwendung von Microsofts Implementierung der GSL sehr einfach unter Windows und Linux.</div>
<div>So, nun geht es aber in die Details. Die GSL besteht auf fünf Komponenten. Hier kommt der erste Überblick.</div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_137950915_67826352d1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"><br></div>
<div><ul><li>GSL.view: Views<ul><li>span&lt;T&gt;</li><li>string_span&lt;T&gt;</li><li>(cw)zstring</li></ul></li><li>GSL.owner<br><ul><li>owner&lt;T&gt;</li><li>unique_ptr&lt;T&gt;</li><li>shared_ptr&lt;T&gt;</li><li>dyn_array&lt;T&gt;</li><li>stack_array&lt;T&gt;</li></ul></li><li>GSL.assert: Assertions<ul><li>Expects()</li><li>Ensures()</li></ul></li><li>GSL.util: Utilities<ul><li>narrow</li><li>narrow_cast()</li><li>not_null&lt;T&gt;</li><li>finally</li></ul></li><li>GSL.concept: Concepts<ul><li>Range</li><li>String</li><li>Number</li><li>Sortable</li><li>Pointer</li><li>...</li></ul></li></ul></div>
<div>Du wunderst dich vermutlich, dass die GSL ihre eigenen Smart Pointer <i>gsl::unique_ptr </i>und <i>gsl::shared_ptr </i>mitbringt, denn der C++11 Standard besitzt bereits <i>std::unique_ptr</i> und <i>std::shared_ptr</i>. Der Grund ist sehr naheliegend: du kannst die GSL bereits mit einem Compiler verwenden, der C++11 nicht unterstützt. Viele der Funkionen und Datentypen der GSL werden Bestandteil von C++20 werden. Das gilt zu mindestens für Concepts und Assertions. Darüber hinaus ist es sehr wahrscheinlich, das die verbleibenden Komponenten in zukünftige C++ Standards aufgenommen werden. </div>
<div class="ztitel">Die Komponenten</div>
<div class="text">Los geht es mit dem Views.</div>
<div class="ztitel_kleiner">GSL.view: Views</div>
<div class="text">Ein View ist niemals ein Besitzer (owner). Im Falle von <i>gsl::span&lt;T&gt;</i> repräsentiert er einen nicht-besitzenden Bereich von zusammenhängendem Speicher. Dies kann ein Array, ein Zeiger mit seiner Länge oder ein <i>std::vector </i>sein. Das gleich gilt für <i>gsl::string_span&lt;T&gt;</i> oder die Null-terminierten C Strings: <i>gsl::(cw)zstring</i>. Der Grund für <i>gsl::span&lt;T&gt; </i>ist, dass ein einfaches Array zu einem Zeiger wird, falls dieses an eine Funktion übergeben wird. Damit geht zwangsläufig seine Länge verloren.</div>
<div class="text"><b><i>gsl::span&lt;T&gt;</i></b> bestimmt automatisch die Länge eines Arrays oder seines Vektors. Falls du einen Zeiger verwendest, musst du die Länge explizit angeben.</div>
<div class="pre">template &lt;typename T&gt;<br>void copy_n(const T* p, T* q, int n){}<br><br>template &lt;typename T&gt;<br>void copy(gsl::span&lt;const T&gt; src, gsl::span&lt;T&gt; des){}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; int arr1[] = {1, 2, 3};<br>&nbsp; int arr2[] = {3, 4, 5};<br>&nbsp; <br>&nbsp; copy_n(arr1, arr2, 3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; copy(arr1, arr2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Im Gegensatz zu der Funktion <i>copy_n </i>(1) musst du bei der Funktion <i>copy </i>(2) nicht die Anzahl seiner Elemente angeben. Daher verschwindet mit <i>gsl::span&lt;T&gt;</i> ein häufiger Fehler von C oder C++ Programmen. </div>
<div class="text">Es gibt viele Typen von Besitzer (owner) in der GSL.</div>
<div class="ztitel_kleiner">GSL.owner: Ownership pointers</div>
<div class="text">Ich nehme an, du kennst bereits <i>std::unique_ptr</i> und <i>std::shared_ptr </i>und unter somit kennst du bereits <i>gsl::unique_ptr</i> und <i>gsl::shared_ptr.</i> Falls&nbsp; dies nicht der Fall ist, hier sind meine Artikel über <a class="" href="http://www.grimm-jaud.de/index.php/blog/tag/smart-pointer" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Smart%20Pointer%20in%20C%2B%2B%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/smart-pointer">Smart Pointer in C++</a>. </div>
<div class="text"><b><i>gsl::owner&lt;T&gt;</i></b> ist ein Zeiger, der Besitzer seiner referenzierten Ressource ist. Du solltest dann gsl::owner&lt;T&gt; verwenden, wenn du keinen Ressourcehandle wie Smart Pointer oder Container einsetzen kannst. Der entscheidende Punkt eines Besitzers ist, dass du seine Ressource explizit freigeben musst. Rohe Zeiger, die nicht als <i>gsl::owner&lt;T&gt;</i> deklariert werden, gelten als Nicht-Besitzer in den C++ core guidelines. Daher bist du nicht in der Verantwortung, ihre Ressource freizugeben.</div>
<div class="text"><i>gsl::dyn_array&lt;T&gt;</i> und <i>gsl::stack_array&lt;T&gt;</i> sind zwei neue Array-Typen.</div>
<div class="text"><ul><li><b> <i>gsl::dyn_array&lt;T</i></b>&gt; ist ein Array fester Länge, das auf dem Heap angelegt wird. Seine Länge wird zur Laufzeit angeben.<br></li><li><b> <i>gsl::stack_array&lt;T&gt;</i></b> ist ein Array fester Länge, das auf dem Stack angelegt wird. Seine Länge wird zur Laufzeit angegeben.</li></ul></div>
<div class="ztitel_kleiner">GSL.assert: Assertions</div>
<div class="text">Danke<b><i> Expects() </i></b>und <b><i>Ensures() </i></b>kannst du Vor- und Nachbedingungen an deine Funktionen stellen. Zur jetzigen Zeitpunkt musst du diese im Funktionskörper platzieren, aber später werden diese direkt in der Funktionsdeklaration spezifiziert. Beide Funktionen sind Bestandteil des <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf" class="" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0380r1.pdf%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22contract%20proposa%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0380r1.pdf%22%2C%22type%22%3A%22E%22%7D">contract proposa</a>l für C++20.<br></div>
<div class="text">Hier ist ein einfaches Beispiel zur Verwendung von <i>Expects()</i> und <i>Ensures()</i>. </div>
<div class="pre">int area(int height, int width)<br>{<br>&nbsp;&nbsp;&nbsp; Expects(height &gt; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto res = height * width;<br>&nbsp;&nbsp;&nbsp; Ensures(res &gt; 0);<br>&nbsp;&nbsp;&nbsp; return res;<br>}</div>
<div class="ztitel_kleiner">GSL.util: Utilities</div>
<div class="text"><i>gsl::narrow_cast&lt;T&gt;</i> und <i>gsl::narrow</i> sind zwei neue Konvertierungen. </div>
<div class="text"><ul><li> <b><i>gsl::narrow_cast&lt;T&gt;</i></b> ist ein <i>static_cast&lt;T&gt;</i>, der nur seine Intention explizit ausdrückt. Eine verengende Konvertierung (narrowing conversion) ist möglich. Eine verengende Konvertierung ist eine Konvertierung mit Verlust der Datengenauigkeit.<br></li><li><b><i>gsl::narrow</i> </b>ist ein <i>static_cast&lt;T&gt;</i>, die eine narrowing_error Ausnahme wirft, falls gilt, dass <i>static_cast&lt;T&gt; != x </i>ist. <br></li></ul></div>
<div class="text"><b><i>gsl::not_null&lt;T*&gt;</i></b> steht für einen Zeiger, der kein Nullzeiger (<i>nullptr</i>) sein kann. Falls du versuchst, einen <i>gsl::not_null&lt;T*&gt;</i> Zeiger auf <i>nullptr </i>zu setzen, erhälts du einen Compilerfehler. Du kannst selbst einen Smart Pointer wie <i>std::unique_ptr</i> oder <i>std::shared_ptr</i> in einem <i>gsl::not_null&lt;T*&gt;</i> verwenden. Typischerweise verwendest du <i>gsl::not_null&lt;T*&gt;</i> für die Funktionsparameter und den Rückgabetyp einer Funktion. Daher kann es dir nicht passieren, dass du vergisst zu prüfen, ob der Zeiger tatsächlich einen Wert besitzt. </div>
<div class="pre">int getLength(gsl::not_null&lt;const char*&gt; p); // p cannot be a nullptr<br><br>int getLength(const char* p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // p can be a nullptr</div>
<div class="text">Beide Funktionen bringen ihre Intention direkt auf den Punkt. Die zweite Funktion nimmt auch einen <i>nullptr</i> an.</div>
<div class="text"><b><i>finally</i></b> erlaubt dir eine Funktion zu registrieren, die dann automatisch ausgeführt wird, wenn der Bereich (scope) verlassen wird. </div>
<div class="pre">void f(int n)<br>{<br>&nbsp;&nbsp;&nbsp; void* p = malloc(1, n);<br>&nbsp;&nbsp;&nbsp; auto _ = finally([p] { free(p); });<br>&nbsp;&nbsp;&nbsp; ...<br>}</div>
<div class="text">Am Ende der Funktion <i>f</i> wird die Lambda-Funktion <i>[p] { free(p); } </i>automatisch ausgeführt.<br></div>
<div class="text">Gemäß den C++ core guidelines solltest du <i>finally</i> nur als letztes Hilfsmittel verwenden, wenn ein angemessenerer Umgang mit Ressourcen mittels Smart Pointer oder Container nicht möglich ist.</div>
<div class="ztitel_kleiner">GSL.concept: Concepts</div>
<div class="text">Ich halte mich sehr kurz, denn die meisten der Konzepte sind im <a alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fn4569.pdf%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Ranges%20TS%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fn4569.pdf%22%2C%22ir_link%22%3A1%7D" class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">Ranges TS</a> bereits implementiert. TS steht für Technical Specification und steht für eine Erweiterung für einen zukünftigen C++ Standard (C++20).&nbsp; Hier sind meine Artikel zu <a title="Link auf http://www.modernescpp.com/index.php/tag/concepts" alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Ftag%2Fconcepts%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22Concepts.%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Ftag%2Fconcepts%22%2C%22ir_link%22%3A1%7D" href="http://www.modernescpp.com/index.php/tag/concepts" class="">Concepts.</a></div>
<div class="ztitel">Meine letzten Worte</div>
<div class="text">Mich hat die GSL sehr überzeugt. Was ich besonders an ihr schätzte, ist, dass sie keinen C++11 konformen Compiler benötigt. Du kannst sie selbst mit deiner bestehenden Codebasis verwenden und ihre Speicher- und Typsicherheit deutlich verbessern. Ich habe fast vergessen einen wichtigen Punkt zu erwähnen: die GSL "aim for zero-overhead when compared to equivalent hand-written checks.". Wenn das keine Zusage ist!<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nach meinem kleinen Umweg über die GSL werden ich zu den C++ core guidelines zurückkehren. Im nächsten Artikel geht es um Funktionen im Allgemeinen, ihre Parameter und ihr Rückgabewert im Besonderen.<br></div>
