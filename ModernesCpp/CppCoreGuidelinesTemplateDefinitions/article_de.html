<div class="vorspann">Template-Definitionen beschäftigen sich mit Regeln, die typisch für die Implementierung eines Templates sind. Das bedeutet insbesondere auch, wie stark die Template-Definition von ihrem Kontext abhängt.<br></div>
<div class="text">Hier sind die Regeln, um die es im heutigen Artikel geht: </div>
<div class="text"><ul><li> <a alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-depend%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22T.60%3A%20Minimize%20a%20template%C2%92s%20context%20dependencies%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-depend%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-depend" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-depend">T.60: Minimize a template’s context dependencies</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-scary" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-scary" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-scary%22%2C%22text%22%3A%22T.61%3A%20Do%20not%20over-parameterize%20members%20%28SCARY%29%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-scary%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" class="">T.61: Do not over-parameterize members (SCARY)</a> </li><li> <a alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nondependent%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22T.62%3A%20Place%20non-dependent%20class%20template%20members%20in%20a%20non-templated%20base%20class%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nondependent%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nondependent" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nondependent">T.62: Place non-dependent class template members in a non-templated base class</a></li></ul></div>
<div class="text">Mit der ersten Regel geht es bereits recht speziell los:<br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-depend" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-depend" alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-depend%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-depend%22%2C%22text%22%3A%22T.60%3A%20Minimize%20a%20template%C2%92s%20context%20dependencies%22%7D" class="">T.60: Minimize a template’s context dependencies</a> <br> </div>
<div class="text">Ich habe einige Momente benötigt, bis ich die Regel verstanden habe. Ein Blick auf die Funktions-Templates <i>sort</i> und <i>algo</i> hilft. Dies ist das vereinfachte Beispiel aus den Guidelines:</div>
<div class="pre">template&lt;typename C&gt;<br>void sort(C&amp; c)<br>{<br>&nbsp;&nbsp;&nbsp; std::sort(begin(c), end(c)); // necessary and useful dependency<br>}<br><br>template&lt;typename Iter&gt;<br>Iter algo(Iter first, Iter last) {<br>&nbsp;&nbsp;&nbsp; for (; first != last; ++first) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; helper(first, x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // potentially surprising dependency:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // helper is chosen based on first and x&nbsp;&nbsp; &nbsp;<br>} </div>
<div class="text">Es wäre optimal, ist aber nicht immer erreichbar, dass ein Template lediglich seine Argumente verwendet. Dies gilt für das Funktions-Template <i>sort;</i> aber nicht für <i>algo</i>. Das Funktions-Template <i>algo</i> besitzt Abhängigkeiten zu den Funktionen <i>sqrt</i> und <i>helper</i>. Letztlich führt die Implementierung von <i>algo</i> mehr Abhängigkeiten ein, als es sich aus dem Interface ablesen lässt. <br></div>
<div class="ztitel"><a alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22T.61%3A%20Do%20not%20over-parameterize%20members%20%28SCARY%29%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-scary%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-scary%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-scary" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-scary">T.61: Do not over-parameterize members (SCARY)</a> <br> </div>
<div class="text">Falls ein Mitglied eines Templates nicht von Template-Parametern abhängt, entferne es aus dem Template. Ein Mitglied kann ein Datentyp oder eine Methode sein. Indem du diese Regel anwendest, verringert sich die Codegröße, denn nichtgenerischer Code ist nicht Bestandteil des Templates. </div>
<div class="text">Das Beispiel aus den Guidelines ist leicht zu verstehen:<br></div>
<div class="pre">template&lt;typename T, typename A = std::allocator{}&gt;<br>&nbsp;&nbsp;&nbsp; // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;<br>class List {<br>public:<br>&nbsp;&nbsp;&nbsp; struct Link {&nbsp;&nbsp; // does not depend on A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T elem;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T* pre;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T* suc;<br>&nbsp;&nbsp;&nbsp; };<br><br>&nbsp;&nbsp;&nbsp; using iterator = Link*;<br><br>&nbsp;&nbsp;&nbsp; iterator first() const { return head; }<br><br>&nbsp;&nbsp;&nbsp; // ...<br>private:<br>&nbsp;&nbsp;&nbsp; Link* head;<br>};<br><br>List&lt;int&gt; lst1;<br>List&lt;int, My_allocator&gt; lst2;</div>
<div class="text">Der Datentyp <i>Link</i> hängt nicht vom Template-Parameter <i>A</i> ab. Daher kann ich ihn entfernen und in <i>List2 </i>direkt verwenden:</div>
<div class="pre">template&lt;typename T&gt;<br>struct Link {<br>&nbsp;&nbsp;&nbsp; T elem;<br>&nbsp;&nbsp;&nbsp; T* pre;<br>&nbsp;&nbsp;&nbsp; T* suc;<br>};<br><br>template&lt;typename T, typename A = std::allocator{}&gt;<br>&nbsp;&nbsp;&nbsp; // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;<br>class List2 {<br>public:<br>&nbsp;&nbsp;&nbsp; using iterator = Link&lt;T&gt;*;<br><br>&nbsp;&nbsp;&nbsp; iterator first() const { return head; }<br><br>&nbsp;&nbsp;&nbsp; // ...<br>private:<br>&nbsp;&nbsp;&nbsp; Link* head;<br>};<br><br>List&lt;int&gt; lst1;<br>List&lt;int, My_allocator&gt; lst2;</div>
<div class="text">Dies war einfach? Ja? Nein? Die Regel verwendet die Abkürzung SCARY. Für was steht sie? Zumindest bin ich neugierig. Aber um ehrlich zu sein, kannst du die nächsten Zeilen ignorieren.</div>
<div class="text">Das Akronym steht für "describes assignments and initializations that are Seemingly erroneous (appearing Constrained by conflicting generic parameters), but Actually work with the Right implementation (unconstrained bY the conflict due to minimized dependencies)".</div>
<div class="text">Die Details dazu gibt es im Dokument <a class="" alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2FWG21%2Fdocs%2Fpapers%2F2009%2Fn2911.pdf%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22N2911.%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2FWG21%2Fdocs%2Fpapers%2F2009%2Fn2911.pdf%22%7D" href="http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf">N2911.</a> Um dich nicht zu langweilen, hier ist die Idee vereinfacht auf die Container der Standard Template Libray angewandt: Diese besitzen keine Abhängigkeiten zu ihren Datentypen <i>key_compare</i>, <i>hasher,</i> <i>key_equal</i> oder <i>allocator</i> und können damit unabhängig erweitert werden. </div>
<div class="text">Die nächste Regel hilft, um die Codegröße zu reduzieren.<br></div>
<div class="ztitel"><a alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22T.62%3A%20Place%20non-dependent%20class%20template%20members%20in%20a%20non-templated%20base%20class%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nondependent%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-nondependent%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nondependent" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-nondependent">T.62: Place non-dependent class template members in a non-templated base class</a></div>
<div class="text">Lass es mich einfacher ausdrücken: Verschiebe die Funktionalität eines Templates, die nicht von den Template-Parametern abhängt, in eine Basisklasse, die kein Template ist. </div>
<div class="text">Zu dieser Regel bieten die Guidelines ein einfaches Beispiel an:</div>
<div class="pre">template&lt;typename T&gt;<br>class Foo {<br>public:<br>&nbsp;&nbsp;&nbsp; enum { v1, v2 };<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Die Aufzählung hängt nicht vom Typparameter T ab und sollte daher in eine nichtgenerische Basisklasse verschoben werden:</div>
<div class="pre">struct Foo_base {<br>&nbsp;&nbsp;&nbsp; enum { v1, v2 };<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>template&lt;typename T&gt;<br>class Foo : public Foo_base {<br>public:<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Jetzt lässt sich <i>Foo</i> ohne Template-Argumente und Template-Instanziierung verwenden.</div>
<div class="text">Diese Technik ist interessant, wenn du die Codegröße reduzieren willst. Dazu habe ich ein einfaches Klassen-Template <i>Array</i> implementiert<i>:<br></i></div>
<div class="pre">// genericArray.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename T, std::size_t N&gt;<br>class Array{<br>public:<br>&nbsp;&nbsp;&nbsp; Array()= default;<br>&nbsp;&nbsp;&nbsp; std::size_t getSize() const{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp; T elem[N];<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; Array&lt;int, 100&gt; arr1;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "arr1.getSize(): " &lt;&lt; arr1.getSize() &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Array&lt;int, 200&gt; arr2;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "arr2.getSize(): " &lt;&lt; arr2.getSize() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Bei genauer Betrachtung des Klassen-Templates <i>Array </i>fällt auf, dass die Methode <i>getSize</i> lediglich vom Typparameter <i>N </i>abhängt. Daher werde ich den Code refaktorieren und eine Klasse <i>ArrayBase </i>definieren, die nur vom Typparameter <i>T</i> abhängt:</div>
<div class="pre">// genericArrayInheritance.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br><br>template&lt;typename T&gt;<br>class ArrayBase {<br>protected:<br>&nbsp;&nbsp;&nbsp; ArrayBase(std::size_t n): size(n) {} <br>&nbsp;&nbsp;&nbsp; std::size_t getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return size;<br>&nbsp;&nbsp;&nbsp; };<br>private:<br>&nbsp;&nbsp;&nbsp; std::size_t size;<br>};<br><br>template&lt;typename T, std::size_t n&gt;<br>class Array: private ArrayBase&lt;T&gt;{<br>public:&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Array(): ArrayBase&lt;T&gt;(n){}<br>&nbsp;&nbsp;&nbsp; std::size_t getSize() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; ArrayBase&lt;T&gt;::getSize();<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; T data[n]; <br>};&nbsp;&nbsp; <br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; Array&lt;int, 100&gt; arr1;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "arr1.getSize(): " &lt;&lt; arr1.getSize() &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Array&lt;int, 200&gt; arr2;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "arr2.getSize(): " &lt;&lt; arr2.getSize() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text"><i>Array </i>besitzt zwei Template-Parameter für den Datentyp <i>T</i> und die Länge <i>n.</i> Hingegen hat <i>ArrayBase </i>nur ein Template-Parameter für den Datentyp <i>T. Arrray </i>ist von <i>ArrayBase </i>abgeleitet. Das heißt, dass <i>ArrayBase</i> zwischen allen Instanzen von <i>Array</i> geteilt wird, die denselben Datentyp<i> T</i> verwenden. In dem konkreten Fall bedeutet dies, dass die<i> getSize</i>-Methode von<i> Array </i>die von <i>ArrayBase </i>verwendet. </div>
<div class="text">Danke <a title="Link auf https://cppinsights.io/" href="https://cppinsights.io/" alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22CppInsight%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" class="">CppInsight</a> kann ich den vom Compiler erzeugten Code direkt zeigen.</div>
<div class="text">Hier ist die Instanziierung von <i>ArrayBase&lt;int&gt;</i>:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_163607388_5353728fb9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Und hier sind die Instanziierungen für <i>Array&lt;int, 100&gt;:</i></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_163607394_cccea74f61.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">und <i>Array&lt;int, 200&gt;</i>:</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_163607401_e385ed5170.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Natürlich gibt es mehr Regel zu Template-Definitionen. Daher geht meine Geschichte zu Templates im nächsten Artikel weiter. Ich hoffe, dass meine Erläuterungen zu Templates ausreichend sind, denn ich weiß, dass viele Programmierer Templates nicht verwenden wollen. Für mich sind die zentralen Ideen von Templates einfach zu verstehen, aber ihre Syntax besitzt noch einiges an Verbesserungspotenzial.<br></div>