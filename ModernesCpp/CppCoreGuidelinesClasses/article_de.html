<div class="vorspann">Eine Klasse ist ein benutzerdefinierter Typ, für die Programmierer die Repräsentation, die Operationen und das Interface festlegen. Die C++ Core Guidelines besitzen sehr viele Regeln für benutzerdefinierte Typen. </div>
<div class="text">Die Guidelines beginnen mit allgemeinen Regeln für Klassen, besitzen aber auch spezielle Regeln für Konstruktoren und Destruktoren, zu Klassenhierarchien sowie zum Überladen von Operatoren und Unions.</div>
<div class="text">Bevor ich mich ausführlich den spannenden, speziellen Regeln widme, gehe ich erst auf die acht allgemeinen Regeln ein.</div>
<div class="text"><ul><li>C.1: Organize related data into structures (structs or classes)<br></li><li>C.2: Use class if the class has an invariant; use struct if the data members can vary independently<br></li><li>C.3: Represent the distinction between an interface and an implementation using a class<br></li><li>C.4: Make a function a member only if it needs direct access to the representation of a class<br></li><li>C.5: Place helper functions in the same namespace as the class they support<br></li><li>C.7: Don’t define a class or enum and declare a variable of its type in the same statement<br></li><li>C.8: Use class rather than struct if any member is non-public<br></li><li>C.9: Minimize exposure of members</li></ul></div>
<div class="text">Ich werde nur soweit auf die allgemeinen Regeln zu Klassen eingehen, damit ihre Intention ersichtlich wird.</div>
<div class="ztitel">Allgemeine Regeln zu Klassen</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_139484881_b988e7e2f0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> <br> </div>
<div class="text"><b>C.1: Organize related data into structures (structs or classes)</b></div>
<div class="text">Wenn Daten zusammen gehören, sollte man sie in einer Klasse oder Struktur kapseln. Daher ist die zweite Funktion deutlich einfacher zu verstehen.</div>
<div class="pre">void draw(int x, int y, int x2, int y2);&nbsp; // BAD: unnecessary implicit relationships<br>void draw(Point from, Point to);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // better<br></div>
<div class="text"><b>C.2: Use class if the class has an invariant; use struct if the data members can vary independently</b></div>
<div class="text">Eine Invariante ist eine logische Bedingung, die typischerweise im Konstruktor etabliert wird. </div>
<div class="pre">struct Pair {&nbsp; // the members can vary independently<br>&nbsp;&nbsp;&nbsp; string name;<br>&nbsp;&nbsp;&nbsp; int volume;<br>};<br><br>class Date {<br>public:<br>&nbsp;&nbsp;&nbsp; // validate that {yy, mm, dd} is a valid date and initialize<br>&nbsp;&nbsp;&nbsp; Date(int yy, Month mm, char dd);<br>&nbsp;&nbsp;&nbsp; // ...<br>private:<br>&nbsp;&nbsp;&nbsp; int y;<br>&nbsp;&nbsp;&nbsp; Month m;<br>&nbsp;&nbsp;&nbsp; char d;&nbsp;&nbsp;&nbsp; // day<br>};</div>
<div class="text">Die Klasse <i>Date</i> besitzt die Invariante<i> y</i>, <i>m</i> und <i>d</i>. Diese wird im Konstruktor initialisiert und geprüft. Der Datentyp <i>Pair</i> besitzt hingegen keine Invariante. Daher kommt eine Struktur zum Einsatz. </div>
<div class="text">Dank der Invariante ist die Klasse einfacher zu verwenden. Einfachheit ist auch der Grund für die nächste Regel.<br></div>
<div class="text"><b>C.3: Represent the distinction between an interface and an implementation using a class</b></div>
<div class="text">Die öffentlichen Methoden stellen in diesem Fall das Interface der Klasse dar, die privaten Methoden deren Implementierung. </div>
<div class="pre">class Date {<br>&nbsp;&nbsp;&nbsp; // ... some representation ...<br>public:<br>&nbsp;&nbsp;&nbsp; Date();<br>&nbsp;&nbsp;&nbsp; // validate that {yy, mm, dd} is a valid date and initialize<br>&nbsp;&nbsp;&nbsp; Date(int yy, Month mm, char dd);<br><br>&nbsp;&nbsp;&nbsp; int day() const;<br>&nbsp;&nbsp;&nbsp; Month month() const;<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Mit der Mainainance-Brille betrachtet lässt sich die Implementierung der Klasse <i>Date</i> ändern, ohne dass die Anwender betroffen sind. <br></div>
<div class="text"><b>C.4: Make a function a member only if it needs direct access to the representation of a class</b></div>
<div class="text">Falls eine Funktion nicht den Zugriff auf die Implementierung einer Klasse&nbsp; benötigt, sollte sie kein Mitglied der Klasse sein. Damit erhält man automatisch <a alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22lose%20Kopplung%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FLose_Kopplung%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FLose_Kopplung%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" class="" title="Link auf https://de.wikipedia.org/wiki/Lose_Kopplung" href="https://de.wikipedia.org/wiki/Lose_Kopplung">lose Kopplung</a>, und eine Veränderung der Implementierung der Klasse beeinträchtigt nicht die Funktion.&nbsp; </div>
<div class="text"><b>C.5: Place helper functions in the same namespace as the class they support</b></div>
<div class="text">Hilfsfunktion sollten im gleichen Namensraum wie die Klasse sein.</div>
<div class="pre">namespace Chrono { // here we keep time-related services<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; class Date { /* ... */ };<br><br>&nbsp;&nbsp;&nbsp; // helper functions:<br>&nbsp;&nbsp;&nbsp; bool operator==(Date, Date);<br>&nbsp;&nbsp;&nbsp; Date next_weekday(Date);<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br>...<br>if (date1 == date2){&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br></div>
<div class="text">Dank <a title="Link auf https://de.wikipedia.org/wiki/Argument_dependent_name_lookup" class="" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FArgument_dependent_name_lookup%22%2C%22text%22%3A%22Argument%20Dependent%20Lookup%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FArgument_dependent_name_lookup%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="https://de.wikipedia.org/wiki/Argument_dependent_name_lookup">Argument Dependent Lookup</a> (ADL) findet der C++ Lookup den Identitätsoperator (==) im <i>Chrono</i>-Namensraum.<br></div>
<div class="text"><b>C.7: Don’t define a class or enum and declare a variable of its type in the same statement</b></div>
<div class="text">Ich gebe zu: Die Definition einer Klasse und die Deklaration einer Variable dieses Typs hat mich schon das eine oder andere Mal verwirrt. </div>
<div class="pre">// bad<br>struct Data { /*...*/ } data{ /*...*/ }; <br><br>// good<br>struct Data { /*...*/ };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>Data data{ /*...*/ };<br></div>
<div class="text"><b>C.8: Use class rather than struct if any member is non-public</b></div>
<div class="text">Dies ist eine praktische und bereits sehr häufig eingesetzte Regel. Falls ein Datentyp "private"- oder "protected"-Mitglieder besitzt, sollte er als Klasse entworfen werden. </div>
<div class="text"><b>C.9: Minimize exposure of members</b></div>
<div class="text">Die Regel ist auch unter dem Ausdruck D<a title="Link auf https://en.wikipedia.org/wiki/Information_hiding" class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FInformation_hiding%22%2C%22text%22%3A%22ata%20Hiding%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FInformation_hiding%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%7D" href="https://en.wikipedia.org/wiki/Information_hiding">ata Hiding</a> bekannt und ist einer der Eckpfeiler objektorientierten Klassendesigns. Sie besagt, dass man sich Gedanken zu zwei Arten von Interfaces machen sollte: ein öffentliches Interface für den allgemeinen Anwendungsfall und ein "protected"-Interface für die abgeleiteten Klassen. Die verbleibenden Mitglieder sollten privat sein. </div>
<div class="text">Nun kommen wir zu den spezielleren Regeln. Hier ist der erste Überblick.</div>
<div class="text"><ul><li>C.concrete: Concrete types<br></li><li>C.ctor: Constructors, assignments, and destructors<br></li><li>C.con: Containers and other resource handles<br></li><li>C.lambdas: Function objects and lambdas<br></li><li>C.hier: Class hierarchies (OOP)<br></li><li>C.over: Overloading and overloaded operators<br></li><li>C.union: Unions</li></ul></div>
<div class="text">Weiter geht's mit den zwei Regeln zu Concrete Types.</div>
<div class="ztitel">Concrete Types</div>
<div class="text"><ul><li>C.10: Prefer concrete types over class hierarchies<br></li><li>C.11: Make concrete types regular</li></ul></div>
<div class="text">Zuerst möchte ich auf Concrete Types und Regular Types eingehen. </div>
<div class="text">Ein Concrete Type<b> i</b>st "the simplest kind of a class". Gerne wird er auch Value Type genannt. Er ist ein Bestandteil einer Klassenhierarchie. Natürlich kann ein Concrete Type nicht abstrakt sein.</div>
<div class="text">Ein Regular Type ist ein Datentyp, für den gilt: "behaves like an int". Daher muss er Kopieren und Zuweisen, aber auch Gleichheit und Ordnung unterstützen. Das geht auch formaler. Ein Regular Type muss die folgenden Operation anbieten.<br></div>
<div class="text"><ul><li> Copy und Zuweisung</li></ul></div>
<div class="pre">&nbsp;&nbsp;&nbsp; Regular a;<br>&nbsp;&nbsp;&nbsp; Regular a&nbsp; = b;<br>&nbsp;&nbsp;&nbsp; ~Regular(a);<br>&nbsp;&nbsp;&nbsp; a = b;<br></div>
<div class="text"><ul><li>Gleichheit</li></ul></div>
<div class="pre">&nbsp;&nbsp;&nbsp; a == b;<br>&nbsp;&nbsp;&nbsp; a != b;<br></div>
<div class="text"><ul><li>Ordnung</li></ul></div>
<div class="pre">&nbsp;&nbsp;&nbsp; a &lt; b;</div>
<div class="text">Die Built-in-Datentypen sind genauso Regular Types wie die Container der Standard Template Library.</div>
<div class="text"><b>C.10: Prefer concrete types over class hierarchies</b></div>
<div class="text">Falls man keinen Anwendungsfall für eine Klassenhierarchie hat, verwendet man einen Concrete Type. Er ist einfacher zu implementieren, kleiner und schneller. Man muss sich keine Gedanken zur Ableitung machen, Virtualität, Referenzen oder Zeiger. Diese Vereinfachung schließt Speicheranforderungen&nbsp; und -freigaben ein. Es gibt keinen virtuellen Dispatch und daher keine unnötige Indirektion zur Laufzeit.</div>
<div class="text">Man besitzt einfach nur einen Wert.<br> </div>
<div class="text"><b>C.11: Make concrete types regular</b></div>
<div class="text">Regular Types (ints) sind einfacher zu verstehen. Sie sind per se intuitiv. Das heißt, falls man einen Concrete Type verwendest, muss man darüber nachdenken, ihn zum Regular Type zu erweitern. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Im nächsten Artikel geht es um den Lebenszyklus von Objekten: erzeugen, kopieren, verschieben und löschen. </div>