<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148876471_e85c2c001a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Dieser Artikel geht auf einige Don'ts ein. Dies sind vor allem die zwei wichtigsten Regeln des Artikels: Setze std::move nicht unüberlegt ein und wende kein Slicing an. Und los geht's. <br></div>
<div class="text">Hier sind alle Regeln für heute im Schnelldurchlauf.</div>
<div class="text"><ul><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-move" class="" alt="%7B%22text%22%3A%22ES.56%3A%20Write%20std%3A%3Amove%28%29%20only%20when%20you%20need%20to%20explicitly%20move%20an%20object%20to%20another%20scope%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-move%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-move%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-move">ES.56: Write std::move() only when you need to explicitly move an object to another scope</a> </li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.60%3A%20Avoid%20new%20and%20delete%20outside%20resource%20management%20functions%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-new%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-new%22%2C%22ir_link%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new">ES.60: Avoid new and delete outside resource management functions</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-del" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.61%3A%20Delete%20arrays%20using%20delete%5B%5D%20and%20non-arrays%20using%20delete%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-del%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-del%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-del">ES.61: Delete arrays using delete[] and non-arrays using delete</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-slice" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-slice" alt="%7B%22text%22%3A%22ES.63%3A%20Don%C2%92t%20slice%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-slice%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-slice%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" class="">ES.63: Don’t slice</a></li></ul></div>
<div class="text">Die erste Regel ist ein verkleidetes Don't. </div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-move" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-move" class="" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-move%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-move%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.56%3A%20Write%20std%3A%3Amove%28%29%20only%20when%20you%20need%20to%20explicitly%20move%20an%20object%20to%20another%20scope%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D">ES.56: Write std::move() only when you need to explicitly move an object to another scope</a></b></div>
<div class="text">Meist ist es nicht notwendig, explizit <i>std::move</i> aufzurufen. Der Compiler wendet automatisch Move-Semantik an, wenn der Ursprung einer Operation ein Rvalue ist. Ein Rvalue ist ein Objekt ohne Identität. Typischerweise besitzt es keinen Namen, und seine Adresse lässt sich nicht bestimmen. Die verbleibenden Werte sind Lvalues. </div>
<div class="text">Wird eine <i>std::move-</i>Operation auf einen Lvalue angewandt, ist das Ergebnis meist ein leeres Objekt. Der Lvalue ist danach in dem sogenannten moved-from-Zustand. Das heißt, dass dieser gültig, aber in einem nicht genauer spezifizierten Zustand ist. Klingt seltsam? Genau! Daher gilt es nur eine Regel zu beachten: Nachdem du auf einen Lvalue wie in <i>std::move(source)</i> Move-Semantik angewandt hast, sind keine Annahmen über den Zustand des Objekts <i>source</i> mehr zulässig. Sein Wert muss neu gesetzt werden. </div>
<div class="text">Stopp. Ich war zu schnell. Die Regel ES.56 lautet "you should only use std::move if you want to move an object to another scope". Ein klassischer Anwendungsfall für die Move-Semantik sind Objekte, die nicht kopiert, aber verschoben werden können. Zum Beispiel will ich in dem folgenden Beispiel einen <i>std::promise</i> in einen anderen Thread verschieben. <br></div>
<div class="pre">// moveExplicit.cpp<br><br>#include &lt;future&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;utility&gt;<br><br>void product(std::promise&lt;int&gt;&amp;&amp; intPromise, int a, int b){&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; intPromise.set_value(a * b);<br>}<br><br>int main(){<br><br>&nbsp; int a= 20;<br>&nbsp; int b= 10;<br><br>&nbsp; // define the promises<br>&nbsp; std::promise&lt;int&gt; prodPromise;<br><br>&nbsp; // get the futures<br>&nbsp; std::future&lt;int&gt; prodResult= prodPromise.get_future();<br><br>&nbsp; // calculate the result in a separat thread<br>&nbsp; std::thread prodThread(product,std::move(prodPromise), a, b);&nbsp;&nbsp; // (2)<br>&nbsp;<br>&nbsp; // get the result<br>&nbsp; std::cout &lt;&lt; "20 * 10 = " &lt;&lt; prodResult.get() &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; // 200<br>&nbsp; <br>&nbsp; prodThread.join();<br><br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // undefined behaviour<br></div>
<div class="text">Die Funktion<i> product</i> (1) erhält ihren <i>std::promise</i> per Rvalue-Referenz. Ein Promise kann nicht kopiert, aber verschoben werden. Daher ist in diesem Fall <i>std::move</i> notwendig&nbsp; um den Promise in den neu erzeugten Kinder-Thread zu verschieben. </div>
<div class="text">Jetzt kommt aber endlichen das dicke Don't: Wende keine <i>std::move</i> in <i>return</i>-Anweisungen an<b>:&nbsp;</b> <br></div>
<div class="pre">vector&lt;int&gt; make_vector() {<br>&nbsp;&nbsp;&nbsp; vector&lt;int&gt; result;<br>&nbsp;&nbsp;&nbsp; // ... load result with data<br>&nbsp;&nbsp;&nbsp; return std::move(result);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad; just write "return result;"<br>}<br></div>
<div class="text">Vertraue deinem Optimierer! Falls das Objekt per Kopie zurückgegeben wird, wird der Optimierer seinen Job tun. Dies war eine Best Practice bis C++14. Das ist verbindlich mit C++17 und wird <i>guaranteed copy elision</i> genannt. Auch wenn diese Technik den Name "copy" enthält, optimiert der Compiler mit C++11 auch Verschiebeoperationen weg. <br></div>
<div class="text"><a alt="%7B%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReturn_value_optimization%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReturn_value_optimization%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22RVO%22%7D" class="" title="Link auf https://en.wikipedia.org/wiki/Return_value_optimization" href="https://en.wikipedia.org/wiki/Return_value_optimization">RVO</a> steht für&nbsp;Return&nbsp;Value&nbsp;Optimisation und bedeutet, dass der Compiler unnötige Copy-Operation entfernen kann. Was bisher ein Optimierungsschritt war, muss der Compiler in C++17 zusichern:&nbsp; <br></div>
<div class="pre">MyType func(){<br>&nbsp; return MyType{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) no copy with C++17<br>}<br>MyType myType = func();&nbsp;&nbsp;&nbsp; // (2) no copy with C++17<br></div>
<div class="text">Zwei unnötige Copy-Operationen können in den paar Zeilen stattfinden. Der erste in Ausdruck (1) und die zweite in Ausdruck (2). Mit C++17 ist das nicht mehr zulässig.</div>
<div class="text">Falls der Rückgabewert einen Namen besitzt, heißt diese Technik NRVO. Das Akronym steht für&nbsp;Named&nbsp;Return&nbsp;Value&nbsp;Optimization.<br></div>
<div class="pre">MyType func(){<br>&nbsp; MyType myVal;<br>&nbsp; return myVal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) one copy allowed <br>}<br>MyType myType = func();&nbsp;&nbsp;&nbsp; // (2) no copy with C++17</div>
<div class="text">Der feine Unterschied ist, das der Compiler mit C++17 den Wert&nbsp;<i>myValue</i> (1) kopieren darf. Hingegen findet in Ausdruck (2) definitiv kein Kopieren statt. </div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22ES.60%3A%20Avoid%20new%20and%20delete%20outside%20resource%20management%20functions%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-new%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-new%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new">ES.60: Avoid new and delete outside resource management functions</a></b></div>
<div class="text">Jetzt kann ich mich kurz halten: Wende kein <i>new</i> und <i>delete </i>in Applikationscode an. Für die Regel gibt es eine einfache Erinnerungshilfe:"<i>No naked new!</i>"<br> </div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-del" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-del" alt="%7B%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.61%3A%20Delete%20arrays%20using%20delete%5B%5D%20and%20non-arrays%20using%20delete%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-del%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-del%22%7D" class="">ES.61: Delete arrays using delete[] and non-arrays using delete</a></b></div>
<div class="text">Hier ist die Begründung für die letzte Regel. Ressourcenmanagement im Applikationscode ist fehleranfällig:</div>
<div class="pre">void f(int n)<br>{<br>&nbsp;&nbsp;&nbsp; auto p = new X[n];&nbsp;&nbsp; // n default constructed Xs<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; delete p;&nbsp;&nbsp; // error: just delete the object p, rather than delete the array p[]<br>}</div>
<div class="text">Die Guidelines schreiben im Kommentar: "just delete the object p". Das möchte ich gerne noch dramatischer formulieren. Der Code besitzt undefiniertes Verhalten. <br> </div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-slice" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-slice%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-slice%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.63%3A%20Don%27t%20slice%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-slice">ES.63: Don't slice</a></b></div>
<div class="text">Zuerst einmal. Was ist Slicing? Slicing bedeutet: Du kopierst ein Objekt während einer Zuweisung oder Initialisierung und bekommst nur ein Teil des Objekts zurück. Los geht's mit einem einfachen Beispiel:</div>
<div class="pre">// slice.cpp<br><br>struct Base { <br>&nbsp; int base{1998};<br>}<br>&nbsp;<br>struct Derived : Base { <br>&nbsp; int derived{2011};<br>}<br><br>void needB(Base b){<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br>&nbsp;<br>int main(){<br><br>&nbsp; Derived d;<br>&nbsp; Base b = d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; Base b2(d);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; needB(d);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>}<br></div>
<div class="text">Die Zeilen (1), (2) und (3) besitzen alle den gleichen Effekt: Der <i>Derived</i>-Anteil von <i>d</i> wird entfernt. Ich nehme an, dass war nicht im Sinne des Autors. </div>
<div class="text">Ich erwähnte es bereits in der Ankündigung zu diesem Artikel, dass Splicing einer der dunkelsten Ecken von C++ ist. Jetzt wird es dunkel: <br></div>
<div class="pre">// sliceVirtuality.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>struct Base { <br>&nbsp;&nbsp;&nbsp; virtual std::string getName() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "Base";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>};<br>&nbsp;<br>struct Derived : Base { <br>&nbsp;&nbsp;&nbsp; std::string getName() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "Derived";<br>&nbsp;&nbsp;&nbsp; }<br>};<br>&nbsp;<br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Base b;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "b.getName(): " &lt;&lt; b.getName() &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Derived d;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "d.getName(): " &lt;&lt; d.getName() &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Base b1 = d;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "b1.getName():&nbsp; " &lt;&lt; b1.getName() &lt;&lt; std::endl;&nbsp; // (5)<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Base&amp; b2 = d;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "b2.getName():&nbsp; " &lt;&lt; b2.getName() &lt;&lt; std::endl;&nbsp; // (6)<br><br>&nbsp;&nbsp;&nbsp; Base* b3 = new Derived;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "b3-&gt;getName(): " &lt;&lt; b3-&gt;getName() &lt;&lt; std::endl; // (7)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">In dem Beispiel erzeuge ich eine kleine Klassenhierarchie, bestehend aus einer Base- und einer Derived-Klasse. Jedes Objekt der Klassenhierarchie soll seinen Namen zurückgeben. Dazu ist notwendig, die Methode <i>getName</i> (2) virtuell zu deklarieren und im Ausdruck (2) zu überschreiben. Jetzt unterstützt meine Klassenhierarchie Polymorphie. Das heißt, ich kann ein abgeleitetes Objekt mittels Referenz (6) oder Zeiger auf ein Objekt der Basisklasse annehmen. Unter der Decke ist das Objekt vom Typ Derived.</div>
<div class="text">Dies gilt aber nicht, wenn ich nur Derived [i]D[/i] nach Base [i]b1[/i] kopiere (5). In diesem Fall schlägt Slicing zu, und ich erhalte eine Base-Objekt unter der Decke. Im Falle des Kopierens wird der deklarierte oder statische Typ verwendet. Falls jedoch eine Indirektion wie eine Referenz oder ein Zeiger zum Einsatz kommt, wird der tatsächliche oder dynamische Typ verwendet. Oft spricht die C++-Community schlicht von der frühen versus der späten Bindung.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148876475_1dcff0481a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Es ist relativ einfach, die Regel im Kopf zu behalten: Falls sich Instanzen einer Klasse polymporph verhalten sollen, muss die Klasse zumindest eine virtuelle Methode deklarieren oder erben. Darüber hinaus müssen Instanzen dieser Klasse mit einer Indirektion wie einer Referenz oder einem Zeiger verwendet werden.</div>
<div class="text">Natürlich gibt es auch ein Heilmittel gegen Slicing: Implementiere eine virtuelle <i>clone</i>-Funktion. Hier gibt es die Details dazu: <a href="/exec/mainmenu.pl?sid=f4655a8f40db147ddad1dda28267def2&amp;rm=open_article_id&amp;bid=2280367" class="" alt="%7B%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A2280367%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Df4655a8f40db147ddad1dda28267def2%26rm%3Dopen_article_id%26bid%3D2280367%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regeln%20f%C3%BCr%20das%20Kopieren%20und%20Verschieben.%22%7D" title="Link auf Beitrag 2280367">C++ Core Guidelines: Regeln für das Kopieren und Verschieben.</a></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In diesem Artikel ging es nur um Son'ts. Der nächste Artikel wird mit Do's beginnen. Verwende geschweifte Klammern für die Initialisierung von Daten. </div>
<div class="ztitel">C++11- und C++14-Schulung bei Stuttgart</div>
<div class="text">Ich freue mich darauf, Ihnen von 13. bis 15. März <a title="Link auf http://www.modernescpp.de/index.php/c" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22modernes%20C%2B%2B%20in%20Theorie%20und%20Praxis%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22custom%22%3A%7B%7D%7D" class="" href="http://www.modernescpp.de/index.php/c">modernes C++ in Theorie und Praxis</a> genau vorstellen zu dürfen. Die Schulung findet definitiv statt und es sind noch wenige Plätze frei.</div>
