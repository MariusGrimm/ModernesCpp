<div class="vorspann">Diese Serie zur Programmierung zur Compilezeit begann mit der Template-Metaprogrammierung, gefolgt von der Type-Traits-Bibliothek und endet heute mit konstanten Ausdrücken (constexpr).</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602254_04cc3574e2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt sind wir endlich an der Spitze des Dreiecks angekommen. Dies ist aber mehr als nur ein Bild.</div>
<div class="ztitel">constexpr</div>
<div class="text"><i>constexpr</i> erlaubt es explizit zur Compilezeit zu programmieren und dies in der vertrauten C++-Syntax. Der Fokus dieses Artikels liegt nicht darin, alle Details zu <i>constexpr</i> vorzustellen, sondern vielmehr darin, Template-Metaprogrammierung mit <i>constexpr</i>-Funktionen zu vergleichen. Des Vergleich willens, möchte ich aber erst einen kurzen Überblick zu <i>constexpr</i> geben. Falls dieser Vergleich zu mager ist, bieten meine früheren Artikel zu <a alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconstexpr%22%2C%22text%22%3A%22constexpr%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconstexpr%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/constexpr" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/constexpr" class="">constexpr</a> ausreichend Nahrung. Welche Vorteile besitzen konstante Ausdrücke?</div>
<div class="ztitel_kleiner">Vorteile</div>
<div class="text">Ein konstanter Ausdruck</div>
<div class="text"><ul><li> kann zur Compilezeit ausgewertet werden.</li><li>erlaubt dem Compiler tiefen Einblick in den Code.</li><li>ist implizit thread-sicher.</li><li>kann im read-only Speicher (ROM-able) erzeugt werden.</li></ul></div>
<div class="text">Konstante Ausdrücke mit <i>constexpr</i> können drei Formen besitzen.<br></div>
<div class="ztitel_kleiner">Drei Formen</div>
<div class="text"><b>Variablen</b></div>
<div class="text"><ul><li>sind implizit konstant.</li><li>müssen durch einen konstanten Ausdruck initialisiert werden: <i>constexpr double pi = 3.14;</i></li></ul></div>
<div class="text"><b>Funktionen</b></div>
<div class="text"><i>constexpr</i> Funktionen in C++14 sind sehr einfach einzusetzen. Sie sind implizit <i>inline</i> und können<br></div>
<div class="text"><ul><li> andere <i>constexpr</i>-Funktionen aufrufen.</li><li>Variablen besitzen, die durch einen konstanten Ausdruck initialisiert werden müssen.</li><li>bedingte Anweisungen oder Schleifen besitzen.</li><li>keine <i>static- </i>oder <i>thread_local</i>-Daten besitzen.</li></ul></div>
<div class="text"><b>Benutzerdefinierte Typen</b></div>
<div class="text"><ul><li>müssen einen Konstruktor besitzen, der selbst ein konstanter Ausdruck ist.</li><li>können keine virtuelle Methoden besitzen.</li><li>können keine virtuellen Basisklassen besitzen.</li></ul></div>
<div class="text">Die Regeln für <i>constexpr-</i>Funktionen und -Methoden sind ziemlich ähnlich. Daher spreche ich nun nur noch von Funktionen. </div>
<div class="text"><i>constexpr</i>-Funktionen dürfen nur von Funktionalität abhängen, die einen konstanten Ausdruck darstellt. Eine <i>constexpr-</i>Funktion bedeutet nicht, dass eine Funktion zur Compilezeit ausgeführt wird. Es bedeutet, dass eine Funktion das Potenzial besitzt, zur Compilezeit ausgeführt zu werden. Eine <i>constexpr</i>-Funktion kann auch zur Laufzeit ausgeführt werden. Es ist oft eine Frage des Compilers oder der Optimierung, ob eine Funktion zur Compile- oder Laufzeit ausgeführt wird. Es gibt aber zwei Gründe, warum <i>constexpr-</i>Funktionen zur Compilezeit ausgeführt werden müssen. <br></div>
<div class="text"><ol><li>Die <i>constexpr-</i>Funktion wird in einem Kontext eingesetzt, der zur Compilezeit ausgewertet wird. Dies kann ein<i> static_assert-</i>Ausdruck oder die Initialisierung eines C-Arrays sein.</li><li>Der Wert eine constexpr-Funktion wird explizit zur Compilezeit angefordert: <i>constexpr auto res = func(5);</i></li></ol></div>
<div class="text">Hier kommt ein kleines Beispiel zu der Theorie. Das Programm <i>constexpr14.cpp</i> berechnet den größten gemeinsamen Teiler zweier Zahlen.</div>
<div class="pre">// constexpr14.cpp<br><br>#include &lt;iostream&gt;<br><br>constexpr auto gcd(int a, int b){<br>&nbsp; while (b != 0){<br>&nbsp;&nbsp;&nbsp; auto t= b;<br>&nbsp;&nbsp;&nbsp; b= a % b;<br>&nbsp;&nbsp;&nbsp; a= t;<br>&nbsp; }<br>&nbsp; return a;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp;std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; constexpr int i= gcd(11,121);&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp; int a= 11;<br>&nbsp; int b= 121;<br>&nbsp; int j= gcd(a,b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; std::cout &lt;&lt; "gcd(11,121): " &lt;&lt; i &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "gcd(a,b): " &lt;&lt; j &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>}</div>
<div class="text">Die Zeile (1) berechnet das Ergebnis <i>i</i> zur Compilezeit und die Zeile (2) zur Laufzeit. Der Compiler würde sich eindeutig beschweren, wenn ich <i>j</i> als constexpr erklären würde: <i>constexpr int j = gcd(a, b)</i>. Der Grund ist, dass weder<i> a</i> noch <i>b</i> konstante Ausdrücke sind. </div>
<div class="text">Die Ausgabe des Programms sollte keine Überraschung bergen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602262_c9d654ea8e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Vielleicht geht ja die Überraschung jetzt los. Lass mich die Magie mit dem <a alt="%7B%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22text%22%3A%22Compiler%20Explorer%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%7D" href="https://godbolt.org/" title="Link auf https://godbolt.org/" class="">Compiler Explorer</a> vorstellen: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602268_7f9adab957.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Die Zeile (1) des Programms constexpr14.cpp reduziert sich auf die Konstante 11 in dem folgenden Ausdruck: <i>mov DWORD PTR[rbp-4], 11</i> (Zeile 33 im Screenshot). Im Gegensatz dazu, wird die Zeile (2) zu einem Funktionsaufruf: <i>call gcd(int, int)</i> (Zeile 41 in dem Screenshot).</div>
<div class="text">Jetz kann ich endlich mein Hauptanliegen vorstellen.</div>
<div class="ztitel">Template-Metaprogrammierung versus constexpr-Funktionen</div>
<div class="text">Zuerst einmal das große Bild:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602274_6039c8eae2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Tabelle verlangt ein paar Erläuterungen.</div>
<div class="text"><ul><li>Ein Template-Metaprogramm wird zur Compilezeit ausgeführt, aber eine <i>constexpr</i>-Funktion (siehe <i>constexpr14.cpp</i>) kann sowohl zur Compile- als auch zur Laufzeit ausgeführt werden.</li><li>Argumente eines Templates (Template-Metaprogrammierung) können Typen und Werte sein. Um genauer zu sein, ein Template kann Datentypen (<i>std::vector&lt;int&gt;</i>), Werte (<i>std:.array&lt;int, 5&gt;</i>) und selbst Templates (<i>std::stack&lt;int, std::vector&lt;int&gt;&gt;</i>) annehmen. <i>constexpr</i>-Funktionen sind vor allem Funktionen, die das Potenzial besitzen, zur Compilezeit ausgeführt zu werden. Daher nehmen sie nur Werte an.</li><li>Es gibt keinen Zustand zur Compilezeit und damit auch keine Veränderung. Das heißt, Template-Metaprogrammierung ist reine funktionale Programmierung. Was? Falls du wissen willst, für was reine funktionale Programmierung steht, gibt der <a href="https://www.grimm-jaud.de/index.php/blog/funktionale-programmierung-die-definition" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/funktionale-programmierung-die-definition" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffunktionale-programmierung-die-definition%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffunktionale-programmierung-die-definition%22%2C%22text%22%3A%22Funktionale%20Programmierung%3A%20Die%20Definition%22%2C%22version%22%3A1%7D">Funktionale Programmierung: Die Definition</a> die erste und die Artikel <a alt="%7B%22version%22%3A1%2C%22text%22%3A%22Funktional%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Ffunktional%3Fstart%3D0%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Ffunktional%3Fstart%3D0%22%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/category/funktional?start=0" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/funktional?start=0">Funktional</a> die genaue Antwort. Hier sind wichtigen Punkte:</li><ul><li>Statt einen Wert zu verändern, wird immer ein neuer Wert in der Template-Metaprogrammierung zurückgegeben.</li><li>Das Inkrementieren eines Wertes <i>i </i>in einer <i>for</i>-Schleife ist zur Compilezeit nicht möglich: <i>for (int i; i &lt;= 10; ++i)</i>. Daher ersetzt die Template-Metaprogrammierung Schleifen mit Rekursionen.</li><li>Dank Template-Spezialisierung ist eine bedingte Ausführung möglich.<br></li></ul></ul></div>
<div>Zugegeben, dieser Vergleich ist sehr kurz und knapp. Eine bildliche Gegenüberstellung von <a href="https://heise.de/-4271375" title="Link auf https://heise.de/-4271375" class="" alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4271375%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4271375%22%2C%22text%22%3A%22Metafunktionen%22%2C%22version%22%3A1%7D">Metafunktionen</a> und constexpr-Funktionen wird die offenen Fragen beantworten. Beide Funktionen berechnen die Fakultät einer Zahl.</div>
<div>Die Funktionsargumente der <i>constexpr</i>-Funktion entsprechen den Template-Argumenten der Metafunktion.</div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602277_05cf606c36.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div>Eine <i>constexpr</i>-Funktion kann Variablen besitzen und sie verändern. Eine Metafunktion erzeugt immer einen neuen Wert.<br></div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602283_05284f4ac8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div>Eine Metafunktion stellt Rekursion durch Schleifen dar.<br></div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602293_23656fa1d9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div>Anstelle einer Endbedingung, verwendet eine Metafunktion eine vollständige Spezialisierung zur Beendigung einer Rekursion. Zusätzlich erlaubt teilweise oder vollständige Spezialisierung eines Templates bedingt Codeausführung entsprechend einer <i>if</i>-Anweisung.</div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602295_7ec106229d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div>Anstelle eines veränderten Wertes <i>res,</i> erzeugt eine Metafunktion immer einen neuen Wert.<br></div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602306_c4eb00603c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div>Eine Metafunktion besitzt keine <i>return</i>-Anweisung. Stattdessen verwendet sie <i>value</i> als Rückgabewert.<br></div>
<div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166602307_988b945e40.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Vorteile von constexpr-Funktionen<br></div>
<div>Neben den Vorteilen, dass <i>constexpr</i>-Funktionen komfortabler zu schreiben und zu pflegen sind und zur Laufzeit ausgeführt werden können, besitzen sie noch einen weiteren Vorteil. Der Codeschnipsel stellt ihn vor:<br></div>
<div class="pre">constexpr double average(double fir , double sec){<br>&nbsp;&nbsp;&nbsp; return (fir + sec) / 2;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; constexpr double res = average(2, 3);<br>} <br></div>
<div><i>constexpr</i>-Funktionen können mit Fließkommazahlen umgehen. Template-Metaprogrammierung verlangt Ganzzahlen.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div>Dieser Artikel beendet meinen Umweg zur Programmierung zur Compilezeit. Das nächste Mal schreibe ich über die verbleibenden Regeln zu Templates.<br></div>