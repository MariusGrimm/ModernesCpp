<div class="vorspann">Die Reise durch die Programmierung zur Compilezeit geht weiter, und zwar mit einem Sprung von C++98 nach C++11 hin zur Type-Traits-Bibliothek, die Template-Metaprogrammierung in einer standardisierten Form verkörpert.</div>
<div class="text">Die Type-Traits-Bibliothek gehört seit C++11 zu C++. Ihre Ursprünge liegen in Boost. Sie erlaubt es, zur Compilezeit Typeigenschaften abzufragen, Typen zu vergleichen und zu modifizieren. Die Bibliothek besitzt mehr als 100 Funktionen, und jeder weitere Standard fügt neue hinzu.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165817178_3f897246e6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich möchte weder in die Tiefe der Type-Traits-Bibliothek abtauchen, da ich bereits einige Artikel über sie geschrieben habe, noch werde ich sie auslassen. Als Kompromiss schreibe ich eine kurze Einführung zur Type-Traits-Bibliothek. Für weiterführende Informationen füge ich Links zu meinen bestehenden Artikel hinzu.</div>
<div class="text">Zuerst einmal, was ist in der Type-Traits-Bibliothek drin? </div>
<div class="ztitel">Die Type-Traits-Bibliothek</div>
<div class="text">Die Bibliothek erlaubt, Typeigenschaften abzufragen, Typen zu vergleichen und zu modifizieren. Los geht der Artikel mit dem Abfragen von Typeigenschaften:</div>
<div class="ztitel_kleiner">Typeigenschaften abfragen</div>
<div class="text">Jeder Datentyp gehört genau zu einer der vierzehn primären Typkategorien.</div>
<div class="text"><b>Primäre Typkategorien</b></div>
<div class="text">Dies sind die vierzehn primäre Typkategorien: </div>
<div class="pre">template &lt;class T&gt; struct is_void;<br>template &lt;class T&gt; struct is_integral;<br>template &lt;class T&gt; struct is_floating_point;<br>template &lt;class T&gt; struct is_array;<br>template &lt;class T&gt; struct is_pointer;<br>template &lt;class T&gt; struct is_reference;<br>template &lt;class T&gt; struct is_member_object_pointer;<br>template &lt;class T&gt; struct is_member_function_pointer;<br>template &lt;class T&gt; struct is_enum;<br>template &lt;class T&gt; struct is_union;<br>template &lt;class T&gt; struct is_class;<br>template &lt;class T&gt; struct is_function;<br>template &lt;class T&gt; struct is_lvalue_reference;<br>template &lt;class T&gt; struct is_rvalue_reference;</div>
<div class="text">Das folgende Programm besitzt zu jeder primären Typkategorie einen passenden Datentyp:</div>
<div class="pre">//&nbsp; primaryTypeCategories.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>struct A{<br>&nbsp; int a;<br>&nbsp; int f(int){return 2011;}<br>};<br><br>enum E{<br>&nbsp; e= 1,<br>};<br><br>union U{<br>&nbsp; int u;<br>};<br><br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt;&nbsp; std::boolalpha &lt;&lt;&nbsp; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::is_void&lt;void&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_integral&lt;short&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_floating_point&lt;double&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_array&lt;int [] &gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_pointer&lt;int*&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_reference&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_member_object_pointer&lt;int A::*&gt;::value &lt;&lt;&nbsp; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_member_function_pointer&lt;int (A::*)(int)&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_enum&lt;E&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_union&lt;U&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_class&lt;std::string&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_function&lt;int * (double)&gt;::value &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::is_lvalue_reference&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::is_rvalue_reference&lt;int&amp;&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt;&nbsp; std::endl;<br><br>}</div>
<div class="text">Hier ist die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165817185_c49bbe62fc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Falls du wissen willst, wie diese Magie passiert: Mein Artikel "<a alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftypeigenschaften-abfragen%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftypeigenschaften-abfragen%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Typeigenschaften%20abfragen%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/typeigenschaften-abfragen" class="" href="https://www.grimm-jaud.de/index.php/blog/typeigenschaften-abfragen">Typeigenschaften abfragen</a>" klärt auf. </div>
<div class="text">Auf den primären Typkategorien basieren die zusammengesetzten Typkategorien.</div>
<div class="text"><b>Zusammengesetzte Typkategorien</b></div>
<div class="text">Die Tabelle zeigt die Beziehungen zwischen den primären und den zusammengesetzten Typkategorien:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165817192_bbb7155d38.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Type-Traits-Bibliothek erlaubt es, noch weitere Typeigenschaften abzufragen:</div>
<div class="pre">template &lt;class T&gt; struct is_const;<br>template &lt;class T&gt; struct is_volatile;<br>template &lt;class T&gt; struct is_trivial;<br>template &lt;class T&gt; struct is_trivially_copyable;<br>template &lt;class T&gt; struct is_standard_layout;<br>template &lt;class T&gt; struct is_pod;<br>template &lt;class T&gt; struct is_literal_type;<br>template &lt;class T&gt; struct is_empty;<br>template &lt;class T&gt; struct is_polymorphic;<br>template &lt;class T&gt; struct is_abstract;<br>template &lt;class T&gt; struct is_signed;<br>template &lt;class T&gt; struct is_unsigned;<br>template &lt;class T, class... Args&gt; struct is_constructible;<br>template &lt;class T&gt; struct is_default_constructible;<br>template &lt;class T&gt; struct is_copy_constructible;<br>template &lt;class T&gt; struct is_move_constructible;<br>template &lt;class T, class U&gt; struct is_assignable;<br>template &lt;class T&gt; struct is_copy_assignable;<br>template &lt;class T&gt; struct is_move_assignable;<br>template &lt;class T&gt; struct is_destructible;<br>template &lt;class T, class... Args&gt; struct is_trivially_constructible;<br>template &lt;class T&gt; struct is_trivially_default_constructible;<br>template &lt;class T&gt; struct is_trivially_copy_constructible;<br>template &lt;class T&gt; struct is_trivially_move_constructible;<br>template &lt;class T, class U&gt; struct is_trivially_assignable;<br>template &lt;class T&gt; struct is_trivially_copy_assignable;<br>template &lt;class T&gt; struct is_trivially_move_assignable;<br>template &lt;class T&gt; struct is_trivially_destructible;<br>template &lt;class T, class... Args&gt; struct is_nothrow_constructible;<br>template &lt;class T&gt; struct is_nothrow_default_constructible;<br>template &lt;class T&gt; struct is_nothrow_copy_constructible;<br>template &lt;class T&gt; struct is_nothrow_move_constructible;<br>template &lt;class T, class U&gt; struct is_nothrow_assignable;<br>template &lt;class T&gt; struct is_nothrow_copy_assignable;<br>template &lt;class T&gt; struct is_nothrow_move_assignable;<br>template &lt;class T&gt; struct is_nothrow_destructible;<br>template &lt;class T&gt; struct has_virtual_destructor;</div>
<div class="text">Viele der Funktionen wie <i>is_trivially_copyable</i> besitzen die Namenskomponente <i>trivially.</i> Das bedeutet, dass diese Funktionen nicht vom Entwickler implementiert wurden. Wird eine Methode vom Compiler mit <i>default</i> angefordert, gilt diese als trivial.</div>
<div class="text"><b>Typvergleiche</b></div>
<div class="text">Die Type-Traits-Bibliothek bietet drei verschieden Vergleiche an:</div>
<div class="pre">&nbsp;&nbsp;&nbsp; is_base_of&lt;Base, Derived&gt;<br>&nbsp;&nbsp;&nbsp; is_convertible&lt;From, To&gt;<br>&nbsp;&nbsp;&nbsp; is_same&lt;T, U&gt;</div>
<div class="text">Das folgende Programm verwendet alle drei Funktionen:</div>
<div class="pre">// compare.cpp<br><br>#include &lt;cstdint&gt;<br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>class Base{};<br>class Derived: public Base{};<br><br>int main(){<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; "std::is_base_of&lt;Base, Derived&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_base_of&lt;Base, Derived&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "std::is_base_of&lt;Derived, Base&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_base_of&lt;Derived, Base&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "std::is_base_of&lt;Derived, Derived&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt;&nbsp; std::is_base_of&lt;Derived, Derived&gt;::value &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; "std::is_convertible&lt;Base*, Derived*&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_convertible&lt;Base*, Derived*&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "std::is_convertible&lt;Derived*, Base*&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_convertible&lt;Derived*, Base*&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "std::is_convertible&lt;Derived*,Derived*&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_convertible&lt;Derived*, Derived*&gt;::value &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, int32_t&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, int32_t&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "std::is_same&lt;int, int64_t&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;int, int64_t&gt;::value &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "std::is_same&lt;long int, int64_t&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_same&lt;long int, int64_t&gt;::value &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>}<br></div>
<div class="text">und besitzt die erwartete Ausgabe.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_165817207_fc5e618f2d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;">&nbsp;<br></div>
<div class="ztitel">Programmierung zur Compilezeit</div>
<div class="text">Nun möchte ich ein paar Schritte zurücktreten und über die Funktionen der Type-Traits-Bibliothek nachdenken. Hier sind meine Beobachtungen. </div>
<div class="text"><ul><li> Die Funktionen der Type-Traits-Bibliothek sind Metafunktion, denn sie werden zur Compilezeit ausgeführt. In diesem Fall sind sie Klassen-Templates.</li><li>Die Argumente der Metafunktionen in den eckigen Klammern (<i>&lt;...&gt;</i>) sind Metadaten. Genau genommen sind es in unseren Beispielen Datentypen.</li><li>Der Rückgabewert der Funktion ist <i>::value</i>. Dies ist nur ein Alias. Seit C++17 gibt es eine einfache Form das Ergebnis zu erhalten: Anstelle von <i>std::in_void&lt;void&gt;::value </i>lässt sich einfach&nbsp; <i>std::is_void_v&lt;void&gt;</i> schreiben.</li></ul></div>
<div class="text">Ich denke, meine drei Beobachtungen erinnern dich an meinen letzten Artikel. Dies sind genau die Konventionen, dich ich in meinen letzten Artikel zur Template Metaprogrammierung vorgestellt habe: "<a alt="%7B%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Programmierung%20zur%20Compilezeit%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A2576432%2C%22type%22%3A%22B%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D28e5d3103da03d3be77296c0f7074579%26rm%3Dopen_article_id%26bid%3D2576432%22%2C%22anchor%22%3A%22%22%7D" title="Link auf Beitrag 2576432" class="" href="/exec/mainmenu.pl?sid=28e5d3103da03d3be77296c0f7074579&amp;rm=open_article_id&amp;bid=2576432">C++ Core Guidelines: Programmierung zur Compilezeit</a>". </div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Falls die Funktionen der Type-Traits-Bibliothek einen Datentyp und nicht einen Wert zurückgeben sollen, dann muss <i>::type</i> aufgerufen werden. Mein nächster Artikel zeigt, welche Typmodifikationen zur Compilezeit die Type-Traits-Bibliothek unterstützt. Letztlich verfolgt die Type-Traits-Bibliothek zwei große Ziele: Korrektheit und Optimierung. </div>
