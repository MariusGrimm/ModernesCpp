<div class="vorspann">Heute schließe ich die Regeln der C++ Core Guidelines zu Templates mit einer großen Überraschung für viele C++-Entwickler ab. Ich schreibe über die Spezialisierung von Funktions-Templates.</div>
<div class="text">Erst mal beginnt dieser Artikel sehr einfach mit einer Einführung in Template-Spezialisierung aus der Vogel-Perspektive.</div>
<div class="ztitel">Template-Spezialisierung</div>
<div class="text">Templates definieren das Verhalten von Familien von Klassen oder Funktionen. Oft ist es notwendig, dass spezielle Typen oder Nichttypen besonders behandelt werden. Um diese Anwendungsfälle umzusetzen, bietet sich die vollständige Spezialisierung von Templates an. Klassen-Templates können auch teilweise spezialisiert werden.</div>
<div class="text">Hier ist ein erster, einfacher Codeschnipsel:</div>
<div class="pre">template &lt;typename T, int Line, int Column&gt;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>class Matrix;<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>class Matrix&lt;T, 3, 3&gt;{};<br><br>template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>class Matrix&lt;int, 3, 3&gt;{};</div>
<div class="text">Zeile 1 ist das primäre oder allgemeine Template. Dies muss vor den teilweisen und vollständigen Spezialisierungen zumindest deklariert werden. Mit der Zeile 2 folgt die teilweise Spezialisierung und mit der Zeile 3 die vollständige Spezialisierung. </div>
<div class="text">Um die teilweise und vollständige Spezialisierung besser zu verstehen, möchte ich eine visuelle Erklärung vorstellen. Stelle dir einen n-dimensionalen Raum von Template-Parametern vor. Im Fall des primären Templates (Zeile 1) kannst du einen beliebigen Datentyp und zwei beliebige <i>int</i>s einsetzen. Im Fall der teilweisen Spezialisierung in der Zeile 2 kannst du nur noch einen Datentypen auswählen. Das heißt, der dreidimensionale Raum wird auf eine Gerade reduziert. Vollständige Spezialisierung bedeutet, dass der dreidimensionale Raum auf einen Punkt reduziert wird. </div>
<div class="text">Was passiert nun, wenn die Templates aufgerufen werden?</div>
<div class="pre">Matrix&lt;int, 3, 3&gt; m1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // class Matrix&lt;int, 3, 3&gt;<br><br>Matrix&lt;double, 3, 3&gt; m2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // class Matrix&lt;T, 3, 3&gt; <br><br>Matrix&lt;std::string, 4, 3&gt; m3;&nbsp; // class Matrix&lt;T, Line, Column&gt; =&gt; ERROR</div>
<div class="text"><i>m1</i> verwendet die vollständige Spezialisierung, <i>m2</i> die teilweise Spezialisierung und <i>m3</i> das primäre Template. Das primäre Template führt zu einem Fehler, da dieses nicht definiert ist. <br></div>
<div class="text">Hier sind die Regeln, die der Compiler anwendet, um die passende Spezialisierung auszuwählen.</div>
<div class="text"><ol><li> Der Compiler findet nur eine Spezialisierung. In diesem Fall wendet er sie an.</li><li>Der Compiler findet mehr als eine Spezialisierung. Der Compiler verwendet die am meisten spezialisierte Variante. Falls dieser Prozess in mehr als einer Spezialisierung endet, führt das zu einem Compilerfehler.</li><li>Der Compiler findet keine Spezialisierung und verwendet daher das primäre Template.</li></ol></div>
<div class="text">Okay, jetzt muss ich erklären, was es heißt, dass A ein mehr spezialisiertes Templates als B ist. Hier ist die Definition von <a href="https://en.cppreference.com/w/cpp/language/partial_specialization" title="Link auf https://en.cppreference.com/w/cpp/language/partial_specialization" class="" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fpartial_specialization%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22cppreference.com%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fpartial_specialization%22%7D">cppreference.com</a>: "A accepts a subset of the types that B accepts."</div>
<div class="text">Nach diesem ersten Überblick möchte ich ein wenig tiefer in Funktions-Templates eintauchen.<br></div>
<div class="ztitel">Spezialisierung und Überladen von Funktions-Templates<br></div>
<div class="text">Funktions-Templates machen einerseits den Umgang mit Template-Spezialisierung einfacher, aber auch andererseits anspruchsvoller.</div>
<div class="text"><ul><li> einfacher, da Funktions-Templates nur die vollständige Spezialisierung unterstützen.</li><li>anspruchsvoller, da das Überladen von Funktionen ins Spiel kommt.</li></ul></div>
<div class="text">Aus der Entwurfssicht lässt sich ein Funktions-Template mit Template-Spezialisierung oder Überladen anpassen:</div>
<div class="pre">// functionTemplateSpecialisation.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>std::string getTypeName(T){<br>&nbsp;&nbsp;&nbsp; return "unknown type";<br>}<br><br>template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>std::string getTypeName&lt;int&gt;(int){<br>&nbsp;&nbsp;&nbsp; return "int";<br>}<br><br>std::string getTypeName(double){&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; return "double";<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName(true): " &lt;&lt; getTypeName(true) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName(4711): " &lt;&lt; getTypeName(4711) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName(3.14): " &lt;&lt; getTypeName(3.14) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Die Zeile 1 ist das primäre Template. Die Zeile 2 enthält die vollständige Spezialisierung für <i>int</i> und die Zeile 3 die Überladung für <i>double. </i>Da ich nicht an den Werten für die Funktionen oder Funktions-Templates interessiert bin, habe ich sie ignoriert: <i>std::string getTypeName(double)</i> zum Beispiel. Die Anwendung der verschiedenen Varianten ist sehr einfach. Der Compiler ermittelt den Datentyp, und die passende Funktion oder das passende Funktions-Template wird aufgerufen. Im Fall der überladenen Funktion zieht der Compiler die Funktion dem Funktions-Template vor, wenn diese perfekt passt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167475254_05ed9db554.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Aber halt. Wo ist die große Überraschung, die ich versprochen habe? Hier kommt sie.<br></div>
<div class="text"><b><span class="tx_larger"><a class="" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.144%3A%20Don%C2%92t%20specialize%20function%20templates%26nbsp%3B%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialize-function%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialize-function">T.144: Don’t specialize function templates&nbsp;</a></span></b></div>
<div class="text">Die Begründung für die Regel ist kurz und bündig: Spezialisierung von Funktions-Template wird beim Überladen nicht berücksichtigt. Das will ich gerne an einem Beispiel zeigen. Es basiert auf dem Programmschnipsel von Demiov/<a href="https://en.wikipedia.org/wiki/David_Abrahams_(computer_programmer)" title="Link auf https://en.wikipedia.org/wiki/David_Abrahams_(computer_programmer)" class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDavid_Abrahams_%28computer_programmer%29%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Abrahams%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDavid_Abrahams_%28computer_programmer%29%22%7D">Abrahams</a>:<br></div>
<div class="pre">// dimovAbrahams.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>// getTypeName<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) primary template<br>std::string getTypeName(T){<br>&nbsp;&nbsp;&nbsp; return "unknown";<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) primary template that overloads (1)<br>std::string getTypeName(T*){<br>&nbsp;&nbsp;&nbsp; return "pointer";<br>}<br><br>template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3) explicit specialization of (2)<br>std::string getTypeName(int*){<br>&nbsp;&nbsp;&nbsp; return "int pointer";<br>}<br><br>// getTypeName2<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4) primary template<br>std::string getTypeName2(T){<br>&nbsp;&nbsp;&nbsp; return "unknown";<br>}<br><br>template&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5) explicit specialization of (4)<br>std::string getTypeName2(int*){<br>&nbsp;&nbsp;&nbsp; return "int pointer";<br>}<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6) primary template that overloads (4)<br>std::string getTypeName2(T*){<br>&nbsp;&nbsp;&nbsp; return "pointer";<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int *p;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName(p): " &lt;&lt; getTypeName(p) &lt;&lt; std::endl;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "getTypeName2(p): " &lt;&lt; getTypeName2(p) &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Zugegeben, der Sourcecode schaut recht langweilig aus. Habe Geduld! In der Zeile 1 definiere ich das primäre Template <i>getTypeName.</i> Zeile 2 stellt eine Überladung für Zeiger und Zeile 3 eine vollständige Spezialisierung für <i>int</i>-Zeiger dar. Im Fall von <i>getTypeName2</i> mache ich eine kleine Variation. Ich platziere die vollständige Spezialisierung (Zeile 5) vor der Überladung von Zeigern (Zeile 6). </div>
<div class="text">Dieses Umsortieren besitzt überraschende Konsequenzen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167475260_9e21cc38b2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Im ersten Fall wird die vollständige Spezialisierung für <i>int</i>-Zeiger aufgerufen und im zweiten Fall die Überladung für Zeiger. Was? </div>
<div class="text">Der Grund für dieses, nicht so intuitive Verhalten ist, dass Funktionsüberladung Template-Spezialisierung ignoriert. Funktionsüberladung berücksichtigt Funktionen und primäre Templates. In beiden Fällen ermittelte die Funktionsüberladung die primären Templates. Im ersten Fall <i>(getTypeName)</i> ist die Zeiger-Variante der bessere Treffer und daher kommt die vollständige Spezialisierung für <i>int</i>-Zeiger zum Einsatz. Im zweiten Fall (<i>getTypeName2)</i> wird auch die Zeiger-Variante verwendet, aber die vollständige Spezialisierung gehört zum primären Template (Zeile 4). Daher wird sie ignoriert. <br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Während ich die Zeilen korrekturlese, habe ich eine Idee. Templates sind für die ein oder andere Überraschung gut. Daher mache ich einen kleinen Ausflug von den C++ Core Guidelines und werde ein paar der Überraschungen vorstellen. Meine Hoffnung ist es, dass du dich an diese Zeilen erinnerst, wenn du den Überraschungen begegnest. <br></div>
<div class="text">Die Zukunft von C++ spricht Templates. Es ist somit eine gute Idee, ihre Sprache besser zu verstehen. <br></div>