<div class="vorspann">Weiter geht es mit der Definition von Concepts. In diesem Artikel ist vor allem die erste der drei verbleibenden Regeln recht anspruchsvoll.</div>
<div class="text">Dies sind die Regeln für den heutigen Artikel:</div>
<div class="text"><ul><li> <a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.24%3A%20Use%20tag%20classes%20or%20traits%20to%20differentiate%20concepts%20that%20differ%20only%20in%20semantics%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tag%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tag%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tag" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tag">T.24: Use tag classes or traits to differentiate concepts that differ only in semantics</a> </li><li> <a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.25%3A%20Avoid%20complimentary%20constraints%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-not%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-not%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-not" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-not">T.25: Avoid complimentary constraints</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-use" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-use%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-use%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.26%3A%20Prefer%20to%20define%20concepts%20in%20terms%20of%20use-patterns%20rather%20than%20simple%20syntax%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-use">T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax</a></li></ul></div>
<div class="text">Die Erläuterungen zur ersten Regel sind ziemlich kompakt, zu kompakt.</div>
<div class="ztitel"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tag%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tag%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.24%3A%20Use%20tag%20classes%20or%20traits%20to%20differentiate%20concepts%20that%20differ%20only%20in%20semantics%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tag" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tag">T.24: Use tag classes or traits to differentiate concepts that differ only in semantics</a> <br> </div>
<div class="text">Dies ist die Begründung der Regel aus den Guidelines: "Two concepts requiring the same syntax but having different semantics leads to ambiguity unless the programmer differentiates them."</div>
<div class="text">Angenommen, ich habe das Trait <i>is_contiguous </i>definiert. In diesem Fall kann ich es verwenden, um einen Random Access Iterator <i>RA_iter</i> von einem Contiguous Iterator <i>Contiguous_iter</i> zu unterscheiden: </div>
<div class="pre">template&lt;typename I&gt; // iterator providing random access<br>concept bool RA_iter = ...;<br><br>template&lt;typename I&gt; // iterator providing random access to contiguous data<br>concept bool Contiguous_iter =<br>&nbsp;&nbsp;&nbsp; RA_iter&lt;I&gt; &amp;&amp; is_contiguous&lt;I&gt;::value;&nbsp; // using is_contiguous trait</div>
<div class="text">Ich kann weiter die Tag-Klasse <i>is_contiguous </i>in einem Concept verpacken und anwenden. Jetzt besitze ich einen leicht lesbaren Ausdruck, der meine Idee eines Contiguous Iterators<i> Contiguous_iter</i> umsetzt:<br></div>
<div class="pre">template&lt;typename I&gt; concept Contiguous = is_contiguous&lt;I&gt;::value;<br><br>template&lt;typename I&gt;<br>concept bool Contiguous_iter = RA_iter&lt;I&gt; &amp;&amp; Contiguous&lt;I&gt;; </div>
<div class="text">Okay, ich denke, ich sollte die zwei entscheidenden Begriffe Traits und Tag Dispatching erklären.</div>
<div class="ztitel_kleiner">Traits</div>
<div class="text">Traits sind Klassen-Templates, die Eigenschaften von generischen Datentypen ermitteln.</div>
<div class="text">Das folgende Programm zeigt für jedes der 14 primären Typkategorien der <a href="https://en.cppreference.com/w/cpp/header/type_traits" class="" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D">Type-Traits-Bibliothek</a> einen Typ, der das spezifische Trait erfüllt. Die primären Typkategorien sind vollständig und disjunkt. Daher ist jeder Datentyp genau Mitglied einer Typkategorie. Wenn du eine Typkategorie für einen Typ prüfst, wird dies unabhängig von <i>const</i> oder <i>volatile</i> Qualifiers durchgeführt:<br></div>
<div class="pre">// traitsPrimary.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>using namespace std;<br><br>template &lt;typename T&gt;<br>void getPrimaryTypeCategory(){<br><br>&nbsp; cout &lt;&lt; boolalpha &lt;&lt; endl;<br><br>&nbsp; cout &lt;&lt; "is_void&lt;T&gt;::value: " &lt;&lt; is_void&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_integral&lt;T&gt;::value: " &lt;&lt; is_integral&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_floating_point&lt;T&gt;::value: " &lt;&lt; is_floating_point&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_array&lt;T&gt;::value: " &lt;&lt; is_array&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_pointer&lt;T&gt;::value: " &lt;&lt; is_pointer&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_reference&lt;T&gt;::value: " &lt;&lt; is_reference&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_member_object_pointer&lt;T&gt;::value: " &lt;&lt; is_member_object_pointer&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_member_function_pointer&lt;T&gt;::value: " &lt;&lt; is_member_function_pointer&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_enum&lt;T&gt;::value: " &lt;&lt; is_enum&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_union&lt;T&gt;::value: " &lt;&lt; is_union&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_class&lt;T&gt;::value: " &lt;&lt; is_class&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_function&lt;T&gt;::value: " &lt;&lt; is_function&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_lvalue_reference&lt;T&gt;::value: " &lt;&lt; is_lvalue_reference&lt;T&gt;::value &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "is_rvalue_reference&lt;T&gt;::value: " &lt;&lt; is_rvalue_reference&lt;T&gt;::value &lt;&lt; endl;<br><br>&nbsp; cout &lt;&lt; endl;<br><br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;void&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;short&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;double&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int []&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int*&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int&amp;&gt;();<br>&nbsp;&nbsp;&nbsp; struct A{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f(double){return 2011;}<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int A::*&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int (A::*)(double)&gt;();<br>&nbsp;&nbsp;&nbsp; enum E{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e= 1,<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;E&gt;();<br>&nbsp;&nbsp;&nbsp; union U{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int u;<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;U&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;string&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int * (double)&gt;();<br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int&amp;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; getPrimaryTypeCategory&lt;int&amp;&amp;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Um dich nicht zu Tode zu langweilen, habe ich nur die Ausgabe der Zeilen (1)</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161197458_b661eb4beb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">und die Ausgaben der Zeilen (2) dargestellt:</div>
<div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161197461_39c2996532.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel_kleiner">Tag Dispatching</div>
<div class="text">Tag Dispatching ermöglicht es, eine Funktion basierend auf den Eigenschaften ihres Typs auszuwählen. Die Entscheidung findet zur Compilezeit statt, und Traits, die ich im letzten Paragraph eingeführt habe, kommen dazu zum Einsatz.</div>
<div class="text">Ein typisches Beispiel für Tag Dispatching ist der Algrorithmus [i]<a href="https://en.cppreference.com/w/cpp/iterator/advance" class="" title="Link auf https://en.cppreference.com/w/cpp/iterator/advance" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fiterator%2Fadvance%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fiterator%2Fadvance%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aadvance%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D">std::advance</a>[/i] aus der Standard Template Library. <i>std::advance(it, n) </i>inkrementiert den Iterator <i>it </i>um <i>n</i> Elemente:&nbsp; <br></div>
<div class="pre">// advanceTagDispatch.cpp<br><br>#include &lt;iterator&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename InputIterator, typename Distance&gt;<br>void advance_impl(InputIterator&amp; i, Distance n, std::input_iterator_tag) {<br>&nbsp; std::cout &lt;&lt; "InputIterator used" &lt;&lt; std::endl; <br>&nbsp; while (n--) ++i;<br>}<br><br>template &lt;typename BidirectionalIterator, typename Distance&gt;<br>void advance_impl(BidirectionalIterator&amp; i, Distance n, std::bidirectional_iterator_tag) {<br>&nbsp; std::cout &lt;&lt; "BidirectionalIterator used" &lt;&lt; std::endl;<br>&nbsp; if (n &gt;= 0) <br>&nbsp;&nbsp;&nbsp; while (n--) ++i;<br>&nbsp; else <br>&nbsp;&nbsp;&nbsp; while (n++) --i;<br>}<br><br>template &lt;typename RandomAccessIterator, typename Distance&gt;<br>void advance_impl(RandomAccessIterator&amp; i, Distance n, std::random_access_iterator_tag) {<br>&nbsp; std::cout &lt;&lt; "RandomAccessIterator used" &lt;&lt; std::endl;<br>&nbsp; i += n;<br>}<br><br>template &lt;typename InputIterator, typename Distance&gt;<br>void advance_(InputIterator&amp; i, Distance n) {<br>&nbsp;&nbsp;&nbsp; typename std::iterator_traits&lt;InputIterator&gt;::iterator_category category;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; advance_impl(i, n, category);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>}<br>&nbsp; <br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};<br>&nbsp;&nbsp;&nbsp; auto myVecIt = myVec.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myVecIt: " &lt;&lt; *myVecIt &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; advance_(myVecIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myVecIt: " &lt;&lt; *myVecIt &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::list&lt;int&gt; myList{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};<br>&nbsp;&nbsp;&nbsp; auto myListIt = myList.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myListIt: " &lt;&lt; *myListIt &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; advance_(myListIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myListIt: " &lt;&lt; *myListIt &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::forward_list&lt;int&gt; myForwardList{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};<br>&nbsp;&nbsp;&nbsp; auto myForwardListIt = myForwardList.begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myForwardListIt: " &lt;&lt; *myForwardListIt &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; advance_(myForwardListIt, 5);<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*myForwardListIt: " &lt;&lt; *myForwardListIt &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Der Ausdruck <i>std::iterator_traits::iterator_category category</i> bestimmt die Iterator-Kategorie zu Compilezeit. Basierend auf der Iterator-Kategorie wird die am besten passende Variante der Funktion <i>advance_impl(i, n, category)</i> in Zeile (2) verwendet. Jeder Container gibt den Iterator der Iterator-Kategorie zurück, die seiner Struktur entspricht. Daher ergibt die Zeile (3) einen Random Acccess Iterator, die Zeile (4) einen Bidirecional Iterator und die Zeile (5) einen Forward Iterator, der auch eine Input Iterator ist. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_161197466_2c2e8ede1c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Aus dem Blickwinkel der Performanz betrachtet, ist diese Entscheidung sinnvoll, denn ein Random Access Iterator kann schneller als ein Bidrectional Iterator und ein Bidirectional Iterator kann schneller als eine Input Iterator inkrementiert werden. Aus dem Blickwinkel der Anwender betrachtet, wendest du <i>std::advance(it, 5) </i>an und erhälst die schnellste Variante, die der Container unterstützt.</div>
<div class="text">Meine Erklärung war doch recht wortreich. Zu den verbleibenden zwei Regeln gibt es nicht so viel zu ergänzen.<br></div>
<div class="ztitel"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-not" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-not%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-not%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22T.25%3A%20Avoid%20complimentary%20constraints%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-not">T.25: Avoid complimentary constraints</a> <br> </div>
<div class="text">Das Beispiel aus den Guidelines zeigt komplementäre Einschränkungen:<br></div>
<div class="pre">template&lt;typename T&gt; <br>&nbsp;&nbsp;&nbsp; requires !C&lt;T&gt; // bad <br>void f(); <br><br>template&lt;typename T&gt; <br>&nbsp;&nbsp;&nbsp; requires C&lt;T&gt; <br>void f();<br></div>
<div class="text">Vermeide dies. Wende hingegen ein eingeschränktes und ein uneingeschränktes Template an:</div>
<div class="pre">template&lt;typename T&gt;&nbsp;&nbsp; // general template<br>&nbsp;&nbsp;&nbsp; void f();<br><br>template&lt;typename T&gt;&nbsp;&nbsp; // specialization by concept<br>&nbsp;&nbsp;&nbsp; requires C&lt;T&gt;<br>void f();</div>
<div class="text">Du kannst selbst das uneingeschränkte Template auf <i>delete</i> setzen, sodass sich nur noch die eingeschränkte Version verwenden lässt: <br></div>
<div class="pre">template&lt;typename T&gt;<br>void f() = delete;</div>
<div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-use" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-use%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-use%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22T.26%3A%20Prefer%20to%20define%20concepts%20in%20terms%20of%20use-patterns%20rather%20than%20simple%20syntax%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-use" class="">T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax</a></div>
<div class="text">Der Titel für diese Regel ist ziemlich unspezifisch, aber das Bespiel liefert die notwendige Aufklärung. Anstelle die Concepts [i]has_equal[/i] und [i]has_not_equal[/i] um das [i]concept Equalitity[/i] zu verwenden: </div>
<div class="pre">template&lt;typename T&gt; concept Equality = has_equal&lt;T&gt; &amp;&amp; has_not_equal&lt;T&gt;;<br></div>
<div class="text">solltest du das Use-Pattern vorziehen. Dadurch wird das folgende Beispiel deutlich lesbarer.</div>
<div class="pre">template&lt;typename T&gt; concept Equality = requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp; bool == { a == b }<br>&nbsp;&nbsp;&nbsp; bool == { a != b }<br>&nbsp;&nbsp;&nbsp; // axiom { !(a == b) == (a != b) }<br>&nbsp;&nbsp;&nbsp; // axiom { a = b; =&gt; a == b }&nbsp; // =&gt; means "implies"<br>}<br></div>
<div class="text">Das Concept fordert in diesem Fall, dass sich <i>== </i>und <i>!</i>= auf die Argumente anwenden lassen und beide Funktionen <i>bool</i> zurückgebe sollten. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Dies ist ein Teil der Einleitung der C++ Core Guidelines zu Templates: "...the interface to a template is a critical concept [--] a contract between a user and an implementer [--] and should be carefully designed". Im nächsten Artikel wird es kritisch.<br></div>
