<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148152865_8bcb84e222.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="vorspann">Die Überschrift dieses Artikels ist vielleicht ein wenig langweilig: mehr Regeln für Expressions. Ehrlich gesagt, dieser Artikel beschäftigt sich vor allem mit Code-Hygiene, denn es geht um Zeiger.</div>
<div class="text">Hier ist mein Plan:</div>
<div class="text"><ul><li> <a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-ptr%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.42%3A%20Keep%20use%20of%20pointers%20simple%20and%20straightforward%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-ptr%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr">ES.42: Keep use of pointers simple and straightforward</a> </li><li> <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-magic%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-magic%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22ES.45%3A%20Avoid%20%5C%22magic%20constants%5C%22%3B%20use%20symbolic%20constants%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-magic" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-magic">ES.45: Avoid "magic constants"; use symbolic constants</a> </li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nullptr" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nullptr%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.47%3A%20Use%26nbsp%3Bnullptr%26nbsp%3Brather%20than%26nbsp%3B0%26nbsp%3Bor%26nbsp%3BNULL%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nullptr%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nullptr" class="">ES.47: Use&nbsp;nullptr&nbsp;rather than&nbsp;0&nbsp;or&nbsp;NULL</a></li></ul></div>
<div class="text">Los geht's mit einer sehr wichtigen Regel:</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr" alt="%7B%22text%22%3A%22ES.42%3A%20Keep%20use%20of%20pointers%20simple%20and%20straightforward%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-ptr%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-ptr%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-ptr">ES.42: Keep use of pointers simple and straightforward</a></b></div>
<div class="text">Die Guidelines bringen es deutlich auf den Punkt: "Complicated pointer manipulation is a major source of errors." Warum sollte uns das interessieren? Klar, unser Legacy-Code ist voll mit Altlasten wie im folgenden Beispiel: </div>
<div class="pre">void f(int* p, int count)<br>{<br>&nbsp;&nbsp;&nbsp; if (count &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int* q = p + 1;&nbsp;&nbsp;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; int n = *p++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; if (count &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; p[4] = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; p[count - 1] = 2;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; use(&amp;p[0], 3);&nbsp;&nbsp;&nbsp;&nbsp; // BAD<br>}<br><br>int myArray[100];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>f(myArray, 100),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)</div>
<div class="text">Das dominante Problem dieses Codebeispiels ist es, dass der Aufruf der Funktion die richtige Länge des C-Arrays übergeben muss. Falls nicht, resultiert undefiniertes Verhalten.</div>
<div class="text">Denke über die letzten zwei Zeilen (1) und (2) ein paar Sekunden nach. Die beginnen mit einem Array, von dem seine Typinformation entfernt wird, indem es als Argument der Funktion <i>f</i> verwendet wird. Dieser Prozess nennt sich "array to poiner decay" und ist der Grund für viele Fehler. Vielleicht hatte der Autor dieser Zeilen einen schlechten Tag und er zählte die Anzahl der Elemente falsch oder die Größe des C-Arrays ändert sich nachträglich. Egal, das Ergebnis ist immer dasselbe: undefiniertes Verhalten. Dieselbe Argumentation gilt natürlich auch für einen C-String.</div>
<div class="text">Was sollen wir tun? Wir sollten den richtigen Datentyp verwenden. Die Guidelines empfehlen den Container <i>gsl:span</i> aus der <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Guidelines%20Support%20Library%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl">Guidelines Support Library</a> (GSL). Hier ist das verbesserte Programmschnipsel:<br></div>
<div class="pre">void f(span&lt;int&gt; a) // BETTER: use span in the function declaration<br>{<br>&nbsp;&nbsp;&nbsp; if (a.length() &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int n = a[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br><br>&nbsp;&nbsp;&nbsp; span&lt;int&gt; q = a.subspan(1); // OK<br><br>&nbsp;&nbsp;&nbsp; if (a.length() &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; a[4] = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br><br>&nbsp;&nbsp;&nbsp; a[count - 1] = 2;&nbsp; // OK<br><br>&nbsp;&nbsp;&nbsp; use(a.data(), 3);&nbsp; // OK<br>}</div>
<div class="text">Gut! <i>gsl::span</i> prüft zur Laufzeit seine Grenzen. Zusätzlich besitzt die Guidelines Support Library eine freie Funktion <i>at</i>, mit der sich die Elemente von <i>gls::span</i> direkt ansprechen lassen. <br></div>
<div class="pre">void f3(array&lt;int, 10&gt; a, int pos) <br>{<br>&nbsp;&nbsp;&nbsp; at(a, pos / 2) = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; at(a, pos - 1) = 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>}<br></div>
<div class="text">Warum sollte ein <i>std::array</i> statt eines C-Arrays, ein <i>gsl::stack_array</i> statt eines C-Arrays eingesetzt werden?</div>
<div class="text">Ich höre bereits Bedenken. Die meisten von uns setzen die Guidelines Support Library nicht ein. Die Funktion <i>f</i> und<i> f3</i> lassen sich direkt mithilfe des Containers<i> std::array </i>und seiner Method <i>std::array::at</i> neu formulieren. Hier sind sie:<br></div>
<div class="pre">// spanVersusArray.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;array&gt;<br><br>void use(int*, int){}<br><br>void f(std::array&lt;int, 100&gt;&amp; a){<br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int n = a.at(0);&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 99&gt; q;<br>&nbsp;&nbsp;&nbsp; std::copy(a.begin() + 1, a.end(), q.begin());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; a.at(4) = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; a.at(a.size() - 1) = 2;<br><br>&nbsp;&nbsp;&nbsp; use(a.data(), 3); <br>}<br><br>void f3(std::array&lt;int, 10&gt; a, int pos){<br>&nbsp;&nbsp;&nbsp; a.at(pos / 2) = 1;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; a.at(pos - 1) = 2; <br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 100&gt; arr{};<br><br>&nbsp;&nbsp;&nbsp; f(arr);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 10&gt; arr2{};<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; f3(arr2, 6);<br><br>}</div>
<div class="text">Der <i>std::array::at</i>-Operator prüft zur Laufzeit seine Grenzen. Falls <i>pos &gt;= size</i>, wirft er eine <i><a class="" title="Link auf http://en.cppreference.com/w/cpp/error/out_of_range" href="http://en.cppreference.com/w/cpp/error/out_of_range" alt="%7B%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fout_of_range%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fout_of_range%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22std%3A%3Aout_of_range%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D">std::out_of_range</a></i>-Ausnahme. Wer Programm <i>spanVersusArray.cpp</i> sorgfältig studiert, dem fallen zwei Einschränkungen auf. Zuerst ist der Ausdruck (1) deutlich verboser als die entsprechende <i>gls::span</i>-Version. Darüber hinaus ist die Länge des <i>std::array</i> Bestandteil der Signatur der Funktion. Das ist sehr schlecht. In diesem Fall kann die Funktion nur mit dem Container <i>std::array&lt;int, 100&gt;</i> verwendet werden. Damit ist auch die Prüfung der Array-Größe im Funktionskörper überflüssig.</div>
<div class="text">Zu unserer Rettung besitzt C++ Templates. Daher ist einfach, diese Einschränkungen zu überwinden und trotzdem typsicher zu bleiben.</div>
<div class="pre">// at.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;array&gt;<br>#include &lt;deque&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;<br>void use(T*, int){}<br><br>template &lt;typename T&gt;<br>void f(T&amp; a){<br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int n = a.at(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::array&lt;typename T::value_type , 99&gt; q;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::copy(a.begin() + 1, a.end(), q.begin());&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; a.at(4) = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; a.at(a.size() - 1) = 2;<br><br>&nbsp;&nbsp;&nbsp; use(a.data(), 3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 100&gt; arr{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; f(arr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::array&lt;double, 20&gt; arr2{};<br>&nbsp;&nbsp;&nbsp; f(arr2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;double&gt; vec{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>&nbsp;&nbsp;&nbsp; f(vec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string myString= "123456789";<br>&nbsp;&nbsp;&nbsp; f(myString);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // std::deque&lt;int&gt; deq{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp;&nbsp; // f(deq);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Jetzt lässt sich die Funktion <i>f</i> auf <i>std::arrays</i>'s beliebiger Länge (1) und beliebigen zugrunde liegenden Datentyps (2) anwenden. Darüber hinaus kann sie mit einem <i>std::vector (</i>3) oder einem <i>std::string</i> (4) aufgerufen werden. Diesen Containern ist gemeinsam, dass ihre Daten einem kontinuierlichen Speicherbereich gespeichert werden. Das gilt nicht für <i>std::deque</i>, und somit schlägt der Aufruf <i>a.data() </i>im Ausdruck (5) fehl. Ein <i>std::deque</i> ist eine Art doppelt verkettete Liste von kleinen Speicherbereichen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148152874_1c3d8798a7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Ausdruck <i>T::value_type </i>(5) erlaubt es, den zugrunde liegenden Typ eines Containers zu erhalten. <i>T</i> ist ein sogenannter Dependent Type, den <i>T</i> ist ein Typ-Parameter des Funktions-Templates <i>f</i>. Das ist der Grund, dass ich dem Compiler unter die Arme greifen und ihm einen Hinweis geben muss, dass er in diesem Fall <i>T::value_type</i> als Typ interpretieren soll: <i>typename T::value_type</i>.</div>
<div class="text"><b><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-magic" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-magic%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.45%3A%20Avoid%20%C2%93magic%20constants%C2%94%3B%20use%20symbolic%20constants%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-magic%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-magic">ES.45: Avoid “magic constants”; use symbolic constants</a></b> </div>
<div class="text">Diese Regel sollte selbstverständlich sein: Eine symbolische Konstante sagt mehr aus als eine magische Konstante. Das Beispiel der Guidelines beginnt in diesem Fall mit einer magischen Konstanten, fährt mit einer symbolischen Konstanten fort und endet mit einer Range-basierten <i>for</i>-Anweisung.<br></div>
<div class="pre">for (int m = 1; m &lt;= 12; ++m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // don't: magic constant 12<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; month[m] &lt;&lt; '\n';<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // months are indexed 1..12 (symbolic constant)<br>constexpr int first_month = 1;<br>constexpr int last_month = 12;<br><br>for (int m = first_month; m &lt;= last_month; ++m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // better<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; month[m] &lt;&lt; '\n';<br><br><br><br>for (auto m : month)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the best (ranged-based for loop)<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; m &lt;&lt; '\n';<br></div>
<div class="text">Im Falle dieser Anweisung ist ein sogenannter <a alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FOff-by-one_error%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22off-by-one%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FOff-by-one_error%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://en.wikipedia.org/wiki/Off-by-one_error" title="Link auf https://en.wikipedia.org/wiki/Off-by-one_error" class="">off-by-one</a>-Fehler schlicht und ergreifend nicht möglich.</div>
<div class="text">Jetzt springe ich direkt zur Regel ES.47, denn ich will die Regeln zur Konvertierung von Daten, die die Regel ES.47 mit einschließt, in einem separaten Artikel vorstellen. </div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nullptr" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nullptr" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nullptr%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22ES.47%3A%20Use%26nbsp%3Bnullptr%26nbsp%3Brather%20than%26nbsp%3B0%26nbsp%3Bor%26nbsp%3BNULL%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nullptr%22%2C%22type%22%3A%22E%22%7D">ES.47: Use&nbsp;nullptr&nbsp;rather than&nbsp;0&nbsp;or&nbsp;NULL</a></b></div>
<div class="text">Es gibt viele gute Gründe, einen nullptr anstelle der Zahl 0 oder dem Makro NULL zu verwenden. Insbesondere sind die Zahl 0 oder das Makro NULL für generischen Code ungeeignet. Ich habe bereits einen Artikel zu den drei Varianten eines Nullzeigers verfasst. Hier sind die Details: "<a href="http://www.grimm-jaud.de/index.php/blog/die-null-zeiger-konstante-nullptr" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdie-null-zeiger-konstante-nullptr%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Die%20Null-Zeiger-Konstante%20nullptr%5C%22.%20%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdie-null-zeiger-konstante-nullptr%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/die-null-zeiger-konstante-nullptr" class="">Die Null-Zeiger-Konstante nullptr". </a> </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wie viele explizite Casts gibt es in modernem C++? Du kommst vermutlich auf die Zahl 4. Diese Antwort ist falsch. In C++11 gibt es 6 verschiedene, explizite Casts. Wenn ich noch die GSL hinzurechnen, komme ich bereits auf 8 verschiedene, explizite Casts. Genau diese 8 explizite Casts sind das Thema des nächsten Artikels.</div>