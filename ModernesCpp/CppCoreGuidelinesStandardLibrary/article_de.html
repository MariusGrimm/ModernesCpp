<div class="vorspann">In den Regeln zur C++-Standard-Bibliothek geht es vor allem um Container, Strings und die IO-Streams.</div><div class="text">Seltsam, es gibt keinen Abschnitt zu den Algorithmen der Standard Template Library (STL) in diesem Kapitel. Seltsam, denn es gibt ein Sprichwort in der C++-Community: Wenn du eine explizite Schleife verwendest, dann kennst du die Algorithmen der STL nicht.<br></div><div class="text"><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-lib" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.1%3A%20Use%20libraries%20wherever%20possible%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-lib%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-lib%22%2C%22user_params%22%3A%22%22%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-lib">SL.1: Use libraries wherever possible</a>, denn das Rad neu zu erfinden ist keine gute Idee. Zusätzlich profitierst du von Früchten anderer. Das heißt, dass deine Bibliothek bereits getestet und wohldefiniert ist. Dies gilt vor allem, wenn du <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-lib" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-lib" alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-lib%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-lib%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22SL.2%3A%20Prefer%20the%20standard%20library%20to%20other%20libraries%22%2C%22ir_link%22%3A1%7D">SL.2: Prefer the standard library to other libraries</a> anwendest. Stelle dir vor, du stellst jemanden ein. Der Vorteil ist dann, dass er bereits die Bibliothek kennt und du ihm nicht deine Bibliotheken schulen musst. Das spart viel Zeit und Geld. Ich hatte einmal einen Kunden, der seine Infrastruktur in den Namensraum <i>std</i> gepackt hat. Wenn du Überraschungen liebst, tue das. Wenn nicht:&nbsp; <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sl-std" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.3%3A%20Do%20not%20add%20non-standard%20entities%20to%20namespace%20std.%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23sl-std%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23sl-std%22%2C%22user_params%22%3A%22%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sl-std">SL.3: Do not add non-standard entities to namespace std.</a></div><div class="text">Die nächsten Regeln zu STL-Containern werden deutlich konkreter.</div><div class="ztitel">Container</div><div class="text">Die erste Regel ist recht einfach zu begründen.</div><div class="ztitel_kleiner"><a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-arrays" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-arrays" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22SL.con.1%3A%20Prefer%20using%20STL%20array%20or%20vector%20instead%20of%20a%20C%20array%26nbsp%3B%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-arrays%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-arrays%22%7D">SL.con.1: Prefer using STL array or vector instead of a C array&nbsp;</a></div><div class="text">Ich nehme an, du kennst den <i>std::vector</i>. Einer der großen Vorteile eines <i>std::vector </i>gegenüber einem C-Array ist, dass der <i>std::vector </i>automatisch seinen Speicher verwaltet. Klar, das gilt für alle Container der Standard Template Library. Lasse mich einen genaueren Blick auf die automatische Speicherverwaltung des <i>std::vector</i> werfen. </div><div class="text"><ul><li><i><b>std::vector</b></i><br></li></ul></div><div class="pre">// vectorMemory.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;<br>void showInfo(const T&amp; t,const std::string&amp; name){<br><br>&nbsp; std::cout &lt;&lt; name &lt;&lt; " t.size(): " &lt;&lt; t.size() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; name &lt;&lt; " t.capacity(): " &lt;&lt; t.capacity() &lt;&lt; std::endl;<br><br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Maximal size: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "vec.max_size(): " &lt;&lt; vec.max_size() &lt;&lt; std::endl;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Empty vector: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; showInfo(vec, "Vector");<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Initialised with five values: " &lt;&lt; std::endl;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; vec = {1,2,3,4,5};<br>&nbsp;&nbsp;&nbsp; showInfo(vec, "Vector");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Added four additional values: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; vec.insert(vec.end(),{6,7,8,9});<br>&nbsp;&nbsp;&nbsp; showInfo(vec,"Vector");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Resized to 30 values: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; vec.resize(30);<br>&nbsp;&nbsp;&nbsp; showInfo(vec,"Vector");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Reserved space for at least 1000 values: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; vec.reserve(1000);<br>&nbsp;&nbsp;&nbsp; showInfo(vec,"Vector");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Shrinke to the current size: " &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; vec.shrink_to_fit();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; showInfo(vec,"Vector");<br><br>}</div><div class="text">Um mir Schreibarbeit zu sparen, habe ich die kleine Funktion <i>showInfo </i>geschrieben. Diese Funktion gibt zu einem Vektor seine Größe und Kapazität aus. Die Größe eines Vektors ist die Anzahl seiner Elemente und seine Kapazität die Anzahl der Elemente, die er besitzen kann ohne Speicher neu anzufordern. Daher ist die Kapazität eines Vektors größer als seine Größe. Die Größe eines Vektors kannst du mit der Methode <i>resize</i> anpassen, dessen Kapazität mit der Methode <i>reserve</i>.<br></div><div class="text">Nun aber das Programm von Anfang bis zum Ende. In Zeile 1 erzeuge ich einen Vektor. Dann stelle ich die maximale Anzahl der Elemente dar (Zeile 2), die ein Vektor besitzen kann. Nach jeder weiteren Operationen auf dem <i>std::vector</i> gebe ich dessen Größe und Kapazität aus. Das trifft für die Initialisierung des Vektors (Zeile 3), für das Hinzufügen von vier Elementen (Zeile 4) zum Vektor, das Vergrößern des Vektors auf 30 Elemente (Zeile 5) und das Reservieren von zusätzlichem Speicherplatz für 1000 Elemente (Zeile 6) zu. Selbst das Verkleinern des Vektors auf seine tatsächliche Größe wird mit der Methode <i>shrink_to_fit</i> (Zeile 7) seit C++11 unterstützt.</div><div class="text">Bevor ich die Ausgabe des Programms auf Linux vorstelle, möchte ich meine wichtigsten Beobachtungen zusammenfassen.</div><div class="text"><ol><li>Die Anpassung der Größe und Kapazität des Vektors geschieht automatisch. Ich verwende in diesem Programm keine expliziten Aufrufe zur Speicherallokation oder -deallokation.</li><li>Durch die Methodenausführung <i>cont.resize(n)</i> erhält der Vektor <i>cont</i> neue, Default-initialisierte Elemente, wenn<i> n &gt; cont.size()</i> ist.</li><li>Durch die Methodenausführung <i>cont.reserve(n)</i> wird neuer Speicher für mindestens<i> n</i> Elemente für <i>cont</i> reserviert, wenn&nbsp; <i>n &gt; const.capacity()</i> ist.</li><li>Der Aufruf der Methode <i>shrink_to_fit</i> ist nicht bindend. Das heißt, die C++-Laufzeit muss die Kapazität des Vektors nicht an seine Größe anpassen. Bei all meinen Anwendungen von <i>shrink_to_fit</i> mit GCC, Clang oder cl.exe wurde der unnötige Speicher immer freigegeben.</li></ol></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174198334_c91bf4c95e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Aber welcher Unterschied besteht zwischen einem C-Array und einem C++-Arrray?</div><div class="text"><ul><li><i><b>std::array</b></i></li></ul></div><div class="text"><i>std::array</i> verbindet das Beste aus zwei Welten. Zum einen besitzt es die Größe und Effizienz eines C-Arrays, zum anderen bietet es das Interface eines <i>std::vector</i> an.</div><div class="text">Mein kleines Programm vergleicht die Speichereffizienz eins C-Arrays, eines C++Arrays (<i>std::array</i>) und eines <i>std::vector</i>:</div><div class="pre">// sizeof.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;array&gt;<br>#include &lt;vector&gt;<br>&nbsp;<br>&nbsp;<br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "sizeof(int)= " &lt;&lt; sizeof(int) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; int cArr[10]= {1,2,3,4,5,6,7,8,9,10};<br>&nbsp; <br>&nbsp; std::array&lt;int,10&gt; cppArr={1,2,3,4,5,6,7,8,9,10};<br>&nbsp; <br>&nbsp; std::vector&lt;int&gt; cppVec={1,2,3,4,5,6,7,8,9,10};<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "sizeof(cArr)= " &lt;&lt; sizeof(cArr) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "sizeof(cppArr)= " &lt;&lt; sizeof(cppArr) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; "sizeof(cppVec) = "&nbsp;&nbsp; &lt;&lt; sizeof(cppVec) + sizeof(int)*cppVec.capacity() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = sizeof(cppVec): " &lt;&lt; sizeof(cppVec) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + sizeof(int)* cppVec.capacity(): "&nbsp;&nbsp; &lt;&lt; sizeof(int)* cppVec.capacity() &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174198344_f5ccb4c641.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Sowohl das C-Array (Zeile 1) als auch das C++-Array (Zeile 2) benötigen 40 Byte. Das entspricht der Größe <i>sizeof(int) * 10</i>. Im Gegensatz dazu benötigt der <i>std::vector </i>24 zusätzliche Bytes (Zeile 3), um seine Daten auf dem freien Speicher zu verwalten. </div><div class="text">Dies war der C-Anteil eines <i>std::array</i>, aber das <i>std::array</i> hat viel mit einem <i>std::vector</i> gemein. Das bedeutet insbesondere, dass ein<i> std::array</i> seine Größe kennt. Damit gehören fehleranfällige Interfaces wie das folgende der Vergangenheit an und besitzen ein starkes Geschmäkle (code-smell).</div><div class="pre">void bad(int* p, int count){<br>&nbsp;&nbsp; ... <br>}<br><br>int myArray[100] = {0};&nbsp;&nbsp;&nbsp; <br>bad(myArray, 100);<br><br>// ----------------------------- <br><br>void good(std::array&lt;int, 10&gt; arr){<br>&nbsp;&nbsp; ...<br>}<br><br>std::array&lt;int, 100&gt; myArray = {0};<br>good(myArray);</div><div class="text">Wenn du ein C-Array als ein Funktionsargument verwendet, schmeißt du fast alle Typinformation weg und übergibst das C-Array als ein Zeiger auf sein erstes Element. Dies ist sehr fehleranfällig, denn du musst die Anzahl der Elemente des C-Arrays als weiteres Argument angeben. Das ist nicht nötig, wenn deine Funktion ein <i>std::array&lt;int, 100&gt;</i> annimmt. </div><div class="text">Falls dir die Funktion good nicht generisch genug ist, kannst du ein Template einsetzen.</div><div class="pre">template &lt;typename T&gt;<br>void foo(T&amp; arr){<br><br>&nbsp;&nbsp; arr.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>}<br><br><br>std::array&lt;int, 100&gt; arr{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>foo(arr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>std::array&lt;double, 20&gt; arr2{};<br>foo(arr2); </div><div class="text">Da ein <i>std::array </i>seine Größe kennt, kannst du danach in der Zeile 1 fragen.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Die nächsten zwei Regeln zu Containern sind recht interessant. Im nächsten Artikel gebe ich dir eine Antwort auf die Frage: Wann soll ich welchen Container verwenden?<br></div><div class="simple-translate-result-wrapper"><br> <br></div>
