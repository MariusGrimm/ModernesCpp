<div class="vorspann">Ich erkläre oft die Grundlagen zu Templates. Diese sind speziell, daher begegnen mir oft Missverständnisse, die zwangsläufig zu Überraschungen führen. <br></div><div class="text">Mein erstes Missverständnis ist wohl für viele, aber nicht für alle C++-Entwickler offensichtlich.</div><div class="ztitel">Templates verwandter Datentypen sind nicht verwandt</div><div class="text">Zuerst einmal, was meine ich mit verwandt. Dies ist mein informeller Begriff, der für Datentypen steht, die <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fimplicit_conversion%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fimplicit_conversion%22%2C%22text%22%3A%22impliziert%20konvertiert%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://en.cppreference.com/w/cpp/language/implicit_conversion">impliziert konvertiert</a> werden können. Hier geht die Geschichte los:</div><div class="pre">// genericAssignment.cpp<br><br>#include &lt;vector&gt;<br><br>template &lt;typename T, int N&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct Point{<br>&nbsp;&nbsp;&nbsp; Point(std::initializer_list&lt;T&gt; initList): coord(initList){}<br><br>&nbsp;&nbsp;&nbsp; std::vector&lt;T&gt; coord;&nbsp;&nbsp;&nbsp; <br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; Point&lt;int, 3&gt; point1{1, 2, 3};<br>&nbsp;&nbsp;&nbsp; Point&lt;int, 3&gt; point2{4, 5, 6};<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; point1 = point2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto doubleValue = 2.2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto intValue = 2;<br>&nbsp;&nbsp;&nbsp; doubleValue = intValue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point&lt;double, 3&gt; point3{1.1, 2.2, 3.3};<br>&nbsp;&nbsp;&nbsp; point3 = point2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>}</div><div class="text">Das Klassen-Template <i>Point</i> steht für einen Punkt in einem n-dimensionalen Raum. Der Datentyp der Koordinaten und die Dimension lassen sich anpassen (Zeile 1). Zum Speichern der Koordinaten dient ein<i> std::vector&lt;T&gt;</i>. Wenn ich nun zwei Punkte mit demselben Datentyp und derselben Dimension definiere, kann ich diese zuweisen. </div><div class="text">Hier beginnt das Missverständnis. Ein int- kann einem double-Wert zugewiesen werden (Zeile 3). Daher sollte es doch möglich sein, einen Punkt von ints einem von doubles zuzuweisen. Der Compiler besitzt aber eine eindeutige Meinung zu Zeile 4. Beide Templates sind nicht verwandt und können damit nicht zugewiesen werden. Sie stellen verschiedene Datentypen dar.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167917684_7bcdbf2fcf.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Die Fehlermeldung gibt den ersten Hinweis. Ich benötige ein Zuweisungsoperator von <i>Point&lt;int, 3&gt;</i> nach <i>Point&lt;double, 3&gt;</i>. Nun besitzt die Klasse einen generischen Copy-Zuweisungsoperator. </div><div class="pre">// genericAssignment2.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T, int N&gt;<br>struct Point{<br><br>&nbsp;&nbsp;&nbsp; Point(std::initializer_list&lt;T&gt; initList): coord(initList){}<br><br>&nbsp;&nbsp;&nbsp; template &lt;typename T2&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Point&lt;T, N&gt;&amp; operator=(const Point&lt;T2, N&gt;&amp; point){&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static_assert(std::is_convertible&lt;T2, T&gt;::value, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Cannot convert source type to destination type!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coord.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coord.insert(coord.begin(), point.coord.begin(), point.coord.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;T&gt; coord;<br>&nbsp;&nbsp;&nbsp; <br>};<br><br><br>int main(){<br><br>&nbsp; Point&lt;double, 3&gt; point1{1.1, 2.2, 3.3};<br>&nbsp; Point&lt;int, 3&gt; point2{1, 2, 3};<br>&nbsp; <br>&nbsp; Point&lt;int, 2&gt; point3{1, 2};<br>&nbsp; Point&lt;std::string, 3&gt; point4{"Only", "a", "test"};<br><br>&nbsp; point1 = point2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp; // point2 = point3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; // point2 = point4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>}<br></div><div class="text">Dank der Zeile (1) ist die Copy-Zuweisung in Zeile (3) gültig. Hier ist ein genauerer Blick auf das Klassen-Template [i]Point[/i].</div><div class="text"><ul><li> <i>Point&lt;T, N&gt;&amp; operator=(const Point&lt;T2, N&gt;&amp; point)</i>: Das Ziel der Zuweisung besitzt den Datentyp <i>Point&lt;T, N&gt;</i> und nimmt nur einen Datentyp an, der dieselbe Dimension besitzt, aber einen verschiedenen Datentyp verwenden kann: <i>Point&lt;T2, N&gt;</i>.</li><li><i>static_assert(std::is_convertible&lt;T2, T&gt;::value, "Cannot convert source type to destination type!")</i>: Dieser Ausdruck prüft mithilfe der Funktion <i>std::is_convertibl</i>e der Type-Traits-Bibiliothek, ob sich <i>T2 </i>in<i> T</i> konvertieren lässt. <br></li></ul></div><div class="text">Wenn die Zeilen (4) und (5) zum Einsatz kommen, schlägt die Kompilierung fehl.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167917690_32dd020ffc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Zeile (3) führt zum Fehler, denn beide Punkte besitzen verschieden Dimensionen. Zeile (4) löst <i>static_assert</i> in dem Zuweisungsoperator aus, da ein <i>std::string</i> nicht nach <i>int</i> konvertiert werden kann. </div><div class="text">Ich nehme an, das nächste Missverständnis besitzt ein größeres Überraschungspotenzial. <br></div><div class="ztitel">Methoden, die von Klassen-Templates geerbt werden, stehen nicht automatisch zur Verfügung</div><div class="text">Es geht wieder einfach los:<br></div><div class="pre">// inheritance.cpp<br><br>#include &lt;iostream&gt;<br><br>class Base{<br>public:<br>&nbsp;&nbsp;&nbsp; void func(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class Derived: public Base{<br>public:<br>&nbsp;&nbsp;&nbsp; void callBase(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Derived derived;<br>&nbsp;&nbsp;&nbsp; derived.callBase();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Das Beispiel besitzt eine Klasse <i>Base</i> und <i>Derived. Derived</i> ist von <i>Base </i>public abgeleitet und kann somit in der Methode <i>callBase</i> (Zeile 2) die Methode <i>func </i>der Klasse <i>Base </i>verwendet werden. Die Ausgabe des Programms zeigt das erwartete Verhalten.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167917696_9cbc6870c6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Wenn die Klasse <i>Base</i> zur Template-Klasse wird, verändert sich das Verhalten grundlegend:</div><div class="pre">// templateInheritance.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>class Base{<br>public:<br>&nbsp;&nbsp;&nbsp; void func(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>template &lt;typename T&gt;<br>class Derived: public Base&lt;T&gt;{<br>public:<br>&nbsp;&nbsp;&nbsp; void callBase(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Derived&lt;int&gt; derived;<br>&nbsp;&nbsp;&nbsp; derived.callBase();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Dass sich das Programm nun nicht mehr übersetzen lässt, ist für viele C++-Programmierer überraschend.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167917698_f6b9aa4c40.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Zeile "<i>there are no arguments to 'func' that depend on a template parameter, so a declaration of 'func' must be available</i>" der Fehlermeldung gibt den ersten Hinweis. func ist ein sogenannter nichtabhängiger (non-dependent) Name, denn er hängt nicht vom Template-Parameter <i>T</i> ab. Die Konsequenz ist es, dass der Compiler nicht die von <i>T</i> abhängig Basisklasse <i>Base&lt;T&gt;</i> berücksichtigt und es keinen Namen<i> func</i> außerhalb des Klassen-Templates gibt. </div><div class="text">Drei Workarounds bieten sich an, um bei der Namensauflösung die abhängige Basisklasse zu berücksichtigen. Das folgende Beispiel verwendet alle drei:</div><div class="pre">// templateInheritance2.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>class Base{<br>public:<br>&nbsp; void func1() const {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func1()" &lt;&lt; std::endl;<br>&nbsp; }<br>&nbsp; void func2() const {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func2()" &lt;&lt; std::endl;<br>&nbsp; }<br>&nbsp; void func3() const {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "func3()" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>template &lt;typename T&gt;<br>class Derived: public Base&lt;T&gt;{<br>public:<br>&nbsp; using Base&lt;T&gt;::func2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; void callAllBaseFunctions(){<br><br>&nbsp;&nbsp;&nbsp; this-&gt;func1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; func2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; Base&lt;T&gt;::func3();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp; }<br>};<br><br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Derived&lt;int&gt; derived;<br>&nbsp; derived.callAllBaseFunctions();<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text"><ul><li><b>Mach den Name abhängig</b>: Der Aufruf <i>this-&gt;func1 </i>in Zeile 1 ist abhängig, den<i> this</i> ist implizit abhängig. Die Namensauflösung berücksichtigt in diesem Fall alle Basisklassen.</li><li><b>Führe den Name in den aktuellen Bereich ein:</b> Der Ausdruck [i]using[/i] <i>Base&lt;T&gt;::func2</i> (Zeile 2) führt <i>func2</i>&nbsp; in den aktuellen Bereich ein.</li><li><b>Rufe den Name vollqualifiziert auf</b>: Indem du <i>func3</i> vollqualifiziert (Zeile 3) aufrufst, brichst du eventuell einen virtuellen Dispatch und bist offen für neue Überraschungen. <br></li></ul></div><div class="text">Zum Abschluss, die Ausgabe des Programms:</div><div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_167917706_855cf5bd62.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Ich möchte noch gerne mehr über abhängige Namen in meinen nächsten Artikel schreiben. Manchmal ist es notwendig, abhängige Namen mit <i>typename</i> oder <i>template</i> auszuzeichnen. Wenn du das, wie ich das erste Mal siehst, bist du vermutlich genauso überrascht wie ich. </div><div class="ztitel">C++-Schulungen im Großraum Stuttgart</div><div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div><div class="text"><ul><li> <a alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F3-c-11-und-c-14%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F3-c-11-und-c-14%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/3-c-11-und-c-14" title="Link auf https://www.modernescpp.de/index.php/c/2-c/3-c-11-und-c-14">C++11 und C++14</a>: 11. bis 13.03. (Termingarantie)<br></li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/18-generische-programmierung-templates-mit-c" href="https://www.modernescpp.de/index.php/c/2-c/18-generische-programmierung-templates-mit-c" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F18-generische-programmierung-templates-mit-c%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F18-generische-programmierung-templates-mit-c%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Generische%20Programmierung%20%28Templates%29%20mit%20C%2B%2B%22%2C%22target%22%3A%22_blank%22%7D">Generische Programmierung (Templates) mit C++</a>: 02. bis 04.04 </li><li> <a href="https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Embedded%20Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438">Embedded Programmierung mit modernem C++</a>: 21. bis 23.05 </li></ul> </div><div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a title="Link auf https://www.modernescpp.de/" href="https://www.modernescpp.de/" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D">www.ModernesCpp.de</a>. </div>
