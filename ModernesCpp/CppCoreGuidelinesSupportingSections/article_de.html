<div class="vorspann">In Summe habe ich in den letzten zwei Jahren rund 100 Artikel zu den C++ Core Guidelines verfasst. Warum? Weil: "This document is a set of guidelines for using C++ well. The aim of this document is to help people to use modern C++ effectively." Hier hört meine Geschichte aber noch nicht auf. Die C++ Core Guidelines besitzen unterstützende Abschnitte (supporting sections).<br></div><div class="text">100 Artikel sind eine ganze Menge. Bevor ich daher in die unterstützenden Abschnitte der Guidelines eintauche, stelle ich zwei Hilfen vor, damit du dich in den bereits existierenden Artikeln zu den Guidelines zurechtfindest.</div><div class="text"><ol><li> Die Kategorie <a href="https://www.grimm-jaud.de/index.php/blog/category/heise-news" alt="%7B%22version%22%3A1%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fheise-news%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fheise-news%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/heise-news">C++ Core Guidelines</a> auf meinem Blog enthält alle Artikel zu den Guidelines.<br></li><li>Den genauen Überblick liefert der Link zu dem TOC <a title="Link auf https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c" alt="%7B%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%26gt%3B%26gt%3BHier%20Starten%26lt%3B%26lt%3B%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fder-einstieg-in-modernes-c%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c">&gt;&gt;Hier Starten&lt;&lt;</a> aller Artikel. Hier ist auch ein Abschnitt zu den C++ Core Guidelines. <br></li></ol></div><div class="text">Jetzt geht es aber los. Dies sind alle unterstützenden Abschnitte:</div><div class="text"><ul><li>A: Architectural ideas</li><li>NR: Non-Rules and myths</li><li>RF: References</li><li>Pro: Profiles</li><li>GSL: Guidelines support library</li><li>NL: Naming and layout rules</li><li>FAQ: Answers to frequently asked questions</li><li>Appendix A: Libraries</li><li>Appendix B: Modernizing code</li><li>Appendix C: Discussion</li><li>Appendix D: Supporting tools</li><li>Glossary</li><li>To-do: Unclassified proto-rules</li></ul></div><div class="ztitel"><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-A" alt="%7B%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-A%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-A%22%2C%22version%22%3A1%2C%22text%22%3A%22A%3A%20Architectural%20ideas%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-A">A: Architectural ideas</a> </div><div class="text">Der erste Abschnitt ist sehr kurz. Er besteht nur aus drei Regeln mit ein paar Zeilen Erläuterungen. Der Fokus dieser Regel lässt sich auf alle Programmiersprachen anwenden.</div><div class="ztitel_kleiner"><a alt="%7B%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ra-stable%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ra-stable%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22A.1%3A%20Separate%20stable%20code%20from%20less%20stable%20code%26nbsp%3B%22%2C%22version%22%3A1%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ra-stable" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ra-stable">A.1: Separate stable code from less stable code&nbsp;</a><br></div><div class="text">Dies ist die Begründung der Regel: <i>"Isolating less stable code facilitates its unit testing, interface improvement, refactoring, and eventual deprecation."</i> Was bedeutet das? <br></div><div class="text">Dank eines Interfaces wird der stabile vom weniger stabilen Code separiert. Dank des Interfaces wird der weniger stabile Code zum Subsystem, das sich nun in Isolation testen oder refaktorieren lässt. Nicht nur das Subsystem, sondern auch die Integration des Subsystems in die Applikation lässt sich jetzt testen. Die erste Art von Test wird typischerweise Unit-Test, die zweite Art Systemintegrationstest genannt. </div><div class="text">Das Subsystem besitzt zwei Kanäle zur Applikation: den funktionalen und den nichtfunktionalen. Beide müssen getestet werden. Der funktionale Kanal steht für die Funktionalität der Subsysteme und der nichtfunktionale Kanal für die Ausnahmen, die passieren können und auf die die Applikation gegebenenfalls reagieren muss. Dank des Interfaces ist das Subsystem eine Implementierung des Interfaces und kann daher relativ einfach durch eine andere, stabilere Implementierung ersetzt werden. <br></div><div class="ztitel_kleiner"><a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ra-lib" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ra-lib%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ra-lib%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22A.2%3A%20Express%20potentially%20reusable%20parts%20as%20a%20library%26nbsp%3B%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ra-lib">A.2: Express potentially reusable parts as a library&nbsp;</a><br></div><div class="text">Das ist einleuchtend, aber es gibt in diesem Zusammenhang deutlich schwierigere Fragen zu beantworten.</div><div class="text"><ol><li> Wann lassen sich Teile der Software potenziell wiederverwenden?</li><li>Wann zahlen die Kosten für die Implementierung eine Bibliothek aus?</li><li>Welcher ist der richtige Grad der Abstraktion?</li></ol></div><div class="text">Die drei Fragen sind recht unscharf und daher relativ schwierig zu beantworten. Dies gilt insbesondere für die dritte Frage. Trotzdem versuche ich mich.</div><div class="text">Zuerst einmal investiere nicht allzu viel Aufwand in deinen Code, um ihn als Bibliothek wiederzuverwenden, denn es gilt allzu oft: "You aren't gonna need it" (<a href="https://en.wikipedia.org/wiki/You_aren't_gonna_need_it" title="Link auf https://en.wikipedia.org/wiki/You_aren't_gonna_need_it" alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FYou_aren%27t_gonna_need_it%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FYou_aren%27t_gonna_need_it%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22YAGNI%22%7D">YAGNI</a>). Schreibe deinen Code hingegen so, dass er wiederverwendet werden könnte. Dies bedeutet, dass dein Code einfachen Charakteristiken wie Testbarkeit, Pflegbarkeit, Verständlichkeit etc. genügen sollte, denn es ist sehr wahrscheinlich, dass du oder andere Programmierer in der Zukunft an den Code Hand anlegen müssen. Oder um es mit den Worten von Philip Wadler zu sagen: "<span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Make your code readable. Pretend the next person who looks at your code is a psychopath and he knows where you live."</span></div><div class="text">"Don't repeat yourself" (DRY), wenn du dieselbe oder ähnliche Funktionalität nochmals benötigst. <span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Nun solltest du spätestens über Abstraktion nachdenken. Wenn ich zwei ähnliche Funktionen habe, schreibe ich eine dritte Funktion, die für die Implementierung steht. Die zwei ursprünglichen Funktionen dienen mir dann nur noch als Aufruf-Wrapper für die Implementierung. Hier ist meine Idee, in Code gegossen. </span></div><div class="pre"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">std::vector&lt;void*&gt; myAlloc;<br><br>void* newImpl(std::size_t sz,char const* file, int line){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; static int counter{};<br>&nbsp;&nbsp;&nbsp; void* ptr= std::malloc(sz);<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; file &lt;&lt; ": " &lt;&lt; line &lt;&lt; " " &lt;&lt;&nbsp; ptr &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; myAlloc.push_back(ptr);<br>&nbsp;&nbsp;&nbsp; return ptr;<br>}<br><br>void* operator new(std::size_t sz,char const* file, int line){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; return newImpl(sz,file,line);<br>}<br><br>void* operator new [](std::size_t sz,char const* file, int line){&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp;&nbsp; return newImpl(sz,file,line);<br>}</span></div><div class="text">Die überladen<i>en new</i>-Operatoren in der einfachen Form (Zeile 1) und in der Form für Arrays (Zeile 2) rufen die Implementierung in der Zeile 3 auf.</div><div class="text"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Ich kann die Frage 3 nicht beantworten, denn die Antwort hängt von vielen Faktoren ab. Zum Beispiel von der Domäne der Software. Soll die Software zum Beispiel auf einem Desktop, Embedded-Gerät oder Trading-Server ausgeführt werden. Die Antwort hängt von Faktoren wie der Pflegbarkeit, Testbarkeit, Skalierbarkeit oder von der Performanz ab. Sie hängt vom Kenntnisstand der Entwickler. Eventuell stellt deine Bibliothek Infrastruktur dar, auf der höhere Abstraktionen entstehen sollen, oder sie ist für Kunden geschrieben. </span></div><div class="text"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Wiederverwendbare Software in der Form einer Bibliothek ist um den Faktor 3 bis 4 aufwendiger als Software, die nur einmal eingesetzt wird. Hier ist meine Daumenregel: <b>Du solltest über eine Bibliothek nachdenken, denn du weißt, dass die Funktionalität wiederverwendet wird. Du solltest eine Bibliothek implementieren, wenn du die Funktionalität mindestens zweimal wiederverwendest.</b><br></span></div><div class="ztitel_kleiner"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0"> <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ra-dag" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ra-dag" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22A.4%3A%20There%20should%20be%20no%20cycles%20among%20libraries%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ra-dag%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ra-dag%22%7D">A.4: There should be no cycles among libraries</a> </span>&nbsp;<br></div><div class="text">Durch Zyklen zwischen Bibliotheken<span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0"> wird deine Software komplizierter. Zuerst werden die Bibliotheken schwieriger zu testen und lassen sich nicht wiederverwenden. Darüber hinaus werden die Bibliotheken deutlich schwieriger zu verstehen und zu erweitern. Wenn du daher einen Zyklus entdeckst, solltest du diesen brechen. <a href="https://codedive.pl/index/speaker/name/john-lakos" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcodedive.pl%2Findex%2Fspeaker%2Fname%2Fjohn-lakos%22%2C%22destination%22%3A%22https%3A%2F%2Fcodedive.pl%2Findex%2Fspeaker%2Fname%2Fjohn-lakos%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22John%20Lakos%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://codedive.pl/index/speaker/name/john-lakos">John Lakos</a> beschreibt diese auf der Seite 185 seines Buchs "</span><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Large Scale C++ Software Design": </span></div><div class="text"><ul><li>Repackage <i>c1 </i>and <i>c2</i> so they are no longer mutually dependent.</li><li>Pysically combine <i>c1</i> and <i>c2</i> into a single component, <i>c12</i>.</li><li>Think of <i>c1</i> and <i>c2</i> as if they were a single component, <i>c12</i>.</li></ul></div><div class="ztitel"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Wie geht's weiter? </span></div><div class="text"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Der nächste unterstützende Abschnitt zu den Non-Rules und Mythen besitzt deutlich mehr Inhalt. Ich vermute, du kennst bereits die meisten der Non-Rules als Mythen. Lasse sie mich im nächsten Artikel entmystifizieren.<br></span></div><div class="simple-translate-result-wrapper"><br> <br></div>