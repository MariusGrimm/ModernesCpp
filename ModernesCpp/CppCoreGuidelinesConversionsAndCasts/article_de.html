<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148426752_e4a6128d19.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Was haben Konvertierungen und Casts gemein? Sie sind sehr häufig die Ursache von Fehlern. Daher geht es nun um typische Fehler.</div>
<div class="text">Hier sind die Regeln der Guidelines:</div>
<div class="text"><ul><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.46%3A%20Avoid%20narrowing%20conversions%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-narrowing%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-narrowing%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing">ES.46: Avoid narrowing conversions</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts" alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.48%3A%20Avoid%20casts%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts%22%2C%22anchor%22%3A%22%22%7D">ES.48: Avoid casts</a> </li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22ES.49%3A%20If%20you%20must%20use%20a%20cast%2C%20use%20a%20named%20cast%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-named%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-named%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named">ES.49: If you must use a cast, use a named cast</a> </li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const" alt="%7B%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-const%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-const%22%2C%22text%22%3A%22ES.50%3A%20Don%C2%92t%20cast%20away%26nbsp%3Bconst%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const">ES.50: Don’t cast away&nbsp;const</a></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-range-checking" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-range-checking%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-range-checking%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.55%3A%20Avoid%20the%20need%20for%20range%20checking%22%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-range-checking">ES.55: Avoid the need for range checking</a></li></ul></div>
<div class="text">Verengende Konvertierung (narrowing conversion) ist eine Konvertierung, die mit einem Verlust der Datengenauigkeit einhergeht. Meistens ist das nicht im Sinne des Autors.</div>
<div class="text"><b><a alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.46%3A%20Avoid%20narrowing%20conversions%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-narrowing%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-narrowing%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing" class="">ES.46: Avoid narrowing conversions</a></b></div>
<div class="text">Hier sind ein paar Beispiele aus den Guidelines:<br></div>
<div class="pre">double d = 7.9;<br>int i = d;&nbsp;&nbsp;&nbsp; // bad: narrowing: i becomes 7<br>i = (int) d;&nbsp; // bad: we're going to claim this is still not explicit enough<br><br>void f(int x, long y, double d)<br>{<br>&nbsp;&nbsp;&nbsp; char c1 = x;&nbsp;&nbsp; // bad: narrowing<br>&nbsp;&nbsp;&nbsp; char c2 = y;&nbsp;&nbsp; // bad: narrowing<br>&nbsp;&nbsp;&nbsp; char c3 = d;&nbsp;&nbsp; // bad: narrowing<br>}<br></div>
<div class="text">Falls du verengende Konvertierung anwenden willst, solltest du es explizit und nicht implizit tun. Dies ist gemäß der Python-Regel aus "<a href="https://www.python.org/dev/peps/pep-0020/" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22The%20Zen%20of%20Python%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0020%2F%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0020%2F%22%2C%22ir_link%22%3A1%7D" title="Link auf https://www.python.org/dev/peps/pep-0020/" class="">The Zen of Python</a>": "Explit is betten than implict<i><b>."</b></i> Die Guideline Support Library (GSL) besitzt zwei Casts, um die Intention auf den Punkt zu bringen: <i>gsl::narrow_cast</i> und <i>gsl::narrow</i>.<br></div>
<div class="pre">double d = 7.9;<br>i = narrow_cast&lt;int&gt;(d);&nbsp;&nbsp; // OK (you asked for it): narrowing: i becomes 7<br>i = narrow&lt;int&gt;(d);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK: throws narrowing_error<br></div>
<div class="text">Der <i>gsl::narrow_cast </i>führt den Cast aus und der <i>gsl::narrow Cast </i>wirft eine Ausnahme, falls eine verengende Konvertierung stattfindet. </div>
<div class="text">Meistens passiert die verengende Konvertierung heimlich. Wie kannst du dich davor schützen? Wende geschweifte Klammern an:&nbsp; <br></div>
<div class="pre">void f(int x, long y, double d){<br>&nbsp;&nbsp;&nbsp; char c1 = {x};&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; char c2 = {y};&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; char c3 = {d};&nbsp; &nbsp;<br>}<br><br>int main(){<br><br>&nbsp; double d = {7.9};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; int i = {d};&nbsp;&nbsp; &nbsp;<br><br>&nbsp; f(3, 3l, 3.0);<br>}</div>
<div class="text">Alle Initialisierungen habe ich in geschweifte Klammern verpackt. Entsprechend dem C++11-Standard, muss mich der Compiler warnen, wenn eine verengende Konvertierung stattfindet.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148426789_e68b8b4d1a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">"Explicit is better than implicit." Dieser Grundsatz gilt nicht für C-Casts. </div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.48%3A%20Avoid%20casts%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">ES.48: Avoid casts</a></b></div>
<div class="text">Was passiert, wenn ich das Typsystem pervertiere?</div>
<div class="pre">// casts.cpp<br><br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp; double d = 2;<br>&nbsp; auto p = (long*)&amp;d;<br>&nbsp; auto q = (long long*)&amp;d;<br>&nbsp; std::cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; *q &lt;&lt; '\n';<br>&nbsp; <br>}<br></div>
<div class="text">Weder das Ergebnis mit dem Visual Studio Compiler</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148426760_7b28401149.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">noch das Ergebnis mit dem GCC- oder Clang-Compiler ist beruhigend:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148426768_f72a92f02b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Was ist schlecht am C-Cast? Du kannst nicht erkennen, welcher Cast angewandt wurde. Falls du einen C-Cast verwendest, wird vereinfachend gesprochen, eine Kombination von Casts gegebenenfalls angewendet. Los geht es mit dem <i>static_cast</i>, gefolgt vom <i>const_cast</i> und zuletzt der <i>reinterpret_cast</i>. </div>
<div class="text">Natürlich ahnst du bereits, wie es weitergeht: "Explicit is better than implict." </div>
<div class="text"><b><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.49%3A%20If%20you%20must%20use%20a%20cast%2C%20use%20a%20named%20cast%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-named%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-named%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">ES.49: If you must use a cast, use a named cast</a></b></div>
<div class="text">Rechne ich die GSL hinzu, bietet C++ acht verschiedene Casts an. Hier sind sie inklusive einer kurzen Beschreibung:</div>
<div class="text"><ul><li><i>static_cast</i>: konvertiert zwischen ähnlichen Datentypen wie Zeiger oder numerischen Typen<br></li><li><i>const_cast</i>: entfernt oder fügt <i>const</i> und <i>volatile</i> hinzu<br></li><li><i>reinterpret_cast</i>: Konvertieren zwischen Zeigern oder zwischen integralen Datentypen und Zeigern<br></li><li><i>dynamic_ cast:</i> konvertiert zwischen polymorphen Zeigern oder Referenzen in derselben Klassenhierarchie<br></li><li><i>std::move:</i> konvertiert in eine Rvalue-Referenz<br></li><li><i>std::forward</i>: konvertiert in eine Rvalue-Referenz<br></li><li><i>gsl::narrow_cast</i>: wendet ein <i>static_cast </i>an<br></li><li><i>gsl::narrow</i>: wendet ein <i>static_cast </i>an<i><br></i></li></ul></div>
<div class="text"><i>std::move</i> und <i>std::forward</i> sind Casts? Lasse mich einen genaueren Blick darauf werfen, was <i>std::move</i> unter der Decke tut:<br></div>
<div class="pre">static_cast&lt;std::remove_reference&lt;decltype(arg)&gt;::type&amp;&amp;&gt;(arg)<br></div>
<div class="text">Zuerst wird der Typ des Arguments <i>arg </i>mithilfe von <i>decltype(arg)</i> bestimmt. Danach werden alle Referenzen entfernt und zwei neue hinzugefügt. Die Funktion <i>std::remove_reference</i> ist aus der Type-Traits-Bibliothek. Ich habe bereits ein paar Artikel zur <a href="http://www.grimm-jaud.de/index.php/blog/tag/type-traits" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftype-traits%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftype-traits%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/type-traits" class="">Type-Traits-Bibliothek</a> geschrieben. Am Ende erhalten wir immer eine Rvalue-Referenz. </div>
<div class="text">Die Eigenschaft <i>const</i> von einem Objekt wegzucasten, stellt undefiniertes Verhalten dar.</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const" alt="%7B%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.50%3A%20Don%C2%92t%20cast%20away%26nbsp%3Bconst%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-const%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-casts-const%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const" class="">ES.50: Don’t cast away&nbsp;const</a></b></div>
<div class="text">Jetzt muss ich ein wenig genauer argumentieren. <i>const</i> von einem Objekt wegzucasten, stellt undefiniertes Verhalten dar, falls das Objekt wie <i>constInt </i>nicht veränderlich war: <br></div>
<div class="pre">const int constInt = 10;<br>const int* pToConstInt = &amp;constInt;<br>&nbsp;<br>int* pToInt = const_cast&lt;int*&gt;(pToConstInt);<br>*pToInt = 12;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // undefined behaviour<br></div>
<div class="text">Falls du mir nicht glaubst, es gibt ein Fußnote in C-Standard [ISO/IEC 9899:2011] (subclause 6.7.3, paragraph 4), der Relevanz für den C++-Standard besitzt: "The implementation may place a const object that is not volatile in a read-only region of storage. Moreover, the implementation need not allocate storage for such an object if its address is never used." <br></div>
<div class="text">Habe ich nicht veränderlich geschrieben? Veränderlich oder <i>mutable</i> ist eines der unbekanntesten Features in C++. <i>mutable</i> erlaubt es, zwischen der bitweisen und logischen Konstanz eines Objekts zu unterscheiden. Was? <br></div>
<div class="text">Stelle dir vor, du sollst eine Schnittstelle zu einem Telefonbuch implementieren. Der Einfachheit halber landen dabei die Einträge in einem <i>std::unordered_map</i>.<br></div>
<div class="pre">// teleBook.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;unordered_map&gt;<br><br>std::unordered_map&lt;std::string, int&gt; getUpdatedTelephoneBook(){<br>&nbsp;&nbsp;&nbsp; // generate a new, updated telephone book<br>&nbsp;&nbsp;&nbsp; return {{"grimm",123}, {"huber", 456}, {"schmidt", 321}};<br>}<br><br>class TelephoneBook{<br>public:<br>&nbsp;&nbsp;&nbsp; int getNumber(const std::string&amp; name) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto ent = cache.find(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ent != cache.end()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ent-&gt;second;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache = getUpdatedTelephoneBook();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cache[name];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt; cache = {{"grimm",123}, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"huber", 456}};<br>};<br><br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; TelephoneBook telBook;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "grimm " &lt;&lt; telBook.getNumber("grimm") &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "schmidt " &lt;&lt; telBook.getNumber("schmidt") &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Das Telefonbuch (1) ist sehr klein. Normalerweise ist es deutlich größer, und es zu aktualisieren ist eine teure Operation (2). Das bedeutet, die Aktualisierung eines Telefonbuchs findet nur einmal jährlich statt. Vom konzeptionellen Blickwinkel betrachtet, sollte das <i>teleBook</i> (3) konstant sein. Dies ist nicht möglich, da die <i>std::unorderd_map </i>in der Funktion <i>getNumber</i> verändert wird. Hier ist der Beweis in roten Ellipsen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148426775_45b227cb4e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">Der Qualifizierer <i>mutable</i> erlaubt es, zwischen der bitweisen und der logischen Konstanz zu unterscheiden. Das Telefonbuch ist logisch, aber nicht bitweise konstant. <br></div>
<div class="pre">// teleBook.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;unordered_map&gt;<br><br>std::unordered_map&lt;std::string, int&gt; getUpdatedTelephoneBook(){<br>&nbsp;&nbsp;&nbsp; // generate a new, updated telephone book<br>&nbsp;&nbsp;&nbsp; return {{"grimm",123}, {"huber", 456}, {"schmidt", 321}};<br>}<br><br>class TelephoneBook{<br>public:<br>&nbsp;&nbsp;&nbsp; int getNumber(const std::string&amp; name) const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto ent = cache.find(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ent != cache.end()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ent-&gt;second;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache = getUpdatedTelephoneBook();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cache[name];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; mutable std::unordered_map&lt;std::string, int&gt; cache = {{"grimm",123}, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"huber", 456}};<br>};<br><br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; const TelephoneBook telBook;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "grimm " &lt;&lt; telBook.getNumber("grimm") &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "schmidt " &lt;&lt; telBook.getNumber("schmidt") &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Ich füge lediglich<i> const</i> (3) zu <i>telBoo</i>k hinzu und <i>mutable</i> zu <i>cache </i>(1). Damit verhält sich das Programm wie erwartet.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_148426778_809d7f0758.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-range-checking" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-range-checking" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22ES.55%3A%20Avoid%20the%20need%20for%20range%20checking%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-range-checking%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-range-checking%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D">ES.55: Avoid the need for range checking</a></b></div>
<div class="text">Jetzt kann ich mich kurz halten. Falls die Range-basierte <i>for</i>-Anweisung oder Algorithmen der STL zum Einsatz kommen, gibt es keine Notwendigkeit, die Bereichsgrenzen zu prüfen.<br></div>
<div class="pre">std::array&lt;int, 10&gt; arr = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; <br>std::sort(arr.begin(), arr.end());<br>for (auto a : arr) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; a &lt;&lt; " ";<br>}&nbsp;&nbsp; <br>// 0 1 2 3 4 5 6 7 8 9<br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">In meinem nächsten Artikel zu Expressions werde ich über <i>std::move, new </i>und <i>delete</i> und <i>slicing</i> schreiben. <i>Slicing</i> ist wohl eines der dunkelsten Ecken von C++. </div>