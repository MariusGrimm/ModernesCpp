<div class="vorspann">Gemäß den C++ Core Guidelines gilt, dass "Templates are the backbone of C++’s support for generic programming and class hierarchies the backbone of its support for object-oriented programming. The two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided." Genau um diese Fallen geht es in dem heutigen Artikel.</div>
<div class="text">Dieser Artikel besteht aus fünf Regeln.</div>
<div class="vorspann"><ul><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-hier" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-hier" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-hier%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-hier%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.80%3A%20Do%20not%20naively%20templatize%20a%20class%20hierarchy%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%7D">T.80: Do not naively templatize a class hierarchy</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-array" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-array" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-array%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-array%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.81%3A%20Do%20not%20mix%20hierarchies%20and%20arrays%22%7D">T.81: Do not mix hierarchies and arrays</a> </li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-linear" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-linear" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-linear%22%2C%22text%22%3A%22T.82%3A%20Linearize%20a%20hierarchy%20when%20virtual%20functions%20are%20undesirable%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-linear%22%2C%22ir_link%22%3A1%7D">T.82: Linearize a hierarchy when virtual functions are undesirable</a> </li><li>T<a alt="%7B%22text%22%3A%22.83%3A%20Do%20not%20declare%20a%20member%20function%20template%20virtual%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-virtual%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-virtual%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-virtual" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-virtual">.83: Do not declare a member function template virtual</a> </li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-abi" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-abi" alt="%7B%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-abi%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-abi%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.84%3A%20Use%20a%20non-template%20core%20implementation%20to%20provide%20an%20ABI-stable%20interface%22%7D">T.84: Use a non-template core implementation to provide an ABI-stable interface</a></li></ul></div>
<div class="text">Die Regel T.81 besitzt nur einen leichten Bezug zu Templates und zur Ableitungshierarchie und die Regel T.82 ist leer. Daher konzentriere ich mich im heutigen Artikel auf die drei verbleibenden Regeln.</div>
<div class="text">Über die Regeln T.80 und T.84 werde ich zusammenschreiben, denn T.84 setzt die Geschichte von T.80 fort.<br></div>
<div class="ztitel"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-hier" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-hier" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.80%3A%20Do%20not%20naively%20templatize%20a%20class%20hierarchy%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-hier%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-hier%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%7D">T.80: Do not naively templatize a class hierarchy</a> und <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-abi%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.84%3A%20Use%20a%20non-template%20core%20implementation%20to%20provide%20an%20ABI-stable%20interface%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-abi%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-abi" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-abi">T.84: Use a non-template core implementation to provide an ABI-stable interface</a></div>
<div class="text">Hier ist das Beispiel aus der naiven Template-Hierarchie aus den Guidelines: </div>
<div class="pre">template&lt;typename T&gt;<br>struct Container {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // an interface<br>&nbsp;&nbsp;&nbsp; virtual T* get(int i);<br>&nbsp;&nbsp;&nbsp; virtual T* first();<br>&nbsp;&nbsp;&nbsp; virtual T* next();<br>&nbsp;&nbsp;&nbsp; virtual void sort();<br>};<br><br>template&lt;typename T&gt;<br>class Vector : public Container&lt;T&gt; {<br>public:<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>Vector&lt;int&gt; vi;<br>Vector&lt;string&gt; vs;</div>
<div class="text">Warum ist diese Implementierung gemäß der Guidelines naiv? Insbesondere deswegen, da die Basisklasse <i>Container</i> mehrere virtuelle Funktionen enthält. Dies ist zu viel Code. Virtuelle Funktionen werden in einem Klassen-Template immer instanziiert. Im Gegensatz dazu werden nichtvirtuelle Funktionen nur dann instanziiert, wenn sie verwendet werden.</div>
<div class="text">Ein einfacher Test mit <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CppInsight%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%7D" href="https://cppinsights.io/" class="" title="Link auf https://cppinsights.io/">CppInsight</a> belegt meine Aussage.</div>
<div class="ztitel_kleiner">Nichtvirtuelle Funktionen</div>
<div class="text">Das folgende Programm verwendet einen <i>std::vector&lt;int&gt;</i> und einen <i>std::vector&lt;std::string&gt;:</i></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164338375_d141409a58.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">CppInsight bringt es auf den Punkt. Für <i>std::vector</i> wird keine Funktion erzeugt:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164338378_3eb5170a6c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Virtuelle Funktionen</div>
<div class="text">Dies ist das vereinfachte Programm aus den Guidelines, dass eine virtuelle Funktion <i>sort</i> enthält:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164338386_a4669e561d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt wird die virtuelle Funktion <i>sort </i>instanziiert. Der Screenshot zeigt lediglich die Ausgabe von CppInsight, die die Instanziierung des Klassen-Templates <i>Container</i> enthält:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164338394_b2e4a30848.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text">In Summe erhalte ich 100 Zeilen Code, wenn ich die virtuelle Funktion verwende.</div>
<div class="text">Die Guidelines geben einen Tipp, wie sich die Codegröße reduzieren lässt. Oft lässt sich ein robustes Interface definieren, in dem die Basisklasse nicht parametrisiert wird. Das bringt mich direkt zur verwandten Regel T.84: <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-abi%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Use%20a%20non-template%20core%20implementation%20to%20provide%20an%20ABI-stable%20interface%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-abi%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-abi" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-abi">Use a non-template core implementation to provide an ABI-stable interface</a>.<br> </div>
<div class="text">Zu der Regel habe ich bereits in dem Artikel "<a alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A2558070%2C%22ir_link%22%3A1%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D6053000053fcf33341417e93e36493cc%26rm%3Dopen_article_id%26bid%3D2558070%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22B%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Template-Definitionen%22%2C%22target%22%3A%22%22%7D" class="" title="Link auf Beitrag 2558070" href="/exec/mainmenu.pl?sid=6053000053fcf33341417e93e36493cc&amp;rm=open_article_id&amp;bid=2558070">C++ Core Guidelines: Template-Definitionen</a>" geschrieben. </div>
<div class="text">Die Regel gibt aber einen weiteren Tipp für ein stabiles Interface: <a class="" title="Link auf https://www.modernescpp.com/index.php/c-core-guidelines-template-definitons" href="https://www.modernescpp.com/index.php/c-core-guidelines-template-definitons" alt="%7B%22text%22%3A%22Pimpl%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fc-core-guidelines-template-definitons%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fc-core-guidelines-template-definitons%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">Pimpl</a>.</div>
<div class="ztitel_kleiner">Pimpl</div>
<div class="text">Pimpl steht für "<b>p</b>ointer to <b>impl</b>ementation" und bedeutet, dass eine Klasse ihre Interna in einer separaten Klasse platziert, auf die sie mittels eines Zeigers zugreift. Diese Technik sollte sich in der Werkzeugkiste jedes ernsthaften C++ Programmierers befinden. Pimpl wird auch gerne "compilation firewall" genannt, denn dies Technik bricht die Abhängigkeit zwischen der Implementierung und dem Nutzer der Klassen-Hierarchie. Dies heißt, dass die Implementierung verändert werden kann, ohne den Code zu zu kompilieren. Die Details dazu gibt es in Herb Sutters Blog: <a title="Link auf http://herbsutter.com/gotw/_100/" class="" href="http://herbsutter.com/gotw/_100/" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fherbsutter.com%2Fgotw%2F_100%2F%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22GotW%20%23100%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fherbsutter.com%2Fgotw%2F_100%2F%22%7D">GotW #100</a>: Compilation Firewalls:<br> </div>
<div class="pre">// in header file <br>class widget { <br>public: <br>&nbsp;&nbsp;&nbsp; widget(); <br>&nbsp;&nbsp;&nbsp; ~widget(); <br>private: <br>&nbsp;&nbsp;&nbsp; class impl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; unique_ptr&lt;impl&gt; pimpl; <br>}; <br>&nbsp;&nbsp;&nbsp; <br>// in implementation file&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>class widget::impl { <br>&nbsp;&nbsp;&nbsp; // ::: <br>}; <br><br>widget::widget() : pimpl{ new impl{ /*...*/ } } { } <br>widget::~widget() { } </div>
<div class="text">Dies sind die Charakteristiken des Idioms.</div>
<div class="text"><ol><li> Verschiebt alle privaten nichtvirtuellen Funktion nach <i>impl</i> (1)</li><li>Deklariert <i>impl</i> <i>vorwärts</i></li><li>Definiert <i>impl</i> in der entsprechenden Implemtationdatei (3)<br></li></ol></div>
<div class="text">Gerne zeige ich noch das vollständige Beispiel von <a class="" title="Link auf https://en.cppreference.com/w/cpp/language/pimpl" href="https://en.cppreference.com/w/cpp/language/pimpl" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fpimpl%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fpimpl%22%2C%22text%22%3A%22cppreference.com%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D">cppreference.com</a>:</div>
<div class="pre">// pimpl.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br>&nbsp;<br>// interface (widget.h)<br>class widget {<br>&nbsp;&nbsp;&nbsp; class impl;<br>&nbsp;&nbsp;&nbsp; std::unique_ptr&lt;impl&gt; pImpl;<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; void draw();<br>&nbsp;&nbsp;&nbsp; bool shown() const { return true; } <br>&nbsp;&nbsp;&nbsp; widget(int);<br>&nbsp;&nbsp;&nbsp; ~widget(); <br>&nbsp;&nbsp;&nbsp; widget(widget&amp;&amp;) = default;&nbsp; <br>&nbsp;&nbsp;&nbsp; widget(const widget&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; widget&amp; operator=(widget&amp;&amp;); <br>&nbsp;&nbsp;&nbsp; widget&amp; operator=(const widget&amp;) = delete;<br>};<br>&nbsp;<br>// implementation (widget.cpp)<br>class widget::impl {<br>&nbsp;&nbsp;&nbsp; int n; // private data<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; void draw(const widget&amp; w) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(w.shown())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "drawing a widget " &lt;&lt; n &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; impl(int n) : n(n) {}<br>};<br>void widget::draw() { pImpl-&gt;draw(*this); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>widget::widget(int n) : pImpl{std::make_unique&lt;impl&gt;(n)} {}<br>widget::~widget() = default;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>widget&amp; widget::operator=(widget&amp;&amp;) = default;<br>&nbsp;<br>// user (main.cpp)<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; widget w(7);<br>&nbsp;&nbsp;&nbsp; w.draw();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>}</div>
<div class="text">Der <i>draw-</i>Aufruf der Klasse<i> impl</i> verwendet eine Rückwärtsreferenz auf<i> widget </i>(Zeile (1) und (2)). Der Destruktor und der Move-Zuweisungsoperator (Zeile (3)) müssen in der Implementierungsdatei definiert werden, denn <i>std::unique_ptr </i>verlangt, dass der Datentyp, auf den er verweist, vollständig ist. </div>
<div class="text">Das Programm verhält sich erwartungsgemäß:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164338399_5d91a2d64d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Neben seinen Vorteilen besitzt das Pimpl-Idiom auch zwei Nachteile: Zum einen enthält es einen zusätzliche Zeiger Indirektion, zum anderen muss der Zeiger gespeichert werden.</div>
<div class="text">Die letzte Regel des heutigen Artikels handelt von einem typischen Fehler. </div>
<div class="ztitel">T<a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-virtual" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-virtual" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-virtual%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22.83%3A%20Do%20not%20declare%20a%20member%20function%20template%20virtual%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-virtual%22%7D">.83: Do not declare a member function template virtual</a></div>
<div class="text">Lass mich ein virtuelles Methoden-Template verwenden:</div>
<div class="pre">// virtualMember.cpp<br><br>class Shape {<br>&nbsp;&nbsp;&nbsp; template&lt;class T&gt;<br>&nbsp;&nbsp;&nbsp; virtual bool intersect(T* p);<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Shape shape;<br><br>}</div>
<div class="text">Die Fehlermeldung meines GCC-8.2-Compilers spricht eine eindeutige Sprache:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164338402_262b43058e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Die nächsten Regeln und daher mein nächster Artikel befassen sich mit Variadic Templates. Das sind Templates, die beliebig viele Argumente annehmen können. Die Regeln in den Guidelines, wie viele Regeln zu Templates bestehen nur auf Überschriften. Das bedeutet, dass mein nächster Artikel zu Variadic Templates allgemeiner Natur sein wird.<br></div>