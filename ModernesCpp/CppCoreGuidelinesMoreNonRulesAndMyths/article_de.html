<div class="vorspann">Nichtregeln und Mythen zu entlarven ist ein mühsamer aber notwendiger Job. Das Ziel hingegen ist offensichtlich: Setze die mächtige Programmiersprache C++ richtig ein.</div><div class="text">Ich kann es mir nicht verkneifen: Mein Familienname qualifiziert mich in besonderer Weise, über das Entlarven der Mythen zu schreiben. Hier sind die Regeln der C++ Core Guidelines, mit denen sich der Artikel heute beschäftigt.</div><div class="vorspann"><ul><li> <a alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-two-phase-init%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22NR.5%3A%20Don%C2%92t%3A%20Don%C2%92t%20do%20substantive%20work%20in%20a%20constructor%3B%20instead%20use%20two-phase%20initialization%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-two-phase-init%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-two-phase-init" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-two-phase-init">NR.5: Don’t: Don’t do substantive work in a constructor; instead use two-phase initialization</a> </li><li> <a alt="%7B%22text%22%3A%22NR.6%3A%20Don%C2%92t%3A%20Place%20all%20cleanup%20actions%20at%20the%20end%20of%20a%20function%20and%20goto%20exit%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-goto-exit%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-goto-exit%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-goto-exit" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-goto-exit">NR.6: Don’t: Place all cleanup actions at the end of a function and goto exit</a> </li></ul></div><div class="ztitel"><a alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22NR.5%3A%20Don%C2%92t%3A%20Don%C2%92t%20do%20substantive%20work%20in%20a%20constructor%3B%20instead%20use%20two-phase%20initialization%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-two-phase-init%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-two-phase-init%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-two-phase-init" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-two-phase-init">NR.5: Don’t: Don’t do substantive work in a constructor; instead use two-phase initialization</a></div><div class="text">Vollkommen klar, dies ist der Job des Konstruktors: <b>Nachdem er fertig ist, soll das Objekt vollständig initialisiert sein. </b>Genau aus diesem Grund steht das Beispiel aus den Guidelines für schlechten Code:</div><div class="pre">class Picture<br>{<br>&nbsp;&nbsp;&nbsp; int mx;<br>&nbsp;&nbsp;&nbsp; int my;<br>&nbsp;&nbsp;&nbsp; char * data;<br>public:<br>&nbsp;&nbsp;&nbsp; Picture(int x, int y)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx = x,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my = y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = nullptr;&nbsp;&nbsp; <br>}<br><br>&nbsp;&nbsp;&nbsp; ~Picture()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cleanup();<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; bool Init()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // invariant checks<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mx &lt;= 0 || my &lt;= 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = (char*) malloc(x*y*sizeof(int));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return data != nullptr;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; void Cleanup()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data) free(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = nullptr;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>Picture picture(100, 0); // not ready-to-use picture here<br>// this will fail..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>if (!picture.Init()) {<br>&nbsp;&nbsp;&nbsp; puts("Error, invalid picture");<br>}<br>// now have a invalid picture object instance.<br></div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/image/rte/textbox.svg" title="<ir_inline itemname=textboxen_mvp_text:1 type=1>" style="max-height: 25px; max-width: 25px;"></div><div class="text">[code]picture(100, 0)[/code] ist nicht vollständig initialisiert, sodass alle Aktionen auf <i>picture </i>in Zeile 1 auf einem ungültigen [code]picture[/code] basieren. Die Lösung des Problems ist so einfach wie effektiv: Stecke die Initialisierung in den Konstruktor:</div><div class="pre">class Picture<br>{<br>&nbsp;&nbsp;&nbsp; size_t mx;<br>&nbsp;&nbsp;&nbsp; size_t my;<br>&nbsp;&nbsp;&nbsp; vector&lt;char&gt; data;<br><br>&nbsp;&nbsp;&nbsp; static size_t check_size(size_t s)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // invariant check<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expects(s &gt; 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s;<br>&nbsp;&nbsp;&nbsp; }<br><br>public:<br>&nbsp;&nbsp;&nbsp; // even more better would be a class for a 2D Size as one single parameter<br>&nbsp;&nbsp;&nbsp; Picture(size_t x, size_t y)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : mx(check_size(x))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , my(check_size(y))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // now we know x and y have a valid size<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , data(mx * my * sizeof(int)) // will throw std::bad_alloc on error<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // picture is ready-to-use<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // compiler generated dtor does the job. (also see C.21)<br>};</div><div class="text">Zusätzlich ist [code]data[/code] in dem zweiten Beispiel ein [code]std::vector[/code] und kein nackter Zeiger. Das heißt, dass die <i>Cleanup-</i>Funktion (Zeile 2) im ersten Beispiel nicht mehr notwendig ist, da der Compiler automatisch aufräumt. Dank der statischen Funktion [code]check_size[/code] kann der Konstruktor seine Argumente prüfen. Dies sind aber noch nicht alle Vorteile, die uns modernes C++ beschert. </div><div class="text">Oft wird ein Konstruktor nur dazu verwendet, um das Defaultverhalten der Objekte zu setzen. Tue es nicht. Setze das Defaultverhalten der Objekte im Klassenkörper. Die folgenden Klassen [code]Widget[/code] und [code]WidgetImpro[/code] bringen dieses praktische Feature auf den Punkt:</div><div class="pre">// classMemberInitialiserWidget.cpp<br><br>#include &lt;iostream&gt;<br><br>class Widget{<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; Widget(): width(640), height(480), frame(false), visible(true) {}<br>&nbsp;&nbsp;&nbsp; explicit Widget(int w): width(w), height(getHeight(w)), frame(false), visible(true){}<br>&nbsp;&nbsp;&nbsp; Widget(int w, int h): width(w), height(h), frame(false), visible(true){}<br><br>&nbsp;&nbsp;&nbsp; void show(){ std::cout &lt;&lt; std::boolalpha &lt;&lt; width &lt;&lt; "x" &lt;&lt; height<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; ", frame: " &lt;&lt; frame &lt;&lt; ", visible: " &lt;&lt; visible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; int getHeight(int w){ return w*3/4; }<br>&nbsp;&nbsp;&nbsp; int width;<br>&nbsp;&nbsp;&nbsp; int height;<br>&nbsp;&nbsp;&nbsp; bool frame;<br>&nbsp;&nbsp;&nbsp; bool visible;<br>};<br><br>class WidgetImpro{<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; WidgetImpro(){}<br>&nbsp;&nbsp;&nbsp; explicit WidgetImpro(int w): width(w), height(getHeight(w)){}<br>&nbsp;&nbsp;&nbsp; WidgetImpro(int w, int h): width(w), height(h){}<br><br>&nbsp;&nbsp;&nbsp; void show(){ std::cout &lt;&lt; std::boolalpha &lt;&lt; width &lt;&lt; "x" &lt;&lt; height<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; ", frame: " &lt;&lt; frame &lt;&lt; ", visible: " &lt;&lt; visible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; int getHeight(int w){ return w * 3 / 4; }<br>&nbsp;&nbsp;&nbsp; int width = 640;<br>&nbsp;&nbsp;&nbsp; int height = 480;<br>&nbsp;&nbsp;&nbsp; bool frame = false;<br>&nbsp;&nbsp;&nbsp; bool visible = true;<br>};<br><br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Widget wVGA;<br>&nbsp; Widget wSVGA(800);<br>&nbsp; Widget wHD(1280, 720);<br><br>&nbsp; wVGA.show();<br>&nbsp; wSVGA.show();<br>&nbsp; wHD.show();<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; WidgetImpro wImproVGA;<br>&nbsp; WidgetImpro wImproSVGA(800);<br>&nbsp; WidgetImpro wImproHD(1280, 720);<br><br>&nbsp; wImproVGA.show();<br>&nbsp; wImproSVGA.show();<br>&nbsp; wImproHD.show();<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div><div class="text">Beide Klassen verhalten sich identisch.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_178739501_01b33a8148.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Der Unterschied der beiden Klassen ist es, dass die Konstruktoren der Klasse [code]WidgetImpro[/code] viel einfacher zu verwenden und zu erweitern sind. Wenn du zum Beispiel eine neue Variable zu beiden Klassen hinzufügst, musst du im Falle der Klasse [code]WidgetImpro[/code] nur eine Codestelle editieren, hingegen ist im Falle der Klasse [code]Widget[/code] jeder Konstruktor betroffen. Dieses Bild habe ich im Kopf, wenn ich eine Klasse entwerfe:<b> Definiere das Defaultverhalten jedes Objekts im Klassenkörper. Verwende explizite Konstruktoren nur, um dieses Defaultverhalten zu ändern. </b></div><div class="text">Fertig? Nein</div><div class="text">Oft kommt eine init-Funktion zum Einsatz, um gemeinsame Initialisierungsaufgaben und Prüfungen der Argumente in einer Funktion zu kapseln. Damit setzt du das wichtige DRY-Prinzip (<a alt="%7B%22text%22%3A%22Don%27t%20Repeat%20Yourself%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%7D" title="Link auf https://en.wikipedia.org/wiki/Don't_repeat_yourself" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">Don't Repeat Yourself</a>) richtig um. Damit brichst du aber auch automatisch ein weiteres wichtiges Prinzip, dass ein Objekt nach dem Aufruf des Konstruktors einsatzbereit sein soll. Wie lässt sich diese Zwickmühle lösen? Einfach, denn seit C++11 lassen sich Konstruktoraufrufe delegieren. Das heißt, stecke die gemeinsame Initialisierung und Prüfung der Argumente in einen besonders smarten Konstruktor und verwende die anderen Konstruktoren als Aufrufkonstruktoren, die ihre Aufgabe an den besonders smarten Konstruktor delegieren. Hier ist meine Idee in Code gegossen:</div><div class="pre">// constructorDelegation.cpp<br><br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br><br>class Degree{<br>public:<br>&nbsp; explicit Degree(int deg){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; degree = deg % 360;<br>&nbsp;&nbsp;&nbsp; if (degree &lt; 0) degree += 360;<br>&nbsp; }<br>&nbsp; <br>&nbsp; Degree() = default;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; explicit Degree(double deg):Degree(static_cast&lt;int&gt;(ceil(deg))) {}&nbsp; <br><br>&nbsp; int getDegree() const { return degree; }<br><br>private:<br>&nbsp; int degree{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Degree degree;<br>&nbsp; Degree degree10(10);<br>&nbsp; Degree degree45(45);<br>&nbsp; Degree degreeMinus315(-315);<br>&nbsp; Degree degree405(405);<br>&nbsp; Degree degree44(44.45);<br><br>&nbsp; std::cout &lt;&lt; "Degree(): " &lt;&lt; degree.getDegree() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "Degree(10): " &lt;&lt; degree10.getDegree() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "Degree(45): " &lt;&lt; degree45.getDegree() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "Degree(-315): " &lt;&lt; degreeMinus315.getDegree() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "Degree(405): " &lt;&lt; degree405.getDegree() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "Degree(44.45): " &lt;&lt; degree44.getDegree() &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div><div class="text">Der Ausdruck [code] int degree{}[/code] (Zeile 1) setzt [code]degree[/code] auf 0. Der Konstruktor in Zeile 1 ist ziemlich smart. Er rechnet jedes Grad auf den Einheitskreis um. Der Konstruktor, der ein [code]double[/code] annimmt, wendet diesen an. Der Vollständigkeit halber ist hier die Ausgabe des Programms. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_178739506_fb4d4b174c.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="ztitel"><a alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-goto-exit%22%2C%22text%22%3A%22NR.6%3A%20Don%C2%92t%3A%20Place%20all%20cleanup%20actions%20at%20the%20end%20of%20a%20function%20and%20goto%20exit%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-goto-exit%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-goto-exit" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-goto-exit">NR.6: Don’t: Place all cleanup actions at the end of a function and goto exit</a> </div><div class="text">Klar, der folgende Code der Guidelines lässt sich einfach verbessern:</div><div class="pre">void do_something(int n)<br>{<br>&nbsp;&nbsp;&nbsp; if (n &lt; 100) goto exit;<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; int* p = (int*) malloc(n);<br>&nbsp;&nbsp;&nbsp; // ...<br>exit:<br>&nbsp;&nbsp;&nbsp; free(p);<br>}<br></div><div class="text">Nebenbei bemerkt, hast du den Fehler gefunden? Der Sprung [code]goto exit[code] überspringt die Definition des Zeigers [code]p[/code].</div><div class="text">Häufig habe ich C-Code gesehen, der dieser typischen Struktur folgte: <br></div><div class="pre">// lifecycle.c<br><br>#include &lt;stdio.h&gt;<br>&nbsp;<br>void initDevice(const char* mess){<br>&nbsp; printf("\n\nINIT: %s\n",mess);<br>}<br>&nbsp;<br>void work(const char* mess){<br>&nbsp; printf("WORKING: %s",mess);<br>}<br>&nbsp;<br>void shutDownDevice(const char* mess){<br>&nbsp; printf("\nSHUT DOWN: %s\n\n",mess);<br>}<br>&nbsp;<br>int main(void){<br>&nbsp;<br>&nbsp; initDevice("DEVICE 1");<br>&nbsp; work("DEVICE1");<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; initDevice("DEVICE 2");<br>&nbsp;&nbsp;&nbsp; work("DEVICE2");<br>&nbsp;&nbsp;&nbsp; shutDownDevice("DEVICE 2");<br>&nbsp; }<br>&nbsp; work("DEVICE 1");<br>&nbsp; shutDownDevice("DEVICE 1");<br>&nbsp;<br>&nbsp; return 0;<br>&nbsp;<br>}</div><div class="text">Dies ist ein typischer, aber leider auch extrem fehleranfälliger Code. Jeder Einsatz des Devices besteht aus drei Schritten: Initialisierung, Verwendung und Freigabe des Devices. Natürlich ist dies ein Job für RAII: </div><div class="pre">// lifecycle.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>&nbsp;<br>class Device{<br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; const std::string resource;<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; Device(const std::string&amp; res):resource(res){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\nINIT: " &lt;&lt; resource &lt;&lt; ".\n";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; void work() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "WORKING: " &lt;&lt; resource &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~Device(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "SHUT DOWN: "&lt;&lt; resource &lt;&lt; ".\n\n";<br>&nbsp;&nbsp;&nbsp; }<br>};<br>&nbsp;<br>int main(){<br>&nbsp;<br>&nbsp;<br>&nbsp; Device resGuard1{"DEVICE 1"};<br>&nbsp; resGuard1.work();<br>&nbsp;<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; Device resGuard2{"DEVICE 2"};<br>&nbsp;&nbsp;&nbsp; resGuard2.work();<br>&nbsp; }<br>&nbsp; resGuard1.work();<br>&nbsp;<br>}</div><div class="text">Initialisiere die Ressource im Konstruktor und gib sie im Destruktor wieder frei. Einerseits ist es damit unmöglich, die Ressource nicht zu initialisieren, andererseits kümmert sich der Compiler darum, die Ressource wieder aufzuräumen. Beide Programme besitzen die gleiche Ausgabe. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_178739511_39ffe4eaea.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Mein Artikel <a alt="%7B%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Db5f71d4553cdbd462160077aa9f422e2%26rm%3Dopen_article_id%26bid%3D2720766%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A2720766%2C%22subject%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Wenn%20RAII%20versagt%22%2C%22ir_link%22%3A1%7D" href="/exec/mainmenu.pl?sid=b5f71d4553cdbd462160077aa9f422e2&amp;rm=open_article_id&amp;bid=2720766" title="Link auf Beitrag 2720766">C++ Core Guidelines: Wenn RAII versagt</a> enthält mehr Informationen zu RAII. </div><div class="ztitel">Weitere Mythen</div><div class="text">Ich bin mir sicher, das ist noch nicht das Ende des Kampfes gegen Nichtregeln und Mythen in modernem C++. Sicher kennst du noch weitere Mythen. Schreibe mir daher eine E-Mail an <a alt="%7B%22text%22%3A%22rainer.grimm%40modernescpp.de%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E_Mail%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22rainer.grimm%40modernescpp.de%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22mailto%3Arainer.grimm%40modernescpp.de%22%7D" href="mailto:rainer.grimm@modernescpp.de" title="Link auf rainer.grimm@modernescpp.de">rainer.grimm@modernescpp.de</a> oder einen Kommentar. Beschreibe darin den Mythos und biete, wenn möglich, eine Lösung für ihn an. Ich werde versuchen die Kommentare in einen Artikel zu gießen und, wenn du es willst, dich namentlich zu nennen. Nun bin ich nur noch gespannt. <br></div><div class="simple-translate-result-wrapper"><br> <br></div>
