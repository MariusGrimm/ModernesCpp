<div class="vorspann">Bevor ich über das sehr beliebte RAII-Idiom in C++ schreibe, möchte ich einen Trick vorstellen, der oft praktisch zur Hand ist, wenn mehrmals nach einem Text gesucht wird: Verwende negative Suche.</div><div class="text">Häufig folgen die Textpatterns (Tokens), nach denen du suchst, einem sich immer wiederholenden Muster. Genau hier kommt die negative Suche ins Spiel</div><div class="ztitel">Verwende negative Suche, falls es möglich ist</div><div class="text">Die zentrale Idee der negativen Suche lässt sich einfach erklären. Du definierst einen komplizierten regulären Ausdruck, um deine Tokens zu finden. Häufig sind die Tokens durch Trenner wie Kommas, Doppelpunkte oder auch Leerzeichen separiert. In diesem Fall ist es oft einfacher, die Trenner zu suchen, da die Tokens genau der Text zwischen den Trennern sind. Das folgende Beispiel bringt meine Idee auf den Punkt.</div><div class="pre">// regexTokenIterator.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;regex&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;std::string&gt; splitAt(const std::string &amp;text,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::regex &amp;reg) {<br>&nbsp; std::sregex_token_iterator hitIt(text.begin(), text.end(), reg, -1);<br>&nbsp; const std::sregex_token_iterator hitEnd;<br>&nbsp; std::vector&lt;std::string&gt; resVec;<br>&nbsp; for (; hitIt != hitEnd; ++hitIt)<br>&nbsp;&nbsp;&nbsp; resVec.push_back(hitIt-&gt;str());<br>&nbsp; return resVec;<br>}<br><br>int main() {<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; const std::string text("3,-1000,4.5,-10.5,5e10,2e-5");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp; const std::regex regNumber(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R"([-+]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][-+]?[0-9]+)?)");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; std::sregex_iterator numberIt(text.begin(), text.end(), regNumber);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; const std::sregex_iterator numberEnd;<br>&nbsp; for (; numberIt != numberEnd; ++numberIt) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; numberIt-&gt;str() &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; }<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; const std::regex regComma(",");<br>&nbsp; std::sregex_token_iterator commaIt(text.begin(), text.end(), regComma, -1); // (5)<br>&nbsp; const std::sregex_token_iterator commaEnd;<br>&nbsp; for (; commaIt != commaEnd; ++commaIt) {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; commaIt-&gt;str() &lt;&lt; std::endl;<br>&nbsp; }<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::vector&lt;std::string&gt; resVec = splitAt(text, regComma);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp; for (auto s : resVec)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s &lt;&lt; " ";<br>&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp; resVec = splitAt("abc5.4def-10.5hij2e-5klm", regNumber);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp; for (auto s : resVec)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s &lt;&lt; " ";<br>&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp; std::regex regSpace(R"(\s+)");<br>&nbsp; resVec = splitAt("abc&nbsp; 123&nbsp; 456\t789&nbsp;&nbsp;&nbsp; def hij\nklm", regSpace);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (9)<br>&nbsp; for (auto s : resVec)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s &lt;&lt; " ";<br>&nbsp; std::cout &lt;&lt; "\n\n";<br>}</div><div class="text">Die Zeile 1 enthält einen String, der aus Zahlen besteht, die durch Kommas separiert sind. Um alle Zahlen auszulesen, definiere ich in Zeile 2 einen regulären Ausdruck für eine Zahl. Eine Zahl kann in diesem Fall eine Ganzzahl, eine Fließkommazahl oder auch eine Zahl in wissenschaftlicher Notation sein. In Zeile 3 definiere ich einen Iterator vom Typ <i>std::regex_iterator</i>, der über alle Tokens iteriert und sie in Zeile 4 darstellt. Der Iterator <i>std::regex_token_iterator </i>in Zeile 5 ist noch mächtiger. Er sucht nach Kommas und gibt mir den Text zwischen den Kommas zurück, da ich den negativen Index -1 angewandt habe.</div><div class="text">Dieses Pattern ist so praktisch, dass ich es in die Funktion <i>splitAt</i> (Zeile 6) gegossen habe. <i>splitAt</i> nimmt einen Text und einen regulären Ausdruck an und schiebt den Text zwischen dem angewandten regulären Ausdruck auf den <i>std::vector&lt;std::string&gt; res</i>. Jetzt ist es ein Kinderspiel, einen Text mehrmals an Kommas (Zeile 7), an Zahlen (Zeile 8) oder an Leerraum (Whitespaces) (Zeile 9) zu trennen.</div><div class="text">Hier ist die Ausgabe des Programms.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_177643402_4da76bc063.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Dies war meine letzte Regel zu regulären Ausdrücken. Damit beende ich auch die Regeln zu der Standard-Bibliothek in den C++ Core Guidelines. Stopp! Es gibt noch eine Regel zu der C-Standard-Bibliothek. <br></div><div class="ztitel"><a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rclib-jmp" alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22SL.C.1%3A%20Don%C2%92t%20use%20setjmp%2Flongjmp%26nbsp%3B%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rclib-jmp%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rclib-jmp%22%2C%22version%22%3A1%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rclib-jmp">SL.C.1: Don’t use setjmp/longjmp&nbsp;</a><br></div><div class="text">Die Begründung für die Regel in den Guidelines ist kurz und bündig: ein <i>longjmp</i> ignoriert einen Destruktor. Damit werden alle Resource-Management-Strategien, die auf RAII basieren, gebrochen. Ich hoffe, du kennst RAII. Wenn nicht, hier ist die Essenz.</div><div class="text">RAII steht für <b>R</b>escource <b>A</b>cquisition <b>I</b>s<b> I</b>nitialization. Dieses wohl wichtigste C++-Idiom besagt, dass eine Ressource im Konstruktor eines Objekts angefordert und im Destruktor des Objekts wieder freigegeben wird. Das Entscheidende dabei ist, dass der Destruktor genau dann automatisch aufgerufen wird, wenn das Objekt seine Gültigkeit verliert.</div><div class="text">Das folgende Beispiel bringt das deterministische Verhalten von RAII auf den Punkt:</div><div class="pre">// raii.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;new&gt;<br>#include &lt;string&gt;<br><br>class ResourceGuard{<br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; const std::string resource;<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; ResourceGuard(const std::string&amp; res):resource(res){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Acquire the " &lt;&lt; resource &lt;&lt; "." &lt;&lt;&nbsp; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~ResourceGuard(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Release the "&lt;&lt; resource &lt;&lt; "." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; ResourceGuard resGuard1{"memoryBlock1"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp; std::cout &lt;&lt; "\nBefore local scope" &lt;&lt; std::endl;<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; ResourceGuard resGuard2{"memoryBlock2"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; std::cout &lt;&lt; "After local scope" &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "\nBefore try-catch block" &lt;&lt; std::endl;<br>&nbsp; try{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResourceGuard resGuard3{"memoryBlock3"};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::bad_alloc();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; }&nbsp;&nbsp; <br>&nbsp; catch (std::bad_alloc&amp; e){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; e.what();<br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; "\nAfter try-catch block" &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}&nbsp; <br></div><div class="text"><i>ResourceGuard</i> ist ein Wächter, der auf seine Ressource aufpasst. In diesem Fall wird die Ressource durch einen String repräsentiert. <i>ResourceGuard</i> erzeugt den String in seinem Konstruktor und gibt diesen in seinem Destruktor wieder frei. <i>ResourceGuard</i> verrichtet seinen Job sehr zuverlässig.</div><div class="text">Der Destruktor von <i>resGuard1</i> (Zeile 1) wird am Ende der <i>main</i>-Funktion (Zeile 2) aufgerufen. Der Lebenszyklus von <i>resGuard2</i> (Zeile 3) endet bereits in Zeile 4. Daher wird der Destruktor automatisch aufgerufen. Selbst das Werfen einer Ausnahme beeinflusst nicht die Zuverlässigkeit von <i>resGuard3</i> (Zeile 5). Sein Destruktor wird am Ende des <i>try</i>-Blocks (Zeile 6) aufgerufen.</div><div class="text">Der Screenshot zeigt schön die Lebenszyklen der einzelnen Objekte.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_177643411_8e80294622.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Gerne will ich die zentrale Idee von RAII hervorheben: <b>Der Lebenszyklus einer Ressource wird an den Lebenszyklus einer lokalen Variable gebunden und C++ verwaltet automatisch den Lebenszyklus seiner lokalen Variablen.</b></div><div class="text">Wie bricht nun aber<i> setjmp/longjmp </i>diesen Automatismus? Zuerst einmal möchte ich das Verhalten von <i>setjmp </i>und <i>std::longjmp </i>vorstellen:&nbsp; </div><div class="text"><i>int setjmp(std::jmp_buf env):</i></div><div class="text"><ul><li>speichert den Ausführungskontext in<i> env</i> für <i>std::longjmp</i></li><li>gibt bei dem ersten, direkten Aufruf 0 zurück</li><li>gibt bei weiteren Aufrufen durch <i>std::longjmp</i> den Wert zurück, den <i>std::longjmp</i> setzt</li><li>ist die Zieladresse eines <i>std::longjmp-</i>Aufrufs</li><li>entspricht der catch-Clause bei der Ausnahmebehandlung<i><br></i></li></ul></div><div class="text"><i>void std::longjmp(std::jmp_buf env, int status):</i></div><div class="text"><ul><li> stellt den Ausführungskontext, der in <i>env</i> gespeichert ist, wieder her</li><li>setzt den Status des <i>setjmp</i>-Aufrufs</li><li>entspricht dem <i>throw</i>-Aufruf bei der Ausnahmebehandlung</li></ul></div><div class="text">Das war sehr technisch. Hier ist ein einfaches Beispiel:</div><div class="pre">// setJumpLongJump.cpp<br><br>#include &lt;cstdlib&gt;<br>#include &lt;iostream&gt;<br>#include &lt;csetjmp&gt;<br>#include &lt;string&gt;<br><br>class ResourceGuard{<br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; const std::string resource;<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; ResourceGuard(const std::string&amp; res):resource(res){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Acquire the " &lt;&lt; resource &lt;&lt; "." &lt;&lt;&nbsp; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~ResourceGuard(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Release the "&lt;&lt; resource &lt;&lt; "." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::jmp_buf env;<br>&nbsp; volatile int val;<br>&nbsp; <br>&nbsp; val = setjmp(env);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp; if (val){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "val: " &lt;&lt;&nbsp; val &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::exit(EXIT_FAILURE);<br>&nbsp; }<br>&nbsp; <br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; ResourceGuard resGuard3{"memoryBlock3"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::longjmp(env, EXIT_FAILURE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>}<br></div><div class="text">Der Aufruf in Zeile 1 speichert den Ausführungskontext und gibt 0 zurück. In Zeile 3 wird der Ausführungskontext wieder aktiviert. Der entscheidende Punkt ist es, dass der Destruktor von<i> resGuard3</i> (Zeile 2) nicht in Zeile 4 aufgerufen wird. Das kann im konkreten Fall bedeuten, dass du ein Speicherleck hast oder dein Mutex nicht freigegeben wird. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_177643413_7484dacc2e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text"><i>EXIT-FAILURE</i> ist der Rückgabewert des zweiten <i>setjmp</i>-Aufrufs (Zeile 1) und auch der Rückgabewert des Executables.</div><div class="ztitel">Wie geht's weiter?<br></div><div class="text">Fertig, aber nicht vollständig! Nun habe ich mehr als 100 Aritkel zu den C++ Core Guidelines geschrieben und dabei viel gelernt. Die C++ Core Guidelines besitzen aber noch eine <i>supporting section</i>. Das hört sich sehr interessant an. Mit dieser <i>supporting section</i> werde ich in meinem nächsten Artikel beginnen.<br></div>