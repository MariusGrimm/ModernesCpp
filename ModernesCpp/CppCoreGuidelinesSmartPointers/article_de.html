<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_146063477_3b0f04eff2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Für viele C++-Entwickler sind Smart Pointer das wichtigste Feature des C++11-Standards. Genau um diese Smart Pointer geht es in dem aktuellen Artikel. <br></div>
<div class="text">Die C++ Core Guidelines besitzen dreizehn Regeln für Smart Pointer. Die erste Hälfte von ihnen beschäftigt sich mit Besitzverhältnissen, die zweite Hälfte mit der Frage: Wie sollen Smart Pointer an Funktionen übergeben werden?</div>
<div class="text">Hier ist der erste, schnelle Überblick.</div>
<div class="text"><ul><li><a alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-owner%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-owner%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.20%3A%20Use%26nbsp%3Bunique_ptr%26nbsp%3Bor%26nbsp%3Bshared_ptr%26nbsp%3Bto%20represent%20ownership%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-owner" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-owner" class="">R.20: Use&nbsp;unique_ptr&nbsp;or&nbsp;shared_ptr&nbsp;to represent ownership</a><br></li><li><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-unique%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-unique%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22R.21%3A%20Prefer%26nbsp%3Bunique_ptr%26nbsp%3Bover%26nbsp%3Bshared_ptr%26nbsp%3Bunless%20you%20need%20to%20share%20ownership%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-unique" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-unique">R.21: Prefer&nbsp;unique_ptr&nbsp;over&nbsp;shared_ptr&nbsp;unless you need to share ownership</a><br></li><li><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-make_shared" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-make_shared" class="" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22R.22%3A%20Use%26nbsp%3Bmake_shared%28%29%26nbsp%3Bto%20make%26nbsp%3Bshared_ptrs%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-make_shared%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-make_shared%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D">R.22: Use&nbsp;make_shared()&nbsp;to make&nbsp;shared_ptrs</a><br></li><li><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-make_unique" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-make_unique" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-make_unique%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-make_unique%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22R.23%3A%20Use%26nbsp%3Bmake_unique%28%29%26nbsp%3Bto%20make%26nbsp%3Bunique_ptrs%22%2C%22type%22%3A%22E%22%7D">R.23: Use&nbsp;make_unique()&nbsp;to make&nbsp;unique_ptrs</a><br></li><li><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-weak_ptr" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-weak_ptr" alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-weak_ptr%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-weak_ptr%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.24%3A%20Use%26nbsp%3Bstd%3A%3Aweak_ptr%26nbsp%3Bto%20break%20cycles%20of%26nbsp%3Bshared_ptrs%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D">R.24: Use&nbsp;std::weak_ptr&nbsp;to break cycles of&nbsp;shared_ptrs</a><br></li><li><a alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrparam%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrparam%22%2C%22text%22%3A%22R.30%3A%20Take%20smart%20pointers%20as%20parameters%20only%20to%20explicitly%20express%20lifetime%20semantics%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrparam" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrparam" class="">R.30: Take smart pointers as parameters only to explicitly express lifetime semantics</a><br></li><li>R.31: If you have non-std&nbsp;smart pointers, follow the basic pattern from&nbsp;std<br></li><li>R.32: Take a&nbsp;unique_ptr&lt;widget&gt;&nbsp;parameter to express that a function assumes ownership of a&nbsp;widget<br></li><li>R.33: Take a&nbsp;unique_ptr&lt;widget&gt;&amp;&nbsp;parameter to express that a function reseats the&nbsp;widget<br></li><li>R.34: Take a&nbsp;shared_ptr&lt;widget&gt;&nbsp;parameter to express that a function is part owner<br></li><li>R.35: Take a&nbsp;shared_ptr&lt;widget&gt;&amp;&nbsp;parameter to express that a function might reseat the shared pointer<br></li><li>R.36: Take a&nbsp;const shared_ptr&lt;widget&gt;&amp;&nbsp;parameter to express that it might retain a reference count to the object ???<br></li><li>R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</li></ul></div>
<div class="text">Die ersten fünf Regeln (<b>R.20 - R.24</b>) sind ziemlich naheliegend. Ich habe bereits einige Artikel über sie geschrieben. Daher werde ich die Regeln zusammenfassen und auf meine bestehenden Artikel verweisen.</div>
<div class="text">Ein <a alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22text%22%3A%22std%3A%3Aunique_ptr%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/std-unique-ptr" href="http://www.grimm-jaud.de/index.php/blog/std-unique-ptr">std::unique_ptr</a> ist der exklusive Besitzer seiner Ressource. Daher kannst du ihn nicht kopieren, sondern nur verschieben. Im Gegensatz dazu teilt sich ein <a alt="%7B%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22std%3A%3Ashared_ptr%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-shared-ptr%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-shared-ptr%22%7D" class="" href="http://www.grimm-jaud.de/index.php/blog/std-shared-ptr" title="Link auf http://www.grimm-jaud.de/index.php/blog/std-shared-ptr">std::shared_ptr</a> seine Ressource. Falls du einen <i>std::shared_ptr</i> kopierst oder zuweist ("copy assign"), wird automatisch sein Referenzzähler inkrementiert. Falls du einen <i>std::shared_ptr</i> löschst oder zurücksetzt, wird sein Referenzzähler dekrementiert. Falls der Referenzzähler den Wert 0 erreicht, wird die zugrundeliegende Ressource gelöscht. Aufgrund dieses Verwaltungsaufwandes sollte ein <i>std::unique_ptr</i> verwenden werdet, wenn dies möglich ist (<b>R.21</b>). </div>
<div class="text">Der Verwaltungsaufwand eines <i>std::shared_ptr </i>macht sich vor allem bei seiner Erzeugung bemerkbar. Das Anlegen eines <i>std::shared</i>_ptr stößt zwei Speicherallokationen an: eine Speicherallokation für die Ressource und eine für den Referenzzähler. Das ist ein aufwendiger Job. Die Rettung naht aber in der Form der Fabrikfunktion <i>std::make_shared</i> (<b>R.22</b>). <i>std::make_shared</i> benötigt nur eine Speicherallokation. Das ist eine große Performanzverbesserung. In dem Artikel "<a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Speicher%20und%20Performanzoverhead%20von%20Smart%20Pointern%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%2C%22anchor%22%3A%22%22%7D" href="http://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern" title="Link auf http://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern" class="">Speicher und Performanzoverhead von Smart Pointern</a>" habe ich die Performanzunterschiede beim Anlegen und Löschen von nackten Zeigern, Smart Pointern inklusive deren Fabrikfunktionen <i>std::make_shared</i> und <i>std::make_unique</i> verglichen. </div>
<div class="text">Es gibt noch einen weiteren, wichtigen Grund, einen <i>std::shared_ptr</i> mit <i>std::make_shared </i>oder einen <i>std::unique_ptr </i>mit <i>std::make_unique</i> zu erzeugen: Es lauert kein Speicherleck (<b>R.22 und R.23</b>). Falls zwei Aufrufe von <i>std::shared_ptr</i> oder <i>std::unique_ptr</i> in einem Ausdruck verwendet werden, kann dies zu einem Speicherleck führen, wenn eine Ausnahme auftritt. Die Details zu dieser Gefahr habe ich meinem letzten Artikel "<a title="Link auf Beitrag 2334380" href="/exec/mainmenu.pl?sid=3e953d5b27cc2747f864bb11c5d8a6d5&amp;rm=open_article_id&amp;bid=2334380" class="" alt="%7B%22destination%22%3A2334380%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D3e953d5b27cc2747f864bb11c5d8a6d5%26rm%3Dopen_article_id%26bid%3D2334380%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regeln%20f%C3%BCr%20Allokieren%20und%20Deallokieren%22%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D">C++ Core Guidelines: Regeln für Allokieren und Deallokieren</a>" (R.13) bereits vorgestellt. </div>
<div class="text">Um ehrlich zu sein, ein <i>std::weak_ptr</i> ist nicht wirklich smart. Er besitzt nicht die Ressource; er leiht sie nur von einem <i>std::shared_ptr </i>aus. Sein Interface ist sehr eingeschränkt. Indem du die Methode <i>lock</i> eines <i>std::weak_ptr</i> verwendest, kannst du einen <i>std::weak_ptr</i> zu einem <i>std::shared_ptr</i> erweitern. Natürlich stellt sich da die Frage: Warum benötigen wir einen <i>std::weak_ptr</i> in C++? Er hilft, Zyklen von <i>std::shared_ptr</i> zu brechen (R.24). Solche Zyklen sind der Grund, dass ein <i>std::shared_ptr</i> nicht automatisch seine Ressource freigeben kann. Oder anders herum ausgedrückt. Falls du einen Zyklus von <i>std::shared_ptr</i> besitzt, dann auch ein Speicherleck. Die Details zu <i>std::weak_ptr</i> und wie sich dieser verwenden lässt, um Speicherlecks von <i>std::shared_ptr</i> zu vermeiden, gibt es in meinem Artikel zu <a alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-weak-ptr%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-weak-ptr%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22std%3A%3Aweak_ptr%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="http://www.grimm-jaud.de/index.php/blog/std-weak-ptr" title="Link auf http://www.grimm-jaud.de/index.php/blog/std-weak-ptr" class="">std::weak_ptr</a>. </div>
<div class="text">Das war meine Zusammenfassung zu Smart-Pointern. Diese Punkte sollten bereits mehr oder weniger Allgemeinwissen zu Smart-Pointern sein. Das gilt aber nicht für die verbleibenden Regeln. Sie beschäftigen sich mit der Frage: Wie soll ein Smart Pointer an eine Funktion übergeben werden?</div>
<div class="text"><b><a alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrparam%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrparam%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22R.30%3A%20Take%20smart%20pointers%20as%20parameters%20only%20to%20explicitly%20express%20lifetime%20semantics%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrparam" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrparam" class="">R.30: Take smart pointers as parameters only to explicitly express lifetime semantics</a></b></div>
<div class="text">Diese Regel ist ein wenig knifflig. Falls du einen Smart Pointer als Funktionsparameter und in dieser Funktion lediglich die dem Smart Pointer zugrundeliegende Ressource verwendest, machst du etwas falsch. In diesem Fall reicht es vollkommen aus, einen Zeiger oder eine Referenz als Funktionsparameter einzusetzen, da du nicht die Lebenszeitsemantik des Smart Pointer verwendest. </div>
<div class="text">Hier ist ein Beispiel zu der ziemlich anspruchsvollen Lebenszeitsemantik eines Smart Pointer.</div>
<div class="pre">// lifetimeSemantic.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br><br>using std::cout;<br>using std::endl;<br><br>void asSmartPointerGood(std::shared_ptr&lt;int&gt;&amp; shr){<br>&nbsp; std::cout &lt;&lt; "shr.use_count(): " &lt;&lt; shr.use_count() &lt;&lt; endl;&nbsp; // (3)<br>&nbsp; shr.reset(new int(2011));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; cout &lt;&lt; "shr.use_count(): " &lt;&lt; shr.use_count() &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>}<br><br>void asSmartPointerBad(std::shared_ptr&lt;int&gt;&amp; shr){<br>&nbsp; // doSomethingWith(*shr);<br>&nbsp; *shr += 19;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; cout &lt;&lt; endl;<br>&nbsp; <br>&nbsp; auto firSha = std::make_shared&lt;int&gt;(1998);<br>&nbsp; auto secSha = firSha;<br>&nbsp; cout &lt;&lt; "firSha.use_count(): " &lt;&lt; firSha.use_count() &lt;&lt; endl; // (1)<br>&nbsp; <br>&nbsp; cout &lt;&lt; endl;<br>&nbsp; <br>&nbsp; asSmartPointerGood(firSha);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp; cout &lt;&lt; endl;<br>&nbsp; <br>&nbsp; cout &lt;&lt; "*firSha: " &lt;&lt; *firSha &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "firSha.use_count(): " &lt;&lt; firSha.use_count() &lt;&lt; endl;<br>&nbsp; <br>&nbsp; cout &lt;&lt; endl;<br>&nbsp; <br>&nbsp; cout &lt;&lt; "*secSha: " &lt;&lt; *secSha &lt;&lt; endl;<br>&nbsp; cout &lt;&lt; "secSha.use_count(): " &lt;&lt; secSha.use_count() &lt;&lt; endl;<br>&nbsp; <br>&nbsp; cout &lt;&lt; endl;<br>&nbsp; <br>&nbsp; asSmartPointerBad(secSha);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; cout &lt;&lt; "*secSha: " &lt;&lt; *secSha &lt;&lt; endl;<br>&nbsp; <br>&nbsp; cout &lt;&lt; endl;<br>&nbsp; <br>}</div>
<div class="text">Los geht es mit dem Gutfall für einen <i>std::shared_ptr.</i> Der Referenzzähler in Zeile (1) ist 2, da der Shared Pointer <i>firSha</i> zum Einsatz kam, um den Shared Pointer <i>secSha </i>zu initialisieren. Ein genauerer Blick auf die Verwendung der Funktion <i>asSmartPointerGood</i>(2) lohnt sich. Zuerst ist der Referenzzähler in der Zeile (3) zwei und dann wird in der Zeile (4) zu eins. Was ist in der Zeile (5) passiert? Ich habe den Shared Pointer <i>shr</i> auf eine neue Ressource <i>new int(2011) </i>gesetzt. Konsequenterweise werden dadurch beide Shared Pointer <i>firSha</i> und <i>secSha</i> geteilte Besitzer von unterschiedlichen Ressourcen. Dies Verhalten lässt sich schön im Screenshot nachvollziehen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_146063488_e750bf22d1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Beim Einsatz von <i>reset</i> auf einem Shared Poitner geschieht viel Magie unter der Decke.</div>
<div class="text">Falls du <i>reset</i> <br></div>
<div class="text"><ul><li>ohne Argument verwendest, wird der Referenzzähler um eins dekrementiert.</li><li>mit einem Argument verwendest und der Referenzzähler war zu mindestens 2, erhälst du zwei unabhängige Shared Pointer, die verschiedene Ressourcen besitzen. Dies ist eine Art tiefes Kopieren (<a alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22deep%20copy%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FObject_copying%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FObject_copying%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/Object_copying" title="Link auf https://en.wikipedia.org/wiki/Object_copying" class="">deep copy</a>) eines Shared Pointer.</li><li>mit einem Argument oder ohne Argument verwendest und der Referenzzähler bekommt den Wert 0, wird die Ressource freigegeben.&nbsp;</li></ul></div>
<div class="text">Diese Magie ist nicht notwendig, falls du nur an der dem Shared Pointer zugrunde liegenden Ressource interessiert bist. Daher ist in diesem Fall ein Zeiger oder eine Referenz der angemessener Funktionsparameter für die Funktion <i>asSmartPointerBad</i>(6). <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Sechs Regeln der Guidelines beschäftigen sich noch mit der Frage: Wie soll ein Smart Pointer einer Funktion übergeben werden? Mit der Beantwortung dieser Frage beschäftigt sich mein nächster Artikel. </div>
<div class="ztitel">Weitere Informationen:</div>
<div class="text">Für meine drei offenen Seminare im ersten Halbjahr 2018 sind noch Plätze frei:</div>
<div class="text"><ul><li>Embedded-Programmierung mit modernem C++: 16. bis 18. Januar 2018 (<b>Anmeldeschluss 20.12</b>)<br></li><li>C++11 und C++14: 13. bis 15. März 2018</li><li>Multithreading mit modernem C++: 8. bis 9. Mai. 2018 </li></ul></div>