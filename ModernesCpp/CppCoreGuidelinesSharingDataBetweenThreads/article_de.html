<div class="vorspann">Die große Herausforderungen mit Threads beginnen dann, wenn veränderliche Daten zwischen diesen geteilt werden. Um kein Data Race und damit undefiniertes Verhalten zu erhalten, müssen die geteilten Daten geschützt werden.</div>
<div class="text">Die drei Regeln des heutigen Artikels mögen für erfahrene Multithreading-Programmierer eine Selbstverständlichkeit sein, für Einsteiger in diese sehr anspruchsvolle Domäne sind sie überlebensnotwendig. Hier sind sie:</div>
<div class="text"><ul><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-raii" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-raii%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-raii%22%2C%22text%22%3A%22CP.20%3A%20Use%20RAII%2C%20never%20plain%20lock%28%29%2Funlock%28%29%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-raii">CP.20: Use RAII, never plain lock()/unlock()</a> </li><li> <a alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lock%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lock%22%2C%22text%22%3A%22CP.21%3A%20Use%20std%3A%3Alock%28%29%20or%20std%3A%3Ascoped_lock%20to%20acquire%20multiple%20mutexes%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lock" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lock" class="">CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutexes</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-unknown" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-unknown%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-unknown%22%2C%22text%22%3A%22CP.22%3A%20Never%20call%20unknown%20code%20while%20holding%20a%20lock%20%28e.g.%2C%20a%20callback%29%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-unknown">CP.22: Never call unknown code while holding a lock (e.g., a callback)</a></li></ul></div>
<div class="text">Los geht es mit der einfachsten Regel:<br></div>
<div class="ztitel"><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-raii%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-raii%22%2C%22text%22%3A%22CP.20%3A%20Use%20RAII%2C%20never%20plain%20lock%28%29%2Funlock%28%29%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-raii" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-raii" class="">CP.20: Use RAII, never plain lock()/unlock()</a> <br> </div>
<div class="text"><b>No naked mutex! </b>Verpacke deinen Mutex immer in ein Lock. Der Lock wird dank RAII automatisch den Mutex freigeben (unlock), falls er seinen Gültigkeitsbereich verlässt. RAII steht für Resource Acquisition Is Initialization und bedeutet, dass du die Lebenszeit deiner Ressource an die Lebenszeit einer lokalen Variable bindest. Die C++-Laufzeit kümmert sich automatisch um die Lebenszeit seiner lokalen Variablen.</div>
<div class="text"><i>std::lock_guard, std::unique_lock, std::shared_lock </i>(C++14) oder <i>std::std::scoped_lock</i> (C++17) setzen dies Pattern in C++ um. Dies gilt aber auch für die Smart Pointer <i>std::unique_ptr</i> und <i>std::shared_ptr</i>. Mein Artikel "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22text%22%3A%22Garbage%20Collection%20%5B--%5D%20No%20Thanks%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" class="">Garbage Collection [--] No Thanks</a>" geht auf die Details zu RAII ein.&nbsp; </div>
<div class="text">Was bedeutet nun RAII für Multithreading-Code?</div>
<div class="pre">std::mutex mtx; <br><br>void do_stuff() <br>{ <br>&nbsp;&nbsp;&nbsp; mtx.lock(); <br>&nbsp;&nbsp;&nbsp; // ... do stuff ... (1) <br>&nbsp;&nbsp;&nbsp; mtx.unlock(); <br>}</div>
<div class="text">Es macht keinen Unterschied, ob eine Ausnahme in Zeile (1) auftritt oder ich schlicht vergessen habe, den Mutex freizugeben. In beiden Fällen erhalte ich ein Deadlock, falls ein anderer Thread den <i>std::mutex mtx</i> benötigt (lock). Die Rettung liegt auf der Hand: </div>
<div class="pre">std::mutex mtx; <br><br>void do_stuff() <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck {mtx}; <br>&nbsp;&nbsp;&nbsp;&nbsp; // ... do stuff ... <br>}&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)</div>
<div class="text">Verpacke den Mutex in ein Lock, und der Lock wird automatisch freigegeben(1), denn dieser verlässt seinen Gültigkeitsbereich.<br></div>
<div class="ztitel"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lock" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lock%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.21%3A%20Use%20std%3A%3Alock%28%29%20or%20std%3A%3Ascoped_lock%20to%20acquire%20multiple%20mutexes%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lock%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lock">CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutexes</a></div>
<div class="text">Falls ein Thread mehr als ein Mutex benötigt, ist größte Vorsicht angesagt. Mutexe sollten immer in derselben Reihenfolge gelockt werden, sonst droht ein Deadlock. Genau dies zeigt das nächste Programm: </div>
<div class="pre">// lockGuardDeadlock.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;chrono&gt;<br>#include &lt;mutex&gt;<br>#include &lt;thread&gt;<br><br>struct CriticalData{<br>&nbsp; std::mutex mut;<br>};<br><br>void deadLock(CriticalData&amp; a, CriticalData&amp; b){<br><br>&nbsp; std::lock_guard&lt;std::mutex&gt;guard1(a.mut);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; std::cout &lt;&lt; "Thread: " &lt;&lt; std::this_thread::get_id() &lt;&lt;&nbsp; std::endl;<br><br>&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1));<br>&nbsp;<br>&nbsp; std::lock_guard&lt;std::mutex&gt;guard2(b.mut);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; std::cout &lt;&lt; "Thread: " &lt;&lt; std::this_thread::get_id() &lt;&lt;&nbsp; std::endl;<br>&nbsp; <br>&nbsp; // do something with a and b (critical region)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)<br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; CriticalData c1;<br>&nbsp; CriticalData c2;<br><br>&nbsp; std::thread t1([&amp;]{deadLock(c1, c2);});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::thread t2([&amp;]{deadLock(c2, c1);});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Thread<i> t1 </i>und <i>t2 </i>benötigen zwei Ressourcen <i>CriticalData, </i>um ihren Job (3) auszuführen. <i>CriticalData </i>besitzt seinen eigenen Mutex, um den Zugriff zu synchronisieren. Unglücklicherweise rufen die Threads die Funktion <i>deadlock</i> mit den Argumenten <i>c1</i> und <i>c2 </i>in verschiedener Reihenfolge auf (1). Dies ist eine Race Condition. Falls der Thread <i>t1</i> zuerst den ersten Mutex <i>a.mut</i> erhält und den zweiten Mutex <i>b.mut</i> nicht erhält, da dieser bereits der andere Thread besitzt, ergibt dies ein Deadlock (2).</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_152838369_17bda7ca3d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der einfachste Weg, den Deadlock aufzulösen, ist, beide Mutexe in eine atomaren Operation zu locken.</div>
<div class="text">Mit C++11 kann dazu der Lock <i>std::unique_lock </i>zusammen mit der Funktion <i>std::lock </i>verwendet werden. <i>std::unique_lock</i> erlaubt es, das Locken des Mutex herauszuzögern. Die Funktion <i>std::lock</i>, die es ermöglicht, eine beliebige Anzahl von Mutexen in einem atomaren Schritt zu locken, führt das Locken der Mutexe aus: <br></div>
<div class="pre">void deadLock(CriticalData&amp; a, CriticalData&amp; b){ <br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;mutex&gt; guard1(a.mut, std::defer_lock); <br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;mutex&gt; guard2(b.mut, std::defer_lock); <br>&nbsp;&nbsp;&nbsp; std::lock(guard1, guard2); // do something with a and b (critical region) <br>}<br></div>
<div class="text">Mit C++17 erlaubt der Lock <i>std::scoped_lock</i>, eine beliebige Anzahl von Mutexen direkt in einer atomaren Operation zu locken: <br></div>
<div class="pre">void deadLock(CriticalData&amp; a, CriticalData&amp; b){ <br>&nbsp;&nbsp;&nbsp; std::scoped_lock(a.mut, b.mut); <br>&nbsp;&nbsp;&nbsp; // do something with a and b (critical region <br>}<br></div>
<div class="ztitel"><a alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.22%3A%20Never%20call%20unknown%20code%20while%20holding%20a%20lock%20%28e.g.%2C%20a%20callback%29%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-unknown%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-unknown%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-unknown" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-unknown" class="">CP.22: Never call unknown code while holding a lock (e.g., a callback)</a></div>
<div class="text">Warum ist der Codeschnipsel sehr schlecht? <br></div>
<div class="pre">std::mutex m;<br>{ <br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lockGuard(m); <br>&nbsp;&nbsp;&nbsp; sharedVariable = unknownFunction(); <br>}</div>
<div class="text">Natürlich kann in dem Beispiel über die <i>unknownFunction</i> nur spekuliert werden. Falls die<br>Funktion</div>
<div class="text"><ul><li>versucht, denselben Mutex <i>m</i> nochmals zu locken, ist das undefiniertes Verhalten. Meistens resultiert ein Deadlock daraus.</li><li>einen neuen Thread startet, der versucht, denselben Mutex <i>m</i> zu locken, wird dies einen Deadlock verursachen.</li><li>einen weiteren Mutex <i>m2</i> benötigt. In diesem Fall erhältst du unter Umständen einen Deadlock, denn du lockst beide Mutexe <i>m</i> und <i>m2</i> gleichzeitig. Natürlich kann es jetzt passieren, dass ein anderer Thread die Mutexe in einer anderen Reihenfolge lockt. <br></li><li>weder direkt noch indirekt versucht, den Mutex<i> m</i> zu locken, scheint alles richtig zu funktionieren. Die Betonung liegt dabei auf "scheint", denn dein Kollege verändert eventuell nachträglich die Funktion oder sie ist Teil einer dynamischen Bibliothek und du erhälst eine neue Variante von <i>unknownFunction</i>. Hierzu lässt sich nur spekulieren.</li><li>wie erwartet funktioniert, kann sie ein Performanzproblem besitzen, denn du weißt nicht, wie lange die Funktion <i>unknownFunction</i> benötigt. Was als Multithreading-Programm gedacht war, kann sich dadurch als Single-Threaded-Programm entpuppen.<br></li></ul></div>
<div class="text">Um diese Probleme zu lösen, bietet sich eine lokale Variable an:</div>
<div class="pre">std::mutex m;<br>auto tempVar = unknownFunction(); <br>{ <br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lockGuard(m); <br>&nbsp;&nbsp;&nbsp; sharedVariable = tempVar; <br>}<br></div>
<div class="text">Die zusätzliche Indirektion löst die Probleme. <i>tempVar</i> ist eine lokale Variable und ist daher immun gegen eine Data Race. Das heißt, du kannst die <i>unknownFunction</i> ohne Schutzmechanismus aufrufen. Zusätzlich ist die Zeit, in der der Mutex gelockt ist, auf das Minimum reduziert: Die Zuweisungen von <i>tempVar</i> and <i>sharedVariable</i>.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Falls du nicht <i>join</i> oder <i>detach</i> auf dem Kinderthread <i>child</i> aufrufst, wirft <i>child </i>in seinem Destruktor eine <i>std::terminate-</i>Ausnahme. <i>std::terminate</i> ruft per Default [i]<a class="" href="http://en.cppreference.com/w/cpp/utility/program/abort" alt="%7B%22text%22%3A%22std%3A%3Aabort%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>[/i] auf. Um diesen Problem zu lösen, bietete die <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22text%22%3A%22Guidelines%20Support%20Library%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl">Guidelines Support Library</a> <i>gsl::joining_thread </i>an. Dieser ruft automatisch <i>join</i> am Ende seiner Gültigkeitszeitraums auf. In meinen nächsten Artikel werde ich mir <i>gsl::joining_thread</i> genauer anschauen. <br></div>
