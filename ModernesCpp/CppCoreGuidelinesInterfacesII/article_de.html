<div class="text">Interfaces sind ein Vertrag zwischen einem Serviceanbieter und einem Servicenutzer. Die C++ Core Guidelines stellen 20 Regeln für diesen Vertrag auf, denn "interfaces is probably the most important single aspect of code organization".</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_137512287_1a3887bee3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">In meinem <a title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Interfaces-I-3767608.html" href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Interfaces-I-3767608.html" class="" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Interfaces-I-3767608.html%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Interfaces-I-3767608.html%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22letzten%20Artikel%22%7D">letzten Artikel</a> stellte ich die ersten zehn Regeln vor. Konsequenterweise schreibe ich in diesem Artikel über die verbleibenden zehn Regeln. Hier sind alle 20 Artikel im Überblick.<br></div>
<div class="text"><ul><li>I.1: Make interfaces explicit<br></li><li>I.2: Avoid global variables<br></li><li>I.3: Avoid singletons<br></li><li>I.4: Make interfaces precisely and strongly typed<br></li><li>I.5: State preconditions (if any)<br></li><li>I.6: Prefer Expects() for expressing preconditions<br></li><li>I.7: State postconditions<br></li><li>I.8: Prefer Ensures() for expressing postconditions<br></li><li>I.9: If an interface is a template, document its parameters using concepts<br></li><li>I.10: Use exceptions to signal a failure to perform a required task<br></li><li>I.11: Never transfer ownership by a raw pointer (T*)<br></li><li>I.12: Declare a pointer that must not be null as not_null<br></li><li>I.13: Do not pass an array as a single pointer<br></li><li>I.22: Avoid complex initialization of global objects<br></li><li>I.23: Keep the number of function arguments low<br></li><li>I.24: Avoid adjacent unrelated parameters of the same type<br></li><li>I.25: Prefer abstract classes as interfaces to class hierarchies<br></li><li>I.26: If you want a cross-compiler ABI, use a C-style subset<br></li><li>I.27: For stable library ABI, consider the Pimpl idiom<br></li><li>I.30: Encapsulate rule violations</li></ul></div>
<div class="text">Und los geht es mit den Details.<br></div>
<div class="ztitel_kleiner">I.11: Never transfer ownership by a raw pointer (T*)</div>
<div class="text">Der Code</div>
<div class="pre">X* <br>{<br>&nbsp;&nbsp;&nbsp; X* res = new X{};<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return res;<br>}</div>
<div class="text">Wer kümmert sich um den Zeiger X? Es gibt mindestens drei Möglichkeiten die Besitzverhältnisse zu klären.</div>
<div class="text"><ul><li>gib anstelle eines Zeigers einen Wert zurück</li><li>verwende einen Smart Pointer</li><li>verwende <i>owner&lt;X*&gt;</i> aus der <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22guideline%20support%20library%22%7D">guideline support library</a> (GSL)<br></li></ul></div>
<div class="ztitel_kleiner">I.12: Declare a pointer that must not be null as not_null</div>
<div class="text">Welchen semantischen Unterschied besitzen die drei Variationen der folgenden Funktion <i>length</i>?</div>
<div class="pre">// it is not clear whether length(nullptr) is valid<br>int length(const char* p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>// better: we can assume that p cannot be nullptr<br>int length(not_null&lt;const char*&gt; p); &nbsp;<br><br>// we must assume that p can be nullptr<br>int length(const char* p);</div>
<div class="text">Die Absicht der zweiten und dritten Variation ist ziemlich offensichtlich. Die zweite Variante nimmt nur einen Zeiger an, der kein Nullzeiger (nullptr) sein kann. Die letzte Variante akzeptiert auch einen <i>nullptr</i>. Ich denke, du ahnst es bereits. <i>not_null</i> ist aus der GSL.<br></div>
<div class="ztitel_kleiner">I.13: Do not pass an array as a single pointer</div>
<div class="text">Arrays einfach als Zeiger zu übergeben, ist sehr fehleranfällig.</div>
<div class="pre">void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)</div>
<div class="text">Was passiert, wenn <i>n</i> zu groß ist? Genau: undefiniertes Verhalten. Die GSL bietet ein Lösung an, genannt "spans".</div>
<div class="pre">void copy(span&lt;const T&gt; r, span&lt;T&gt; r2); // copy r to r2</div>
<div class="text">Spans leiten die Anzahl ihrer Argument automatisch ab. <br></div>
<div class="ztitel_kleiner">I.22: Avoid complex initialization of global objects</div>
<div class="text">Globale Objekte können für viel Spaß sorgen. Zum Beispiel, wenn sie in verschiedenen Übersetzungseinheiten sind, ist die Reihenfolge ihrer Initialisierung nicht definiert. Damit besitzt das folgende Programmschnipsel undefiniertes Verhalten.</div>
<div class="pre">// file1.c<br><br>extern const X x;<br><br>const Y y = f(x);&nbsp;&nbsp; // read x; write y<br><br>// file2.c<br><br>extern const Y y;<br><br>const X x = g(y);&nbsp;&nbsp; // read y; write x<br></div>
<div class="ztitel_kleiner">I.23: Keep the number of function arguments low</div>
<div class="text">Es gibt eine einfache Regel: eine Funktion solle genau eine Aufgabe erfüllen. Falls diese Regel eingehalten wird, reduziert sich automatisch die Anzahl der Funktionsargumente und die Funktion ist einfacher zu verwenden.</div>
<div class="text">Um ehrlich zu sein, die <a alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Neuen%20Algorithmen%20in%20C%2B%2B17%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FNeue-Algorithmen-in-C-17-3704576.html%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FNeue-Algorithmen-in-C-17-3704576.html%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.heise.de/developer/artikel/Neue-Algorithmen-in-C-17-3704576.html" class="" title="Link auf https://www.heise.de/developer/artikel/Neue-Algorithmen-in-C-17-3704576.html">Neuen Algorithmen in C++17</a> wie <a alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Ftransform_reduce%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Ftransform_reduce%22%2C%22text%22%3A%22std%3A%3Atransform_reduce%20%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" class="" href="http://en.cppreference.com/w/cpp/algorithm/transform_reduce" title="Link auf http://en.cppreference.com/w/cpp/algorithm/transform_reduce">std::transform_reduce </a>verletzen bisweilen diese Regel. <br></div>
<div class="ztitel_kleiner">I.24: Avoid adjacent unrelated parameters of the same type</div>
<div class="text">Welcher Parameter stellt die Quelle und das Ziel der folgenden <i>copy_n </i>Funktion dar? Wohlbegründete Vermutung sind willkommen.</div>
<div class="pre">void copy_n(T* p, T* q, int n);</div>
<div class="text">Ich muss leider allzu häufig in die Dokumentation schauen.<br></div>
<div class="ztitel_kleiner">I.25: Prefer abstract classes as interfaces to class hierarchies</div>
<div class="text">Zugegeben, daß ist eine offensichtliche und lang bewährte Regel für objekt-orientiertes Design. Die Regel gibt zwei Begründungen.</div>
<div class="text"><ul><li>abstrakte Basisklassen sind häufig deutlich stabiler als nicht-abstrakte Basisklassen</li><li>nicht-abstrakte Basisklassen mit Zustand und nicht-abstrakten Methoden schränken die abgeleiteten Klassen deutlich ein<br></li></ul></div>
<div class="ztitel_kleiner">I.26: If you want a cross-compiler ABI, use a C-style subset</div>
<div class="text">ABI steht für Application Binary Interface.<br></div>
<div class="text">Das ist natürlich eine seltsame Regel in den C++ Core Guidelines. Der Grund ist, das "Different compilers implement different binary layouts for classes, exception handling, function names, and other implementation details.". Auf einigen Plattformen entstehen aber gemeinsame ABIs. Falls du <b>einen</b> Compiler verwendest, kannst du natürlich die volle C++ Funktionalität anwenden. In diesem Fall musst du deinen Code gegebenenfalls neu kompilieren.</div>
<div class="ztitel_kleiner">I.27: For stable library ABI, consider the Pimpl idiom</div>
<div class="text">Pimpl steht für pointer to implementation und ist die C++ Variante des bekannten <a class="" href="https://de.wikipedia.org/wiki/Br%C3%BCcke_(Entwurfsmuster)" title="Link auf https://de.wikipedia.org/wiki/Br%C3%BCcke_(Entwurfsmuster)" alt="%7B%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FBr%25C3%25BCcke_%28Entwurfsmuster%29%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FBr%25C3%25BCcke_%28Entwurfsmuster%29%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22bridge%20pattern%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">bridge pattern</a>. Die Idee ist es, dass ein nicht-polymorphes Interface einen Zeiger auf seine Implementierung hält, sodass Veränderungen der Implementierung kein neues Kompilieren des Interfaces erfordern.</div>
<div class="text">Hier ist ein Beispiel aus den C++ Core Guidelines.</div>
<div class="pre">interface (widget.h)<br>class widget {<br>&nbsp;&nbsp;&nbsp; class impl;<br>&nbsp;&nbsp;&nbsp; std::unique_ptr&lt;impl&gt; pimpl;<br>public:<br>&nbsp;&nbsp;&nbsp; void draw(); // public API that will be forwarded to the implementation<br>&nbsp;&nbsp;&nbsp; widget(int); // defined in the implementation file<br>&nbsp;&nbsp;&nbsp; ~widget();&nbsp;&nbsp; // defined in the implementation file, where impl is a complete type<br>&nbsp;&nbsp;&nbsp; widget(widget&amp;&amp;) = default;<br>&nbsp;&nbsp;&nbsp; widget(const widget&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; widget&amp; operator=(widget&amp;&amp;); // defined in the implementation file<br>&nbsp;&nbsp;&nbsp; widget&amp; operator=(const widget&amp;) = delete;<br>};<br><br>implementation (widget.cpp)<br><br>class widget::impl {<br>&nbsp;&nbsp;&nbsp; int n; // private data<br>public:<br>&nbsp;&nbsp;&nbsp; void draw(const widget&amp; w) { /* ... */ }<br>&nbsp;&nbsp;&nbsp; impl(int n) : n(n) {}<br>};<br>void widget::draw() { pimpl-&gt;draw(*this); }<br>widget::widget(int n) : pimpl{std::make_unique&lt;impl&gt;(n)} {}<br>widget::~widget() = default;<br>widget&amp; widget::operator=(widget&amp;&amp;) = default;</div>
<div class="text">Der pimpl ist der Zeiger, der die Implementierung referenziert.</div>
<div class="text">Die Details zu dem pimpl Idiom kannst du schön in dem <a title="Link auf https://herbsutter.com/gotw/_100/" class="" href="https://herbsutter.com/gotw/_100/" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fherbsutter.com%2Fgotw%2F_100%2F%22%2C%22href%22%3A%22https%3A%2F%2Fherbsutter.com%2Fgotw%2F_100%2F%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22GOW%20%23100%22%7D">GOW #100</a> Artikel von Herb Sutter nachlesen. GOW steht für Guru Of the Week.<br></div>
<div class="ztitel_kleiner">I.30: Encapsulate rule violations</div>
<div class="text">Manchmal ist Code hässlich, nicht sicher oder fehleranfällig. Fasse den Code zusammen und verpacke ihn in ein einfach zu verwendetens Interface. Dieser Vorgang ist eine Abstraktion, die du ab und an anwenden musst. Um ehrlich zu sein, ich habe mit solch einem Problem kein Problem, falls dieser Code stabil ist und das Interface es nur erlaubt, ihn richtig zu verwenden.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem letzten Artikel und in diesem habe ich oft die <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22guideline%20support%20library%20%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%7D">guideline support library </a>erwähnt. Jetzt ist es an der Zeit, einen tieferen Blick zu wagen. Genau das werde ich im nächsten Artikel tun.<br></div>