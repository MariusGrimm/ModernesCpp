<div class="text">Drei Artikel waren notwendig, um die 20 Regeln für Klassenhierarchien in den C++ Core Guidelines vorzustellen. In diesem Artikel schließe ich die Miniserie mit den verbleibenden sieben Regeln ab.</div>
<div class="text">In bekannter Manier gibt es erst mal das große Bild. Hier sind die speziellen Regeln für Klassenhierarchien.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143304963_f7aa9341e0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>C.126: An abstract class typically doesn’t need a constructor<br></li><li>C.127: A class with a virtual function should have a virtual or protected destructor<br></li><li>C.128: Virtual functions should specify exactly one of virtual, override, or final<br></li><li>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance<br></li><li>C.130: Redefine or prohibit copying for a base class; prefer a virtual clone function instead<br></li><li>C.131: Avoid trivial getters and setters<br></li><li>C.132: Don’t make a function virtual without reason<br></li><li>C.133: Avoid protected data<br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-public" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-public%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.134%3A%20Ensure%20all%20non-const%20data%20members%20have%20the%20same%20access%20level%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-public%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-public">C.134: Ensure all non-const data members have the same access level</a> <br></li><li> <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.135%3A%20Use%20multiple%20inheritance%20to%20represent%20multiple%20distinct%20interfaces%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface">C.135: Use multiple inheritance to represent multiple distinct interfaces</a> <br></li><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.136%3A%20Use%20multiple%20inheritance%20to%20represent%20the%20union%20of%20implementation%20attributes%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface">C.136: Use multiple inheritance to represent the union of implementation attributes</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-vbase" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-vbase%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-vbase%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.137%3A%20Use%20virtual%20bases%20to%20avoid%20overly%20general%20base%20classes%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-vbase">C.137: Use virtual bases to avoid overly general base classes</a> <br></li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-using" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-using%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-using%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C.138%3A%20Create%20an%20overload%20set%20for%20a%20derived%20class%20and%20its%20bases%20with%20using%22%2C%22type%22%3A%22E%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-using">C.138: Create an overload set for a derived class and its bases with using</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-final" alt="%7B%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-final%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-final%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.139%3A%20Use%20final%20sparingly%22%2C%22version%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-final">C.139: Use final sparingly</a> <br></li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual-default-arg" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual-default-arg" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual-default-arg%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.140%3A%20Do%20not%20provide%20different%20default%20arguments%20for%20a%20virtual%20function%20and%20an%20overrider%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual-default-arg%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">C.140: Do not provide different default arguments for a virtual function and an overrider</a></li></ul></div>
<div class="text">Los geht's mit der Regel C.134.<br></div>
<div class="ztitel"><a alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.134%3A%20Ensure%20all%20non-const%20data%20members%20have%20the%20same%20access%20level%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-public%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-public%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-public" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-public">C.134: Ensure all non-const data members have the same access level</a></div>
<div class="text">Die vorherige Regel <a href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html" class="" alt="%7B%22version%22%3A1%2C%22text%22%3A%22C.133%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html%22%7D">C.133</a> lautete, dass du keine protected Daten verwenden sollst. Diese Regel formuliert, dass deine nicht-konstanten Daten entweder alle public oder private sein sollen. Ein Objekt kann Attribute besitzen, die die Invarianz des Objekts festlegen oder auch nicht festlegen. Nicht-konstante Daten, die nicht die Invarianz von Attributen festlegen, sollten public sein. Im Gegensatz dazu gilt, nicht-konstante und private Attribute definieren die Invarianz des Objekts. Nur zu Erinnerung: ein Datenattribut, das eine Invarianz besitzt, besitzt einen eingeschränkten Gültigkeitsbereich.</div>
<div class="text">Wenn wir das Klassendesign allgemeiner betrachten, lassen sich zwei Typen von Klassen identifizieren.</div>
<div class="text"><ul><li> <b>Alles public</b>: Klassen, die nur public Attribute besitzen, da für die Attribute keine Einschränkungen existieren. Hier sollte eine <i>struct</i> zum Einsatz kommen.</li><li><b>Alles private</b>: Klassen, die nur private und konstante Attribute besitzen, die die Einschränkungen für die konkreten Objekte definieren.</li></ul></div>
<div class="text">Basierend auf dieser Beobachtung sollten alle nicht-konstanten Attribute der Klasse entweder public oder private sein.</div>
<div class="text">Stelle dir vor, du hast eine Klasse mit nicht-konstanten und public Attributen. Das bedeutet, dass die Einschränkungen für diese Attribute in der ganzen Klassenhierarchie gepflegt werden müssen. Das ist natürlich sehr fehleranfällig, denn die Einschränkungen lassen sich nicht einfach kontrollieren. Oder anders ausgedrückt: Das Klassendesign bricht eine der grundlegenden Regeln des objektorientierten Entwurfs: Kapselung. </div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.135%3A%20Use%20multiple%20inheritance%20to%20represent%20multiple%20distinct%20interfaces%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D">C.135: Use multiple inheritance to represent multiple distinct interfaces</a></div>
<div class="text">Es ist eine sehr gute Idee, wenn ein Interface nur einen Aspekt des Klassendesigns unterstützt. Was genau bedeutet das? Falls du ein reines Interface, das nur aus rein virtuellen Funktionen besteht, entwirfst, müssen konkreten Klassen alle Funktionen implementieren. Das bedeutet insbesondere in dem Fall, wenn das Interface zu mächtig angelegt wurde, dass die konkrete Klasse Funktionen implementieren muss, die sie weder benötigt noch einen Sinn für sie ergeben.</div>
<div class="text">Ein Beispiel für zwei getrennte Interfaces sind die <i>istream</i> and <i>ostream</i> Interfaces der Ein- und Ausgabestreams.</div>
<div class="pre">class iostream : public istream, public ostream {&nbsp;&nbsp; // very simplified<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Durch die Kombination der Interfaces <i>istream</i> für die Eingabe- und <i>ostream</i> für die Ausgabeoperationen, lässt sich einfach ein neues Interface entwerfen.</div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-mi-interface" class="" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.136%3A%20Use%20multiple%20inheritance%20to%20represent%20the%20union%20of%20implementation%20attributes%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-mi-interface%22%2C%22custom%22%3A%7B%7D%7D">C.136: Use multiple inheritance to represent the union of implementation attributes</a>, <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-vbase" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-vbase" alt="%7B%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-vbase%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.137%3A%20Use%20virtual%20bases%20to%20avoid%20overly%20general%20base%20classes%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-vbase%22%2C%22alias%22%3A%22%22%7D">C.137: Use virtual bases to avoid overly general base classes</a></div>
<div class="text">Beide Regeln sind sehr speziell. Daher werde ich auf sie nicht eingehen. Die Guidelines sagen, dass die Regeln C.137 verhältnismässig selten zum Einsatz kommt und dass die Regel C.138 der Regel C.129 sehr ähnlich ist: <a href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html" class="" alt="%7B%22target%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22When%20designing%20a%20class%20hierarchy%2C%20distinguish%20between%20implementation%20inheritance%20and%20interface%20inheritance.%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Mehr-Regeln-zu-Klassenhierarchien-3852056.html%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance.</a> </div>
<div class="ztitel"><a alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-using%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.138%3A%20Create%20an%20overload%20set%20for%20a%20derived%20class%20and%20its%20bases%20with%20using%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-using%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-using" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-using">C.138: Create an overload set for a derived class and its bases with using</a></div>
<div class="text">Diese Regel ist ziemlich offensichtlich und gilt für virtuelle und nicht virtuelle Funktionen. Falls du nicht die using Deklaration verwendest, dann versteckt die abgeleitete Klasse die gleichnamigen Funktionen der Basisklassen. In der englischsprachigen Literatur werden die gleichnamigen Funktionen der Basisklasse als <i>overload se</i>t bezeichnet. Für diesen Prozess die gleichnamigen Funktionen der Basisklasse zu verstecken, wird auch gerne der Begriff <i>shadowing</i> verwendet. Das Überraschungspotential ist sehr groß, wenn du diese Regel nicht beachtest.</div>
<div class="text">Genau das zeigt ein Beispiel aus den Guidelines.</div>
<div class="pre">class B {<br>public:<br>&nbsp;&nbsp;&nbsp; virtual int f(int i) { std::cout &lt;&lt; "f(int): "; return i; }<br>&nbsp;&nbsp;&nbsp; virtual double f(double d) { std::cout &lt;&lt; "f(double): "; return d; }<br>};<br>class D: public B {<br>public:<br>&nbsp;&nbsp;&nbsp; int f(int i) override { std::cout &lt;&lt; "f(int): "; return i + 1; }<br>};<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; D d;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; d.f(2) &lt;&lt; '\n';&nbsp;&nbsp; // prints "f(int): 3"<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; d.f(2.3) &lt;&lt; '\n'; // prints "f(int): 3"<br>}<br></div>
<div class="text">Betrachte die letzte Zeile. <i>d.f(2.3) </i>wird mit einem <i>double</i> Argument aufgerufen. Trotzdem kommt die für <i>int </i>überladene Funktion der Klasse <i>D</i> zum Einsatz. Das führt auch noch dazu, dass eine verengende Konvertierung von <i>double </i>auf <i>int </i>stattfindet. Das entspricht mit großer Wahrscheinlichkeit nicht der Intention des Autors. Um die <i>double</i> Überladung der Klasse <i>B</i> zu verwenden, muss diese in den Scope for <i>D</i> eingeführt werden. </div>
<div class="pre">class D: public B {<br>public:<br>&nbsp;&nbsp;&nbsp; int f(int i) override { std::cout &lt;&lt; "f(int): "; return i + 1; }<br>&nbsp;&nbsp;&nbsp; using B::f; // exposes f(double)<br>};</div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-final" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-final" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-final%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.139%3A%20Use%20final%20sparingly%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-final%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">C.139: Use final sparingly</a></div>
<div class="text"><i>final</i> ist ein neues Feature mit C++11. Du kannst es für Klassen oder virtuelle Funktionen anwenden.</div>
<div class="text"><ul><li> Falls eine Klasse <i>My_widge</i>t final von der Klasse Widget abgeleitet wird, kann von der Klasse <i>My_widget</i> nicht weiter abgeleitet werden.<br></li></ul></div>
<div class="pre">class Widget { /* ... */ };<br><br>// nobody will ever want to improve My_widget (or so you thought)<br>class My_widget final : public Widget { /* ... */ };<br><br>class My_improved_widget : public My_widget { /* ... */ };&nbsp; // error: can't do that</div>
<div class="text"><ul><li>Eine virtuelle Funktion kann als <i>final</i> deklariert werden. Das bedeutet, dass die Funktion nicht mehr überschrieben werden kann.</li></ul></div>
<div class="pre">struct Base<br>{<br>&nbsp;&nbsp;&nbsp; virtual void foo();<br>};<br>&nbsp;<br>struct A : Base<br>{<br>&nbsp;&nbsp;&nbsp; void foo() final; // A::foo is overridden and it is the final override<br>};<br>&nbsp;<br>struct B final : A // struct B is final<br>{<br>&nbsp;&nbsp;&nbsp; void foo() override; // Error: foo cannot be overridden as it's final in A<br>};</div>
<div class="text">Wenn du <i>final </i>einsetzt, unterbindest du das Erweitern der Klasse oder seiner virtuellen Funktionen. Das hat oft Konsequenzen, die erst deutlich später offensichtlich werden. Einem potentiellen, kleinen Performanzvorteil durch die Verwendung von <i>fina</i>l sollte nicht die Erweiterbarkeit der Klassenhierarchie geopfert werden.<br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual-default-arg" alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22C.140%3A%20Do%20not%20provide%20different%20default%20arguments%20for%20a%20virtual%20function%20and%20an%20overrider%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual-default-arg%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-virtual-default-arg%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-virtual-default-arg">C.140: Do not provide different default arguments for a virtual function and an overrider</a></div>
<div class="text">Falls du diese Regel nicht beachtest, können böse Überraschungen auftreten. Los geht's.<br></div>
<div class="pre">// overrider.cpp<br><br>#include &lt;iostream&gt;<br><br>class Base {<br>public:<br>&nbsp;&nbsp;&nbsp; virtual int multiply(int value, int factor = 2) = 0;<br>};<br><br>class Derived : public Base {<br>public:<br>&nbsp; int multiply(int value, int factor = 10) override {<br>&nbsp;&nbsp;&nbsp; return factor * value;<br>&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Derived d;<br>&nbsp; Base&amp; b = d;<br><br>&nbsp; std::cout &lt;&lt; "b.multiply(10): " &lt;&lt; b.multiply(10) &lt;&lt; std::endl; <br>&nbsp; std::cout &lt;&lt; "d.multiply(10): " &lt;&lt; d.multiply(10) &lt;&lt; std::endl;&nbsp; <br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Hier ist die böse Überraschung. Das Programm besitzt nicht das erwartete Ergebnis.<br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143304970_37aa497a5f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Was passiert hier? Beide Objekte b und d rufen dieselbe Funktion auf, da diese virtuell ist. Damit kommt späte Bindung zum Einsatz. Das gilt aber nicht für die Daten wie die Defaultargumente. Sie werden statisch gebunden und somit kommt frühe Bindung zum Einsatz.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nun ist es vollbracht. In den zwei vorherigen und diesem Artikel habe ich alle 20 Regeln zu Klassenhierarchien vorgestellt. Eine Frage bleibt aber offen:&nbsp; Wie lassen sich die Objekte der Klassenhierarchien ansprechen. Genau mit der Beantwortung dieser Frage wird sich der nächste Artikel beschäftigen.</div>
<div class="ztitel">Weitere Informationen:</div>
<div class="text"><ul><li>Das pdf-Päckchen mit Artikel zu C++17 steht auf <a href="http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-embedded-c-17" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-embedded-c-17" alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22www.grimm-jaud.de%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-embedded-c-17%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-embedded-c-17%22%7D">www.grimm-jaud.de</a> bereit. Es enthält neben dem gut 30-seitigen pdf alle Codebeispiele und eine einfache cmake Datei.<br></li></ul></div>
