<div class="vorspann">Ich war sehr neugierig, welche weiteren Mythen mir meine Leser schicken würden. Insbesondere die Leser auf diesem Blog waren ziemlich aktiv. Ich erhielt ein paar E-Mails und beobachtete eine lebhafte Diskussion auf <a href="https://www.heise.de/forum/heise-Developer/Kommentare/C-Core-Guidelines-Mehr-Nichtregeln-und-Mythen/forum-432200/comment/" title="Link auf https://www.heise.de/forum/heise-Developer/Kommentare/C-Core-Guidelines-Mehr-Nichtregeln-und-Mythen/forum-432200/comment/" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fforum%2Fheise-Developer%2FKommentare%2FC-Core-Guidelines-Mehr-Nichtregeln-und-Mythen%2Fforum-432200%2Fcomment%2F%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fforum%2Fheise-Developer%2FKommentare%2FC-Core-Guidelines-Mehr-Nichtregeln-und-Mythen%2Fforum-432200%2Fcomment%2F%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22heise%20Developer%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">heise Developer</a>.</div><div class="text">Bevo ich zu den mir zugeschickten Mythen schreibe, möchte ich zuerst die letzte Regel der C++ Core Guidelines vorstellen. Hier ist der letzte Mythos:</div><div class="text"><a alt="%7B%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-protected-data%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-protected-data%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22NR.7%3A%20Don%C2%92t%3A%20Make%20all%20data%20members%20protected%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-protected-data" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-protected-data">NR.7: Don’t: Make all data members protected</a>&nbsp;<br></div><div class="text">Daten, die als "protected" deklariert sind, machen dein Programm anspruchsvoller und fehleranfälliger. Falls in der Basisklasse <i>protected</i>-Daten zum Einsatz kommen, lässt sich nicht mehr über abgeleitete Klassen in Isolation nachdenken. Damit brichst du die Kapselung. Du musst dir immer Gedanken zu ganzen Klassenhierarchien machen. </div><div class="text">Das bedeutet, diese drei Fragen müssen in der Regel beantwortet werden.</div><div class="text"><ol><li>Muss ich einen Konstruktor implementieren, um das <i>protected</i>-Datum richtig zu initialisieren?</li><li>Welchen Wert besitzen das <i>protected</i>-Datum, wenn ich es verwende?</li><li>Welche Funktionalität wird in Mitleidenschaft gezogen, wenn ich das <i>protected</i>-Datum verändere?</li></ol></div><div class="text">Natürlich wird die Beantwortung dieser Fragen umso anspruchsvoller, je mehr die Klassenhierarchie in die Tiefe wächst.</div><div class="text">Streng genommen ist ein <i>protected</i>-Datum eine globale Variable in der Klassenhierarchie. Das erste Gebot der Softwareentwicklung lautet aber: <b>Vermeide globale Daten</b>. </div><div class="text">Nun zu den Mythen:<br></div><div class="ztitel">In C++ geschriebene Programme brauchen mehr Speicher und CPU-Zeit als in C geschriebenen Programme (Gunter Königsmann)<br></div><div class="text">Ehrlich gesagt, gegen diesen Mythos zu argumentieren, ist ziemlich schwierig und im Allgemeinen nicht möglich, wenn es um die C++-Bibliothek geht. Dies ist der Grund, dass ich nur ein paar Beobachtungen am Ende dieses Kapitels präsentiere. Zuerst einmal kommen aber die harten Fakten auf den Tisch. Der "Technical Report on C++ Performance" hilft mir dabei sehr. </div><div class="ztitel_kleiner"><a alt="%7B%22text%22%3A%22Technical%20report%20on%20C%2B%2B%20performance%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%7D" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">Technical report on C++ performance</a>&nbsp;</div><div class="text">2006 verfasst die Working Group WG 21 das Dokument <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ISO%2FIEC%20TR%2018015%22%2C%22subject%22%3A%22%22%7D">ISO/IEC TR 18015</a>. Der Titel hört sich sehr sperrig an. Tatsächlich ist das Dokument die erste Wahl, wenn es darum geht,&nbsp;die Performanz von C++ zu analysieren. Diesen folgenden Aspekt bringt das Dokument direkt auf den Punkt:</div><div class="text"><ul><li>to give the reader a model of time and space overheads implied by use of various C++ language and library features,</li><li>to debunk widespread myths about performance problems,</li><li>to present techniques for use of C++ in applications where performance matters, and</li><li>to present techniques for implementing C++ Standard language and library facilties to yield efficient code.</li></ul></div><div class="text">Verfasser des gut 200-seitigen Reports sind so bekannte Namen wie Dave Abrahams, Howard Hinnand, Dietmar Kühl, Dan Saks, Bill Seymour, Bjarne Stroustrup und Detlef Vollmann.</div><div class="text">In dem Dokument selbst geht es um die C++-Sprachmerkmale, deren Kosten und Verwendung, dem Erzeugen effizienter Bibliotheken in C++, der Nutzung von C++ in Embedded-Systemen und einer Schnittstelle in C++, um mit Hardware zu kommunizieren. Insbesondere auf die C++-Sprachmerkmale, deren Kosten und Verwendung will ich genauer eingehen.&nbsp;</div><div class="text"><b>C++-Sprachmerkmale, Kosten und Verwendung</b><br> </div><div class="text">Bei ihrer Analyse greifen die Autoren auf drei Computerarchitekturen mit fünf verschiedenen C++-Compilern zurück. Die Compiler rufen sie mit unterschiedlichen Optimisierungsstufen auf. Die Ergebnisse, die ich deutlich vereinfachend darstelle, sind sehr aufschlussreich.</div><div class="text"><b>Namensräume</b></div><div class="text"><ul><li>Besitzen keinen signifikanten Einfluss auf die Größe des Programms oder sein Zeitverhalten.</li></ul></div><div class="text"><b>Typkonvertierungs-Operatoren</b></div><div class="text"><ul><li>Die C++-Casts <i>const_cast</i>, <i>static_cast </i>und<i> reinterpret_cast</i> unterscheiden sich weder in Größe noch Zeitverhalten von ihrem C-Pendant.</li><li>Der zur Laufzeit ausgeführte <i>dynamic_cast</i> besitzt einigen Kosten. (Anmerkung: Diese Konvertierung besitzt kein Pendant in C.)</li></ul></div><div class="text"><b>Klasse</b></div><div class="text"><ul><li>Eine Klasse (class) ohne virtuelle Funktionen ist genauso groß wie eine Struktur (struct).</li><li>Eine Klasse mit virtuellen Funktionen besitzt die Kosten eines Zeigers und einer virtuellen Funktionstabelle (virtual function table). Dies sind typischerweise 2 bis 4 Byte.</li></ul></div><div class="text"><b>Funktionsaufrufe auf Objekten</b></div><div class="text"><ul><li>Der Aufruf einer nichtvirtuellen, nichtstatischen, nicht-inline Funktion ist genauso teuer wie der Aufruf einer freien Funktion.</li><li>Der Aufruf einer virtuellen Funktion ist so teuer wie der Aufruf einer freien Funktion mithilfe eines Zeigers, der in einem Array gespeichert ist.</li><li>Virtuelle Funktionen eines Klasse-Templates können Kosten verursachen.&nbsp;</li><li>Das Inlining von Funktionen bringt einen signifikanten Vorteil, reicht aber noch nicht ganz an die Performanz von C-Makros heran. </li></ul></div><div class="text"><b>Mehrfachvererbung</b></div><div class="text"><ul><li>Kann Zeit- und/oder Größen-Kosten implizieren.</li><li>Virtuelle Basisklassen besitzen gegenüber nichtvirtuellen Basisklassen zusätzlichen Kosten.</li></ul></div><div class="text"><b>Run-Time Type Information (RTTI)</b></div><div class="text"><ul><li>Pro Klasse werden typischerweise zusätzlich 40 Bytes benötigt.</li><li>Der <span class="tx_code">typeid</span>-Aufruf ist relativ langsam. Dies scheint aber&nbsp;ein Problem der Güte der Implementierung zu sein.</li><li>Die Konvertierung zur Laufzeit mit <span class="tx_code">dynamic_cast</span> ist langsam. Der Grund scheint laut dem Report vor allem auch in der Qualität der Implementierung zu liegen.</li></ul></div><div class="text"><b>Ausnahmebehandlung</b></div><div class="text"><ul><li>Zwei Strategien für den Umgang mit Ausnahmen haben sich etabliert. Das ist die Code- und die Tabellen-Strategie. Während bei der Code-Strategie zur Laufzeit zusätzliche Datenstrukturen für den Ausführungskontext verwaltet und verschoben werden müssen, wird bei der Tabellen-Strategie der Ausführungskontext in einer Tabelle vorgehalten.</li><li>Die Code-Strategie besitzt ein Größen-Overhead für den Stack und die Laufzeit. Der Zeit-Overhead ist ca. 6 Prozent, selbst wenn die Ausnahme nicht auftritt.</li><li>Die Tabellen-Strategie besitzt weder Kosten in der Programmgröße noch in der Laufzeit (Anmerkung: Für die Laufzeit gilt dies nur, wenn keine Ausnahme auftrat). Dafür ist diese Strategie schwieriger zu implementieren.</li></ul></div><div class="text"><b>Templates</b></div><div class="text"><ul><li>Für jedes Template-Argument wird ein neues Funktions- oder Klassen-Template erzeugt. Naiver Umgang mit Templates kann daher zu einem deutlichen Anstieg der Codegröße führen. Moderne C++-Compiler können&nbsp;die Anzahl der Template-Instanziierung deutlich reduzieren. In der Standard Template Library wird teilweise oder vollständige Template-Spezialisierung angewandt, um die Anzahl der Template-Instanziierungen zu reduzieren.</li></ul></div><div class="text">Die genauen Details, die exakten Zahlen und alle weiteren Punkte lassen sich in dem Report <a alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22TR18015.pdf%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">TR18015.pdf</a> schön nachlesen.</div><div class="ztitel_kleiner"><a href="http://www.misra.org.uk/Activities/tabid/56/Default.aspx" title="Link auf http://www.misra.org.uk/Activities/tabid/56/Default.aspx" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.misra.org.uk%2FActivities%2Ftabid%2F56%2FDefault.aspx%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.misra.org.uk%2FActivities%2Ftabid%2F56%2FDefault.aspx%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22MISRA%20C%2B%2B%22%7D">MISRA C++</a> <br></div><div class="text">MISRA C++ (<b>M</b>otor <b>I</b>ndustry <b>S</b>oftware <b>R</b>eliability <b>A</b>ssociation) stellt Regeln für das Schreiben von Software in sicherheitskritischen System auf. MISRA C++ wurde ursprünglich für die Automobilindustrie entwickelt, ist aber mittlerweile Industriestandard im Flugzeugbau, Militär und auch im Medizinbereich. <br></div><div class="text">MISRA C++ stellt heraus, warum die Bedeutung von C++ in sicherheitskritischen System immer weiter zunimmt (1.1 The use of C++ in critical systems) :</div><div class="text"><ul><li> C++ gives good support for high-speed, low-level, input/output operations, which are essential to many embedded systems.</li><li>The increased complexity of applications make the use of a high-level language more appropriate than assembly language.</li><li>C++ compilers generate code with similar size and RAM requirements to those of C.</li></ul></div><div class="text">Ein bitterer Wermutstropfen bleibt aber.&nbsp;MISRA C++ basiert auf klassischem C++. Dies ist vereinfachend gesprochen C++98. Modernes C++ hat aber deutlich mehr zu bieten für Embedded-Systeme. Diese Beobachtung gilt leider auch für den bereits vorgestellten Report <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Technical%20report%20on%20C%2B%2B%20performance%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">Technical report on C++ performance</a>.</div><div class="text">Ohne ein paar Beobachtungen zu modernem C++ kann ich diesen Artikel nicht beenden. Modernes C++ ist ein Begriff, der meist für die C++-Standards C++11, C++14 und C++17 eingesetzt wird.<br></div><div class="ztitel_kleiner">Meine Beobachtungen </div><div class="text">Die Schwierigkeit, die Features der C++ Bibliothek mit ihrem C Pendant zu vergleichen, besteht vor allem darin, dass ein Vergleich äquivalente Datenstrukturen, Algorithmen oder Programme voraussetzt. Das heißt, damit lässt sich ein C-String mit einem C++-String nicht vergleichen, denn die C++-Variante verwaltet zum Beispiel automatisch ihren Speicher. Dieselbe Beobachtung lässt sich auf einen C-Array und die Container der Standard Template Library anwenden. Diese Punkte halten mich aber nicht davon ab, ein paar Punkte aufzuzählen. Wenn du mehr Details wissen willst, lese den hinterlegten Artikel.</div><div class="text"><ul><li> Ein <i>std::array i</i>st per Design so schnell und benötigt so wenig Speicher wie ein C-Array. Zusätzlich kennt es seine Länge: <a href="https://heise.de/-4431985" title="Link auf https://heise.de/-4431985" alt="%7B%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4431985%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4431985%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%5Bi%5Dstd%3A%3Avector%5B%2Fi%5D%20und%20%5Bi%5Dstd%3A%3Aarray%5B%2Fi%5D%20sind%20die%20erste%20Wahl%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D">[i]std::vector[/i] und [i]std::array[/i] sind die erste Wahl</a>.<br></li><li>Ein <i>std::unique_ptr </i>ist per Design so schnell und benötigt so wenig Speicher wie ein nackter Zeiger. Klar, der <i>std::unique_ptr</i> ist auch sicher per Design: <a alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Speicher-%20und%20Performanzoverhead%20von%20Smart%20Pointern%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern" href="https://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern">Speicher- und Performanzoverhead von Smart Pointern</a>.<br></li><li>Die Type-Traits Bibliothek erlaubt es Code zu schreiben, der sich selbst optimiert: <a alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Type-Traits-%20Performanz%20z%C3%A4hlt%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftype-traits-performanz-zaehlt%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftype-traits-performanz-zaehlt%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/type-traits-performanz-zaehlt" title="Link auf https://www.grimm-jaud.de/index.php/blog/type-traits-performanz-zaehlt">Type-Traits- Performanz zählt</a>.<br></li><li>Dank <i>constexpr</i> lassen sich aufwendige Berechnungen auf die Compilezeit verschieben: <a alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Programmierung%20zur%20Compilezeit%20mit%20constexpr%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Programmierung-zur-Compilezeit-mit-constexpr-4296535.html%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Programmierung-zur-Compilezeit-mit-constexpr-4296535.html%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Programmierung-zur-Compilezeit-mit-constexpr-4296535.html" href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Programmierung-zur-Compilezeit-mit-constexpr-4296535.html">C++ Core Guidelines: Programmierung zur Compilezeit mit constexpr</a>.<br></li><li>Move-Semantik und Perfect Fowarding erlauben es, teures und unsicheres Kopieren durch billiges und sicheres Verschieben zu ersetzen. Vereinfachend gesprochen kann eine Copy-Operation im Gegensatz zu einer Move-Operation fehlschlagen: <a alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Copy-%20versus%20Move-Semantik%3A%20Ein%20paar%20Zahlen%20%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcopy-versus-move-semantik-ein-paar-zahlen%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcopy-versus-move-semantik-ein-paar-zahlen%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/copy-versus-move-semantik-ein-paar-zahlen" title="Link auf https://www.grimm-jaud.de/index.php/blog/copy-versus-move-semantik-ein-paar-zahlen">Copy- versus Move-Semantik: Ein paar Zahlen </a>und <a alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Perfect%20Forwarding%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/perfect-forwarding" title="Link auf https://www.grimm-jaud.de/index.php/blog/perfect-forwarding">Perfect Forwarding</a>.<br></li></ul></div><div class="ztitel_kleiner">Wie geht's weiter? </div><div class="text">Ich hätte nicht gedacht, dass ich fast einen ganzen Artikel benötige, um gegen die Mythen zur Performanz und zum Speicherverbrauch von C++ zu argumentieren. Du kannst dir vorstellen, dass ich weitere Mythen zugeschickt bekommen habe. Auf diese werde ich in meinem nächsten Artikel eingehen. Falls du noch einen Mythos kennst, kannst du ihn mir auch gerne schicken: <a title="Link auf rainer.grimm@modernescpp.de" href="mailto:rainer.grimm@modernescpp.de" alt="%7B%22text%22%3A%22rainer.grimm%40modernescpp.de%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22type%22%3A%22E_Mail%22%2C%22href%22%3A%22mailto%3Arainer.grimm%40modernescpp.de%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22%22%2C%22destination%22%3A%22rainer.grimm%40modernescpp.de%22%2C%22ir_link%22%3A1%7D">rainer.grimm@modernescpp.de</a>.</div><div class="simple-translate-result-wrapper"><br> <br></div>
