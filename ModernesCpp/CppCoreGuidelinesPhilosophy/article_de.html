<div class="vorspann">Heute tauche ich tiefer in die C++ Core Guidelines ein. In meinem <a alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%2C%22text%22%3A%22letzten%20Artikel%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FWas-ist-modernes-C-3746281.html%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FWas-ist-modernes-C-3746281.html%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf https://www.heise.de/developer/artikel/Was-ist-modernes-C-3746281.html" href="https://www.heise.de/developer/artikel/Was-ist-modernes-C-3746281.html">letzten Artikel</a> habe ich sie bereits vorgestellt. Heute geht es aber in dem Abschnitt "primarily for humans". Diese ist der allgemeinste aller Abschnitte und besitzt den Namen Philosophie. Die Regeln sind so allgemeingültig, dass du sie auf jede Programmiersprache anwenden kannst.<br></div>
<div class="text">Nur eine kleine Gedächtnisstütze für dich. Die C++ Core Guidelines bestehen aus 350 Regeln. Diese sind in die folgenden Abschnitte gruppiert.</div>
<div class="text"><ul><li>In: Introduction<br></li><li>P: Philosophy<br></li><li>I: Interfaces<br></li><li>F: Functions<br></li><li>C: Classes and class hierarchies<br></li><li>Enum: Enumerations<br></li><li>R: Resource management<br></li><li>ES: Expressions and statements<br></li><li>E: Error handling<br></li><li>Con: Constants and immutability<br></li><li>T: Templates and generic programming<br></li><li>CP: Concurrency<br></li><li>SL: The Standard library<br></li><li>SF: Source files<br></li><li>CPL: C-style programming<br></li><li>Pro: Profiles<br></li><li>GSL: Guideline support library<br></li><li>FAQ: Answers to frequently asked questions</li></ul></div>
<div class="text">Heute werfe ich einen genaueren Blick auf die 13 Regeln zur Philosophie. Sie liefern die Begründung für die mehr als 350 weiteren Regeln.</div>
<div class="utitel">Philosophie</div>
<div class="utitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_136830782_dcca79f10e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die folgenden 13 Regeln können nicht vollständig geprüft werden.</div>
<div class="text"><ul><li>P.1: Express ideas directly in code<br></li><li>P.2: Write in ISO Standard C++<br></li><li>P.3: Express intent<br></li><li>P.4: Ideally, a program should be statically type safe<br></li><li>P.5: Prefer compile-time checking to run-time checking<br></li><li>P.6: What cannot be checked at compile time should be checkable at run time<br></li><li>P.7: Catch run-time errors early<br></li><li>P.8: Don’t leak any resources<br></li><li>P.9: Don’t waste time or space<br></li><li>P.10: Prefer immutable data to mutable data<br></li><li>P.11: Encapsulate messy constructs, rather than spreading through the code<br></li><li>P.12: Use supporting tools as appropriate<br></li><li>P.13: Use support libraries as appropriate</li></ul></div>
<div class="text">Falls möglich, werde ich Beispiele aus den <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="">C++ Core Guidelines</a> zu jeder Regel präsentieren.</div>
<div class="ztitel">Express ideas directly in code</div>
<div class="text">Dein Code soll deine Ideen direkt ausdrücken. Die zwei Methoden bringen die Idee auf den Punkt.</div>
<div class="pre">class Date {<br>&nbsp;&nbsp;&nbsp; // ...<br>public:<br>&nbsp;&nbsp;&nbsp; Month month() const;&nbsp; // do&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int month();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // don't<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Weder drückt die zweite Methode <i>month() </i>aus, dass sie die Instanz nicht verändern wird noch, dass sie einen <i>Monat</i> zurückgibt. </div>
<div class="text">Dieselbe Argumentation trifft oft für explizite Schleifen versus Algorithmen der Standard Template Library (STL) zu.</div>
<div class="pre">int index = -1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad<br>for (int i = 0; i &lt; v.size(); ++i) {<br>&nbsp;&nbsp;&nbsp; if (v[i] == val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>auto p = find(begin(v), end(v), val);&nbsp; // better</div>
<div class="text">Die übergeordnete Regel ist in diesem Beispiel offensichtlich. Du solltest als professioneller C++ Entwickler die Algorithmen der STL kennen. </div>
<div class="ztitel">Write in ISO Standard C++</div>
<div class="text">Die Regel hört sich recht einfach an und besitzt daher ein einfach Konsequenz: "Verwende einen aktuellen C++11 oder C++14 Compiler ohne Erweiterungen."</div>
<div class="ztitel">Express intent</div>
<div class="text">Dein Code soll seine Absicht direkt ausdrücken. Was können wir aus den drei folgenden expliziten und impliziten Schleifen ableiten?</div>
<div class="pre">for (const auto&amp; v: vec) { ... }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br>for (auto&amp; v: vec){ ... }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>for_each(par, vec, [](auto v){ ... }); (3)</div>
<div class="text">In (1) werden die Elemente des Containers vec nicht modifiziert. Das gilt aber nicht für die Range-basierte for-Schleife in (2).&nbsp; Der Algorithmus <i>for_each</i> (2) wird parallel ausgeführt (<i>par</i>). Das bedeutet, dass es irrelevant ist, in welcher Reihenfolge die Elemente prozessiert wird. <br></div>
<div class="ztitel">Ideally, a program should be statically type safe<br></div>
<div class="text">Dein Ziel sollte es sein, Programme zu schreiben, die bereits zur Compilezeit auf ihre Typsicherheit geprüft werden. Natürlich ist das nicht immer in C++ möglich. Daher nennen die C++ Core Guidelines diese kritischen Bereiche und bietet Lösungen an.</div>
<div class="text"><ul><li> verwende <i>std::variant</i> (neu mit C++17) anstelle von unions</li><li>minimiere die Verwendung von casts; setze statt dessen Templates ein, falls möglich</li><li>verwende <i>gsl::spa</i>n gegen array decay (falls du ein Array an eine Funktion übergibst, wird dieses Array implizit zu einem Zeiger auf sein erstes Element reduziert) und Bereichsfehler</li><li>minimiere "narrowing conversion" ("narrowing conversion" oder verengende Konvertierung ist die implizite Konvertierung von Datentypen auf einfachere Datentypen, mit der ein Verlust der Datengenauigkeit eingehen kann; so kann aus einem <i>double</i> ein <i>int</i> werden)</li></ul></div>
<div class="text">gsl steht für Gudelines Support Library GSL. GSL ist eine kleine Bibliothek, die hilft, die Regeln der C++ Core Guidelines umzusetzen. Ich werde ihr noch einen separaten Artikel widmen.</div>
<div class="ztitel">Prefer compile-time checking to run-time checking<br></div>
<div class="text">Alles, was bereits zum Compilezeit geprüft werden kann, sollte zur Compilezeit geprüft werden. Seit C++11 besitzen wir die Funktion <i>static_assert</i> und die Typ-Traits Bibliothek. Dank <i>static_asser</i>t lässt sich ein Ausdruck wie <i>static_assert(sizeof(int) &gt;= 4)</i> zur Compilezeit auswerten. Dank der Type-Traits Biblitothek können wir mächtige Bedingungen an einen Typ T zur Compilezeit formulieren: <i>static_assert(std::is_integral&lt;T&gt;::value)</i>. Es versteht sich von selbst: Falls der <i>static_assert </i>Ausdruck zu <i>false</i> evaluiert, steigt der Compiler mit einer lesbaren Fehlermeldung aus. Ich schrieb bereits Artikel zu <a href="http://www.grimm-jaud.de/index.php/blog/tag/static-assert" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/static-assert" class="" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fstatic-assert%22%2C%22text%22%3A%22static_assert%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fstatic-assert%22%2C%22type%22%3A%22E%22%7D">static_assert</a>. </div>
<div class="ztitel">What cannot be checked at compile time should be checkable at run time</div>
<div class="text">Diese Regel beschäftigt sich mit hart zu findenden Fehlern, die es zu vermeiden gilt. Daher beschäftigt sich das Beispiel mit dynamisch allozierten Arrays.</div>
<div class="pre">extern void f(int* p);<br>extern void f2(int* p, int n);<br>extern void f3(unique_ptr&lt;int[]&gt; uniq, int n);<br><br>f(new int[n]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br>f2(new int[n], m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>f3(make_unique&lt;int[]&gt;(n), m);&nbsp;&nbsp; (3)</div>
<div class="text">Was ist verbesserungswürdig an diesem Beispiel? Der Aufruf (1) übergibt nicht die Anzahl seiner Elemente. (2) erlaubt es hingegen, die falsche Anzahl an Element anzugeben. Der Aufruf (3) übergibt die Besitzverhältnisse und die seine Anzahl separat. Diese Probleme lassen sich lösen, wenn du eine Referenz oder views (Teil der gsl) verwendest.</div>
<div class="ztitel">Catch run-time errors early</div>
<div class="text">Hier sind die Maßnahmen für diese Regel:</div>
<div class="text"><ul><li> Kümmere dich um Zeiger und Arrays: Prüfe deren Bereiche frühzeitig und nicht mehrfach</li><li>Kümmere dich um Konvertierungen: Unterbinde oder zu mindestens markiere "narrowing conversions"</li><li>Kümmere dich um die ungeprüfte Eingaben</li></ul></div>
<div class="ztitel">Don't leak any resource<br></div>
<div class="text">Leckende ("leaking") Ressourcen sind insbesondere für lang-laufende Programme kritisch. Ressourcen können Speicher, aber auch Dateihandel oder auch Sockets sein. Die idiomatische Art, diese Anforderung in C++ zu beantworten, ist RAII. RAII steht für Rescource Acquisition Is Initialization. Dies C++ Idiom besagt, das eine Ressource im Konstruktor eines lokalen Objektes angefordert und im Destruktor des Objektes wieder freigegeben wird. Damit ist die Lebenszeit der kritischen Ressource an die Lebenszeit eines lokalen Objekts gebunden. Genau um dieses lokale Objekt kümmert sich aber die C++ Laufzeit. Hier gibt es mehr Details zu <a alt="%7B%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fgarbage-collectio-no-thanks%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fgarbage-collectio-no-thanks%22%2C%22text%22%3A%22%20RAII%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf http://www.modernescpp.com/index.php/garbage-collectio-no-thanks" href="http://www.modernescpp.com/index.php/garbage-collectio-no-thanks"> RAII</a> mit Anmerkungen von Bjarne Stroustrup. </div>
<div class="ztitel">Don't waste time or space</div>
<div class="text">Die Begründung für die Regeln ist sehr einleuchtend: "This is C++." Ein Beispiel zu dieser Regel ist ein Rätsel. </div>
<div class="text">Was wird hier verschwendet?</div>
<div class="pre">void lower(string s)<br>{<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; strlen(s); ++i) s[i] = tolower(s[i]);<br>}</div>
<div class="ztitel">Prefer immutable data to mutable data<br></div>
<div class="text">Es gibt viele Gründe konstante Daten zu verwenden:</div>
<div class="text"><ul><li> Es ist einfacher ein Programm mit Konstanten als mit Variablen zu verifizieren.</li><li>Konstanten besitzen ein deutlich höheres Optimierungspotential.</li><li>Konstanten erlauben keine data races.</li></ul></div>
<div class="ztitel">Encapsulate messy constructs, rather than spreading through the code<br></div>
<div class="text">Unordentlicher Sourcecode ist sehr empfänglich für Fehler und deutlich schwieriger zu schreiben. Daher solltest du diesen low-level Code in Funktionen oder Methoden kapseln und ein gutes Interface dazu anbieten.</div>
<div class="ztitel">Use supporting tools as appropriate</div>
<div class="text">Computer sind deutlich besser und zuverlässiger darin, die langweiligen und sich wiederholenden Aufgaben immer und immer wieder zu wiederholen. Das bedeutet, dass du statische Codeanalyse Werkzeuge, Werkzeuge für Nebenläufigkeit und Testwerkzeuge verwenden solltest, um diese verifizierenden Schritte zu automatisieren. </div>
<div class="ztitel">Use support libraries as appropriate</div>
<div class="text">Diese Regel ist einfach zu begründen. Du solltest gut entworfene, dokumentierte und unterstützte Bibliotheken verwenden. Damit erhältst du eine gut getestete, nahezu fehlerfrei Bibliothek und hoch optimierte Algorithmen von den Domän Experten. Zwei herausragende Beispiele sind die C++ Standard Bibliothek und die Guidelines Support Library. </div>
<div class="utitel">Wie geht's weiter?</div>
<div class="text">Ein Interface ist ein Vertrag zwischen einem Service Anbieter und einem Server Nutzer. Es gibt 30 Regeln zu Interfaces in den C++ Core Guidelines. In nächsten Artikel werde ich einen genaueren Blick darauf werfen.<br></div>
