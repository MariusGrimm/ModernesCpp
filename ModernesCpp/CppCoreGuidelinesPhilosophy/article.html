<p>Today, I will dig a little bit deeper into the C++ Core Guidelines. In my<a href="index.php/what-is-modern-c"> last post</a> about the C++ Core Guidelines I wrote about the Introduction section. Today I write about the section that is "primarily for humans". This is the most general section and is called Philosophy. The rules are so general that you can apply them to each programming language.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<p>Only to remind you. The C++ Core Guidelines consists of 350 rules. They a grouped in the following sections.</p>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-introduction">In: Introduction</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-philosophy">P: Philosophy</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-interfaces">I: Interfaces</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-functions">F: Functions</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-class">C: Classes and class hierarchies</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-enum">Enum: Enumerations</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-resource">R: Resource management</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-expr">ES: Expressions and statements</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-errors">E: Error handling</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-const">Con: Constants and immutability</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-templates">T: Templates and generic programming</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-concurrency">CP: Concurrency</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-stdlib">SL: The Standard library</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-source">SF: Source files</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-cpl">CPL: C-style programming</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-profile">Pro: Profiles</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-gsl">GSL: Guideline support library</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-faq">FAQ: Answers to frequently asked questions</a></li>
</ul>
<p>Let's look at each of the 13 philosophy rules. They should provide the rationale for all 350 rules.<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"> </a></p>
<h2>Philosophy</h2>
<p>&nbsp;<img src="images/blog/ModernCpp/CppCoreGuidelinesPhilosophy/800px-Head_Platon_Glyptothek_Munich_548.jpg" alt="800px Head Platon Glyptothek Munich 548" width="200" height="278" style="margin: 15px;" /></p>
<p>The following 13 rules cannot be checked completely. Here are they.</p>
<ul>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-direct">P.1: Express ideas directly in code</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-Cplusplus">P.2: Write in ISO Standard C++</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-what">P.3: Express intent</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-typesafe">P.4: Ideally, a program should be statically type safe</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-compile-time">P.5: Prefer compile-time checking to run-time checking</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-run-time">P.6: What cannot be checked at compile time should be checkable at run time</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-early">P.7: Catch run-time errors early</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-leak">P.8: Don’t leak any resources</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-waste">P.9: Don’t waste time or space</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-mutable">P.10: Prefer immutable data to mutable data</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-library">P.11: Encapsulate messy constructs, rather than spreading through the code</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-tools">P.12: Use supporting tools as appropriate</a></li>
<li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rp-lib">P.13: Use support libraries as appropriate</a></li>
</ul>
<p>If possible, I will provide examples from the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a> to each of the rules.</p>
<h3>Express ideas directly in code</h3>
<p>A method should express it's intent. Have a look here.</p>
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #006699; font-weight: bold;">class</span> <span style="color: #00aa88; font-weight: bold;">Date</span> {
    <span style="color: #0099ff; font-style: italic;">// ...</span>
<span style="color: #9999ff;">public:</span>
    Month month() <span style="color: #006699; font-weight: bold;">const</span>;  <span style="color: #0099ff; font-style: italic;">// do    </span>
    <span style="color: #007788; font-weight: bold;">int</span> <span style="color: #cc00ff;">month</span>();          <span style="color: #0099ff; font-style: italic;">// don't</span>
    <span style="color: #0099ff; font-style: italic;">// ...</span>
};
</pre>
</div>
<p>&nbsp;</p>
<p>Neither does the second method <span style="font-family: courier new,courier;">month</span> express that is will not change the instance nor does it return a return a <span style="font-family: courier new,courier;">Month</span> object.</p>
<p>The same reasoning often holds for explicit loops versus algorithms of the Standard Template Library (STL).</p>
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #007788; font-weight: bold;">int</span> index <span style="color: #555555;">=</span> <span style="color: #555555;">-</span><span style="color: #ff6600;">1</span>;                    <span style="color: #0099ff; font-style: italic;">// bad</span>
<span style="color: #006699; font-weight: bold;">for</span> (<span style="color: #007788; font-weight: bold;">int</span> i <span style="color: #555555;">=</span> <span style="color: #ff6600;">0</span>; i <span style="color: #555555;">&lt;</span> v.size(); <span style="color: #555555;">++</span>i) {
    <span style="color: #006699; font-weight: bold;">if</span> (v[i] <span style="color: #555555;">==</span> val) {
      index <span style="color: #555555;">=</span> i;
      <span style="color: #006699; font-weight: bold;">break</span>;
    }
}

<span style="color: #006699; font-weight: bold;">auto</span> p <span style="color: #555555;">=</span> find(begin(v), end(v), val);  <span style="color: #0099ff; font-style: italic;">// better</span>
</pre>
</div>
<p>&nbsp;</p>
<p>The meta rule is obvious. You should know and use the algorithms of the STL.</p>
<h3>Write in ISO Standard C++</h3>
<p>This rule reads quite simple and has a straightforward enforcement statement: "Use an up-to-date C++ compiler (currently C++11 or C++14) with a set of options that do not accept extensions."</p>
<h3>Express intent</h3>
<p>Your code should express its intent. What can we deduce from the three explicit and implicit loops?</p>
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #006699; font-weight: bold;">for</span> (<span style="color: #006699; font-weight: bold;">const</span> <span style="color: #006699; font-weight: bold;">auto</span><span style="color: #555555;">&amp;</span> v<span style="color: #555555;">:</span> vec) { ... }       (<span style="color: #ff6600;">1</span>)
<span style="color: #006699; font-weight: bold;">for</span> (<span style="color: #006699; font-weight: bold;">auto</span><span style="color: #555555;">&amp;</span> v<span style="color: #555555;">:</span> vec){ ... }              (<span style="color: #ff6600;">2</span>)
for_each(par, vec, [](<span style="color: #006699; font-weight: bold;">auto</span> v){ ... }); (<span style="color: #ff6600;">3</span>)
</pre>
</div>
<p>&nbsp;</p>
<p>The elements of the container <span style="font-family: courier new,courier;">vec</span> will not be modified in (1). In contrary, the elements expression (2) will be modified. The algorithm<span style="font-family: courier new,courier;"> for_each</span> is executed with parallel execution policy (<span style="font-family: courier new,courier;">par</span>). That means the order of iteration does not matter.</p>
<h3>Ideally, a program should be statically type safe</h3>
<p>You should strive for statically type safe programs. Of course, that is not possible because there are problem areas in C++. The C++ Core Guidelines name the problem areas and possible solutions.</p>
<ul>
<li>use <span style="font-family: courier new,courier;">std::variant</span> (new with C++17) instead of unions</li>
<li>minimise the use of casts; use templates if possible</li>
<li>use <span style="font-family: courier new,courier;">gsl::span</span> against array decay&nbsp;(if you pass an array to a function it will implicitly decay to a pointer) and range errors</li>
<li>minimise narrowing conversions (narrowing conversion is an implicit conversion including the loss of data accuracy; for example, a <span style="font-family: courier new,courier;">double</span> becomes implicitly an <span style="font-family: courier new,courier;">int</span>)</li>
</ul>
<p>gsl stands for Guideline support library GSL. GSL is a small library to support the set of guidelines from the C++ Core Guidelines. I will write about the GSL in an upcoming post.</p>
<h3>Prefer compile-time checking to run-time checking</h3>
<p>All that can be done at compile time must not be done at run time. Since C++11 we have the function <span style="font-family: courier new,courier;">static_assert</span> and the type-traits library. <span style="font-family: courier new,courier;">static_assert</span> will check a predicate such as <span style="font-family: courier new,courier;">static_assert(sizeof(int) &gt;= 4)</span> at compile time. Thanks to the type-traits library, we can state mighty conditions about a type <span style="font-family: courier new,courier;">T</span> at compile time: <span style="font-family: courier new,courier;">static_assert(std::is_integral&lt;T&gt;::value).</span> Of course, if the check fails at compile time, the compilation will fail with a readably error message.<span style="font-family: courier new,courier;"> </span>already wrote about<span style="font-family: courier new,courier;"> <a href="index.php/tag/static-assert"><span style="font-family: courier new,courier;">static_assert.</span></a></span></p>
<h3>What cannot be checked at compile time should be checkable at run time</h3>
<p>This rule talks about hard-to-detect errors that should be avoided. The examples are about dynamically allocated arrays.</p>
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #006699; font-weight: bold;">extern</span> <span style="color: #007788; font-weight: bold;">void</span> <span style="color: #cc00ff;">f</span>(<span style="color: #007788; font-weight: bold;">int</span><span style="color: #555555;">*</span> p);
<span style="color: #006699; font-weight: bold;">extern</span> <span style="color: #007788; font-weight: bold;">void</span> <span style="color: #cc00ff;">f2</span>(<span style="color: #007788; font-weight: bold;">int</span><span style="color: #555555;">*</span> p, <span style="color: #007788; font-weight: bold;">int</span> n);
<span style="color: #006699; font-weight: bold;">extern</span> <span style="color: #007788; font-weight: bold;">void</span> <span style="color: #cc00ff;">f3</span>(unique_ptr<span style="color: #555555;">&lt;</span><span style="color: #007788; font-weight: bold;">int</span>[]<span style="color: #555555;">&gt;</span> uniq, <span style="color: #007788; font-weight: bold;">int</span> n);

f(<span style="color: #006699; font-weight: bold;">new</span> <span style="color: #007788; font-weight: bold;">int</span>[n]);                  (<span style="color: #ff6600;">1</span>)
f2(<span style="color: #006699; font-weight: bold;">new</span> <span style="color: #007788; font-weight: bold;">int</span>[n], m);              (<span style="color: #ff6600;">2</span>)
f3(make_unique<span style="color: #555555;">&lt;</span><span style="color: #007788; font-weight: bold;">int</span>[]<span style="color: #555555;">&gt;</span>(n), m);   (<span style="color: #ff6600;">3</span>)
</pre>
</div>
<p>&nbsp;</p>
<p>What's bad about the examples? The call (1) does not pass the number of elements. (2) makes it possible to pass the wrong number of elements and (3) passes the ownership and the size separately. By passing a reference or a vewi (part of the gsl) you can overcome this issues.</p>
<h3>Catch run-time errors early</h3>
<p>Here are the enforcements for this rule:</p>
<ul>
<li>Look at pointers and arrays: Do range-checking early and not repeatedly</li>
<li>Look at conversions: Eliminate or mark narrowing conversions</li>
<li>Look for unchecked values coming from input</li>
<li>Look for structured data (objects of classes with invariants) being converted into strings</li>
</ul>
<h3>Don't leak any resource</h3>
<p>Leaking resources are in particular critical for long-running programs. Resources may be memory but also file handles or sockets. The idiomatic way to solve this issue is RAII. The idea of the RAII idiom is quite simple. You bind the acquisition and the release of a resource to the lifetime of a local object. Therefore, the resource will automatically be&nbsp;initialized in the constructor and released in the destructor. The acronym RAII stands for <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization. Smart pointer and locks are based on this technique. Here are more details to<a href="index.php/garbage-collectio-no-thanks"> RAII</a>.</p>
<h3>Don't waste time or space</h3>
<p>The reason for this rule is quite promising: "This is C++". One example of the rule is a riddle.</p>
<p>What's wasted here?</p>
<div style="background: #f0f3f3; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #007788; font-weight: bold;">void</span> <span style="color: #cc00ff;">lower</span>(string s)
{
    <span style="color: #006699; font-weight: bold;">for</span> (<span style="color: #007788; font-weight: bold;">int</span> i <span style="color: #555555;">=</span> <span style="color: #ff6600;">0</span>; i <span style="color: #555555;">&lt;</span> strlen(s); <span style="color: #555555;">++</span>i) s[i] <span style="color: #555555;">=</span> tolower(s[i]);
}
</pre>
</div>
<p>&nbsp;</p>
<h3>Prefer immutable data to mutable data</h3>
<p>There are a lot of reasons that speak for immutable data:</p>
<ul>
<li>It's easier to reason about constants than about variables.</li>
<li>Constant have more optimisation potential.</li>
<li>Constants are free of <span style="font-family: courier new,courier;">data races</span>.</li>
</ul>
<h3>Encapsulate messy constructs, rather than spreading through the code</h3>
<p>Messy code is prone to bugs and harder to write. Therefore, you should encapsulate the low-level code in a function or a method and put a good interface around it.</p>
<h3>Use supporting tools as appropriate</h3>
<p>Computers are better than humans in doing the boring and repetitive tasks. That means you should use static analysis tools, concurrency tools, and testing tools to automate this verifying steps.</p>
<h3>Use support libraries as appropriate</h3>
<p>That is quite easy to explain. You should go for well-designed, well-documented, and well-supported libraries. Therefore, you will get a well-tested and a nearly error-free library and highly optimised algorithms from the domain experts. Two outstanding examples are the C++ standard library and the Guidelines Support Library.</p>
<h2>What's next?</h2>
<p>An interface is a contract between the service provider and the service user. There are 30 rules about interfaces in the C++ Core Guidelines. In the next post, I will have a closer look at interfaces.</p>
