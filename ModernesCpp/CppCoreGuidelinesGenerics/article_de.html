<div class="vorspann">In diesem Artikel führe ich die Regeln zur generischen Programmierung in C++ ein. Generische Programmierung ist meines Erachtens das herausragende Feature und die Zukunft von C++. Daher geht es heute und in den weiteren Artikeln um die Zukunft von C++.</div>
<div class="text">Ich unterscheide nicht scharf zwischen Templates und generischer Programmierung. Einer der beiden Begriffe kommt in dem Artikel zum Einsatz, wenn er am besten passt. Natürlich weiß ich, dass Templates nur eine Technik sind, generischen Code zu schreiben. Ich nehme an, dass dir der Begriff Templates in C++ vertraut ist. Dies gilt aber wohl nicht für generische Programmierung. Hier ist die Definition aus <a alt="%7B%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FGeneric_programming%22%2C%22text%22%3A%22Wikipedia%3A%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FGeneric_programming%22%2C%22anchor%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/Generic_programming" title="Link auf https://en.wikipedia.org/wiki/Generic_programming" class="">Wikipedia:</a></div>
<div class="einrueckung"><b>Generic programming</b> is a style of computer programming in which algorithms are written in terms of types <i>to-be-specified-later</i> that are then <i>instantiated</i> when needed for specific types provided as parameters.</div>
<div class="text">Die Regeln zur generischen Programmierung behandeln den aktuellen C++17- und anstehenden C++20-Standard. Ich gehe dabei davon aus, dass wir mit C++20 Concepts erhalten werden. In Summe enthalten die C++ Core Guidelines 100 Regeln zu Concepts, Template Interfaces, Template-Definitionen, Template-Hierarchien, Variadic Templates und Template-Metaprogrammierung. Die ersten fünf Regeln sind allgemeiner Natur:</div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-raise" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-raise" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.1%3A%20Use%20templates%20to%20raise%20the%20level%20of%20abstraction%20of%20code%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-raise%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-raise%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%7D">T.1: Use templates to raise the level of abstraction of code</a> </li><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-algo%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-algo%22%2C%22text%22%3A%22T.2%3A%20Use%20templates%20to%20express%20algorithms%20that%20apply%20to%20many%20argument%20types%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-algo" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-algo">T.2: Use templates to express algorithms that apply to many argument types</a> </li><li> <a alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-cont%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.3%3A%20Use%20templates%20to%20express%20containers%20and%20ranges%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-cont%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-cont" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-cont" class="">T.3: Use templates to express containers and ranges</a> </li><li> <a alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-generic-oo%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22T.5%3A%20Combine%20generic%20and%20OO%20techniques%20to%20amplify%20their%20strengths%2C%20not%20their%20costs%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-generic-oo%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-generic-oo" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-generic-oo">T.5: Combine generic and OO techniques to amplify their strengths, not their costs</a></li></ul></div>
<div class="text">In den Beispielen sind Concepts meist auskommentiert. Wenn du sie ausprobierten willst, entferne die Kommentare und verwende zumindest den GCC 6.1 Compiler mit dem Flag [i]-fconcepts[/i] oder ein Online-Compiler: <a alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fconstraints%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fconstraints%22%2C%22text%22%3A%22constraints%20and%20concepts%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/language/constraints" class="" href="https://en.cppreference.com/w/cpp/language/constraints">constraints and concepts</a>. </div>
<div class="text">Concepts sind Prädikate für Templates, die zu Compilezeit ausgewertet werden. Sie sollen semantische Kategorien wie [i]Number[/i], [i]Callable[/i], [i]Iterator[/i] oder [i]Range[/i] beschreiben, aber nicht für syntaktische Einschränkungen wie [i]HasPlus[/i] oder [i]IsInvocable[/i] stehen. Hier gibt es mehr Details zu <a href="http://www.modernescpp.com/index.php/tag/concepts" class="" title="Link auf http://www.modernescpp.com/index.php/tag/concepts" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Ftag%2Fconcepts%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Concepts%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Ftag%2Fconcepts%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D">Concepts</a>.</div>
<div class="text">Eventuell verwirren dich die zwei Begriffe semantische Kategorien und syntaktische Einschränkungen. Die erste Regel sorgt für Aufklärung.<br></div>
<div class="ztitel"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-raise%22%2C%22text%22%3A%22T.1%3A%20Use%20templates%20to%20raise%20the%20level%20of%20abstraction%20of%20code%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-raise%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-raise" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-raise">T.1: Use templates to raise the level of abstraction of code</a> <br> </div>
<div class="text">Hier kommt das Beispiel aus den Guidelines. Das zweite Concept habe ich [i]Addable[/i] genannt: <br></div>
<div class="pre">template&lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; // requires Incrementable&lt;T&gt;<br>T sum1(vector&lt;T&gt;&amp; v, T s)<br>{<br>&nbsp;&nbsp;&nbsp; for (auto x : v) s += x;<br>&nbsp;&nbsp;&nbsp; return s;<br>}<br><br>template&lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; // requires Addable&lt;T&gt;<br>T sum2(vector&lt;T&gt;&amp; v, T s)<br>{<br>&nbsp;&nbsp;&nbsp; for (auto x : v) s = s + x;<br>&nbsp;&nbsp;&nbsp; return s;<br>}</div>
<div class="text">Was stimmt bei den beiden Concepts nicht? Beide sind viel zu spezifisch. Beide Concepts basieren auf konkreten Operationen wie Inkrementieren und Addieren. Da will ich gerne ein Schritt weiter von den syntaktischen Einschränkungen zu der semantischen Kategorie [i]Arithmetic[/i] gehen: </div>
<div class="pre">template&lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; // requires Arithmetic&lt;T&gt;<br>T sum(vector&lt;T&gt;&amp; v, T s)<br>{<br>&nbsp;&nbsp;&nbsp; for (auto x : v) s += x;<br>&nbsp;&nbsp;&nbsp; return s;<br>}<br></div>
<div class="text">Nun besitzt der Algorithmus die minimalen Anforderungen. Stopp! Der Algorithmus ist besser, aber nicht gut. Er setzt einen [i]std::vector[/i]&nbsp; als Container voraus. Es ist zwar generisch bezüglich der Elemente <i>se</i>ines Containers, aber nicht auf den Containern selbst. Daher lässt sich der Algorithmus noch allgemeiner formulieren:<br></div>
<div class="pre">template&lt;typename Cont, typename T&gt;<br>&nbsp;&nbsp;&nbsp; // requires Container&lt;Cont&gt;<br>&nbsp;&nbsp;&nbsp; // &amp;&amp; Arithmetic&lt;T&gt;<br>T sum(Cont&amp; v, T s)<br>{<br>&nbsp;&nbsp;&nbsp; for (auto x : v) s += x;<br>&nbsp;&nbsp;&nbsp; return s;<br>}</div>
<div class="text">Nun besitzt der Algorithmus die richtige Abstraktion. Vielleicht ziehst du ja eine kompaktere Schreibweise vor. Anstelle des Schlüsselworts [i]typename[/i] wende ich das Concept jetzt direkt an:</div>
<div class="pre">template&lt;Container Cont, Arithmetic T&gt;<br>T sum(Cont&amp; cont, T s){<br>&nbsp;&nbsp;&nbsp; for (auto x : cont) s += x;<br>&nbsp;&nbsp;&nbsp; return s;<br>}</div>
<div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-algo" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-algo" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-algo%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-algo%22%2C%22text%22%3A%22T.2%3A%20Use%20templates%20to%20express%20algorithms%20that%20apply%20to%20many%20argument%20types%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">T.2: Use templates to express algorithms that apply to many argument types</a> </div>
<div class="text">Die erst Überladung von [i]std::find[/i] besitzt laut <a title="Link auf https://en.cppreference.com/w/cpp/algorithm/find" class="" href="https://en.cppreference.com/w/cpp/algorithm/find" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Ffind%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22cppreferen.com%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Ffind%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D">cppreferen.com</a> die folgende Deklaration:<br></div>
<div class="pre">template&lt; class InputIt, class T &gt;<br>InputIt find( InputIt first, InputIt last, const T&amp; value );</div>
<div class="text">Die Typen der Iteratoren sind in ihren Namen kodiert: [i]InputIt[/i] steht für einen Input Iterator und bedeutet, dass dieser Iterator das Objekt lesen kann, auf das er verweist. Die Deklaration besitzt zwei Schwächen.</div>
<div class="text"><ol><li> Die Anforderungen an den Iterator sind im Namen kodiert. Das erinnert mich an die heftig in meinen Schulungen diskutierte hungarische Notation.</li><li>Es gibt keine Anforderungen, die sicherstellt, dass das vom Iterator referenzierte Objekt mit dem [i]value[/i] verglichen werden kann. <br></li></ol></div>
<div class="text">Daher will ich die Concepts direkt verwenden:<br></div>
<div class="pre">template&lt;Input_iterator Iter, typename Val&gt;<br>&nbsp;&nbsp;&nbsp; // Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;<br>Iter find(Iter b, Iter e, Val v)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="ztitel"><a alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-cont%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-cont%22%2C%22text%22%3A%22T.3%3A%20Use%20templates%20to%20express%20containers%20and%20ranges%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-cont" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-cont">T.3: Use templates to express containers and ranges</a> <br> </div>
<div class="text">Es ist naheliegend, einen Container generisch anzulegen. Hier ist zum Beispiel ein [i]Vector[/i]: <br></div>
<div class="pre">template&lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; // requires Regular&lt;T&gt;<br>class Vector -{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; T* elem;&nbsp;&nbsp; // points to sz Ts<br>&nbsp;&nbsp;&nbsp; int sz;<br>};<br><br>Vector&lt;double&gt; v(10);<br>v[7] = 9.9;</div>
<div class="text">Ein Frage bleibt bei dem Beispiel noch offen. Wann ist ein benutzerdefinierter Datentyp regulär? Das Dokument "<a href="http://stepanovpapers.com/DeSt98.pdf" title="Link auf http://stepanovpapers.com/DeSt98.pdf" class="" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fstepanovpapers.com%2FDeSt98.pdf%22%2C%22text%22%3A%22Fundamentals%20of%20Generic%20Programming%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fstepanovpapers.com%2FDeSt98.pdf%22%2C%22custom%22%3A%7B%7D%7D">Fundamentals of Generic Programming</a>" sagt aus, wenn sich der Datentyp wie ein Built-in-Datentyp (z.B.: [i]bool[/i], [i]int[/i] oder [i]double[/i]<span class="tx_code"></span>) erhält. Ich muss natürlich erwähnen, dass das Dokument aus den Federn von James C. Dehnert und Alexander Stepanov stammt. Vermutlich weißt du, wer Stepanov ist. Er ist der bekannte Vater der Standard Template Library (STL). <br></div>
<div class="text">Laut dem Dokument ist ein Datentyp regulär, wenn er die folgenden Operationen anbietet:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_158249245_10177b51f3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Gleich- und Ungleichheitsoperatoren können wie die Ordnungsoperatoren auf der Ebene der Komponenten definiert werden.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mein ursprünglicher Plan war es, über die Regel 5.5: <a alt="%7B%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-generic-oo%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-generic-oo%22%2C%22text%22%3A%22Combine%20generic%20and%20OO%20techniques%20to%20amplify%20their%20strengths%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-generic-oo" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-generic-oo">Combine generic and OO techniques to amplify their strengths</a> zu schreiben. Ich habe aber meinen Plan geändert, da die Regel zum einen sehr kurz ist und zum anderen Type Erasure als Anwendungsfall vorstellt. Type Erasure ist eine Technik, die es erlaubt, auf verschiedene Datentypen ein generisches Interface anzubieten. Diese anspruchsvolle Technik lässt sich aber nicht in ein paar Sätzen erklären. Dazu benötige ich den ganzen nächsten Artikel. </div>