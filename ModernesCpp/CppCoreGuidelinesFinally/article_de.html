<div class="vorspann">In diesem Artikel geht es um die Ausnahmesituation, wenn keine Ausnahme geworfen werden darf. Falls dein Programm in einer eingeschränkten Embedded-Umgebung läuft oder du harte Echtzeitanforderungen sicherstellen musst, ist dies für dich wohl keine Ausnahme.</div>
<div class="text">Lass mich mit der Ausnahmesituation beginnen, in der keine Ausnahme geworfen werden darf. Mein ursprünglicher Plan war es, zumindest die Regeln E.19 bis E.27 der C++ Core Guidelines in diesem Artikel vorzustellen. Leider bin ich an der Regel E.19 hängen geblieben.</div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-finally" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-finally" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22E.19%3A%20Use%20a%20%5Bi%5Dfinal_action%5B%2Fi%5D%20object%20to%20express%20cleanup%20if%20no%20suitable%20resource%20handle%20is%20available%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-finally%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-finally%22%2C%22subject%22%3A%22%22%7D" class="">E.19: Use a [i]final_action[/i] object to express cleanup if no suitable resource handle is available</a></div>
<div class="text">Die erste Regel mag dich überraschen, denn du hast womöglich noch nie etwas von <i>final_action</i> gehört. Auf mich traf das jedenfalls zu. Daher musste ich recherchieren. Während meiner Suche fand ich den exzellenten Artikel von Bartłomiej Filipek. Er ist Autor des bekannten C++-Blogs: "<a title="Link auf https://www.bfilipek.com/p/start-here.html" href="https://www.bfilipek.com/p/start-here.html" class="" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Bartek%27s%20coding%20blog%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.bfilipek.com%2Fp%2Fstart-here.html%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.bfilipek.com%2Fp%2Fstart-here.html%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D">Bartek's coding blog</a>" und erlaubte mir, seinen Artikel "<a alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Beautiful%20code%3A%20final_act%20from%20GSL%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.bfilipek.com%2F2017%2F04%2Ffinalact.html%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.bfilipek.com%2F2017%2F04%2Ffinalact.html%22%7D" class="" href="https://www.bfilipek.com/2017/04/finalact.html" title="Link auf https://www.bfilipek.com/2017/04/finalact.html">Beautiful code: final_act from GSL</a>" in meinen einzubetten. Hier ist er ins Deutsche übersetzt:</div>
<div class="text">Manchmal gibt es die Notwendigkeit, ein spezielle Aktion am Ende eines Bereichs zu hinterlegen: Dies kann Code sein, der eine Ressource freigibt, ein Flag setzt oder es sind begin/end-Funktionsaufrufe. Kürzlich fand der Autor ein sehr praktisches Werkzeug, um diesen Job umzusetzen. </div>
<div class="text">Es geht um <i>gsl::final_act/finally</i><span class="tx_code">.</span></div>
<div class="ztitel_kleiner">Einleitung</div>
<div class="text">Den Anschlussartikel gibt es <a href="http://www.bfilipek.com/2017/04/finalact-follow-up.html" title="Link auf http://www.bfilipek.com/2017/04/finalact-follow-up.html" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22hier%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.bfilipek.com%2F2017%2F04%2Ffinalact-follow-up.html%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.bfilipek.com%2F2017%2F04%2Ffinalact-follow-up.html%22%7D" class="">hier</a>.</div>
<div class="text">Angenommen, wir haben den folgenden Code:</div>
<div class="pre">void addExtraNodes();<br>void removeExtraNodes();<br><br>bool Scanner::scanNodes()<br>{<br>&nbsp;&nbsp;&nbsp; // code...<br>&nbsp;&nbsp;&nbsp; addExtraNodes();<br><br>&nbsp;&nbsp;&nbsp; // code...<br>&nbsp;&nbsp;&nbsp; removeExtraNodes();<br>&nbsp;&nbsp;&nbsp; return true;<br>}</div>
<div class="text">Wir besitzen einige Objekte, die die Funktion <i>scanNodes</i> scannt. Diese Knoten gilt es, zum Container hinzuzufügen. Am Ende soll der ursprüngliche Zustand des Containers wieder gelten, daher müssen die Knoten wieder entfernt werden. </div>
<div class="text">Natürlich könnte der Sourcecode so strukturiert sein, dass die Operation nur auf einer Copy des Container stattfinden würde. In diesem Fall wäre es nicht notwendig, die Knoten zu entfernen. Es gibt aber leider oft Sourcecode, in dem die Aktionen auf einem globalen Container stattfinden und damit die Notwendigkeit besteht, bestimmte Aufräumarbeiten immer auszuführen. Viele Fehler können passieren, wenn eine Aktion auf einem geteilten Container stattfindet und dieser sich nicht in dem erwarteten Zustand befindet. </div>
<div class="text">Der Code hier scheint auf jeden Fall kein Problem zu besitzen. Es wird ja <i>removeExtraNodes</i> am Ende der Funktion aufgerufen. Doch was passiert, wenn die Funktion <i>scanNodes</i> mehrere <i>return</i>-Anweisungen besitzt? Das ist einfach. In diesem Fall müssen nur mehrere Aufrufe<i> removeExtraNodes</i> ausgeführt werden. <br></div>
<div class="text">Was ist aber nun, wenn die Funktion eine Ausnahme wirft? Dann müssen wir noch die Aufräumarbeiten vor der Ausnahme ausführen. Das ist ganz offensichtlich. Der Aufruf <i>removeExtraNodes</i> muss nicht nur vor der letzten <i>return</i>-Anweisung ausgeführt werden.</div>
<div class="ztitel_kleiner">Hilfe ist notwendig</div>
<div class="text">Jetzt möchte sich der Autor auf die C++ Core Guidelines beziehen. Sie geben folgenden Rat:</div>
<div class="text"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-finally" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-finally" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-finally%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-finally%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22E.19%3A%20Use%20a%20final_action%20object%20to%20express%20cleanup%20if%20no%20suitable%20resource%20handle%20is%20available%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" class="">E.19: Use a final_action object to express cleanup if no suitable resource handle is available</a></div>
<div class="text">Die Guidelines sagen, dass die Software ein besseres Design haben soll als ein <i>goto</i>, gefolgt von einem <i>exit</i>-Aufruf, oder einfach nichts zu tun haben soll. Hier ist der Vorschlag:</div>
<div class="pre">bool Scanner::scanNodes()<br>{<br>&nbsp;&nbsp;&nbsp; // code...<br>&nbsp;&nbsp;&nbsp; addExtraNodes();<br>&nbsp;&nbsp;&nbsp; auto _ = finally([] { removeExtraNodes(); });<br><br>&nbsp;&nbsp;&nbsp; // code...<br><br>&nbsp;&nbsp;&nbsp; return true;<br>}<br></div>
<div class="text">Was passiert hier? Alles was passierte, war nur, den Aufruf <i>removeExtraNodes</i> in ein spezielles Objekt zu verpacken. Dies spezielle Objekt wird die aufrufbare Einheit (Lambda-Funktion) in ihrem Destruktor aufrufen. Das ist genau das, was gesucht wurde!</div>
<div class="text">Wo gibt es den magischen <i>finally()</i>-Code? Hier: <a href="https://github.com/Microsoft/GSL/blob/master/include/gsl/gsl_util" title="Link auf https://github.com/Microsoft/GSL/blob/master/include/gsl/gsl_util" alt="%7B%22user_params%22%3A%22%22%2C%22text%22%3A%22Guideline%20Support%20Library%2Fgsl_util.h.%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%2Fblob%2Fmaster%2Finclude%2Fgsl%2Fgsl_util%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%2Fblob%2Fmaster%2Finclude%2Fgsl%2Fgsl_util%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="">Guideline Support Library/gsl_util.h.</a></div>
<div class="ztitel_kleiner">Unter der Decke</div>
<div class="text">Der Sourcecode zu <i>final_act</i> ist einfach, daher kann ich ihn hier direkt reinkopieren:<br></div>
<div class="pre">template &lt;class F&gt;<br>class final_act<br>{<br>public:<br>&nbsp;&nbsp;&nbsp; explicit final_act(F f) noexcept <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : f_(std::move(f)), invoke_(true) {}<br><br>&nbsp;&nbsp;&nbsp; final_act(final_act&amp;&amp; other) noexcept <br>&nbsp;&nbsp;&nbsp;&nbsp; : f_(std::move(other.f_)), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke_(other.invoke_)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other.invoke_ = false;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; final_act(const final_act&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; final_act&amp; operator=(const final_act&amp;) = delete;<br><br>&nbsp;&nbsp;&nbsp; ~final_act() noexcept<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (invoke_) f_();<br>&nbsp;&nbsp;&nbsp; }<br><br>private:<br>&nbsp;&nbsp;&nbsp; F f_;<br>&nbsp;&nbsp;&nbsp; bool invoke_;<br>};<br></div>
<div class="text">Ist der Code nicht wundervoll?</div>
<div class="text">Die Klasse nimmt eine aufrufbare Einheit [i]f_[/i] an und ruft sie dann auf, wenn eine Instanz von ihr destruiert wird. Daher wird immer der Destruktor, der die Aufräumarbeit enthält, aufgerufen, egal ob er jetzt vorzeitig oder durch eine Ausnahme ausgelöst wird.</div>
<div class="text">Um optimal mit der Move-Semantik zusammenzuarbeiten, enthält die Klasse einen zusätzlichen Wahrheitswert [i]invoke_[/i]. Dieser stellt sicher, dass der Code für temporäre Objekte nicht ausgeführt wird. Hier gibt es mehr Information dazu: "<a class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22Final_act%20copy%2Fmove%20semantics%20is%20wrong%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%2Fpull%2F90%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%2Fpull%2F90%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://github.com/Microsoft/GSL/pull/90" href="https://github.com/Microsoft/GSL/pull/90">Final_act copy/move semantics is wrong</a>". </div>
<div class="text">C++17 unterstützt die Template Argument Deduction für Klassen. Damit lässt sich [i]final_act[/i] direkt erklären.&nbsp;</div>
<div class="pre">final_act _f([] { removeExtraNodes(); });</div>
<div class="text">Vor C++17 erlaubte es die Hilfsfunktion [i]finally[/i], Objekte vom Typ [i]final_act[/i] einfach zu erzeugen.<br> </div>
<div class="pre">template &lt;class F&gt;<br>inline final_act&lt;F&gt; finally(const F&amp; f) noexcept<br>{<br>&nbsp;&nbsp;&nbsp; return final_act&lt;F&gt;(f);<br>}<br><br>template &lt;class F&gt;<br>inline final_act&lt;F&gt; finally(F&amp;&amp; f) noexcept<br>{<br>&nbsp;&nbsp;&nbsp; return final_act&lt;F&gt;(std::forward&lt;F&gt;(f));<br>}</div>
<div class="text">Was finde ich nun so schön an dem Code?</div>
<div class="text"><ul><li> Der Code ist sehr einfach.</li><li>Der Code ist ausdrucksreich und benötigt daher keine Kommentare.</li><li>Der Code übernimmt genau eine Aufgabe.</li><li>Der Code ist generisch. Er setzt nur eine aufrufbare Einheit voraus: Funktion, Funktionsobjekt oder Lambda-Funktion.</li><li>Der Code unterstützt modernes C++: Move-Semantik und [i]noexcept[/i].</li></ul></div>
<div class="ztitel_kleiner">Wichtige Anmerkung: [i]final_act[/i] sollte [i]noexcept[/i] sein</div>
<div class="text">Wie es bereits häufig in den Kommentaren zur GSL erklärt wurde, sollte [i]final_act[/i] [i]noexcept[/i] sein. Dies gilt, da es dazu dient, einen Destruktor aufzurufen, der natürlich [i]noexcept[/i] sein soll. Weder soll der Destruktor eine Ausnahme werfen noch [i]final_act[/i]. Das mag eine kleine Einschränkung sein, wenn du gewöhnlichen Code mittels [i]final_act[/i] aufrufen willst. Gleichzeitig ist dies aber ein Zeichen von schlechtem Design.<br></div>
<div class="ztitel_kleiner">Wo kann [i]finally[/i] verwendet werden?</div>
<div class="text">Um einen Punkt klarzustellen: Verwende [i]finally[/i] nicht zu häufig! Deine Objekte sollten nicht von globalem Zustand abhängen und daher auf dem <a href="http://www.modernescpp.com/index.php/garbage-collectio-no-thanks" title="Link auf http://www.modernescpp.com/index.php/garbage-collectio-no-thanks" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22text%22%3A%22RAII%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fgarbage-collectio-no-thanks%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fgarbage-collectio-no-thanks%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" class="">RAII</a>-Idiom basieren. Trotzdem gibt es Anwendungsfälle, in denen [i]finally[/i] zum Einsatz kommen sollte:</div>
<div class="text"><ul><li><b>Transaktionen: </b>Dies ist ein allgemeiner Begriff für Aktionen, die wieder vollkommen rückgängig gemacht werden können, falls ein Fehler auftrat. Das ist zum Beispiel notwendig, wenn ein Fehler beim Schreiben einer Datei auftrat. Diese Aktion soll natürlich rückgängig gemacht werden.<br> </li><li><b>begin/end-Funktionen</b>: In diesen ist es notwendig eine [i]end[/i]-Aktion zu hinterlegen, nachdem die [i]begin[/i]-Aktion ausgeführt wurde. Dies war genau im Beispiel der Fall.</li><li><b>Setzen eines Flags</b>: Du hast ein geteiltes Flag, das du auf einen neuen Zustand setzt. Dieses muss aber am Ende der Funktion wieder zurückgesetzt werden.</li><li><b>Umgang mit Ressourcen ohne RAII</b>: Falls du deine Ressource nicht in ein RAII-Objekt verpacken kannst, ist [i]final_act[/i] eine Lösung.</li><li><b>Beenden einer Verbindung:</b> Am Ende der Funktion muss zum Beispiel ein Socket geschlossen werden.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/image/rte/textbox.svg" title="<ir_inline itemname=textboxen_mvp_text:1 type=1>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Fallen dir noch andere Anwendungsfälle für [i]final_act[/i] ein? Du kannst diese Liste studieren: "<a title="Link auf https://rnestler.github.io/c-list-of-scopeguard.html" href="https://rnestler.github.io/c-list-of-scopeguard.html" class="" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22C%2B%2B%20List%20of%20ScopeGuard%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Frnestler.github.io%2Fc-list-of-scopeguard.html%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Frnestler.github.io%2Fc-list-of-scopeguard.html%22%7D">C++ List of ScopeGuard</a>". </div>
<div class="ztitel">Zusammenfassung</div>
<div class="text">Den Anschlussartikel gibt es <a alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.bfilipek.com%2F2017%2F04%2Ffinalact-follow-up.html%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.bfilipek.com%2F2017%2F04%2Ffinalact-follow-up.html%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22hier%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" class="" href="http://www.bfilipek.com/2017/04/finalact-follow-up.html" title="Link auf http://www.bfilipek.com/2017/04/finalact-follow-up.html">hier</a>. [i]final_act[/i] ist ein wunderschönes und gut entworfenes Werkzeug, das hilft, die hässliche Aufräumarbeit zu erledigen. Du solltest zwar in deinem Code bessere Herangehensweisen wie RAII anwenden, wenn dies aber nicht möglich ist, ist [i]final_act[/i] oft die pragmatischste Lösung. </div>
<div class="text">Verwendest du ähnliche Klassen in deinem Sourcecode, um die Aufräumarbeit zu erledigen?</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Falls du keine Ausnahme werfen darfst und [i]finally[/i] auch keine Option ist, hast du ein Problem. In meinem nächsten Artikel werde ich mich damit beschäftigen.<br></div>
