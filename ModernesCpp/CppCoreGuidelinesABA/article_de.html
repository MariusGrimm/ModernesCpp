<div class="vorspann">Heute löse ich das Rätsel des <a class="" alt="%7B%22text%22%3A%22letzten%20Artikels%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4090498%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4090498%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" title="Link auf https://heise.de/-4090498" href="https://heise.de/-4090498">letzten Artikels</a> auf. Dank meiner Leser ist die Problemanalyse sehr genau.</div>
<div class="text">Zuerst möchte ich eine kleine Erinnerungshilfe geben. Das Rätsel beginnt mit der Regel CP.100 der C++ Core Guidelines.</div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lockfree" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22CP.100%3A%20Don%C2%92t%20use%20lock-free%20programming%20unless%20you%20absolutely%20have%20to.%26nbsp%3B%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lockfree%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lockfree%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lockfree">CP.100: Don’t use lock-free programming unless you absolutely have to.&nbsp;</a></div>
<div class="text">Die Regel enthält die Herausforderung, dass der folgende Codeschnipsel einen Bug enthält, der auf das ABA-Problem zurückzuführen ist. Mein Artikel <a class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3740324%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3740324%22%2C%22text%22%3A%22ABA%20%5B--%5D%20A%20ist%20nicht%20gleich%20A%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://heise.de/-3740324" href="https://heise.de/-3740324">ABA [--] A ist nicht gleich A</a> gibt eine einfache Einführung in das ABA-Problem. </div>
<div class="pre">extern atomic&lt;Link*&gt; head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the shared head of a linked list<br><br>Link* nh = new Link(data, nullptr);&nbsp;&nbsp;&nbsp; // make a link ready for insertion<br>Link* h = head.load();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read the shared head of the list&nbsp;&nbsp; <br><br>do {<br>&nbsp;&nbsp;&nbsp; if (h-&gt;data &lt;= data) break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if so, insert elsewhere&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; nh-&gt;next = h;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // next element is the previous head&nbsp; <br>} while (!head.compare_exchange_weak(h, nh));&nbsp;&nbsp;&nbsp; // write nh to head or to h </div>
<div class="text">Hier ist ein ausführbares Codefragement zu dem Codeschnipsel. Die tiefe Codeanalyse folgt unmittelbar.<br></div>
<div class="pre">#include &lt;atomic&gt;<br><br>class Link {<br>public:<br>&nbsp;&nbsp;&nbsp; Link(int d, Link* p) : data(d), next(p) {}<br>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; data;<br>&nbsp;&nbsp;&nbsp; Link*&nbsp;&nbsp; next;<br>};<br><br>void foo (int data) {<br>&nbsp;&nbsp;&nbsp; extern std::atomic&lt;Link*&gt; head;<br><br>&nbsp;&nbsp;&nbsp; Link* nh = new Link(data, nullptr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; Link* h&nbsp; = head.load();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; do {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (h-&gt;data &lt;= data) break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nh-&gt;next = h;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; } while (!head.compare_exchange_weak(h, nh));&nbsp; // (5)<br>}</div>
<div class="text">Zuerst einmal: Was tut das Programm? Das Programm erzeugt eine einfach verkettete Liste von Knoten (<i>Link</i>). Jeder Knoten besitzt einen Zeiger und ein Datenfeld. Der Zeiger verweist auf den nächsten Knoten (<i>node-&gt;next</i>) und das Datenfeld speichert den Wert ab: <i>node-&gt;data</i>. Jeder neue Knoten wird so in die Liste eingefügt, dass [i]data[/i] in aufsteigender Reihenfolge sortiert ist. </div>
<div class="text">Um einen neuen Knoten an die richtige Stelle in die Liste einzuführen, sind die folgenden Schritte notwendig.</div>
<div class="text"><ul><li><b>Zeile 1</b>: Ein neuer Knoten wird erzeugt. Das ist unproblematisch, weil in jedem Thread lokal neuer Speicher angefordert wird.</li><li><b>Zeile 2</b>: Der Zeiger auf <i>head</i> wird gelesen. Diese Operation ist atomar, daher ist die Operation in Isolation betrachtet unkritisch. Was bedeutet dies in Isolation betrachtet? Zeile 2 erzeugt mit Zeile 5 eine Art Transaktion. Zeile 2 speichert den initialen Zustand der Transaktion und Zeile 5 veröffentlicht die Transaktion, falls sich in der Zwischenzeit ihre Ausgangsbedingung nicht geändert hat. Lediglich der Wert von <i>data</i> wird geprüft. Dies kann zur Folge haben, dass die Funktion beendet wird, falls <i>head</i> bereits kleiner als das neue Datum ist.<br></li><li><b>Zeile 3:</b>&nbsp; Entsprechend der letzten Zeile, ist diese Zeile auch in Ordnung. <br></li><li><b>Zeile 4</b>: <i>nh</i> ist ein lokaler Knoten. Damit ist die Zuweisung <i>nh-&gt;next</i> unproblematisch. Es kann zwar passieren, dass der Kopf [i]h[/i] in der Zwischenzeit verändert wurde und damit <i>nh-&gt;next</i> nicht auf den neuen <i>head</i> verweist. Dies wird aber gegebenenfalls erst dann ein Problem, wenn diese Veränderung in der folgenden Zeile 5 veröffentlicht wird.<br></li><li><b>Zeile 5</b>: Der Befehl <i>head.compare_exchange_weak(h, nh)</i> vergleicht den <i>head</i> mit dem gespeicherten Knoten <i>h</i> in der Zeile 2. Gegebenenfalls tauscht er beide in einer atomaren Operation aus, sobald beide gleich sind. Falls der <i>head</i> ungleich <i>h</i> ist, wird [i]h[/i] auf <i>head</i> gesetzt. Zeile 5 stellt das Ende der atomaren Transaktion dar und veröffentlicht die veränderte, einfach verkettete Liste.</li></ul></div>
<div class="text">Welches Problem besitzen diese Codezeilen? Die ganze Transaktion basiert auf dem Zeigervergleich in Zeile 5. Falls sich der Zeigervergleich korrumpieren lässt, gilt dies auch für die einfach verkettete Liste.<br></div>
<div class="text">Es gibt ein kleines Zeitfenster zwischen dem Laden von <i>head</i> (Zeile 2) und dem Test, ob der aktuelle [i]head[/i] (Zeile 5) dem alten <i>head</i> in Zeile 2 noch entspricht. Das bedeutet, in diesem kleinen Zeitfenster kann ein anderer Thread ausgeführt werden und den <i>head</i> verändern, sodass es der ursprüngliche <i>head</i> nicht mitbekommt.</div>
<div class="text">Jetzt stelle ich eine solche Sequenz von Events dar, die die einfache verkettete Liste korrumpiert. </div>
<div class="ztitel">Bruch der Invariante</div>
<div class="text">Die Invariante der folgenden einfach verketteten Liste ist es, dass ihre Elemente aufsteigend sortiert sind. Der blaue Knoten steht für den Kopf der Liste. Dies ist Anfangszustand der Liste. Der Kopf besitzt die Adresse <i>0x0815</i>. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_155136067_84b683ddb4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Thread 1</div>
<div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_155136074_bdd6ac13ff.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>Will den neuen Knoten mit dem Wert 42 hinzufügen.</li><li>42 &lt; 47, daher soll der neue Knoten zum neuen Kopf werden.</li><li>Kurz bevor die Zeile 5 ausgeführt wird, kommt der Thread 2 zum Zuge.</li></ul></div>
<div class="ztitel_kleiner">Thread 2<br></div>
<div class="text"><ul><li>Entfernt den aktuellen Kopf mit dem Wert 47.</li><li>Macht den Knoten mit dem Wert 60 zum neuen Kopf.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_155136098_8272bac1d0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>Möchte den neuen Knoten mit dem Wert 30 zum neuen Kopf machen.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_155136081_c68ce129d2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>Macht den Knoten mit dem Wert 30 zum neuen Kopf und verwendet für ihn die Adresse <i>0x0815</i>. Dies war die Adresse des vorherigen Kopfes 47 und dies passiert gerne, da Speicher wiederverwendet wird.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_155136088_02ebc51a1f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Thread 1<br></div>
<div class="text"><ul><li>Machte den Knoten mit dem Wert 42 zum neuen Kopf. Dies ist möglich, da der Vergleich in Zeile 5 den alten mit dem neuen Kopf vergleicht und beide die gleiche Adresse besitzen: <i>0x0815<b>.</b></i></li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_155136096_c5821534bf.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Jetzt gilt die Invariante der einfach verketteten Liste nicht mehr, da die Werte der Knoten nicht mehr aufsteigend sortiert sind.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Jetzt bin ich fast fertig mit den Regeln zur Concurrency und zum lock-freien Programmieren im Besonderen. Die verbleibenden Regeln gehen auf falsche Annahmen zu Hardware/Compiler-Kombinationen ein und widmen sich dem berühmt-berüchtigten Double-Checked Locking Pattern.<br></div>
