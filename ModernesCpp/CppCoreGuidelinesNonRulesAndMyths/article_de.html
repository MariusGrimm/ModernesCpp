<div class="vorspann">Natürlich kennst du schon viele Nicht-Regeln und Mythen zu C++. Nicht-Regeln und Mythen, die wir widerlegen müssen, wenn wir modernes C++ programmieren wollen. Die unterstützenden Bereiche der C++ Core Guidelines beschäftigen sich mit den widerspenstigen Nicht-Regeln und Mythen, bieten aber auch Alternativen an.</div><div class="text">Dies sind die vier Regeln für den heutigen Artikel.</div><div class="vorspann"><ul><li> <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-top" alt="%7B%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-top%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22NR.1%3A%20Don%C2%92t%3A%20All%20declarations%20should%20be%20at%20the%20top%20of%20a%20function%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-top%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-top">NR.1: Don’t: All declarations should be at the top of a function</a> </li><li> <a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-single-return%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22NR.2%3A%20Don%C2%92t%3A%20Have%20only%20a%20single%20return-statement%20in%20a%20function%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-single-return%22%2C%22alias%22%3A%22%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-single-return" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-single-return">NR.2: Don’t: Have only a single return-statement in a function</a> </li><li> <a alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-no-exceptions%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-no-exceptions%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22NR.3%3A%20Don%C2%92t%3A%20Don%C2%92t%20use%20exceptions%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-no-exceptions" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-no-exceptions">NR.3: Don’t: Don’t use exceptions</a> </li><li> <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-lots-of-files" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-lots-of-files" alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22NR.4%3A%20Don%C2%92t%3A%20Place%20each%20class%20declaration%20in%20its%20own%20source%20file%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-lots-of-files%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-lots-of-files%22%7D">NR.4: Don’t: Place each class declaration in its own source file</a> </li></ul></div><div class="text">Viele Programmierer wenden die erste Regel an.</div><div class="ztitel"><a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-top" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-top" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-top%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-top%22%2C%22text%22%3A%22NR.1%3A%20Don%C2%92t%3A%20All%20declarations%20should%20be%20at%20the%20top%20of%20a%20function%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D">NR.1: Don’t: All declarations should be at the top of a function</a></div><div class="text">Die Regel ist ein Relikt alter Programmiersprachen, die die Initialisierung von Variablen und Konstanten nach einer Anweisung nicht erlauben. Das Ergebnis einer signifikanten Trennung der Variablendeklaration von ihrer Verwendung ist gerne, dass die Variable nicht initialisiert verwendet wird. Genau das passiert in dem Beispiel der C++ Core Guidelines: <br></div><div class="pre">int use(int x)<br>{ &nbsp;<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; char c;<br>&nbsp;&nbsp;&nbsp; double d;<br>&nbsp;&nbsp;&nbsp; // ... some stuff ...<br>&nbsp;&nbsp;&nbsp; if (x &lt; i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = f(x, d);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; if (i &lt; x) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = g(x, c);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return ;<br>}</div><div class="text">Ich denke, du hast das Problem in dem Codeschnipsel bereits gefunden. Die Variable <i>i </i>wird nicht initialisiert, da sie eine built-in Variable ist, die in einem lokalen Bereich verwendet wird. Damit besitzt das Programm undefiniertes Verhalten. Wenn<i> i</i> hingegen eine benutzerdefinierte Variable wie ein <span class="tx_code">std::string</span> ist, würde diese initialisiert werden. Nun ist die Frage, was du tun sollst. <br></div><div class="text"><ul><li>Deklariere die Variable<i> i</i> direkt vor ihrer Verwendung.</li><li>Initialisiere ein Variable immer zum Beispiel mit <span class="tx_code">int i{}</span> oder noch besser mit <span class="tx_code">auto</span>. Der Compiler kann aus einer Deklaration wie <span class="tx_code">auto i</span> den Typ von<i> i </i>nicht erraten und in diesem Fall das Programm nicht übersetzen. Andersherum gesagt, bedeutet dies, dass die Verwendung von <span class="tx_code">auto</span> dich dazu zwingt Variablen zu initialisieren. <br></li></ul></div><div class="text">Ich kenne bereits die nächste Regel aus häufigen Diskussionen.<br></div><div class="ztitel"><a alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-single-return%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22NR.2%3A%20Don%C2%92t%3A%20Have%20only%20a%20single%20return-statement%20in%20a%20function%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-single-return%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-single-return" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-single-return">NR.2: Don’t: Have only a single return-statement in a function</a></div><div class="text">Setzt du diese Regel um, setzt du implizit die erste Nicht-Regel ein. </div><div class="pre">template&lt;class T&gt;<br>std::string sign(T x)&nbsp;&nbsp;&nbsp; // bad<br>{<br>&nbsp;&nbsp;&nbsp; std::string res;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (x &lt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = "negative";<br>&nbsp;&nbsp;&nbsp; else if (x &gt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = "positive";<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = "zero";<br>&nbsp;&nbsp;&nbsp; return res;<br>}</div><div class="text">Dank mehrerer Rückgabeanweisungen wird der Code einfacher zu lesen und schneller. </div><div class="pre">template&lt;class T&gt;<br>//&nbsp; requires Number&lt;T&gt;<br>string sign(T x)<br>{<br>&nbsp;&nbsp;&nbsp; if (x &lt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "negative";<br>&nbsp;&nbsp;&nbsp; else if (x &gt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "positive";<br>&nbsp;&nbsp;&nbsp; return "zero";<br>}</div><div class="text">Was passiert, wenn ich die automatische Ermittlung des Rückgabetyps mit verschiedenen Rückgabetypen anwende?&nbsp;</div><div class="pre">// differentReturnTypes.cpp<br><br>template &lt;typename T&gt;<br>auto getValue(T x){<br>&nbsp; if (x &lt; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // int<br>&nbsp;&nbsp;&nbsp; return -1;<br>&nbsp; else if (x &gt; 0)<br>&nbsp;&nbsp;&nbsp; return 1.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // double<br>&nbsp; else return 0.0f;&nbsp;&nbsp; // float<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; getValue(5.5);<br>&nbsp;<br>}&nbsp; </div><div class="text">Wie vermutet, führt dies zu einem Fehler.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_178365191_63cbcfd32c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Vermutlich ist die nächste Nicht-Regel die, die am kontroversten diskutiert wird.<br></div><div class="ztitel"><a alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22NR.3%3A%20Don%C2%92t%3A%20Don%C2%92t%20use%20exceptions%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-no-exceptions%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-no-exceptions%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-no-exceptions" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-no-exceptions">NR.3: Don’t: Don’t use exceptions</a></div><div class="text">Zuerst einmal, zählen die Guidelines die gewichtigsten Argumente gegen Ausnahmen auf.</div><div class="text"><ol><li>exceptions are inefficient</li><li>exceptions lead to leaks and errors</li><li>exception performance is not predictable</li></ol></div><div class="text">Die Guidelines antworten mit schwergewichtigen Argumenten auf diese Behauptungen.</div><div class="text">1. Oft wird die Effizienz der Ausnahmebehandlung mit einem Programm verglichen, dass sich schlicht beendet oder den Fehlercode darstellt. Viele Implementierungen der Ausnahmebehandlung sind auch nicht besonders gut. Natürlich macht der Vergleich bei all diesen Punkten keinen Sinn. Daher möchte ich auf das Dokument <a alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Technical%20Report%20on%20C%2B%2B%20Performance%20%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2FTR18015.pdf%22%2C%22user_params%22%3A%22%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">Technical Report on C++ Performance </a>(TR18015.pdf) verweisen, das zwei typische Arten vorstellt, wie Ausnahmebehandlung implementiert ist. </div><div class="text"><ol><li>Der Codeansatz, in der Code mit jedem try-Block assoziiert ist.</li><li>Der Tabellenansatz, der vom Compiler erzeugte statische Tabellen verwendet.<br></li></ol></div><div class="text">Vereinfachend gesagt, besitzt der Codeansatz den Nachteil, dass selbst dann die Buchhaltung der Ausnahmebehandlung durchgeführt werden muss, wenn keine Ausnahme auftritt. Das bedeutet natürlich, dass der Stack größer und die Applikation langsamer wird. Dieser Nachteil gilt nicht für den Tabellenansatz, denn dieser impliziert keine zusätzlichen Kosten für den Stack oder die Laufzeit des Programms, wenn keine Ausnahmen auftreten. Im Gegensatz dazu ist der Tabellenansatz komplizierter zu implementieren und die statischen Tabellen können relativ groß werden.<br></div><div class="text">2. Zum Punkt 2 habe ich nichts hinzuzufügen. Ausnahmen können nicht dafür getadelt werden, falls das Programm keine Strategie für Ressourcenmanagment besitzt.</div><div class="text">3. Wenn du harte Echtzeitbedingungen umzusetzen hast, sodass eine späte Antwort eine falsche Antwort ist, wird eine Ausnahmebehandlung auf der Basis des Tabellenansatzes [--] wie wir sahen [--] keinen Schaden im Gutfall verursachen. Ehrlich gesagt, auch wenn du harte Echtzeitbedingungen umsetzen musst, betrifft diese Einschränkung meist nur einen kleinen Teil des Programms.<br></div><div class="text">Anstelle gegen die Nicht-Regel zu argumentieren, sind hier die Regeln für die Verwendung von Ausnahmen.</div><div class="text">Ausnahmen&nbsp; </div><div class="text"><ul><li> erlauben es, deutlich zwischen einem Fehlercode als Rückgabewert und einem regulären Rückgabewert zu unterscheiden.</li><li>können nicht vergessen oder ignoriert werden.</li><li>lassen sich systematisch anwenden.</li></ul></div><div class="text">Gerne möchte ich eine Anekdote zu Legacy Code erzählen. Dieser Legacy Code verwendete Fehlercode um den Erfolg oder den Misserfolg eines Funktionsaufrufs zu kommunizieren. Der Fehlercode wurde in dem System geprüft. Das war gut, aber dank der Fehlercodes verwendeten die Funktionen keinen Rückgabewert. Die Konsequenz war, dass die Funktionen auf globalen Variablen agierten und daher auch keine Funktionsparameter besaßen. Das Ende der Geschichte war, dass das System nicht mehr wartbar und testbar war und mein Job bestand darin, es zu refaktorieren.<br></div><div class="text">Die typische fehlerbehaftete Anwendung von Ausnahmen ist die folgende. Du fängst jede Ausnahme in jeder Funktion. Letztendlich endest du nun mit einem schwer wartbarem Code mit einer Spaghettistruktur. Ausnahmen sollten nicht das Mittel der Wahl sein um einen schnellen Fix zu machen, sondern sind Bestandteil der Systemarchitektur. Stelle dir daher vor, du entwirfst ein Eingabe-Subsystem. In diesem Fall musst du auch die potenziellen Ausnahmen dokumentieren und testen. Ausnahme sind ein wesentlicher Bestandteil des nicht-funktionalen Kanals und gehören damit zu dem Vertrag, dem du dem Anwender deines Subsystems gibst. Du benötigst eine klare Grenze zwischen der Anwendung und dem Subsystem. Das Ergebnis mag sein, dass das Subsystem die obskure Ausnahmen in einfache Ausnahmen übersetzt, sodass die Applikation darauf reagieren kann. Eine Ausnahme übersetzen heißt, dass die obskure Ausnahme in dem Subsystem gefangen wird und in einer einfacheren Form neu geworfen wird: <br></div><div class="pre">try{<br>&nbsp;&nbsp;&nbsp;&nbsp; // code, that may throw an obscure exception<br>&nbsp; }&nbsp;&nbsp; <br>&nbsp; catch (ObscureException18&amp; ob){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw InputSubsystemError("File has wrong permissions!");<br>}</div><div class="text">Das Ergebnis einer solch vorgestellten Systemarchitektur, die den nicht-funktionalen Kanal (Ausnahmen) umfasst, ist, dass du das Subsystem, dass du die Integration des Subsystems in die Applikation und dass du das System (Applikation) in Isolation testen kannst.</div><div class="text">Die letzte Mythos für heute ist sehr einfach zu entlarven.<br></div><div class="ztitel"><a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-lots-of-files" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-lots-of-files" alt="%7B%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-lots-of-files%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22NR.4%3A%20Don%C2%92t%3A%20Place%20each%20class%20declaration%20in%20its%20own%20source%20file%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rnr-lots-of-files%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D">NR.4: Don’t: Place each class declaration in its own source file</a> </div><div class="text">Das richtige Mittel um den Code zu strukturieren sind nicht Dateien; der richtige Weg ist es Namensräume zu verwenden. Wird jede Klasse in einer eigenen Klasse deklariert, ergeben sich viele Dateien und dein Programm ist damit schwieriger zu verwalten und zu testen. <br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Du kannst sicher sein: The C++ Core Guidelines und ich sind noch nicht fertig mit den Nicht-Regeln und Mythen zu C++. Danach solltest du in der Lage sein, Nicht-Regeln und Mythen zu demystifizieren, sobald du ihnen begegnest. <br></div><div class="simple-translate-result-wrapper"><br> <br></div>
