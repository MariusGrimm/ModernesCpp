<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143963025_bd59a45337.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Die Guidelines besitzen zehn Regeln für das Überladen von Funktionen und Operatoren. Viele von ihnen sind recht naheliegend. Werden sie aber nicht eingehalten, birgt die Software viele Überraschungen. </div>
<div class="text">Ich bin sehr verwundert, dass es nur zehn Regeln für das Überladen in den Guidelines gibt. Verwundert, da ich in der Vergangenheit sehr häufig Diskussion zum Überladen von Operatoren in C++ geführt habe. Zusätzlich kommt hinzu, dass <a title="Link auf http://www.grimm-jaud.de/index.php/blog/fakten" class="" alt="%7B%22text%22%3A%22MISRA%20C%2B%2B%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffakten%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffakten%22%7D" href="http://www.grimm-jaud.de/index.php/blog/fakten">MISRA C++</a>, das sehr häufig in Automobilbereich und der Embedded-Entwicklung eingesetzt wird, das Überladen von Operatoren verbietet. </div>
<div class="text">Im Gegensatz zu der intensiven Diskussion zum Überladen von Operatoren in C++ habe ich keine Diskussion dazu in Python im Gedächtnis. Dies gilt, obwohl das Überladen von Operatoren in Python sehr mächtig und zugleich idiomatisch ist. Betrachte nur die vielen speziellen Methoden, die mit zwei Unterstrichen beginnen und enden und in Python liebevoll <i>dunder</i> genannt werden. Diese musst du implementieren, um einen Datentyp zu erhalten, der sich wie ein <i>int</i> verhält. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143963034_6f0fc6c3f6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Nun geht es aber los mit C++. Hier sind die zehn Regeln.</div>
<div class="text"><ul><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conventional" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conventional" alt="%7B%22version%22%3A1%2C%22text%22%3A%22C.160%3A%20Define%20operators%20primarily%20to%20mimic%20conventional%20usage%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conventional%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conventional%22%7D">C.160: Define operators primarily to mimic conventional usage</a> <br></li><li> <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-symmetric%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-symmetric%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C.161%3A%20Use%20nonmember%20functions%20for%20symmetric%20operators%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-symmetric" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-symmetric">C.161: Use nonmember functions for symmetric operators</a> <br></li><li> <a alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.162%3A%20Overload%20operations%20that%20are%20roughly%20equivalent%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent">C.162: Overload operations that are roughly equivalent</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent-2" alt="%7B%22version%22%3A1%2C%22text%22%3A%22C.163%3A%20Overload%20only%20for%20operations%20that%20are%20roughly%20equivalent%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent-2%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent-2%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent-2">C.163: Overload only for operations that are roughly equivalent</a> <br></li><li>C.164: Avoid conversion operators<br></li><li>C.165: Use using for customization points<br></li><li>C.166: Overload unary &amp; only as part of a system of smart pointers and references<br></li><li>C.167: Use an operator for an operation with its conventional meaning<br></li><li>C.168: Define overloaded operators in the namespace of their operands<br></li><li>C.170: If you feel like overloading a lambda, use a generic lambda</li></ul></div>
<div class="text">Wenn die Regel recht offensichtlich ist, werde ich es in bekannter Manier kurz halten.<br></div>
<div class="ztitel">Overloading and overloaded operators</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conventional" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conventional%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conventional%22%2C%22version%22%3A1%2C%22text%22%3A%22C.160%3A%20Define%20operators%20primarily%20to%20mimic%20conventional%20usage%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conventional">C.160: Define operators primarily to mimic conventional usage</a></b></div>
<div class="text">Du solltest dem <a href="https://de.wikipedia.org/wiki/Principle_of_Least_Surprise" alt="%7B%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FPrinciple_of_Least_Surprise%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FPrinciple_of_Least_Surprise%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Prinzip%20der%20kleinsten%20%C3%9Cberraschung%22%2C%22version%22%3A1%7D" title="Link auf https://de.wikipedia.org/wiki/Principle_of_Least_Surprise" class="">Prinzip der kleinsten Überraschung</a> folgen. Oder um es in den Worten von C:61 auszudrücken: <a alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22A%20copy%20operation%20should%20be%20copy.%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3834288%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3834288%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%7D" href="https://www.heise.de/-3834288" class="" title="Link auf https://www.heise.de/-3834288">A copy operation should be copy.</a> Das heißt, nach der Zuweisung<i> x = y</i> muss gelten: <i>x == y.</i></div>
<div class="text">Das war recht offensichtlich. Die nächste Regel hört sich ziemlich einfach an. Ihre Diskussion bringt aber interessante Erkenntnisse ans Licht. <br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-symmetric" class="" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-symmetric%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-symmetric%22%2C%22version%22%3A1%2C%22text%22%3A%22C.161%3A%20Use%20nonmember%20functions%20for%20symmetric%20operators%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-symmetric">C.161: Use nonmember functions for symmetric operators</a></b></div>
<div class="text">In der Regel ist die Implementierung eines symmetrischen Operators in einer Klasse nicht möglich. Das zeigt relativ schnell der Operator +. <br></div>
<div class="text">Nimm daher an, dass du eine Klasse <i>MyInt</i> implementieren willst, die die Addition mit dem fundamentalen Datentyp<i> int </i>unterstützen soll. Hier ist die erste Umsetzung der Anforderung.</div>
<div class="pre">// MyInt.cpp<br><br>struct MyInt{<br>&nbsp;&nbsp;&nbsp; MyInt(int v):val(v){};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp; MyInt operator+(const MyInt&amp; oth) const { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt(val + oth.val);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br><br>int main(){<br><br>&nbsp; MyInt myFive = MyInt(2) + MyInt(3);<br>&nbsp; MyInt myFive2 = MyInt(3) + MyInt(2);<br>&nbsp; <br>&nbsp; MyInt myTen = myFive + 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp; MyInt myTen2 = 5 + myFive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3 ERROR<br>&nbsp; <br>}<br></div>
<div class="text">Dank des impliziten Konvertierungskonstruktors (1) ist der Ausdruck (2) gültig. Das gilt aber nicht für den Ausdruck (3), denn die <i>5</i> in dem Ausdruck<i> 5 + myFive </i>wird nicht automatisch nach <i>MyInt </i>konvertiert. Das Ergebnis ist ein Compilerfehler.<br></div>
<div class="text">Genauer gesagt, scheitert das Kompilieren des Programms, da der fundamental Datentyp <i>int</i> den Operator + nicht für <i>MyInt</i> überladen hat. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143963037_692dfed52a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Das kleine Programm besitzt gleich mehrere Probleme.<br></div>
<div class="text"><ol><li>Der + Operator ist nicht symmetrisch.</li><li>Die <i>val</i>-Variable ist <i>public.</i></li><li>Der Konvertierungskonstruktor ist implizit.</li></ol></div>
<div class="text">Es ist einfach, die ersten zwei Probleme zu lösen, indem ein freier +-Operator zum Einsatz kommt, der in der Klasse als <i>friend</i> deklariert wird.<br></div>
<div class="pre">// MyInt2.cpp<br><br>class MyInt2{<br>public:<br>&nbsp;&nbsp;&nbsp; MyInt2(int v):val(v){};<br>&nbsp;&nbsp;&nbsp; friend MyInt2 operator+(const MyInt2&amp; fir, const MyInt2&amp; sec){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt2(fir.val + sec.val);<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br><br>int main(){<br><br>&nbsp; MyInt2 myFive = MyInt2(2) + MyInt2(3);<br>&nbsp; MyInt2 myFive2 = MyInt2(3) + MyInt2(2);<br>&nbsp; <br>&nbsp; MyInt2 myTen = myFive + 5;<br>&nbsp; MyInt2 myTen2 = 5 + myFive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; <br>}</div>
<div class="text">Nun springt die implizite Konvertierung von <i>int</i> nach <i>MyInt</i> ein, und die Variable val ist privat. Dem Wortlaut der Regel <a alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22version%22%3A1%2C%22text%22%3A%22C.164%3A%20Avoid%20conversion%20operators%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion">C.164: Avoid conversion operators</a> folgend, gilt aber, das du keinen impliziten Konvertierungskonstruktor anwenden sollst. Wende ich aber einen expliziten Konvertierungskonstruktor an, dann übersetzt das Programm nicht mehr.</div>
<div class="pre">// MyInt3.cpp<br><br>class MyInt3{<br>public:<br>&nbsp;&nbsp;&nbsp; explicit MyInt3(int v):val(v){};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp; friend MyInt3 operator+(const MyInt3&amp; fir, const MyInt3&amp; sec){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt3(fir.val + sec.val);<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br><br>int main(){<br><br>&nbsp; MyInt3 myFive = MyInt3(2) + MyInt3(3);<br>&nbsp; MyInt3 myFive2 = MyInt3(3) + MyInt3(2);<br>&nbsp; <br>&nbsp; MyInt3 myTen = myFive + 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp; MyInt3 myTen2 = 5 + myFive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp; <br>}</div>
<div class="text">Dank des expliziten Konvertierungskonstruktors (1) ist die implizite Konvertierung von <i>int </i>to <i>MyInt </i>nicht zulässig und die Zeilen (2) und (3) führen zu einem Fehler. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143963043_a2e300d5ca.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Zumindest folgte ich der Regel und der Operator + ist symmetrisch. </div>
<div class="text">Der naheliegendste Weg, die ursprüngliche Anforderung umzusetzen, ist es, zwei zusätzliche +-Operatoren für <i>MyInt4 </i>anzubieten. Einer nimmt <i>int</i> als linkes, einer nimmt <i>int</i> als rechtes Argument an. <br></div>
<div class="pre">// MyInt4.cpp<br><br>class MyInt4{<br>public:<br>&nbsp;&nbsp;&nbsp; explicit MyInt4(int v):val(v){};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp; friend MyInt4 operator+(const MyInt4&amp; fir, const MyInt4&amp; sec){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt4(fir.val + sec.val);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; friend MyInt4 operator+(const MyInt4&amp; fir, int sec){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt4(fir.val + sec);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; friend MyInt4 operator+(int fir, const MyInt4&amp; sec){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyInt4(fir + sec.val);<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br><br>int main(){<br><br>&nbsp; MyInt4 myFive = MyInt4(2) + MyInt4(3);<br>&nbsp; MyInt4 myFive2 = MyInt4(3) + MyInt4(2);<br>&nbsp; <br>&nbsp; MyInt4 myTen = myFive + 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp; MyInt4 myTen2 = 5 + myFive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp; <br>}</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C.162%3A%20Overload%20operations%20that%20are%20roughly%20equivalent%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent">C.162: Overload operations that are roughly equivalent</a> und <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent-2" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent-2%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-equivalent-2%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.163%3A%20Overload%20only%20for%20operations%20that%20are%20roughly%20equivalent%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-equivalent-2" class="">C.163: Overload only for operations that are roughly equivalent</a></b></div>
<div class="text">Die zwei Regeln lassen sich einfach zusammenfassen. Äquivalente Funktionen sollten die gleichen Namen besitzen. Oder anders herum. Nichtäquivalente Funktionen sollten nicht den gleichen Namen besitzen. </div>
<div class="text">Hier ist ein Beispiel aus den Guidelines.&nbsp; <br></div>
<div class="pre">void print(int a);<br>void print(int a, int base);<br>void print(const string&amp;);</div>
<div class="text">Der Aufruf der Funktion <i>print(arg)</i> fühlt sich wie generisches Programmieren an. Du musst dir keine Gedanken dazu machen, welche Version von <i>print</i> verwendet wird .</div>
<div class="text">Das gilt aber nicht für die drei nächsten Funktionen. Sie besitzen verschiedene Namen.</div>
<div class="pre">void print_int(int a);<br>void print_based(int a, int base);<br>void print_string(const string&amp;); </div>
<div class="text">Falls nichtäquivalente Funktionen den gleichen Namen besitzen, dann sind die Namen wohl zu allgemein oder schlichtweg falsch. Dies ist verwirrend und fehleranfällig.<br></div>
<div class="ztitel_kleiner">Wie geht's weiter</div>
<div class="text">Die nächste Regel ist sehr wichtig: <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion" alt="%7B%22text%22%3A%22C.164%3A%20Avoid%20conversion%20operators.%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion">C.164: Avoid conversion operators.</a> Ich habe auf sie bereits in der Regel C.161 Bezug genommen. Du sollst keine impliziten Konvertierungskonstruktor und [--] das ist neu [--] keinen impliziten Konvertierungsoperator verwenden. Genau darüber werde ich im nächsten Artikel schreiben.</div>
<div class="ztitel">Weitere Informationen</div>
<div class="text">In der letzten Woche habe ich die zweite Auflage meines Buchs "The C++ Standard Library" veröffentlicht. Dieses Update deckt auch den neuen C++17-Standard ab. Auf <a title="Link auf https://leanpub.com/cpplibrary" class="" href="https://leanpub.com/cpplibrary" alt="%7B%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fcpplibrary%22%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fcpplibrary%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22Leanpub%22%7D">Leanpub</a> gibt es weitere Informationen zum Buch.&nbsp; </div>
