<div class="vorspann">Die wohl wichtigste Regel der C++ Core Guidelines zur Concurrency ist, falls möglich, ein Werkzeug zu verwenden, um den Code zu prüfen. Nicht alle, aber viele Bugs lassen sich mit Werkzeugen finden, und jeder beseitigte Bug ist ein guter Bug. Hier sind die zwei Werkzeuge, die mir sehr oft wertvolle Hilfe in den letzten Jahren gegeben haben: <a title="Link auf https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual" alt="%7B%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fgoogle%2Fsanitizers%2Fwiki%2FThreadSanitizerCppManual%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22ThreadSanitizer%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fgoogle%2Fsanitizers%2Fwiki%2FThreadSanitizerCppManual%22%7D" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual" class="">ThreadSanitizer</a> und <a title="Link auf http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/" alt="%7B%22type%22%3A%22E%22%2C%22text%22%3A%22CppMem%22%2C%22href%22%3A%22http%3A%2F%2Fsvr-pes20-cppmem.cl.cam.ac.uk%2Fcppmem%2F%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fsvr-pes20-cppmem.cl.cam.ac.uk%2Fcppmem%2F%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="" href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/">CppMem</a>.</div>
<div class="text">Dies ist die Regel für den heutigen Artikel:</div>
<div class="ztitel"><a alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22CP.9%3A%20Whenever%20feasible%20use%20tools%20to%20validate%20your%20concurrent%20code%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-tools%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-tools%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-tools" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-tools">CP.9: Whenever feasible use tools to validate your concurrent code</a></div>
<div class="text">Glaube mir, dieser Artikel basiert auf eigener Erfahrung. Einerseits schreiben viele meiner Schulungsteilnehmer Programme mit Data Races, andererseits habe ich einige Multithreading-Programme implementiert, die Bugs hatten. Wie kann ich mir so sicher sein: dank des dynamischen Codeanalyse-Werzeugs <a alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fgoogle%2Fsanitizers%2Fwiki%2FThreadSanitizerCppManual%22%2C%22text%22%3A%22ThreadSanitizer%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fgoogle%2Fsanitizers%2Fwiki%2FThreadSanitizerCppManual%22%2C%22user_params%22%3A%22%22%7D" title="Link auf https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual" class="">ThreadSanitizer</a> und des statischen Codeanalyse-Werkzeugs <a class="" href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CppMem%22%2C%22href%22%3A%22http%3A%2F%2Fsvr-pes20-cppmem.cl.cam.ac.uk%2Fcppmem%2F%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fsvr-pes20-cppmem.cl.cam.ac.uk%2Fcppmem%2F%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" title="Link auf http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/">CppMem</a>. Die Anwendungsfälle für beide Werkzeuge unterscheiden sich deutlich.</div>
<div class="text">ThreadSanitizer gibt das große Bild und entdeckt zur Laufzeit des Programms, ob dieses ein Data Race besitzt. CppMem hingegen bietet eine sehr detaillierte Sicht auf einen kleinen Codeschnipsel, der in der Regel atomare Variablen enthält. Vor allem gibt CppMem die Antwort zu der Frage: Welche verschränkten Ausführungen der Threads sind aufgrund des verwendeten Speichermodells möglich?</div>
<div class="text">Los geht der Artikel mit ThreadSanitizer.</div>
<div class="ztitel_kleiner">ThreadSanitizer</div>
<div class="text">Dies ist die offizielle Beschreibung von <a class="" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual" alt="%7B%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fgoogle%2Fsanitizers%2Fwiki%2FThreadSanitizerCppManual%22%2C%22text%22%3A%22ThreadSanitizer%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fgoogle%2Fsanitizers%2Fwiki%2FThreadSanitizerCppManual%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual">ThreadSanitizer</a>: "ThreadSanitizer (aka TSan) is a data race detector for C/C++. Data races are one of the most common and hardest to debug types of bugs in concurrent systems. A data race occurs when two threads access the same variable concurrently and at least one of the accesses is write.&nbsp;<a href="http://en.wikipedia.org/wiki/C++11" class="" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FC%2B%2B11%22%2C%22text%22%3A%22C%2B%2B11%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FC%2B%2B11%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://en.wikipedia.org/wiki/C++11">C++11</a>&nbsp;standard officially bans data races as&nbsp;undefined behavior."</div>
<div class="text">ThreadSanitizer ist Bestandteil von clang 3.2 und gcc 4.8. Es unterstützt Linux x86_64 und ist auf Ubuntu 12.04 getestet. Um ThreadSanitizer zu verwenden, musst du mit dem Flag <i>-fsanitize=thread </i>compilieren und gegen es linken, zumindest das Optimierungslevel <i>-O2</i> anwenden und das Flag<i> -g </i>für Debug-Information einsetzen: <i>-fsanitize=thread -O2 -g</i>. </div>
<div class="text">Die Laufzeitkosten sind signifikant: Der Speicherverbraucht steigt um den Faktor 5 - 10, die Ausführungszeit um den Faktor 2 - 20. Daher möchte ich gerne das wichtigste Prinzip der Softwareentwicklung nennen: <b>Zuerst gilt, dass das Programm korrekt ist, dann schnell. </b></div>
<div class="ztitel_kleiner">Das Ping-Pong Spiel</div>
<div class="text">Nun werde ich ThreadSanitizer in Aktion vorstellen. Hier ist eine Übungsaufgabe zu Bedingungsvariablen, die ich gerne in meiner Schulungen stelle:</div>
<div class="text">&nbsp;Schreiben Sie ein kleines Ping-Pong Spiel:</div>
<div class="text"><ul><li>Zwei Threads sollen abwechselnd einen Wahrheitswert auf <i>true</i> bzw. <i>false </i>setzen. Dabei setzt ein Thread den Wert auf <i>true</i> und signalisiert dies dem anderen Thread, der den Wert auf <i>false</i> setzt.</li><li>Das Spiel soll nach einer endlichen Zahl von Ballwechseln beendet werden.<br></li></ul></div>
<div class="text">Dies ist eine typische Lösung der Übungsaufgabe.</div>
<div class="pre">// conditionVariablePingPong.cpp<br><br>#include &lt;condition_variable&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>bool dataReady= false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>std::mutex mutex_;<br>std::condition_variable condVar1;<br>std::condition_variable condVar2;<br><br>int counter=0;<br>int COUNTLIMIT=50;<br><br>void setTrue(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp; while(counter &lt;= COUNTLIMIT){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br><br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar1.wait(lck, []{return dataReady == false;});&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; dataReady= true;<br>&nbsp;&nbsp;&nbsp; ++counter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; dataReady &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar2.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br><br>&nbsp; }<br>}<br><br>void setFalse(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; while(counter &lt; COUNTLIMIT){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br><br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar2.wait(lck, []{return dataReady == true;});<br>&nbsp;&nbsp;&nbsp; dataReady= false;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; dataReady &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar1.notify_one();<br><br>&nbsp; }<br><br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "Begin: " &lt;&lt; dataReady &lt;&lt; std::endl;<br><br>&nbsp; std::thread t1(setTrue);<br>&nbsp; std::thread t2(setFalse);<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br>&nbsp; <br>&nbsp; dataReady= false;<br>&nbsp; std::cout &lt;&lt; "End: " &lt;&lt; dataReady &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Die Funktion <i>setTrue</i> (1) setzen den Wahrheitswert <i>dataReady</i> (3) auf true und die Funktion <i>setFalse</i> (2) setzt ihn auf <i>false</i>. Das Spiel beginnt mit <i>setTrue.</i> Die Bedingungsvariable in der Funktion wartet auf die Benachrichtigung und prüft daher zuerst den Wahrheitswert <i>dataRace</i> (4). Danach erhöht die Funktion den <i>counter</i> (5) um 1 und benachrichtigt mit der Hilfe der Bedingungsvariable <i>condVar2</i> (6) den anderen Thread. Die Funktion <i>setFalse </i>folgt demselben Arbeitsablauf. Falls der <i>counter </i>den Wert <i>COUNTLIMIT</i> (7) erreicht, endet das Spiel. Übungsaufgabe gelöst? NEIN!</div>
<div class="text">Es gibt eine Data Race auf <i>counter</i>. Dieser wird gleichzeitig gelesen (8) und geschrieben (5). Dank ThreadSanitizer kann ich den Beweis sofort antreten:<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_152566012_26f393249d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">ThreadSanitizer entdeckt das Data Race während der Laufzeit des Programms. </div>
<div class="text">Mit CppMem lassen sich hingegen kleine Codeschnipsel analysieren. </div>
<div class="ztitel_kleiner">CppMem<br></div>
<div class="text">In diesem Artikel kann ich nur einen einfachen Überblick zu CppMem geben. Das Online-Werkzeug, das sich auch lokal installieren lässt, bietet sehr wertvolle Dienste an.</div>
<div class="text"><ol><li> CppMem validiert kleine Codeschnipsel, die typischerweise atomare Variablen enthalten.</li><li>Die sehr detaillierte Analyse von CppMem hilft ungemein, einen tieferen Einblick in das C++ Speichermodell zu erhalten. <br></li></ol></div>
<div class="text">Für deutlich tiefere Einsichten in CppMem, habe ich bereits einige Artikel zu <a class="" href="https://www.grimm-jaud.de/index.php/blog/tag/cppmem" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/cppmem" alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fcppmem%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fcppmem%22%2C%22text%22%3A%22CppMem%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D">CppMem</a> geschrieben. In dem Artikel werde ich mich auf den ersten Punkt fokussieren und CppMem kurz aus der Vogelperspektive betrachten. </div>
<div class="ztitel_kleiner">Ein kleiner Überblick</div>
<div class="text">Mein vereinfachter Überblick geht von der Default-Konfiguration des Werkzeugs aus. Dieser Überblick sollte als Startpunkt für eigene Experimente ausreichen.</div>
<div class="text">Der Einfachheit halber beziehe ich mich auf die roten Zahlen in dem folgenden Screenshot.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_152566016_b6df03a18b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><ol><li>Model <ul><li>Spezifiziert das C++-Speichermodell. <i>preferred</i> entspricht dem C++-Speichermodell.</li></ul> </li><li>Program<ul><li>Enthält das ausführbare Programm in einer Syntax, die sehr stark an C oder C++ angelehnt ist.<br></li><li>CppMem bietet einen Satz an Programmen zu typischen Szenarien von Multithreading-Programmen an. Genauer sind die&nbsp;in dem sehr lesenswerten Artikel "<a class="" href="http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf" alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.cl.cam.ac.uk%2F~pes20%2Fcpp%2Fpopl085ap-sewell.pdf%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Mathematizing%20C%2B%2B%20Concurrency%22%2C%22href%22%3A%22http%3A%2F%2Fwww.cl.cam.ac.uk%2F~pes20%2Fcpp%2Fpopl085ap-sewell.pdf%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf">Mathematizing C++ Concurrency</a>" beschrieben. Darüber hinaus lässt sich natürlich auch eigener Code verwenden.&nbsp;</li><li>Da es um Threads bei CppMem geht, besitzt das Werkzeug ein paar Vereinfachungen für Threads. <ul><li>Threads werden durch die Symbole <i>{{{&nbsp; ... ||| ... }}} </i>definiert.&nbsp;Dabei steht die Ellipse (...) für das jeweilige Arbeitspaket des Threads.</li></ul></li></ul></li><li>Display Relations <ul><li>Beschreibt die Beziehungen zwischen Lese, Schreibe und Lese-Schreibe-Modifikationen auf atomaren Operationen, Speicherbarrieren und Locks.</li><li>Wenn eine Beziehung ausgewählt ist, wird diese im annotierten Graph (siehe Punkt 6) dargestellt.<br></li><ul><li>Hier sind typische Beziehungen<br><ul><li><b>sb</b>: sequencedbeforer <br></li><li><b>rf:</b> read from</li><li><b>mo</b>: modification order</li><li><b>sc</b>: sequentially consistency</li><li><b>lo:</b> lock order</li><li><b>sw</b>: sychronizes-with</li><li><b>dob</b>: dependency-ordered-before</li><li><b>data_races</b><br> </li></ul> </li></ul></ul> </li><li>Display Layout <ul><li>Mit diesen Schaltern lässt sich steuern, welche Doxygraph-Graph zur Darstellung der konkreten Ausführung verwendet werden soll.</li></ul> </li><li>Auswahl der Ausführung</li><ul><li>Wechsel zwischen den verschiedenen, konsistenten Ausführungen</li></ul><li>Annotierter Graph</li><ul><li>Stellt den annotierten Graph dar.<br></li></ul></ol></div>
<div class="text">Nun will ich das Werkzeug anwenden.<br></div>
<div class="ztitel_kleiner">Ein Data Race</div>
<div class="text">Zuerst ist hier mein kleines Programm. Dieses besitzt ein Data Race auf <i>x</i> (1). Die Verwendung der atomare Variable <i>y </i>hingegen ist wohldefiniert. Dies ist unabhängig davon, welche <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" class="" title="Link auf https://en.cppreference.com/w/cpp/atomic/memory_order" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_order%22%2C%22text%22%3A%22memory-order%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_order%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D">memory-order</a> ich für <i>y</i> einsetze, den zumindest ist <i>y</i> atomar.&nbsp; </div>
<div class="pre">// dataRaceOnX.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>int x = 0;<br>std::atomic&lt;int&gt; y{0};<br><br>void writing(){&nbsp; <br>&nbsp; x = 2000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; y.store(11, std::memory_order_release);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>}<br><br>void reading(){&nbsp; <br>&nbsp; std::cout &lt;&lt; y.load(std::memory_order_acquire) &lt;&lt; " "; // (2)<br>&nbsp; std::cout &lt;&lt; x &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::thread thread1(writing);<br>&nbsp;&nbsp;&nbsp; std::thread thread2(reading);<br><br>&nbsp;&nbsp;&nbsp; thread1.join();<br>&nbsp;&nbsp;&nbsp; thread2.join();<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Hier ist das entsprechende Programm in der vereinfachten CppMem-Syntax. <br></div>
<div class="pre">// dataRaceOnXCppMem.txt<br><br>int main(){<br>&nbsp; int x = 0;<br>&nbsp; atomic_int y = 0;<br>&nbsp; <br>&nbsp; {{{ <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 2000;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y.store(11, memory_order_release);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; ||| <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y.load(memory_order_acquire);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }}}<br>}<b><br></b></div>
<div class="text">CppMem zeigt es sofort an. Die erste konsistente Ausführung besitzt ein Data Race auf x.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_152566023_d1a633233e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das Data Race ist direkt in dem Graph sichtbar. Es ist die gelbe Kante (dr) zwischen der Schreibe- (<i>x=2000</i>) und der Lese-Operation (<i>x=0</i>).</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Klar, es gibt noch viele Regeln zu Concurreny in den C++ Core Guidelines. Im nächsten Artikel werde ich mir genauer Locks und Mutexe anschauen.<br></div>