<div class="vorspann">Heute schließe ich meine Geschichte zu den Mythen meiner Blog-Leser ab. Bei den aktuellen Mythen geht es um Funktionsparameter, die Initialisierung von Klassenelementen und Zeiger versus Referenzen.</div><div class="utitel">Nimm die Parameter immer als konstante Referenz an (Gunter Königsmann)<br></div><div class="text">Wenn eine Funktion ihre Parameter annimmt und diese nicht verändern soll, gibt es zwei Optionen:</div><div class="text"><ul><li>Sie nimmt die Parameter by Value (kopieren) an.</li><li>Sie nimmt die Parameter als konstante Referenz an.</li></ul></div><div class="text">Dies war die Korrektheitsperspektive. Doch was lässt sich über die Performanz sagen? Die C++ Core Guidelines geben auf diese Frage eine Antwort. Das folgende Beispiel bringt die Schwierigkeit auf den Punkt:</div><div class="pre">void f1(const string&amp; s);&nbsp; // OK: pass by reference to const; always cheap<br><br>void f2(string s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad: potentially expensive<br><br>void f3(int x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK: Unbeatable<br><br>void f4(const int&amp; x);&nbsp;&nbsp;&nbsp;&nbsp; // bad: overhead on access in f4()<br></div><div class="text">Wohl basierend auf Erfahrung stellt die Guidelines die folgende Daumenregel auf. </div><div class="text"><ul><li><b>Du sollst einen Parameter p per konstanter Referenz annehmen, wenn gilt: <span class="tx_code">sizeof(p) &gt; 4 * sizeof(int)</span></b></li><li><b>Du sollst einen Parameter p kopieren, wenn gilt: <span class="tx_code">sizeof(p) &lt; 3 * sizeof(int)</span><i><br></i></b></li></ul></div><div class="text">Damit stellt sich nur noch die Frage, wie groß die Datentypen sind. Das Programm <span class="tx_code">sizeofArithmeticTypes.cpp</span> gibt die Antwort für die arithmetischen Datentypen:<br></div><div class="pre">// sizeofArithmeticTypes.cpp<br><br>#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(void*): " &lt;&lt; sizeof(void*) &lt;&lt; std::endl;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(5):&nbsp; "&nbsp; &lt;&lt; sizeof(5)&nbsp;&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(5l): "&nbsp; &lt;&lt; sizeof(5l)&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(5ll): " &lt;&lt; sizeof(5ll) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(5.5f): " &lt;&lt; sizeof(5.5f) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(5.5): "&nbsp; &lt;&lt; sizeof(5.5)&nbsp; &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "sizeof(5.5l): " &lt;&lt; sizeof(5.5l) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text"><span class="tx_code">sizeof(void*)</span> gibt zurück, ob es sich um ein 32-Bit- oder 64-Bit-System handelt. Dank des Online-Compilers <a alt="%7B%22text%22%3A%22rextester%22%2C%22href%22%3A%22https%3A%2F%2Frextester.com%2F%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Frextester.com%2F%22%7D" href="https://rextester.com/" title="Link auf https://rextester.com/">rextester</a> lässt sich das Programm auf GCC, Clang und <i>cl.exe</i> (Windows) ausführen. Hier sind die Zahlen für die 64-Bit-Systeme:</div><div class="ztitel_kleiner">GCC</div><div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179451450_938b929b44.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel_kleiner">Clang</div><div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179451458_42bef75807.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel_kleiner">cl.exe (Windows)</div><div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179451463_d28c585b24.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Die Zahlen von <i>cl.exe</i> unterscheiden sich deutlich von den von GCC und Clang. Ein <i>long int</i> besitzt 4 Bytes und ein <i>long double </i>8 Bytes auf Windows. Im Gegensatz dazu sind beide Datentypen auf dem GCC und Clang doppelt so groß. <br></div><div class="ztitel">Initialisierung und Zuweisungen in einem Konstruktor sind äquivalent (Gunter Königsmann)</div><div class="text">Zuerst muss ich klären, für was die Initialisierung und die Zuweisung in einem Konstruktor steht:<br></div><div class="pre">class Good{&nbsp; <br>&nbsp;&nbsp;&nbsp; int i;<br>public:<br>&nbsp;&nbsp;&nbsp; Good(int i_): i{i_&nbsp;}{} <br>};<br><br>class Bad{&nbsp; <br>&nbsp;&nbsp;&nbsp; int i;<br>public:<br>&nbsp;&nbsp;&nbsp; Bad(int i_): { i = i_&nbsp;; } <br>};</div><div class="text">Die Klasse <span class="tx_code">Good</span> verwendet Initialisierung, aber die Klasse <span class="tx_code">Bad</span> Zuweisung. Dies sind die Konsequenzen:</div><div class="text"><ul><li>Die Variable [code]i[/code] wird in der Klasse [code]Good[/code] direkt initialisiert.</li><li>Die Variable [code]i[/code] wird in der Klasse [code]Bad[/code] zuerst Default-konstruiert und danach nochmals überschrieben.<br></li></ul></div><div class="text">Die Konstruktorinitialisierung ist einerseits schneller, aber auch andererseits bei Konstanten, Referenzen, und Mitglieder einer Klasse, die sich nicht Default-konstruieren lassen, möglich:<br></div><div class="pre">// constructorAssignment.cpp<br><br>struct NoDefault{<br>&nbsp;&nbsp;&nbsp; NoDefault(int){};<br>};<br><br>class Bad{<br>&nbsp;&nbsp;&nbsp; const int constInt;<br>&nbsp;&nbsp;&nbsp; int&amp; refToInt;<br>&nbsp;&nbsp;&nbsp; NoDefault noDefault;<br>public:<br>&nbsp;&nbsp;&nbsp; Bad(int i, int&amp; iRef){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constInt = i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; refToInt = iRef;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Bad(int i, int&amp; iRef): constInt(i), refToInt(iRef), noDefault{i} {}<br>};<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; int i = 10;<br>&nbsp;&nbsp;&nbsp; int&amp; j = i;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; Bad bad(i, j);<br>&nbsp; <br>}</div><div class="text">Wenn ich versuche, das Programm zu übersetzen, erhalte ich drei Fehlermeldungen:</div><div class="text"><ol><li>[code]constInt[/code] ist nicht initialisiert und kann nicht im Konstruktor überschrieben werden.</li><li>[code]refToInt[/code] ist nicht initialisiert.</li><li>Die Klasse [code]NoDefault[/code] besitzt keinen Default-Konstruktor, da ich einen Konstruktor für [code]int[/code] bereits implementiert habe. Wenn du einen Konstruktor für eine Klasse implementierst, erzeugt der Compiler nicht automatisch einen Default-Konstruktor.</li></ol></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179451469_2d74bba76b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">In der zweiten, erfolgreichen Übersetzung verwende ich den auskommentierten Konstruktor, der die Initialisierung der Zuweisung vorzieht.</div><div class="text">In dem Beispiel kamen aus gutem Grunde Referenz statt nackten Zeiger zum Einsatz.<br></div><div class="ztitel">Du benötigst nackte Zeiger in deinem Code (Thargon110)</div><div class="text">Motiviert durch den Kommentar von Thargon110 bin ich jetzt dogmatisch: NNN. Was? Natürlich meinte ich <b>N</b>o <b>N</b>aked <b>N</b>ew. Aus der Perspektive des Applikationsentwicklers betrachtet gibt es keinen Grund, nackte Zeiger einzusetzen. Wenn du zeigerartige Semantik benötigst, stecke deinen nackten Zeiger in einen Smart Pointer [--] dafür genau steht NNN [--] und das Problem ist gelöst.</div><div class="text">Im Wesentlichen hat C++11 [code]std::unique_ptr[/code] für die exklusiven und [code]std::shared_ptr[/code] für die geteilten Besitzverhältnisse. Das heißt, wenn ein&nbsp;[code]std::shared_ptr[/code] kopierst wird, wird ein interner Referenzzähler inkrementiert und wenn ein [code]std::shared_ptr[/code] gelöscht wird, wird ein interner Referenzzähler dekrementiert. Besitzverhältnisse stehen dafür, dass Smart Pointer auf den zugrundeliegenden Speicher aufpassen und ihn freigeben, wenn er nicht mehr benötigt wird. Der Speicher wird im Falle des&nbsp;[code]std::shared_ptr[/code] nicht mehr benötigt, wenn der Referenzzähler den Wert 0 besitzt.</div><div class="text">Damit gibt es mit modernem C++ keine Speicherleaks mehr. Ich höre schon deine Klagen und freue mich darauf, sie zu widerlegen:<br></div><div class="text"><ul><li> Zyklen von [code]std::shared_ptr[/code] können Speicherleaks verursachen, da der Referenzzähler nie den Wert 0 erreicht. Stimmt, aber ein [code]std:.weak_ptr[/code] hilft, zyklische Referenzen von [code]std::shared_ptr[/code] zu brechen: [code]<a alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-weak-ptr%22%2C%22text%22%3A%22std%3A%3Aweak_ptr%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-weak-ptr%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/std-weak-ptr" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-weak-ptr">std::weak_ptr</a>[/code].</li><li>Der [code]std::shared_ptr[/code] besitzt Verwaltungsaufwand und ist damit teurer als ein nackter Zeiger. Stimmt, darum sollte [code]std::unique_ptr[/code] die erste Wahl sein: [code]<a alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22text%22%3A%22std%3A%3Aunique_ptr%5B%2Fcode%5D%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/std-unique-ptr" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-unique-ptr">std::unique_ptr[/code]</a>.</li><li>Ein [code]<a href="https://www.grimm-jaud.de/index.php/blog/std-unique-ptr" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-unique-ptr" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22text%22%3A%22std%3A%3Aunique_ptr%5B%2Fcode%5D%22%7D">std::unique_ptr[/code]</a> ist nicht sehr praktisch, denn er kann nicht kopiert werden. Stimmt, ein [code]<a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-unique-ptr%22%2C%22text%22%3A%22std%3A%3Aunique_ptr%5B%2Fcode%5D%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/std-unique-ptr" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-unique-ptr">std::unique_ptr[/code]</a> kann aber verschoben werden.</li></ul></div><div class="text">Gerade die letzte Klage ist sehr hartnäckig. Daher wird mir das kleine Beispiel wertvolle Dienste leisten:</div><div class="pre">// moveUniquePtr.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br><br>void takeUniquePtr(std::unique_ptr&lt;int&gt; uniqPtr){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "*uniqPtr: " &lt;&lt; *uniqPtr &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; auto uniqPtr1 = std::make_unique&lt;int&gt;(2014);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; takeUniquePtr(std::move(uniqPtr1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto uniqPtr2 = std::make_unique&lt;int&gt;(2017);<br>&nbsp;&nbsp;&nbsp; auto uniqPtr3 = std::make_unique&lt;int&gt;(2020);<br>&nbsp;&nbsp;&nbsp; auto uniqPtr4 = std::make_unique&lt;int&gt;(2023);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::unique_ptr&lt;int&gt;&gt; vecUniqPtr;<br>&nbsp;&nbsp;&nbsp; vecUniqPtr.push_back(std::move(uniqPtr2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; vecUniqPtr.push_back(std::move(uniqPtr3));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; vecUniqPtr.push_back(std::move(uniqPtr4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::for_each(vecUniqPtr.begin(), vecUniqPtr.end(),&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::unique_ptr&lt;int&gt;&amp; uniqPtr){ std::cout &lt;&lt;&nbsp; *uniqPtr &lt;&lt; std::endl; } );<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div><div class="text">Die Funktion [code]takeUniquePtr[/code] (Zeile 1) nimmt einen [code]std::unique_ptr[/code] per Value an. Die zentrale Beobachtung ist es, dass dazu der [code]std::unique_ptr[/code] verschoben werden muss. Diese zentrale Beobachtung gilt auch für die Argumente des [code]std::vector&lt;std::unique_ptr&lt;int&gt;&gt;[/code] (Zeile 2). [code]std::vector[/code] wie alle Container der Standard Template Library (STL) will seine Elemente besitzen. Ein Kopieren eines [code]std::unique_ptr[/code] ist aber nicht möglich. [code]std::move[/code] löst dieses Problem. Du kannst selbst einen Algorithmus der STL wie [code]std::for_each[/code] auf einen [code]std::vector&lt;std::unique_ptr&lt;int&gt;&gt;[/code] (Zeile 3) anwenden, wenn dieser keine Copy-Semantik verwendet. </div><div class="ztitel">Verwende Referenzen anstelle von Zeigern<br></div><div class="text">Am Ende will ich noch auf den initialen Punkt von Thargon110 reagieren. Ich muss zugeben, dass diese Regel deutlich höhere Relevanz in klassischem C++ ohne Smart Pointer besitzt, denn Smart Pointer sind im Gegensatz zu nackten Zeigern Besitzer. </div><div class="text">Verwende eine Referenz anstelle eines Zeigers, denn eine Referenz besitzt immer einen Wert. Ermüdende Prüfungen wie die folgende sind daher nicht mehr notwendig mit Referenzen:<br></div><div class="pre">if(!ptr){<br>&nbsp;&nbsp; std::cout &lt;&lt; "Something went terrible wrong" &lt;&lt; std::endl;<br>&nbsp;&nbsp; return;<br>}<br>std::cout &lt;&lt; "All fine" &lt;&lt; std::endl;<br></div><div class="text">Zusätzlich kannst du die Prüfung nicht vergessen. Referenzen verhalten sich wie konstante Zeiger.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Die C++ Core Guidelines definieren Profile. Profile sind Teilmengen der Regeln. Profile gibt es für Typ-Sicherheit, Bounds-Sicherheit (Prüfung der Containergrenzen)&nbsp; und Lebenszeit-Sicherheit.</div><div class="ztitel">Wahl des nächsten PDF-Päckchens:</div><div class="text">Auf meinem deutschen und meinem englischen Blog findet gerade die Wahl zum nächsten PDF-Päckchen statt. Hier sind die Links zur Wahl:</div><div class="simple-translate-result-wrapper"><ul><li>Deutscher Blog: <a alt="%7B%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6%22%2C%22text%22%3A%22Welches%20PDF-P%C3%A4ckchen%20soll%20ich%20zusammenstellen%3F%20Mache%20dein%20Kreuz%21%20%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6" href="https://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6">Welches PDF-Päckchen soll ich zusammenstellen? Mache dein Kreuz! </a> </li><li>Englischer Blog: <a alt="%7B%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice-5%22%2C%22text%22%3A%22Which%20PDF%20bundle%20should%20I%20provide%3F%20Make%20your%20choice%21%20%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice-5%22%7D" href="http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice-5" title="Link auf http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice-5">Which PDF bundle should I provide? Make your choice! </a> </li></ul> <br></div><div class="simple-translate-result-wrapper"><br> <br></div><div class="simple-translate-result-wrapper"><br> <br></div>
