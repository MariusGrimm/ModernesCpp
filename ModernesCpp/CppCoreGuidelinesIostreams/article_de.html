<div class="vorspann">Wenn ein Programm mit seiner Umgebung interagiert, sind in C++ die Ein- und Ausgabe-Sstreams das Mittel der Wahl. Natürlich gibt es auch hier einige Regeln zu beachten. Welche, das zeigt der Artikel.</div><div class="text">Die C++ Core Guidelines geben eine gute Einführung in iostreams, der ich nichts hinzufügen möchte: "iostreams is a type safe, extensible, formatted and unformatted I/O library for streaming I/O. It supports multiple (and user extensible) buffering strategies and multiple locales. It can be used for conventional I/O, reading and writing to memory (string streams), and user-defines extensions, such as streaming across networks (asio: not yet standardized)."</div><div class="text">Überraschend war für mich vor allem die Tatsache, dass es nur fünf Regeln zu Iostreams in den C++ Core Guidelines gibt. Verschärfend kommt noch hinzu, dass die Regeln relativ wenig Inhalt besitzen. Das steht für mich im Widerspruch zu der Tatsache, dass iostreams in fast jedem Programm verwendet werden und damit sehr wichtig sind. Hier sind die fünf Kandidaten.<br> </div><div class="text"><ul><li> <a alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-low%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-low%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22SL.io.1%3A%20Use%20character-level%20input%20only%20when%20you%20have%20to%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-low" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-low">SL.io.1: Use character-level input only when you have to</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-validate" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-validate%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-validate%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.io.2%3A%20When%20reading%2C%20always%20consider%20ill-formed%20input%22%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-validate">SL.io.2: When reading, always consider ill-formed input</a> </li><li> <a alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22SL.io.3%3A%20Prefer%20iostreams%20for%20I%2FO%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-streams%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-streams%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-streams" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-streams">SL.io.3: Prefer iostreams for I/O</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-sync" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-sync%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-sync%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22SL.io.10%3A%20Unless%20you%20use%20printf-family%20functions%20call%20ios_base%3A%3Async_with_stdio%28false%29%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-sync">SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22SL.io.50%3A%20Avoid%20endl%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-endl%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-endl%22%7D">SL.io.50: Avoid endl</a> </li></ul></div><div class="text">Um eine Geschichte aus den fünf Regeln zu machen, werde ich zusätzliche Information hinzufügen. Dies gilt aber nicht für die erste Regel.<br></div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-low" alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-low%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-low%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.io.1%3A%20Use%20character-level%20input%20only%20when%20you%20have%20to%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-low">SL.io.1: Use character-level input only when you have to</a></div><div class="text">Zuerst einmal zeige ich das schlechte Beispiel aus den Guidelines. In diesem wird mehr als ein Zeichen eingelesen:</div><div class="pre">char c;<br>char buf[128];<br>int i = 0;<br>while (cin.get(c) &amp;&amp; !isspace(c) &amp;&amp; i &lt; 128)<br>&nbsp;&nbsp;&nbsp; buf[i++] = c;<br>if (i == 128) {<br>&nbsp;&nbsp;&nbsp; // ... handle too long string ....<br>}</div><div class="text">Ehrlich gesagt, ist dies eine schlechte Lösung für eine einfache Aufgabe. Dies gilt aber nicht für den nächsten Codeschnipsel:</div><div class="pre">string s;<br>s.reserve(128);<br>cin &gt;&gt; s;</div><div class="text">Vermutlich ist der bessere Weg in diesem Fall auch der schnellere Weg.</div><div class="text">Die nächste Regel formuliert eine Selbstverständlichkeit.<br></div><div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-validate" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-validate" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22SL.io.2%3A%20When%20reading%2C%20always%20consider%20ill-formed%20input%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-validate%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-validate%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D">SL.io.2: When reading, always consider ill-formed input</a></div><div class="text">Die Frage ist natürlich: Wie lässt sich mit falschen Daten umgehen? Jeder Stream hat einen Zustand assoziiert.</div><div class="ztitel_kleiner">Zustand des Streams</div><div class="text">Flags repräsentieren den Zustand des Streams. Die Methoden, um diese Flags zu manipulieren, benötigen die Header-Datei <i>&lt;iostream&gt;</i>.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175880927_004949b0be.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Zur Anschaulichkeit stelle ich ein paar Beispiele vor, die für die verschiedenen Zustände der Streams verantwortlich sind.</div><div class="text"><b>Ursachen der Stream-Zustände</b></div><div class="text"><i>std::ios::eofbit</i></div><div class="text"><ul><li>Jenseits des letzten gültigen Zeichens lesen. <br></li></ul></div><div class="text"><i>std::ios::failbit</i></div><div class="text"><ul><li> Falsch formatiertes Lesen.</li><li>Jenseits des letzten gültigen Zeichens lesen.</li><li>Das Öffnen einer Datei schlug fehl.</li></ul></div><div class="text"><i>std::ios::badbit</i></div><div class="text"><ul><li> Die Größe des Stream-Puffers kann nicht angepasst werden.</li><li>Die Codekonverierung der Stream-Puffers schlug fehl.</li><li>Ein Teil des Streams verursachte eine Ausnahme.</li></ul></div><div><b>Lesen und Setzen des Stream-Zustands</b><br></div><div><i>stream.clear()</i></div><div><ul><li> Initialisiert die Flags und setzt den Stream in den <i>goodbit</i>-Zustand</li></ul></div><div><i>stream.clear(sta)</i></div><div><ul><li> initialisiert die Flags und setzt den Stream in den <i>sta-</i>Zustand</li></ul></div><div><i>stream.rdstate()</i></div><div><ul><li> Gibt den Zustand des Streams zurück.</li></ul></div><div>stream.setstate(fla)</div><div><ul><li> Setzt das zusätzliche Flag <i>fla.</i></li></ul></div><div class="text">Operationen auf Streams haben nur dann eine Auswirkung, wenn der Stream im <i>goodbit</i>-Zustand ist. Falls der Stream in dem <i>badbit</i>-Zustand ist, kann er nicht mehr in den <i>goodbit</i>-Zustand gesetzt werden. </div><div class="pre">// streamState.cpp<br><br>#include &lt;ios&gt;<br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "In failbit-state: " &lt;&lt; std::cin.fail() &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; int myInt;<br>&nbsp;&nbsp;&nbsp; while (std::cin &gt;&gt; myInt){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Output: " &lt;&lt; myInt &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "In failbit-state: " &lt;&lt; std::cin.fail() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "In failbit-state: " &lt;&lt; std::cin.fail() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cin.clear();<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt;&nbsp; "In failbit-state: " &lt;&lt; std::cin.fail() &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>} </div><div class="text">Die Eingabe des Strings <i>wrongInput</i> bewirkt, dass <i>std::cin </i>in the <i>std::ios::failbit</i>-Zustand gesetzt wird. Konsequenterweise kann <i>wrongInput</i> und <i>std::cin::fail() </i>nicht dargestellt werden. Zuerst gilt es, den Zustand des <i>std::cin-</i>Stream in den <i>goodbit</i>-Zustand zu setzen. </div><div class="text">Du kannst deine Ausgabe mit <i>printf</i> oder mit den Iostreams darstellen. Meine Empfehlung ist offensichtlich.<br></div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-streams" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-streams%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-streams%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.io.3%3A%20Prefer%20iostreams%20for%20I%2FO%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-streams">SL.io.3: Prefer iostreams for I/O</a> </div><div class="text">Das folgende Programm stellt zweimal die Daten auf die gleiche Art formatiert dar. Zuerst kommt <i>printf</i> mit einem Formatstring zum Einsatz und dann Iostreams mit einem Formatmanipulator:<br></div><div class="pre">// printfIostreams.cpp<br><br>#include &lt;cstdio&gt;<br><br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>&nbsp;<br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printf("\n");<br>&nbsp;&nbsp;&nbsp; printf("Characters: %c %c \n", 'a', 65);<br>&nbsp;&nbsp;&nbsp; printf("Decimals: %d %ld\n", 2011, 650000L);<br>&nbsp;&nbsp;&nbsp; printf("Preceding with blanks: %10d \n", 2011);<br>&nbsp;&nbsp;&nbsp; printf("Preceding with zeros: %010d \n", 2011);<br>&nbsp;&nbsp;&nbsp; printf("Doubles: %4.2f %E \n", 3.1416, 3.1416);<br>&nbsp;&nbsp;&nbsp; printf("%s \n", "From C to C++");<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Characters: " &lt;&lt; 'a' &lt;&lt; " " &lt;&lt;&nbsp; static_cast&lt;char&gt;(65) &lt;&lt; std::endl;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Decimals: " &lt;&lt; 2011 &lt;&lt; " " &lt;&lt; 650000L &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Preceding with blanks: " &lt;&lt; std::setw(10) &lt;&lt; 2011 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Preceding with zeros: " &lt;&lt; std::setfill('0') &lt;&lt; std::setw(10) &lt;&lt; 20011 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Doubles: " &lt;&lt; std::setprecision(3) &lt;&lt; 3.1416 &lt;&lt; " " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::setprecision(6) &lt;&lt; std::scientific &lt;&lt;&nbsp; 3.1416 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "From C to C++" &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text">Wie versprochen, dieselbe Ausgabe:<br></div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175880936_c6881a31a5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Aber warum sollten Iosteams <i>printf</i> vorgezogen werden? Es gibt einen entscheidenden Unterschied zwischen <i>printf</i> und Iostreams. Der bei <i>printf</i> angegebenen Format-String bestimmt den Datentyp und wie der Wert dargestellt wird; der Formatmanipulator des Iostreams bestimmt nur, wie der Wert dargestellt wird. Dieser Unterschied kann nicht deutlich genug hervorgehoben werden: <b>Der Compiler bestimmt den richtigen Datentyp automatisch im Falle der Iostreams.</b></div><div class="text">Was bedeutet es, wenn der Compiler automatisch den Datentyp bestimmt? Angenommen, du hattest einen arbeitsreichen Tag oder du bist noch ein relativ unerfahrener C++-Entwickler, sodass du den falschen Format-String verwendest. Das bedeutet, dein Programm besitzt undefiniertes Verhalten:</div><div class="pre">// printfIostreamsUndefinedBehaviour.cpp<br><br>#include &lt;cstdio&gt;<br><br>#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printf("\n");<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printf("2011: %d\n",2011);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printf("3.1416: %d\n",3.1416);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printf("\"2011\": %d\n","2011");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // printf("%s\n",2011);&nbsp;&nbsp;&nbsp; // segmentation fault<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "2011: " &lt;&lt;&nbsp; 2011 &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3.146: " &lt;&lt; 3.1416 &lt;&lt; std::endl;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\"2011\": " &lt;&lt; "2011" &lt;&lt; std::endl;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">So schaut undefiniertes Verhalten auf meinem Rechner aus: <br></div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175880942_2d4b9f862f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Compiler schreibt für gewöhnlich im Falle eines falschen Formatstring eine Warnung. Dafür gibt es aber keine Garantie. Zusätzlich ist die Frage, welche Relevanz eine Warnung besitzt, wenn die Deadline bereits weit überschritten ist. In diesem Fall ignorierst du die Warnung und wirst sie dir wohl später anschauen. Anstelle mit Fehlern umzugehen, sollten sie aber erst gar nicht gemacht werden.</div><div class="text">Der Unterschied zwischen <i>printf</i> und Iostreams lässt mich unmittelbar an die <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.aristeia.com%2FPapers%2FIEEE_Software_JulAug_2004_revised.htm%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.aristeia.com%2FPapers%2FIEEE_Software_JulAug_2004_revised.htm%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22wichtigste%20Designregel%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" href="https://www.aristeia.com/Papers/IEEE_Software_JulAug_2004_revised.htm" title="Link auf https://www.aristeia.com/Papers/IEEE_Software_JulAug_2004_revised.htm">wichtigste Designregel</a> von Scott Meyers denken: "Make interfaces easy to use correctly and hard to use incorrectly."</div><div class="ztitel">Wie geht's weiter?<br></div><div class="text">Für die Iostreams habe ich Formatmanipulatoren verwendet. Um dein Leben als Softwareentwickler einfach zu gestalten, solltest du eine paar Formatmanipulatoren kennen. Im nächsten Artikel zeige ich dir, welche.<br></div><div class="simple-translate-result-wrapper"><br> <br></div>
