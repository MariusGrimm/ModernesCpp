<div class="vorspann">Mit sehr großer Wahrscheinlichkeit werden wir Concepts mit C++20 erhalten. Hier sind die Regeln der C++ Core Guidelines zu ihrer richtigen Anwendung.</div>
<div class="text">Zuerst gehe ich einen Schritt rückwärts. Was sind Concepts?<b> Concepts</b> sind Prädikate zur Compile-Zeit. Das heißt, dass sie zur Übersetzungszeit evaluiert werden und einen Wahrheitswert zurückgeben. </div>
<div class="text">Die nächste Frage steht schon an. Was sind die Vorteile von Concepts? </div>
<div class="text">Concepts</div>
<div class="text"><ul><li>erlauben Programmierern, direkt die Anforderungen an die Templates als Teil des Interfaces zu formulieren.</li><li>unterstützen das Überladen von Funktionen und die Spezialisierung von Klassen-Templates, basierend auf den Anforderungen an die Templates.</li><li>erzeugen deutlich verbesserte Fehlermeldungen, indem sie die Anforderungen an die Template-Parameter mit den aktuellen Template-Argumenten vergleichen.</li><li>können als Platzhalter für die generische Programmierung verwendet werden.</li><li>erlauben es, eigene Concepts zu definieren.</li></ul></div>
<div class="text">Nun geht es wieder einen Schritt vorwärts. Hier sind die vier Regeln für heute:</div>
<div class="text"><ul><li><a alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concepts%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concepts%22%2C%22text%22%3A%22T.10%3A%20Specify%20concepts%20for%20all%20template%20arguments%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts">T.10: Specify concepts for all template arguments</a> </li><li> <a alt="%7B%22version%22%3A1%2C%22text%22%3A%22T.11%3A%20Whenever%20possible%20use%20standard%20concepts%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts">T.11: Whenever possible use standard concepts</a> </li><li><a alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22T.12%3A%20Prefer%20concept%20names%20over%26nbsp%3Bauto%26nbsp%3Bfor%20local%20variables%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-auto%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-auto%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-auto" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-auto">T.12: Prefer concept names over&nbsp;auto&nbsp;for local variables</a></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-shorthand" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-shorthand" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.13%3A%20Prefer%20the%20shorthand%20notation%20for%20simple%2C%20single-type%20argument%20concepts%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-shorthand%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-shorthand%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" class="">T.13: Prefer the shorthand notation for simple, single-type argument concepts</a> </li></ul></div>
<div class="text">Los geht es mit der ersten Regel.</div>
<div class="ztitel"><a alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concepts%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concepts%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.10%3A%20Specify%20concepts%20for%20all%20template%20arguments%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts">T.10: Specify concepts for all template arguments</a> <br> </div>
<div class="text">Zu dieser Regel gibt es nicht so viel hinzuzufügen. Wegen Korrektheit und Lesbakeit, solltest du Concepts für alle Template-Parameter verwenden. Concepts kannst du in der wortreichen Variante anwenden.<br></div>
<div class="pre">template&lt;typename T&gt;<br>requires Integral&lt;T&gt;()<br>T gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br></div>
<div class="text">Oder du kannst Concepts deutlich kompakter anwenden.</div>
<div class="pre">template&lt;Integral T&gt;<br>T gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}</div>
<div class="text">Im ersten Beispiel wende ich das Concept an, indem ich es in dem <i>require</i>-Abschnitt einsetze. Im zweiten Beispiel kommt das Concept einfach anstelle des Schlüsselworts <i>typename</i> oder <i>class</i> zum Einsatz. Das Concept <i>Integral</i> muss ein konstanter Ausdruck sein, der einen Wahrheitswert zurückgibt</div>
<div class="text">Ich habe das Concept mit der Funktion <i>std::is_integral</i> aus der Type-Traits-Bibliothtek definiert.<br></div>
<div class="text"><span class="tx_code">template&lt;typename T&gt;<br>concept bool Integral(){<br>&nbsp; return std::is_integral&lt;T&gt;::value;<br>}</span></div>
<div class="text">Ein Concept selbst zu definieren, sollte die Ausnahme sein.<br> </div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" alt="%7B%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.11%3A%20Whenever%20possible%20use%20standard%20concepts%22%7D" class="">T.11: Whenever possible use standard concepts</a> <br></div>
<div class="text">Okay, wenn möglich, solltest du Concepts aus der Guidelines Support Library (GSL) oder dem Ranges TS verwenden. Mal schauen, welche Concepts es gibt. Ich ignoriere die Conepts aus der GSL, denn sie sind meist schon im RangesTS definiert. Hier sind die Concepts des Ranges TS <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf" class="" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fn4569.pdf%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22text%22%3A%22N4569%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fn4569.pdf%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D">N4569</a>: Working Draft, C++ Extension for Ranges.</div>
<div class="ztitel_kleiner">Concepte der Kernsprache</div>
<div class="text"><ul><li>Same</li><li>DerivedFrom</li><li>ConvertibleTo</li><li>Common</li><li>Integral</li><li>Signed Integral</li><li>Unsigned Integral</li><li>Assignable</li><li>Swappable</li></ul></div>
<div class="ztitel_kleiner">Concepte für Vergleiche</div>
<div class="text"><ul><li>Boolean</li><li>EqualityComparable</li><li>StrictTotallyOrdered</li></ul></div>
<div class="ztitel_kleiner">Concept für Objekte</div>
<div class="text"><ul><li>Destructible</li><li>Constructible</li><li>DefaultConstructible</li><li>MoveConstructible</li><li>Copy Constructible</li><li>Movable</li><li>Copyable</li><li>Semiregular</li><li>Regular</li></ul></div>
<div class="ztitel_kleiner">Concepte für aufrufbare Einheiten<br></div>
<div class="text"><ul><li>Callable</li><li>RegularCallable</li><li>Predicate</li><li>Relation</li><li>StrictWeakOrder</li></ul></div>
<div class="text">Wenn du wissen willst, für was ein Concept steht, dann gibt dir das bereits erwähnte Dokument <a alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fn4569.pdf%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22N4569%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fn4569.pdf%22%2C%22target%22%3A%22_blank%22%7D" class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">N4569</a> die Antwort. Die Definitionen der Concepts basieren auf der <a class="" alt="%7B%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22version%22%3A1%2C%22text%22%3A%22Type-Traits-Bibliothek%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" href="https://en.cppreference.com/w/cpp/header/type_traits">Type-Traits-Bibliothek</a>. Hier sind zum Beispiel die Definitionen der Concepts <i>Integral, Signed Integral</i> und <i>Unsigned Integral</i>.<br></div>
<div class="pre">template &lt;class T&gt;<br>concept bool Integral() {<br>&nbsp;&nbsp;&nbsp; return is_integral&lt;T&gt;::value;<br>}<br><br>template &lt;class T&gt;<br>concept bool SignedIntegral() {<br>&nbsp;&nbsp;&nbsp; return Integral&lt;T&gt;() &amp;&amp; is_signed&lt;T&gt;::value;<br>}<br><br>template &lt;class T&gt;<br>concept bool UnsignedIntegral() {<br>&nbsp;&nbsp;&nbsp; return Integral&lt;T&gt;() &amp;&amp; !SignedIntegral&lt;T&gt;();<br>}<br></div>
<div class="text">Die Funktionen <i>std::is_integral&lt;T&gt;</i> und <i>std::is_signed&lt;T&gt;</i> sind Prädikate aus der Type-Traits-Bibliothek. </div>
<div class="text">Zusätzlich werden Namen in dem Text des C++-Standard verwendet, die die Anforderungen der Standard Template Library ausdrücken. Dies sind Concepts, die nicht geprüft werden, sondern Concepts, die die Anforderungen zum Beispiel von Algorithmen wie <a title="Link auf https://en.cppreference.com/w/cpp/algorithm/sort" href="https://en.cppreference.com/w/cpp/algorithm/sort" class="" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fsort%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fsort%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22std%3A%3Asort%22%2C%22ir_link%22%3A1%7D">std::sort</a> ausdrücken. <br></div>
<div class="pre">template&lt; class RandomIt &gt;<br>void sort( RandomIt first, RandomIt last );</div>
<div class="text">Die erste Überladung von <i>std::sort</i> verlangt zwei <i>RandomAccessIterator</i>. Nun muss ich natürlich auflösen, was ein <i>RandomAccessIterator</i> ist.</div>
<div class="text"><ul><li>Ein <i>RandomAccessIterator</i>&nbsp;ist ein <i>BidirectionalIterator</i>, der auf jedes Element in konstanter Zeit verweisen kann.<br></li><li>Ein <i>BidirectionalIterator</i>&nbsp;ist ein <i>ForwardIterator</i>, der sich in beide Richtungen verwenden lässt. <br></li><li>Ein <i>ForwardIterator</i>&nbsp;ist ein <i>Iterator</i>, der Elemente lesen kann, auf die er verweist. <br></li><li>Ein <i>Iterator</i> beschreibt einen Datentyp, der dazu verwendet werden kann, Elemente eines Containers zu identifizieren und zu traversieren.</li></ul></div>
<div class="text">Die Details zu den benannten Anforderungen, die im Text des C++ Standards verwendet werden, lassen sich unter <a title="Link auf https://en.cppreference.com/w/cpp/named_req" href="https://en.cppreference.com/w/cpp/named_req" class="" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22cppreference.com%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fnamed_req%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">cppreference.com</a> schön nachlesen.<br></div>
<div class="ztitel"><a alt="%7B%22text%22%3A%22T.12%3A%20Prefer%20concept%20names%20over%26nbsp%3Bauto%26nbsp%3Bfor%20local%20variables%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-auto%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-auto%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-auto" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-auto">T.12: Prefer concept names over&nbsp;auto&nbsp;for local variables</a><br> </div>
<div class="text"><i>auto</i> ist ein uneingeschränktes Concept (Platzhalter), du solltest aber eingeschränkte Concepts verwenden. Du kannst eingeschränkte Concepts immer dann verwenden, wenn du uneingeschränkte Concepts (<i>auto</i>) eingesetzt hast. Wenn das keine einfache Regel ist?</div>
<div class="text">Das folgende Beispiel verdeutlicht die Regel.<br></div>
<div class="pre">// constrainedUnconstrainedConcepts.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br>#include &lt;vector&gt;<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>concept bool Integral(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; return std::is_integral&lt;T&gt;::value;<br>}<br><br>int getIntegral(int val){<br>&nbsp; return val * 5;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::vector&lt;int&gt; myVec{1, 2, 3, 4, 5};<br>&nbsp; for (Integral&amp; i: myVec) std::cout &lt;&lt; i &lt;&lt; " ";&nbsp;&nbsp; // (2)<br>&nbsp; std::cout &lt;&lt; std::endl;&nbsp; <br><br>&nbsp; Integral b= true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; std::cout &lt;&lt; b &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; Integral integ= getIntegral(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; std::cout &lt;&lt; integ &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; auto integ1= getIntegral(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; std::cout &lt;&lt; integ1 &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">In der Zeile (1) habe ich das Concept <i>Integral</i> definiert. Daher iteriere ich in der Range-basierten for-Schleife (Zeile 2) über Ganzzahlen und die Variablen <i>b</i> und <i>integ</i> in Zeile (3) und (4) sind ebenfalls Ganzzahlen. In der Zeile (5) bin ich nicht so streng. In dieser wende ich ein uneingeschränktes Concept an.</div>
<div class="text">Hier ist die Ausgabe des Programms. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159984340_8cd8d87eff.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-shorthand" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-shorthand" alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-shorthand%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-shorthand%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22T.13%3A%20Prefer%20the%20shorthand%20notation%20for%20simple%2C%20single-type%20argument%20concepts%22%7D" class="">T.13: Prefer the shorthand notation for simple, single-type argument concepts</a> </div>
<div class="text">Das Beispiel aus den C++ Core Guidelines schaut unschuldig aus, besitzt aber das Potenzial, die Art und Weise zu revolutionieren, wie wir Templates definieren. Hier ist es:</div>
<div class="pre">template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Correct but verbose: "The parameter is<br>//&nbsp;&nbsp;&nbsp; requires Sortable&lt;T&gt;&nbsp;&nbsp; // of type T which is the name of a type<br>void sort(T&amp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // that is Sortable"<br><br>template&lt;Sortable T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Better (assuming support for concepts): "The parameter is of type T<br>void sort(T&amp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // which is Sortable"<br><br>void sort(Sortable&amp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Best (assuming support for concepts): "The parameter is Sortable"<br></div>
<div class="text">Dies Beispiel zeigt drei Variationen, das Funktions-Template <i>sort</i> zu definieren. Alle Variationen besitzen die gleiche Semantik und setzen das Concept <i>Sortable</i> voraus. Die letzte Variation wirkt wie eine Funktionsdeklaration, ist aber eine Funktions-Template Deklaration, da der Parameter ein Concept ist und nicht ein konkreter Datentyp. Das schreibe ich gerne nochmals: Dank des Concepts als Parameter wird <i>sort</i> <span class="tx_code"></span>zum Funktions-Template.<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Die C++ Core Guidelines schreibt: "Defining good concepts is non-trivial. Concepts are meant to represent fundamental concepts in an application domain."&nbsp; Gerne will ich mir in meinem nächsten Artikel genauer anschauen, was das bedeutet.<br></div>
