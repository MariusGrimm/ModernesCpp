<div class="vorspann">Modernes C++ besitzt acht assoziative Container, aber die zwei Container std::map und std::unordered_map sind besonders. Warum? Genau diese Frage beantwortet dieser Artikel.</div><div class="text">In meinem letzten Artikel "<a title="Link auf Beitrag 2685470" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A2685470%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20std%3A%3Aarray%20und%20std%3A%3Avector%20sind%20die%20erste%20Wahl%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D564b680b8c22e3eba2fc4d68cc6a1116%26rm%3Dopen_article_id%26bid%3D2685470%22%7D" href="/exec/mainmenu.pl?sid=564b680b8c22e3eba2fc4d68cc6a1116&amp;rm=open_article_id&amp;bid=2685470">C++ Core Guidelines: std::array und std::vector sind die erste Wahl</a>" behaupte ich, dass in 99 Prozent aller Anwendungsfälle <i>std::array</i> oder <i>std::vector</i> die beste Wahl ist. Eine ähnliche Aussage lässt sich auch für assoziative Container aufstellen: In 95 Prozent aller Anwendungsfälle sind <i>std::map</i> oder <i>std::unordered_map</i> die best Wahl. Gelegentlich ist der Wert nicht notwendig, der dem Schlüssel assoziiert ist. Dies sind die verbleibenden 5 Prozent. Bevor ich nun den Artikel beginne und einen Überblick und Zahlen zu den beiden assoziativen Containern präsentiere, ist hier meine Daumenregel: <b>Wenn du einen Container mit einer Schlüssel/Wert-Assoziation benötigst und die Schlüssel sortiert sein sollen, verwende eine <i>std::map</i>; falls nicht, verwende eine <i>std::unordered_map</i>.</b> </div><div class="text">Mehr Details zu den assoziativen Container gibt es in meinen früheren Artikeln zu <a alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22assoziativen%20Containern%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fhashtabellen%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fhashtabellen%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/hashtabellen" href="https://www.grimm-jaud.de/index.php/blog/tag/hashtabellen">assoziativen Containern</a>. </div><div class="ztitel">Die acht Variationen</div><div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174845687_160a944d88.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Um Ordnung in dieser Tabelle aus acht assoziativen Containern zu schaffen, musst du drei Fragen beantworten. Jede Frage kann mit ja oder nein beantwortetet werden. <i>2 ^ 3 == 8</i>. Hier sind die drei Fragen.<br></div><div class="text"><ol><li>Ist der Container geordnet?</li><li>Besitzt der Schüssel einen assoziierten Wert?</li><li>Sind mehrere identische Schlüssel möglich?<br></li></ol></div><div class="text">Hier sind die Antworten:</div><div class="text"><ol><li> Wenn der Container nicht geordnet ist, wird er <i>unordered</i> genannt.</li><li>Wenn der Schlüssel keinen Wert assoziiert hat, wird er <i>map</i> genannt; sonst <i>se</i>t.</li><li>Wenn der Container mehr als einen identischen Schlüssel besitzt, wird er <i>multi</i> genannt. <br></li></ol></div><div class="text">Wenn ich von einem geordneten Container spreche, meine ich die Ordnung auf den Schlüsseln. </div><div class="text">Falls diese Begrifflichkeit zu kompliziert war, dann gebe ich dir ein anschaulicheres Bild.</div><div class="ztitel">Ein Telefonbuch<br></div><div class="text">Die acht Variationen assoziativer Container stehen für verschiedene Versionen eines Telefonbuchs. Was ist ein Telefonbuch? Ein Telefonbuch ist eine Sequenz von Schlüssel/Wert-Paaren. Du verwendest den Schlüssel (Familienname), um auf den Wert (Telefonnummer) zuzugreifen.</div><div class="text">Die Familiennamen können nun in einem Telefonbuch geordnet oder nicht geordnet sein. Das Telefonbuch kann jedem Familiennamen eine Telefonnummer zugeordnet haben oder auch nicht. Darüber hinaus kann ein Telefonbuch mehrere identische Familiennamen erlauben oder nicht. Dies ist sehr praktisch, denn dank mehrerer identischer Familiennamen ist es möglich, sowohl die Handy- als auch die Festnetznummer im Telefonbuch zu hinterlegen. </div><div class="text">Der Grund für diesen Artikel ist es nicht, die Unterschiede assoziativer Container zu erklären. Der Grund ist ein anderer: Die Zugriffszeit auf einen geordneten assoziativen Container ist logarithmisch, aber die Zugriffszeit auf einen ungeordneten assoziativen Container ist amortisiert konstant. <br></div><div class="ztitel">Performanz einer <i>std::map</i> und einer <i>std::unordered_map</i></div><div class="text">Was heißt amortisiert konstante Zugriffszeit für einen ungeordneten assoziativen Container wie <i>std::unordered_map</i>? Deine Abfrage einer Telefonnummer ist unabhängig von der Größe des Telefonbuchs. Du glaubst mir nicht? Hier ist ein kleiner Performanztest.</div><div class="text">Ich besitze ein Telefonbuch mit circa 89.000 Einträgen. In Laufe des Tests werde ich das Telefonbuch in 10er-Schritten bis auf 89.000.000 Einträge erweitern. Nach jedem Schritt frage ich nach allen Telefonnummern. Das heißt, dass ich die Familiennamen in einer beliebigen Reihenfolge verwende.</div><div class="text">Der folgende Auszug zeigt einen Teil der ersten Version des Telefonbuchs. Die Name/Nummer-Paare sind durch Doppelpunkte und der Name ist von der Nummer durch ein Komma getrennt.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174845693_0e464e568c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Das Programm sollte nicht so schwer zu lesen sein:</div><div class="pre">// telephoneBook.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;random&gt;<br>#include &lt;regex&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;unordered_map&gt;<br>#include &lt;vector&gt;<br><br>using map = std::unordered_map&lt;std::string, int&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>std::ifstream openFile(const std::string&amp; myFile){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp; std::ifstream file(myFile, std::ios::in);<br>&nbsp; if ( !file ){<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Can't open file "+ myFile + "!" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp; }<br>&nbsp; return file;<br>&nbsp; <br>}<br><br>std::string readFile(std::ifstream file){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::stringstream buffer;<br>&nbsp;&nbsp;&nbsp; buffer &lt;&lt; file.rdbuf();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return buffer.str();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>map createTeleBook(const std::string&amp; fileCont){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; map teleBook; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::regex regColon(":");<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::sregex_token_iterator fileContIt(fileCont.begin(), fileCont.end(), regColon, -1);<br>&nbsp;&nbsp;&nbsp; const std::sregex_token_iterator fileContEndIt;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string entry;<br>&nbsp;&nbsp;&nbsp; std::string key;<br>&nbsp;&nbsp;&nbsp; int value;<br>&nbsp;&nbsp;&nbsp; while (fileContIt != fileContEndIt){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entry = *fileContIt++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto comma = entry.find(",");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key = entry.substr(0, comma);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = std::stoi(entry.substr(comma + 1, entry.length() -1));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; teleBook[key] = value;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return teleBook;<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>std::vector&lt;std::string&gt; getRandomNames(const map&amp; teleBook){&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; allNames;<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; pair: teleBook) allNames.push_back(pair.first);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::random_device randDev;<br>&nbsp;&nbsp;&nbsp; std::mt19937 generator(randDev());<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::shuffle(allNames.begin(), allNames.end(), generator);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return allNames;<br>}<br>&nbsp;&nbsp;&nbsp; <br>void measurePerformance(const std::vector&lt;std::string&gt;&amp; names, map&amp; m){&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; for (const auto&amp; name: names) m[name];<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur= std::chrono::steady_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Access time: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br>&nbsp;&nbsp;&nbsp; <br>int main(int argc, char* argv[]){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // get the filename<br>&nbsp;&nbsp;&nbsp; std::string myFile;<br>&nbsp;&nbsp;&nbsp; if ( argc == 2 ){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile= {argv[1]};<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Filename missing !" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ifstream file = openFile(myFile);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string fileContent = readFile(std::move(file));<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; map teleBook = createTeleBook(fileContent);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "teleBook.size(): " &lt;&lt;&nbsp; teleBook.size() &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; randomNames = getRandomNames(teleBook);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; measurePerformance(randomNames, teleBook); <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div><div class="text">Meine Erläuterung beginnt mit dem <i>main</i>-Programm. Zuerst öffne ich die Datei, lese den Inhalt ein, erzeuge das Telefonbuch (<i>std::map</i> oder <i>std::unordered_map</i>), erhalte eine zufällige Permutation der Familiennamen und mache letztlich den Performanztest. Okay, das war zu kurz.</div><div class="text">Die Zeile 1 ist die interessanteste Zeile. Eine <i>std::unordered_map</i> unterstützt eine Obermenge des Interfaces einer <i>std::map</i>. Dadurch wird mein Performanztest sehr gemütlich. Zuerst verwendete ich eine Map (<i>using map = std::map&lt;std::string, int&gt;;</i>) und dann änderte ich die Zeile zu <i>using map = std::unordered_map&lt;std::string, int&gt;</i>;. Die entsprechenden Beziehungen gelten natürlich für die Paare (<i>std::set/std::unordered_set</i>), (<i>std::mutliset, std::unordered_multiset</i>) und (<i>std::multimap, std::unordered_multimap</i>). Ich denke, die folgenden Funktion sind ziemlich interessant. <br></div><div class="text"><ul><li><i>createTeleBook</i><ul><li>die <i>while-</i>Schleife iteriert über alle Name/Number-Tokens, erzeugt durch den regulären Ausdruck <i>regColon</i> (Zeile 2)</li><li>jedes Token wird durch ein Komma separiert (Zeile 3)</li><li>am Ende wird das Name/Number-Paar zu dem Telefonbuch hinzugefügt (Zeile 4)</li></ul></li><li><i>getRandomNames</i><ul><li>schiebt alle Namen auf den Vektor (Zeile 5)</li><li>erzeugt eine Permutation der Namen (Zeile 6)</li></ul></li><li><i>measurePerformance</i><ul><li>fragt nach dem Namen im Telefonbuch (Zeile 7)</li></ul></li></ul></div><div class="text">Jetzt kommen endlich die Performanzzahlen für die <i>std::map</i> und die <i>std::unordered_map</i>.</div><div class="ztitel_kleiner">std::map</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174845698_f6041e2fab.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel_kleiner">std::unordered_map</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174845704_d466cc3ead.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die Screenshots stellen exakt dar, wie groß die Telefonbücher sind. Die Zahlen bestätigen die Zahlen, die ich in der ersten Tabelle bereits präsentierte: Die Zugriffszeit auf ein <i>std::map</i> hängt logarithmisch von der Anzahl seiner Elemente ab und die Zugriffszeit auf eine <i>std::unordered_map</i> ist amortisiert konstant. Der folgende Plot stellt die Performanzzahlen der <i>std::map</i> der der <i>std::unordered_map</i> gegenüber. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174845713_1cf4a6c600.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Für 100.000 Einträge ist die <i>std::map </i>dreimal langsamer als die <i>std::unordered_map</i> und für 100.000.000 Einträge ist sie 7,5-mal langsamer.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Nach diesem kleinen Ausflug von den C++ Core Guidlines geht es in meinem nächsten Artikel um Verletzungen der Containergrenzen und wie sich diese vermeiden lassen. <br></div><div class="ztitel">C++-Schulungen im Großraum Stuttgart</div><div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div><div class="text"><ul><li> <a href="https://www.modernescpp.de/index.php/c/2-c/20-c-11-und-c-1420190311073407" title="Link auf https://www.modernescpp.de/index.php/c/2-c/20-c-11-und-c-1420190311073407" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F20-c-11-und-c-1420190311073407%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F20-c-11-und-c-1420190311073407%22%7D">C++11 und C++14</a>: 25. bis 27 Juni 2019 </li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/21-generische-programmierung-templates-mit-c20190311073743" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F21-generische-programmierung-templates-mit-c20190311073743%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F21-generische-programmierung-templates-mit-c20190311073743%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Generische%20Programmierung%20%28Templates%29%20mit%20C%2B%2B%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="https://www.modernescpp.de/index.php/c/2-c/21-generische-programmierung-templates-mit-c20190311073743">Generische Programmierung (Templates) mit C++</a>: 13. bis 15. August 2019<br></li><li><a href="https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" title="Link auf https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%7D">Embedded-Programmierung mit modernem C++</a>: 5. bis 7. November 2019<br></li></ul></div><div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%7D" title="Link auf https://www.modernescpp.de/" href="https://www.modernescpp.de/">www.ModernesCpp.de</a>. </div><div class="simple-translate-result-wrapper"><br> <br></div>