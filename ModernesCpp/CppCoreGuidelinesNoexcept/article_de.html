<div class="vorspann">Wer die verbleibenden Regeln zur Fehlerbehandlung überfliegt, liest oft das Wort noexcept. Bevor sich dieser Artikel daher mit den Regeln zur Fehlerbehandlung genauer beschäftigt, wird sich zuerst der noexcept-Spezifizierer und der noexcept-Operator angeschaut. <br></div>
<div class="text"><i>noexcept</i> gibt es in zwei Variationen in C++11: als Spezifizierer und als Operator. Die C++ Core Guidelines verwenden den Spezifizierer.</div>
<div class="ztitel"><i>noexcept</i> als Spezifizierer</div>
<div class="text">Indem du eine Funktion, eine Methode oder ein Funktions-Template als <i>noexcept</i> deklarierst, drückst du aus, dass diese keine Ausnahme werfen, und falls sie es tun, du dich darum nicht kümmerst und das Programm abstürzen lässt. Es gibt viele Arten, deine Absicht auf den Punkt zu bringen:</div>
<div class="pre">void func1() noexcept;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // does not throw<br>void func2() noexcept(true);&nbsp; // does not throw<br>void func3() throw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // does not throw<br><br>void func4() noexcept(false); // may throw</div>
<div class="text">Die <i>noexcept</i>-Spezifikation ist äquivalent zu der <i>noexcept(true)-</i>Spezifikation. <i>throw()</i> ist äquivalent zu <i>noexcept(true)</i>, wurde aber mit C++11 auf deprecated gesetzt und wird mit C++20 aus dem C++-Standard entfernt werden. <i>noexcept(false</i>) sagt aus, dass die Funktion eine Ausnahme werfen kann. Die <i>noexcept</i>-Spezifikation ist Bestandteil des Funktionstyps, kann aber nicht zum Überladen verwendet werden.</div>
<div class="text">Es gibt zwei gute Gründe, <i>noexcept</i> zu verwenden. Zuerst einmal dokumentiert <i>noexcept</i> das Verhalten der Funktion. Wenn eine Funktion als <i>noexcept</i> deklariert ist, kann sie sicher in Funktionen verwendet werden, die keine Ausnahme werfen. Darüber hinaus ist <i>noexcept</i> eine Optimierungsmöglichkeit für den Compiler. <i>noexcept</i> muss nicht <a class="" title="Link auf https://en.cppreference.com/w/cpp/error/unexpected" href="https://en.cppreference.com/w/cpp/error/unexpected" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Funexpected%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Funexpected%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aunexpected%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">std::unexpected</a> aufrufen und stack unwinding durchführen. Ein Container kann bei seiner Initialisierung seine Elemente billig in den Container verschieben, falls der Move-Konstruktor als <i>noexcept</i> erklärt ist. Falls nicht, werden die Elemente gegebenenfalls teuer in den Container kopiert. <br></div>
<div class="text">Jede Funktion in C++ kann entweder keine Ausnahme (<i>non-throwing</i>) oder eventuell eine Ausnahme (<i>potentially throwing</i>) werfen. Eventuell bedeutet.</div>
<div class="text"><ol><li> Die Funktion verwendet eine Funktion, die eine Ausnahme werfen kann.</li><li>Die Funktion ist ohne eine noexcept-Spezifikation deklariert.</li><li>Die Funktion verwendet einen <i>dynamic_cast</i> auf eine Referenz.<br></li></ol></div>
<div class="text">Es gibt eine Ausnahme zum Punkt 2. Die Ausnahme umfasst die folgenden speziellen Methoden einer Klasse. Sind sind implizit non-throwing:</div>
<div class="text"><ul><li> Default-Konstruktor und Destruktor</li><li>Move- und Copy-Konstruktor</li><li>Move- und Copy-Zuweisungsoperator<br></li></ul></div>
<div class="text">Diese speziellen sechs Methoden wie der Destruktor können nur non-throwing sein, wenn alle Destruktor der Attribute und der Basisklassen non-throwing sind. Die entsprechenden Aussagen gelten natürlich auch für die verbleibenden fünf Methoden. </div>
<div class="text">Was passiert nun, wenn eine Funktion eine Ausnahme wirft, die als non-throwing deklariert ist? In diesem Fall wird std::terminate aufgerufen. <a class="" title="Link auf https://en.cppreference.com/w/cpp/error/terminate" href="https://en.cppreference.com/w/cpp/error/terminate" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22std%3A%3Aterminate%20%22%7D">std::terminate </a>ruft den aktuellen <a class="" title="Link auf https://en.cppreference.com/w/cpp/error/terminate_handler" href="https://en.cppreference.com/w/cpp/error/terminate_handler" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22std%3A%3Atermination_handler%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate_handler%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate_handler%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D">std::termination_handler</a> auf, der wiederum <a class="" href="https://en.cppreference.com/w/cpp/utility/program/abort" alt="%7B%22text%22%3A%22std%3A%3Aabort%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a> per Default aufruft. Das Ergebnis ist eine abnormale Programmbeendigung. <br></div>
<div class="text">Der Vollständigkeit halber möchte ich noch genauer den noexcept-Operator vorstellen. </div>
<div class="ztitel"><i>noexcept</i> als Operator</div>
<div class="text">Der <i>noexcept</i>-Operator prüft zur Compilezeit, ob ein Ausdruck keine Ausnahme wirft, wertet diesen Ausdruck aber nicht aus. Er kann in einer <i>noexcept</i>-Spezifikation eines Funktions-Templates verwendet werden und ausdrücken, dass das Funktions-Template abhängig vom konkreten Datentyp eine Ausnahme werfen kann. </div>
<div class="text">Um meine Beschreibung verständlicher zu machen, zeige ich ein einfaches Funktions-Template, dass seinen Rückgabewert kopiert:</div>
<div class="pre">// noexceptOperator.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;array&gt;<br>#include &lt;vector&gt;<br><br>class NoexceptCopy{<br>public:<br>&nbsp; std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>};<br><br>class NonNoexceptCopy{<br>public:<br>&nbsp; std::vector&lt;int&gt; v{1, 2, 3, 4 , 5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>};<br><br>template &lt;typename T&gt; <br>T copy(T const&amp; src) noexcept(noexcept(T(src))){&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; return src; <br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; NoexceptCopy noexceptCopy;<br>&nbsp;&nbsp;&nbsp; NonNoexceptCopy nonNoexceptCopy;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "noexcept(copy(noexceptCopy)): " &lt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noexcept(copy(noexceptCopy)) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "noexcept(copy(nonNoexceptCopy)): " &lt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noexcept(copy(nonNoexceptCopy)) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Klar, die interessanteste Zeile des Beispielprogramms ist die Zeile (1). Insbesondere der Ausdruck <i>noexcept(noexcept(T(src))</i>. Das innere <i>noexcept</i> ist der <i>noexcept</i>-Operator und das äußere der <i>noexcept</i>-Spezifizierer. Der Ausdruck <i>noexcept(T(src))</i> prüft in diesem Fall, ob der Copy-Konstruktor keine Ausnahme wirft. Dies gilt für die Klasse <i>Noexcept</i> (2), aber nicht für die Klasse <i>NonNoexcept</i> (3), denn der Copy-Konstruktor des <i>std::vector </i>kann eine Ausnahme werfen. Entsprechend gibt der Ausdruck (4) <i>true</i> und der Ausdruck (5) <i>false</i> zurück.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_156589631_eb6b5f7c00.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Vermutlich weißt du es bereits. Mithilfe der Type-Traits-Bibliothek lässt sich zur Compilezeit prüfen, ob ein Datentyp T einen Konstruktor besitzt, der keine Ausnahme werfen kann: <i>std::is_nothrow_copy_constructible::value.</i> Daher kann auch statt des <i>noexcept</i>-Operators das Prädikat aus der Type-Traits-Bibliothek verwendet werden:</div>
<div class="pre">template &lt;typename T&gt; <br>T copy(T const&amp; src) noexcept(std::is_nothrow_copy_constructible&lt;T&gt;::value){<br>&nbsp; return src; <br>}<br></div>
<div class="text">Ich weiß nicht, welche Version von <i>copy</i> du vorziehst? Ich ziehe die Version vor, bei der die Type-Traits-Bibliothek zum Einsatz kommen, denn diese bringt die Absicht des Codes besser auf den Punkt.</div>
<div class="ztitel"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-noexcept" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-noexcept%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-noexcept%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22E.12%3A%20Use%20noexcept%20when%20exiting%20a%20function%20because%20of%20a%20throw%20is%20impossible%20or%20unacceptable%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-noexcept">E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable</a></div>
<div class="text">Der Titel der Regel hat mich ein wenig verwirrt. Er besagt, dass du eine Funktion als noexcept deklarieren sollst, wenn</div>
<div class="text"><ul><li> diese keine Ausnahme wirft oder</li><li>du die Ausnahme nicht verarbeiten kannst. Du bist daher bereit, das Programm abstürzen zu lassen, denn eine <i>std::bad_alloc-</i>Ausnahme aufgrund von Speichermangel lässt sich nicht lösen. <br></li></ul></div>
<div class="text">Es ist keine gute Idee, eine Ausnahme zu werfen, wenn du der direkte Besitzer eines Objekts bist.</div>
<div class="ztitel"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-throw" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-throw" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22E.13%3A%20Never%20throw%20while%20being%20the%20direct%20owner%20of%20an%20object%26nbsp%3B%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-never-throw%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Re-never-throw%22%2C%22type%22%3A%22E%22%7D">E.13: Never throw while being the direct owner of an object&nbsp;</a></div>
<div class="text">Hier ist das Beispiel zu den direkten Besitzverhältnissen der C++ Core Guidelines:</div>
<div class="pre">void leak(int x)&nbsp;&nbsp; // don't: may leak<br>{<br>&nbsp;&nbsp;&nbsp; auto p = new int{7};<br>&nbsp;&nbsp;&nbsp; if (x &lt; 0) throw Get_me_out_of_here{};&nbsp; // may leak *p<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; delete p;&nbsp;&nbsp; // we may never get here<br>}<br></div>
<div class="text">Wenn der <i>throw</i>-Ausdruck zum Einsatz kommt, geht der Speicher verloren und du hast ein Speicherleck. Die einfache Lösung ist es, dass du dein direktes Besitzverhältnis abgibst und stattdessen die C++-Laufzeit zum Besitzer des Objekts machst. Erzeuge dazu eine lokale Variable oder zumindest einen Wächter als lokale Variable. Jetzt kannst du dir sicher sein, dass die C++-Laufzeit auf ihre Objekte aufpasst. Hier sind die drei sicheren Variationen des Programms:</div>
<div class="pre">void leak(int x)&nbsp;&nbsp; // don't: may leak<br>{<br>&nbsp;&nbsp;&nbsp; auto p1 = int{7};<br>&nbsp;&nbsp;&nbsp; auto p2 = std::make_unique&lt;int&gt;(7);<br>&nbsp;&nbsp;&nbsp; auto p3 = std::vector&lt;int&gt;(7);<br>&nbsp;&nbsp;&nbsp; if (x &lt; 0) throw Get_me_out_of_here{}; <br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="text"><i>p1 i</i>st eine lokale Variable. Hingegen sind<i> p2</i> und <i>p3 </i>eine Art Wächter für das Objekt. Der <i>std::vector</i> verwendet unter der Decke den Heap. Zusätzlich wirst du das händische Löschen der Variable <i>p</i> los.</div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Das ist einfach. Im nächsten Artikel folgt die Fortsetzung zu meiner Geschichte zu Ausnahmen und Fehlerbehandlungen in C++. </div>
<div class="ztitel">C++-Schulungen im Großraum Stuttgart</div>
<div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen. </div>
<div class="text"><ul><li>&nbsp;<a class="" href="https://www.modernescpp.de/index.php/c/2-c/4-c-11-und-c-1420160101184722" alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F4-c-11-und-c-1420160101184722%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F4-c-11-und-c-1420160101184722%22%2C%22version%22%3A1%7D" title="Link auf https://www.modernescpp.de/index.php/c/2-c/4-c-11-und-c-1420160101184722">C++11 und C++14</a>: 11.09 [--] 13.09 (Termingarantie)</li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/14-multithreading-mit-c20160404172352" alt="%7B%22text%22%3A%22Multithreading%20mit%20modernem%20C%2B%2B%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F14-multithreading-mit-c20160404172352%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F14-multithreading-mit-c20160404172352%22%2C%22user_params%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/14-multithreading-mit-c20160404172352" class="">Multithreading mit modernem C++</a>: 13.11 [--] 14. 11 <br></li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/17-embedded-programmierung-mit-modernem-c20170911213829" href="https://www.modernescpp.de/index.php/c/2-c/17-embedded-programmierung-mit-modernem-c20170911213829" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F17-embedded-programmierung-mit-modernem-c20170911213829%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F17-embedded-programmierung-mit-modernem-c20170911213829%22%2C%22type%22%3A%22E%22%7D" class="">Embedded-Programmierung mit modernem C++</a>: 15.01 [--] 17.01</li></ul></div>
<div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a class="" title="Link auf https://www.modernescpp.de/index.php" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22www.ModernesCpp.de.%22%7D" href="https://www.modernescpp.de/index.php">www.ModernesCpp.de.</a> <br></div>
