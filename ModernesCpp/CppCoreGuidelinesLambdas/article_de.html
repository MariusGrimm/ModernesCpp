<div class="text">Modernes C++ ohne Lambda Ausdrücke? Kaum vorstellbar!&nbsp; Daher ist es um so verwunderlicher, dass sich die Regeln zu Lambda Ausdrücken an zwei Händen abzählen lassen. In diesem Artikel geht es um vier strategische Regeln zu ihrem richtigen Einsatz, die weitreichende Konsequenzen besitzen.</div>
<div class="text">Hier sind die vier Regeln zu Lambda Ausdrücken (kurz Lambdas) kurz und kompakt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_142305840_1affcd702a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-capture-vs-overload" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-capture-vs-overload" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-capture-vs-overload%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22F.50%3A%20Use%20a%20lambda%20when%20a%20function%20won%C2%92t%20do%20%28to%20capture%20local%20variables%2C%20or%20to%20write%20a%20local%20function%29%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-capture-vs-overload%22%7D">F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)</a> <br></li><li> <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-reference-capture%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22F.52%3A%20Prefer%20capturing%20by%20reference%20in%20lambdas%20that%20will%20be%20used%20locally%2C%20including%20passed%20to%20algorithms%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-reference-capture%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-reference-capture" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-reference-capture" class="">F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</a> <br></li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-value-capture%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-value-capture%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22F.53%3A%20Avoid%20capturing%20by%20reference%20in%20lambdas%20that%20will%20be%20used%20nonlocally%2C%20including%20returned%2C%20stored%20on%20the%20heap%2C%20or%20passed%20to%20another%20thread%22%2C%22custom%22%3A%7B%7D%7D">F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</a> <br></li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lambda-init" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-lambda-init%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-lambda-init%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.28%3A%20Use%20lambdas%20for%20complex%20initialization%2C%20especially%20of%20const%20variables%22%2C%22custom%22%3A%7B%7D%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lambda-init">ES.28: Use lambdas for complex initialization, especially of const variables</a></li></ul></div>
<div class="text">In dem Vorspann sage ich, dass ich über Lamdas schreiben will. Daher ist es vermutlich überraschend, dass der Titel Funktionsobjekte und Lambas lautet. Falls du weißt, dass Lambdas lediglich Funktionsobjekte sind, die der Compiler auf Bedarf automatisch erzeugt, dann hält sich deine Überraschung in Grenzen. Falls nicht, stelle ich im nächsten Abschnitt kurz und bündig die wichtigsten Fakten vor. Ein Blick unter die Decke hilft sehr, Lambda Ausdrücke besser zu verstehen. <br></div>
<div class="text">Hier sind die wichtigsten Fakten.</div>
<div class="ztitel">Lambda Ausdrücke: Ein Blick unter die Decke</div>
<div class="text">Zuerst einmal, ist ein Funktionsobjekt eine Instanz einer Klasse, für die der Aufrufoperator (<i>operator() </i>) überladen ist. Das bedeutet, dass ein Funktionsobjekt ein Objekt ist, das sich wie eine Funktion verhält. Der Hauptunterschied zwischen einer Funktion und einem Funktionsobjekt ist: Ein Funktionsobjekt kann Zustand besitzen. </div>
<div class="text">Hier ist ein einfaches Beispiel für ein Funktionsobjekt </div>
<div class="pre">int addFunc(int a, int b){ return a + b; }<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; struct AddObj{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int operator()(int a, int b) const { return a + b; }<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; AddObj addObj;<br>&nbsp;&nbsp;&nbsp; addObj(3, 4) == addFunc(3, 4);<br><br>}<br></div>
<div class="text">Instanzen der Struktur <i>AddObj</i> und die Funktion <i>addFunc</i> sind beide aufrufbare Einheiten (engl. callable). Ich habe die Struktur <i>AddObj</i> genau an der Stelle definiert, an der ich sie benötige. Genau diesen Schritt wendet der C++ Compiler automatisch an, wenn ich einen Lambda Ausdruck verwende.</div>
<div class="text">Hier ist der äquivalente Lambda Ausdruck.<br></div>
<div class="pre">int addFunc(int a, int b){ return a + b; }<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto addObj = [](int a, int b){ return a + b; };<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; addObj(3, 4) == addFunc(3, 4);<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text"><b>Das ist alles!</b> Falls die Lambda ihre Umgebung bindet und damit Zustand besitzt, erhält die entsprechende Struktur AddObj einen Konstruktor für das Initialisieren ihrer Attribute. Falls sie ihre Argumente per Referenz bindet, dann tut dies auch der Konstruktor. </div>
<div class="text">C++14 kennt Generic Lambdas. Daher bedeutet, du kannst einen Lambda Ausdruck der Form <i>[](auto a, auto b){ return a + b; };</i> definieren. Was bedeutet dies für den Aufrufoperator von<i> AddObj</i>? Ich denke, du ahnst es bereits. Der Aufrufoperator wird zum Template. Das will ich gerne nochmals explizit betonen: <b>Eine Generic Lambda ist ein Template.</b><br></div>
<div class="text">Ich hoffe, dieser Abschnitt war nicht zu kompakt. Jetzt geht es weiter mit den Regeln zu Lambda Ausdrücken.<br></div>
<div class="ztitel_kleiner"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-capture-vs-overload%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22F.50%3A%20Use%20a%20lambda%20when%20a%20function%20won%C2%92t%20do%20%28to%20capture%20local%20variables%2C%20or%20to%20write%20a%20local%20function%29%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-capture-vs-overload%22%2C%22type%22%3A%22E%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-capture-vs-overload" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-capture-vs-overload" class="">F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)</a></div>
<div class="text">Der Unterschied im Einsatzgebiet von Funktionen zu Lambdas reduziert sich im Wesentlichen auf zwei Punkte. </div>
<div class="text"><ol><li>Du kannst Lambdas nicht überladen.</li><li>Eine Lambda kann lokale Variablen binden.<br></li></ol></div>
<div class="text">Hier ist ein konstruiertes Beispiel zum zweiten Punkt.</div>
<div class="pre">#include &lt;functional&gt;<br><br>std::function&lt;int(int)&gt; makeLambda(int a){&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; return [a](int b){ return a + b; };<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto add5 = makeLambda(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto add10 = makeLambda(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; add5(10) == add10(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Die Funktion <i>makeLambda</i> gibt einen Lambda Ausdruck zurück. Dieser Lambda Ausdruck nimmt ein <i>int</i> an und gibt ein<i> int </i>zurück. Dies ist der Typ des polymorphen Funktionswrappers std::function: std::function&lt;int(int)&gt;. (1). Der Aufruf <i>makeLambda(5)</i> (2) erzeugt einen Lambda Ausdruck, der <i>a</i> kopiert.<i> a</i> besitzt in diesem Fall den Wert 5. Dieselbe Argumentation gilt natürlich auch für den Ausdruck <i>makeLambda(10)</i> (3). Daher ergeben die Aufrufe<i> add5(10)</i> und <i>add10(5)</i> beide 15 (4). </div>
<div class="text">Die nächsten zwei Regeln beschäftigen sich explizit damit, wenn ein Lambda Ausdruck seine Argumente per Referenz bindet. Beide Regeln sind sehr ähnlich, daher kann ich sie zusammen beschreiben. </div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-reference-capture" class="" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22F.52%3A%20Prefer%20capturing%20by%20reference%20in%20lambdas%20that%20will%20be%20used%20locally%2C%20including%20passed%20to%20algorithms%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-reference-capture%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-reference-capture%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-reference-capture">F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</a>,<a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22%20F.53%3A%20Avoid%20capturing%20by%20reference%20in%20lambdas%20that%20will%20be%20used%20nonlocally%2C%20including%20returned%2C%20stored%20on%20the%20heap%2C%20or%20passed%20to%20another%20thread%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-value-capture%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-value-capture%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D"> F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</a> <br></div>
<div class="text">Aus Effizienz- und Korrektheits-Gründen sollte dein Lambda Ausdruck seine Argumente per Referenz binden, falls der Lambda Ausdruck nur lokal verwendet wird. Entsprechend gilt natürlich. Wenn du dein Lambda Ausdruck nicht lokal verwendest, solltest du deine Argumente nicht per Referenz binden, sondern kopieren. Falls du die letzte Aussage brichst, erhältst du undefiniertes Verhalten.&nbsp; </div>
<div class="text">Hier ist ein Beispiel zu undefinierten Verhalten mit Lambda Ausdrücken.<br></div>
<div class="pre">// lambdaCaptureReference.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br><br>std::function&lt;int(int)&gt; makeLambda(int a){<br>&nbsp;&nbsp;&nbsp; int local = 2 * a;<br>&nbsp;&nbsp;&nbsp; auto lam = [&amp;local](int b){ return local + b; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "lam(5): "&lt;&lt;&nbsp; lam(5) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp;&nbsp;&nbsp; return lam;<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; int local = 10;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; auto addLocal = [&amp;local](int b){ return local + b; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; auto add10 = makeLambda(5);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; std::cout &lt;&lt; "addLocal(5): " &lt;&lt; addLocal(5) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; // 4<br>&nbsp; std::cout &lt;&lt; "add10(5): " &lt;&lt; add10(5) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Die Definiton der Lambda <i>addLocal</i> (3) und ihre Anwendung (4) ist wohldefiniert. Das gleiche gilt für die Definition des Lambda Ausdrucks<i> lam</i> (1) und seine Anwendung (2) innerhalb der Funktion. Das undefinierte Verhalten tritt dann auf, wenn die Funktion <i>makeLambda</i> den Lambda Ausdruck zurückgibt, der eine Referenz auf die lokale Variable<i> local </i>besitzt. </div>
<div class="text">Hast du eine Vermutung, welchen Wert der Aufruf <i>add10(5) </i>in Ausdruck (5) besitzen wird? Hier ist die Ausgabe des Programms.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_142305844_322998e9c7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Jede Ausführung des Programms ergibt ein anderes Ergebnis für den Ausdruck (5). <br></div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lambda-init" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lambda-init" alt="%7B%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-lambda-init%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-lambda-init%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22ES.28%3A%20Use%20lambdas%20for%20complex%20initialization%2C%20especially%20of%20const%20variables%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">ES.28: Use lambdas for complex initialization, especially of const variables</a></div>
<div class="text">Um ehrlich zu sein, ich mag dies Regel. Sie macht deinn Code einfacher robuster. Warum bezeichnen die Guidelines das folgende Programm schlecht? <br></div>
<div class="pre">widget x;&nbsp;&nbsp; // should be const, but:<br>for (auto i = 2; i &lt;= N; ++i) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this could be some<br>&nbsp;&nbsp;&nbsp; x += some_obj.do_something_with(i);&nbsp; // arbitrarily long code<br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed to initialize x<br>// from here, x should be const, but we can't say so in code in this style</div>
<div class="text">Die Idee des Programms ist es, das <i>widget x </i>zu initialisieren. Sobald die Initialisierung fertig ist, soll die Variable konstant bleiben. Das ist eine Idee, die sich nicht direkt in C++ umsetzen lässt. Daher müsstest du zum Beispiel den Zugriff auf das <i>widget x</i> in einem Multithreading Programm aufwändig synchronisieren.<br></div>
<div class="text">Dies Synchronisation wäre nicht notwendig, wenn das<i> widget x</i> konstant ist. Hier kommt der gute Pendant zu dem Codeschnipsel mithilfe eines Lambda Ausdrucks.</div>
<div class="pre">const widget x = [&amp;]{<br>&nbsp;&nbsp;&nbsp; widget val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // assume that widget has a default constructor<br>&nbsp;&nbsp;&nbsp; for (auto i = 2; i &lt;= N; ++i) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this could be some<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val += some_obj.do_something_with(i);&nbsp; // arbitrarily long code<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed to initialize x<br>&nbsp;&nbsp;&nbsp; return val;<br>}();</div>
<div class="text">Dank des an Ort und Stelle ausführten Lambda Ausdrucks kann <i>widget x</i> als Konstante definiert werden. Da du diesen Wert nicht mehr ändern kannst, kannst du die Variable von nun an gänzlich ohne Sychronisation in Multithreading Programmen verwenden.&nbsp;&nbsp; </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Eines der Wesensmerkmale der objekt-orientierten Programmierung ist Vererbung. Die C++ Core Guidelines bietet gut 25 Regeln für Klassenhierarchien an. In dem nächsten Artikel gehe ich auf die Konzepte Interfaces und Implementierung in Klassenhierarchien ein. </div>
<div class="ztitel">Weitere Informationen</div>
<div class="text"><ul><li>Lambda Funktionen, ein erste Vorstellung: <a class="" title="Link auf http://www.linux-magazin.de/Ausgaben/2011/12/C-11" href="http://www.linux-magazin.de/Ausgaben/2011/12/C-11" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2011%2F12%2FC-11%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Die%20Elf%20spielt%20auf%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2011%2F12%2FC-11%22%2C%22alias%22%3A%22%22%7D">Die Elf spielt auf</a> (freier Artikel für das Linux-Magazin)<br></li><li>Lambda Funktionen, mehr Details:<a class="" title="Link auf http://www.linux-magazin.de/Ausgaben/2012/02/C-11" href="http://www.linux-magazin.de/Ausgaben/2012/02/C-11" alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2012%2F02%2FC-11%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2012%2F02%2FC-11%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%20Kurz%20und%20knackig%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D"> Kurz und knackig</a> (freier Artikel für das Linux-Magazin)</li><li>Den Source-Code zu den Beispiel gibt es hier: <a class="" title="Link auf https://github.com/RainerGrimm/ModernesCppSource" href="https://github.com/RainerGrimm/ModernesCppSource" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FRainerGrimm%2FModernesCppSource%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FRainerGrimm%2FModernesCppSource%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22GitHub%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D">GitHub</a> <br></li></ul></div>