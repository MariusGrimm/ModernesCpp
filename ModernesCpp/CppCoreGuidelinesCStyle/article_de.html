<div class="vorspann">Dank der gemeinsamen Geschichte von C und C++ sind beide Programmiersprachen sehr ähnlich. Da aber keine der Sprachen eine Teilmenge der anderen ist, gilt es, ein paar Regeln zu beachten, wenn sie gleichzeitig verwendet werden sollen.</div><div class="text">Dieses Kapitel in den C++ Core Guidelines heißt: C-style Programming. Ehrlich gesagt, war mein erster Gedanke, nachdem ich es überflogen hatte, es zu ignorieren. Ein paar Gedanken später entschied ich mich aber, darüber zu schreiben. Zwei Gründe dafür möchte ich nennen:</div><div class="text"><ol><li> Das ist eine typisches Herausforderungen, wenn wir Legacy-Software pflegen.</li><li>Ein Leser fragt mich explizit, ob ich den nicht mehr über Legacy-Software schreiben könne.</li></ol></div><div class="text">Hier sind die Regeln für heute:</div><div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-C" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-C" alt="%7B%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CPL.1%3A%20Prefer%20C%2B%2B%20to%20C%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-C%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-C%22%7D">CPL.1: Prefer C++ to C</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-subset" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-subset%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-subset%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22CPL.2%3A%20If%20you%20must%20use%20C%2C%20use%20the%20common%20subset%20of%20C%20and%20C%2B%2B%2C%20and%20compile%20the%20C%20code%20as%20C%2B%2B%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-subset">CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-interface" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-interface%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-interface%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22CPL.3%3A%20If%20you%20must%20use%20C%20for%20interfaces%2C%20use%20C%2B%2B%20in%20the%20calling%20code%20using%20such%20interfaces%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-interface">CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces</a></li></ul></div><div class="text">Die erste Regel ist ein Selbstläufer, denn es geht in den Guidelines um C++.<br></div><div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-C" alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CPL.1%3A%20Prefer%20C%2B%2B%20to%20C%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-C%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-C%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-C">CPL.1: Prefer C++ to C</a>&nbsp;</div><div class="text">Ohne Worte meinerseits die Begründung zu der Regel aus den C++ Core Guidelines: "C++ provides better type checking and more notational support. It provides better support for high-level programming and often generates faster code." </div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-subset" alt="%7B%22text%22%3A%22CPL.2%3A%20If%20you%20must%20use%20C%2C%20use%20the%20common%20subset%20of%20C%20and%20C%2B%2B%2C%20and%20compile%20the%20C%20code%20as%20C%2B%2B%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-subset%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-subset%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-subset">CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++</a>&nbsp;</div><div class="text">Die erste Frage, die es zu beantworten gilt, wenn C und C++ gleichzeitig eingesetzt werden sollen, ist: Kannst du den ganzen Code mit einem C++ Compiler übersetzen? Beginnen möchte ich mit der positiven Antwort.<br></div><div class="ztitel_kleiner">Der ganze Sourccode steht zur Verfügung</div><div class="text">Das ist gut, denn du bist fast fertig. Fast, denn C ist keine Teilmenge von C++. Hier ist ein kleines, schlechtes C Programm, dass sich mit einem C++ Compiler nicht übersetzen lässt. <br></div><div class="pre">// cStyle.c<br><br>#include &lt;stdio.h&gt;<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; double sq2 = sqrt(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printf("\nsizeof(\'a\'): %d\n\n", sizeof('a')); // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c;<br>&nbsp;&nbsp;&nbsp; void* pv = &amp;c;<br>&nbsp;&nbsp;&nbsp; int* pi = pv;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int class = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>}</div><div class="text">Zuerst möchte ich das Programm mit dem C90 Standard übersetzen und ausführen. </div><div class="text">Von ein paar Warnungen abgesehen, geht alles gut.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_168745379_77a449585d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Das Programm <i>cStyle.c </i>besitzt ein paar Probleme. Es gibt keine Deklaration für die <i>sqrt-</i>Funktion (Zeile 2), die Zeile (3) führt eine implizite Konvertierung von einem <i>void</i>-Zeiger auf einen<i> int-</i>Zeiger durch und die Zeile (4) verwendet das Schlüsselwort <i>class</i>. </div><div class="text">Jetzt bin ich auf die Meinung des C++-Compilers gespannt.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_168745371_cfc38dd3a2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Ich erhalte, was ich verdiene: drei Compiler-Fehler. Das Programm <i>cStyle.c</i> zeigt noch einen viel subtileren Unterschied zwischen einem C- und C++-Compiler. Dazu habe ich das Programm auf die Zeile (2) reduziert: <i>printf("\nsizeof(\'a\'): %d\n\n", sizeof('a'));</i>. Hier ist die Ausgabe.&nbsp;</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_168745385_6300922b16.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Anstelle von 4 wie bei dem C-Compiler, ist <i>sizeof('a')</i> mit dem C++-Compiler 1: <i>'c'</i> ist ein <i>int</i> in C<b>. </b></div><div class="text">Nun kommt die herausfordernde Aufgabe.<br></div><div class="ztitel_kleiner">Der ganze Sourcecode steht nicht zur Verfügung</div><div class="text">Dies sind die wichtigen Punkte, die es zu beachten gilt.</div><div class="text"><ol><li> Verwende deinen C++ Compiler, um deine <i>main</i> Funktion zu übersetzen. Im Gegensatz zum C-Compiler, erzeugt der C++-Compiler zusätzlichen Startup-Code, der vor der <i>main</i>-Funktion ausgeführt wird. Zum Beispiel ruft dieser Startup-Code Konstruktoren von globalen (statischen) Objekten auf.</li><li>Verwende deinen C++-Compiler, um dein Programm zu linken. Wenn der C++-Compiler zum Linken verwenden wird, bindet er automatisch die Standard-C++-Bibliothek hinzu.<br></li><li> Verwende einen C- und C++-Compiler vom selben Anbieter, der dieselbe Aufrufkonvention (calling convention) verwenden sollte<b>.</b> Die Aufrufkonvention spezifiziert die Art und Weise, wie der Compiler auf Funktionen zugreift. Dies beinhaltet, in welcher Reihenfolge der Parameter allokiert werden, wie die Parameter übergeben werden oder ob der Aufrufer oder Aufgerufene sich um den Stack kümmert. Die Details zu x86s Aufrufkonvention lassen sich schön auf <a title="Link auf https://en.wikipedia.org/wiki/X86_calling_conventions" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FX86_calling_conventions%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FX86_calling_conventions%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Wikipedia%22%2C%22target%22%3A%22_blank%22%7D" href="https://en.wikipedia.org/wiki/X86_calling_conventions">Wikipedia</a> nachlesen.<br></li></ol></div><div class="ztitel"><a alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22CPL.3%3A%20If%20you%20must%20use%20C%20for%20interfaces%2C%20use%20C%2B%2B%20in%20the%20calling%20code%20using%20such%20interfaces%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-interface%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rcpl-interface%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-interface" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rcpl-interface">CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces</a></div><div class="text">Im Gegensatz zu C unterstützt C++ das Überladen von Funktionen. Das heißt, dass sich Funktionen mit dem selben Namen aber verschiedenen Parametern definieren lassen. Der Compiler sucht sich einfach die passenden Funktion heraus, wenn sie aufgerufen wird:</div><div class="pre">// functionOverloading.cpp<br><br>#include &lt;iostream&gt;&nbsp; <br>&nbsp; <br>void print(int) { <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "int" &lt;&lt; std::endl; <br>} <br><br>void print(double) { <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "double" &lt;&lt; std::endl; <br>} <br><br>void print(const char*) { <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "const char* " &lt;&lt; std::endl; <br>} <br><br>void print(int, double, const char*) { <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "int, double, const char* " &lt;&lt; std::endl; <br>} <br><br>&nbsp; <br>int main() { <br>&nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; print(10); <br>&nbsp;&nbsp;&nbsp; print(10.10); <br>&nbsp;&nbsp;&nbsp; print("ten"); <br>&nbsp;&nbsp;&nbsp; print(10, 10.10, "ten");<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Die Ausgabe ist erwartungsgemäß:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_168745389_2f4b3ab1f2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die entscheidende Frage ist aber nun: Wie kann der Compiler die verschiedenen Funktionen unterscheiden? Der C++-Compiler encodiert zusätzlich die Typen der Parameter in den Funktionsname. Dieser Prozess nennt sich Name Mangling. Name Mangeling ist nicht standardisiert und wird von jedem C++-Compiler spezifisch umgesetzt. Hin und wieder wird Name Mangling auch als Name Decoration bezeichnet.</div><div class="text">Mit der Hilfe des Programms <a title="Link auf https://godbolt.org/z/gFn4NU" alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22functionOverloading.cpp%20auf%20dem%20compiler%20explorer%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FgFn4NU%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2Fz%2FgFn4NU%22%7D" href="https://godbolt.org/z/gFn4NU">functionOverloading.cpp auf dem compiler explorer</a> ist es einfach, dass Name Mangling in Aktion zu zeigen. Dazu ist es notwendig, den Button Demangle zu deaktivieren.</div><div class="text">Hier sind die Namen, die der GCC 8.3 und der MSVC 19.16 erzeugen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_168745399_aa13e9d015.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Durch den <i>extern "C"</i> Link-Spezifizierer weist du den C++ Compiler an, keine Name Mangling zu verwenden.</div><div class="text">Indem du eine Funktion mittels <i>extern "C"</i> in deinem Code deklarierst, kannst du eine C-Funktion von C++ oder eine C++-Funktion von C aufrufen. <br></div><div class="text"><i>extern "C"</i> lässt sich explizit für jede Funktion,</div><div class="pre">extern "C" void foo(int);</div><div class="text">für jede Funktion in einem Bereich </div><div class="pre">extern "C" {<br>&nbsp;&nbsp;&nbsp; void foo(int);<br>&nbsp;&nbsp;&nbsp; double bar(double);<br>};<br></div><div class="text">oder auf eine ganze Headerdatei mit Include Guards anwenden. Das Makro<i> __cplusplus</i> gibt es nur, wenn der C++-Compiler verwendet wird:</div><div class="pre">#ifdef __cplusplus<br>extern "C" {<br>#endif<br>&nbsp;&nbsp;&nbsp; void foo(int);<br>&nbsp;&nbsp;&nbsp; double bar(double);<br>&nbsp;&nbsp;&nbsp; .<br>&nbsp;&nbsp;&nbsp; .<br>&nbsp;&nbsp;&nbsp; .<br>#ifdef __cplusplus<br>}<br>#endif</div><div class="ztitel">Wie geht es weiter?</div><div class="text"><span class="tlid-translation translation">Ich freue mich sehr, dass mit dem nächsten Artikel eine Miniserie zu CppInsight auf meinem Blog beginnt. CppInsight ist ein großartiges Werkzeug, das ich in meinen Artikeln und Schulungen intensiv verwende, um die Magie des C++-Compilers ans Tageslicht zu bringen. Dem Werkzeug fehlt jedoch eine gute Einführung. Wer kann das Einführung besser schreiben als Andreas Fertig, der Autor von CppInsight?</span><br></div>
