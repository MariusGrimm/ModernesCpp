<div class="text"><b>Anders als es der Titel und die Regeln zu den C++ Core Guidelines vermuten lassen, ist es keine Selbstverständlichkeit, höhere Performanz aus den Ein- und Ausagbestreams zu erhalten.</b></div><div class="text">Okay, jetzt muss ich einen Schritt zurückgehen. Obwohl ich einige Tests ausgeführt habe, sind meine Zahlen deutlich kontroverser als ich dachte. Falls du irgendwelche Ideen, Verbesserungen und Klarstellungen hast, nenne sie mir. Ich werde im nächsten Artikel darauf eingehen.</div><div class="text">Hier sind die Performanz-orientierten Regel der Guidelines zu Ein- und Ausgabestreams.</div><div class="text"><ul><li> <a alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-sync%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-sync%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.io.10%3A%20Unless%20you%20use%20printf-family%20functions%20call%20ios_base%3A%3Async_with_stdio%28false%29%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-sync" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-sync">SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)</a> </li><li> <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-endl%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-endl%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SL.io.50%3A%20Avoid%20endl%22%7D">SL.io.50: Avoid endl</a> </li></ul></div><div class="text">Ich denke, du kennst <i>std::ios_base::sync_with_stdio</i> nicht? </div><div class="pre"><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-sync" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-sync" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-sync%22%2C%22text%22%3A%22SL.io.10%3A%20Unless%20you%20use%20printf-family%20functions%20call%20ios_base%3A%3Async_with_stdio%28false%29%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-sync%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D">SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)</a></div><div class="text">Per Default, werden Operationen auf den C++ Streams mit den C Streams synchronisiert. Die Synchronisation findet nach jeder Ein- und Ausgabeoperation statt.<br></div><div class="text"><ul><li> C++ Streams<i>: std::cin, std::cou, std::cerr, std::clog, std::wcin, std::wcout, </i>std::wcerr und std::<i>wclog.</i></li><li>C Streams:<i> stdin, stout</i> und <i>stderr.</i><br></li></ul></div><div class="text">Diese Synchronisation erlaubt es C und C++ Operationen zu vermischen, da C++ Streams nicht gepuffert an die C Streams gehen. Es gibt noch eine weitere wichtige Beobachtung: Synchronisierte C++ Streams sind thread-sicher. Das heißt, alle Threads können ohne Synchronisation schreiben. Das Ergebnis mag ein Überlappen der Ausgabe sein; es ist aber kein Data-Race.</div><div class="text">Wenn du <i>std::ios_base::sync_with_stdio(false)</i> setzt, finde die Synchronisation zwischen C++ Streams und C Streams nicht statt, denn die C++ Streams können ihre Ausgabe in einen Puffer schreiben. Dank des Puffers, können die Ein- und Ausgaben schneller werden. <i>std::ios_base::sync_with_stdio(false) </i>muss vor der ersten Ein- oder Ausgabeoperation aufgerufen werden.</div><div class="text">Ich denke, dir ist aufgefallen, dass ich sehr oft "kann" geschrieben habe. Aus gutem Grunde.</div><div class="ztitel_kleiner">Überlappen der C++ Streams und der C Streams<br></div><div class="text">Zuerst einmal interessiert es mich, was passiert, wenn ich das folgende Programm mit verschiedenen Compilern ausführe.</div><div class="pre">// syncWithStdio.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;cstdio&gt;<br>&nbsp;<br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ios::sync_with_stdio(false);<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "1";<br>&nbsp;&nbsp;&nbsp; std::printf("2");<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text">Um ein besseres Bild meiner Compiler zu erhalten, habe ich ein wenig Information hinzugefügt.</div><div class="text">GCC 8.2</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600827_050db38557.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600836_76c7120ed4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Clang 8.0</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600838_4e92d63666.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600848_436e3ec620.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">cl.exe 19.20</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600854_3751801beb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600856_e09d3e99b4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Es scheint so, als ob nur der GCC unsynchronisiert ausgibt. Diese Beobachtung gilt nicht für clang oder cl.exe Compiler. Ein kleiner Performanztest bestätigte meinen ersten Eindruck.</div><div class="ztitel_kleiner">Performance mit und ohne Synchronisation</div><div class="text">Lass mich ein kleines Programm implementieren, dass mit und ohne Synchronisation auf die Konsole schreibt. Die Ausführung ohne Synchronisation sollte schneller sein. </div><div class="text"><b>Synchronisiert</b></div><div class="pre">// syncWithStdioPerformanceSync.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;random&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br><br>constexpr int iterations = 10;<br><br>std::ifstream openFile(const std::string&amp; myFile){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp; std::ifstream file(myFile, std::ios::in);<br>&nbsp; if ( !file ){<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Can't open file "+ myFile + "!" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp; }<br>&nbsp; return file;<br>&nbsp; <br>}<br><br>std::string readFile(std::ifstream file){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::stringstream buffer;<br>&nbsp;&nbsp;&nbsp; buffer &lt;&lt; file.rdbuf();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return buffer.str();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>auto writeToConsole(const std::string&amp; fileContent){<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; for (auto c: fileContent) std::cout &lt;&lt; c;<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::steady_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; return dur;<br>}&nbsp; <br><br>template &lt;typename Function&gt;<br>auto measureTime(std::size_t iter, Function&amp;&amp; f){<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur{};<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; iter; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dur += f();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return dur / iter;<br>}<br>&nbsp;&nbsp;&nbsp; <br>int main(int argc, char* argv[]){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // get the filename<br>&nbsp;&nbsp;&nbsp; std::string myFile;<br>&nbsp;&nbsp;&nbsp; if ( argc == 2 ){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile= argv[1];<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Filename missing !" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ifstream file = openFile(myFile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string fileContent = readFile(std::move(file));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto averageWithSync = measureTime(iterations, [&amp;fileContent]{ return writeToConsole(fileContent); });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "With Synchronisation: " &lt;&lt; averageWithSync.count() &lt;&lt; " seconds" &lt;&lt; std::endl;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div><div class="text">Das Programm sollte einfach zu verstehen sein. Ich öffne in Zeile 1 eine Datei, lese in Zeile 2 ihren ganzen Inhalt ein und schreibe sie <i>iterations</i>-Mal auf die Konsole (Zeile 3). Die geschieht in der Funktion <i>writeToConsole(fileContent)</i>. iterations ist in meinen konkreten Fall 10. Zum Abschluss gebe ich die durchschnittliche Zeit für die Ausgabe aus (Zeile 4).</div><div class="text"><b>Nicht Synchronisiert</b></div><div class="pre">&nbsp;// syncWithStdioPerformanceWithoutSync.cpp<br><br>... <br>&nbsp;<br>int main(int argc, char* argv[]){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ios::sync_with_stdio(false);&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // get the filename<br>&nbsp;&nbsp;&nbsp; std::string myFile;<br>&nbsp;&nbsp;&nbsp; if ( argc == 2 ){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile= argv[1];<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Filename missing !" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ifstream file = openFile(myFile);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string fileContent = readFile(std::move(file));<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto averageWithSync = measureTime(iterations, [&amp;fileContent]{ return writeToConsole(fileContent); });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto averageWithoutSync = measureTime(iterations, [&amp;fileContent]{ return writeToConsole(fileContent); });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Without Synchronisation: " &lt;&lt; averageWithoutSync.count() &lt;&lt; " seconds" &lt;&lt; std::endl;&nbsp; <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div><div class="text">Ich fügte lediglich die Zeile 1 zu dem Programm hinzu. Jetzt war ich natürlich auf die Performanzverbesserungen gespannt.</div><div class="text">Mein Performanztests führte ich mit einer kleinen und einer großen Textdatei durch (600.000 Buchstaben). Die große Datei lieferte keine neuen Einsichten. Daher ignoriere ich sie in diesem Artikel.<br></div><div class="pre">&gt;&gt; syncWithStdioPerformanceSync syncWithStdioPerformanceSync.cpp&nbsp; </div><div class="pre">&gt;&gt; syncWithStdioPerformanceWithoutSync syncWithStdioPerformanceSync.cpp</div><div class="pre"><ul><li><b>GCC</b></li></ul></div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600863_549c0de46a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="pre"><ul><li><b>Clang</b></li></ul></div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600872_db8150298b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:11 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="pre"><ul><li><b>cl.exe</b></li></ul></div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600876_90a18346ae.png" title="<ir_inline itemname=bilder_mvp_bild_var2:12 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Die Zahlen [--] insbesondere unter Windows [--]&nbsp; überraschten mich.</div><div class="text"><ul><li>Mit dem GCC hatte im unsynchronisierten Fall eine Performanzverbesserng von 70 Prozent.</li><li>Weder Clang noch cl.exe zeigten eine Performanzverbesserung. Es scheint so zu sein, als ob die unsynchronisierte Variante doch synchronisiert. Meine Zahlen bestätigen meine Beobachtungen des Programms syncWithStdio.cpp.</li><li>Nur für die Statistik. Ist dir aufgefallen, wie langsam die Konsole unter Windows ist?</li></ul></div><div class="text">Okay, ich bin schuldig. Ich breche fast immer die nächste Regel.<br></div><div class="ztitel_kleiner"><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl" alt="%7B%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-endl%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22SL.io.50%3A%20Avoid%20endl%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rio-endl%22%7D">SL.io.50: Avoid endl</a> </div><div class="text">Warum solltest du std::endl vermeiden? Oder anders herum: Was ist der Unterschied zwischen dem Manipulator std::endl und '\n'?</div><div class="text"><ul><li><i><b>std:endl </b></i>schreibt ein newline und leert (flushed) den Puffer.</li><li><i><b>'\n'</b></i> schreibt ein newline.<br></li></ul></div><div class="text">Den Puffer zu leeren ist eine teuere Operation und sollte daher vermieden werden. Wenn es notwendig ist, wird der Puffer automatisch geleert. Ehrlich gesagt, war ich sehr neugierig auf die Zahlen. Um den Effekt ganz deutlich zu sehen, präsentiere ich ein Programm, dass nach jedem Zeichen einen Zeilenumbruch (Zeile 3) einfügt.</div><div class="pre">// syncWithStdioPerformanceEndl.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;random&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br><br>constexpr int iterations = 500;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>std::ifstream openFile(const std::string&amp; myFile){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp; std::ifstream file(myFile, std::ios::in);<br>&nbsp; if ( !file ){<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Can't open file "+ myFile + "!" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp; }<br>&nbsp; return file;<br>&nbsp; <br>}<br><br>std::string readFile(std::ifstream file){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::stringstream buffer;<br>&nbsp;&nbsp;&nbsp; buffer &lt;&lt; file.rdbuf();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; return buffer.str();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>template &lt;typename End&gt;<br>auto writeToConsole(const std::string&amp; fileContent, End end){<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; for (auto c: fileContent) std::cout &lt;&lt; c &lt;&lt; end;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur = std::chrono::steady_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; return dur;<br>}&nbsp; <br><br>template &lt;typename Function&gt;<br>auto measureTime(std::size_t iter, Function&amp;&amp; f){<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur{};<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; iter; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dur += f();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return dur / iter;<br>}<br>&nbsp;&nbsp;&nbsp; <br>int main(int argc, char* argv[]){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; // get the filename<br>&nbsp;&nbsp;&nbsp; std::string myFile;<br>&nbsp;&nbsp;&nbsp; if ( argc == 2 ){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFile= argv[1];<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Filename missing !" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::ifstream file = openFile(myFile);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string fileContent = readFile(std::move(file));<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto averageWithFlush = measureTime(iterations, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&amp;fileContent]{ return writeToConsole(fileContent, std::endl&lt;char, std::char_traits&lt;char&gt;&gt;); }); // (2)<br>&nbsp;&nbsp;&nbsp; auto averageWithoutFlush = measureTime(iterations, [&amp;fileContent]{ return writeToConsole(fileContent, '\n'); });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "With flush(std::endl) " &lt;&lt; averageWithFlush.count() &lt;&lt; " seconds" &lt;&lt; std::endl;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Without flush(\\n): " &lt;&lt; averageWithoutFlush.count() &lt;&lt; " seconds" &lt;&lt; std::endl;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "With Flush/Without Flush: " &lt;&lt; averageWithFlush/averageWithoutFlush &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text">Im ersten Fall verwendete ich <i>std::endl</i> (Zeile 2) und im zweiten Fall<i> '\n' </i>(Zeile 3). </div><div class="text">Das Programm ist dem vorherigen sehr ähnlich. Der große Unterschied ist, dass ich in diesem Fall 500 Wiederholungen (Zeile 1) durchführte. Warum? Ich wurde durch die Variationen der Zahlen sehr überrascht. Mit ein paar Iterationen konnte ich keinen Unterschied feststellen. Manchmal war die Variante mit<i> std::endl </i>doppelt so schnell wie die mit <i>'\n';</i> manchmal war sie viermal langsamer. Dies galt sowohl für GCC als auch den cl.exe-Compiler. Ich verwendete auch verschiedene Compilerversionen. Ehrlich, das war nicht was ich erwartete. Wenn ich aber 500 Wiederholungen ausführte, bekam ich das Ergebnis, dass ich erwartete. <i>’\n' </i>scheint ca. 10-20 Prozent schneller als <i>std::endl </i>zu sein.</div><div class="text"><b>Nochmals: Nur 10 bis 20 Prozent schneller. </b><br></div><div class="text"><ul><li>GCC</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600887_e36861adc0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:15 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>cl.exe</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176600879_5e288774dd.png" title="<ir_inline itemname=bilder_mvp_bild_var2:14 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="ztitel">Meine kleine Schlussfolgerung</div><div class="text">Eine kleine Schlussfolgerung möchte ich aus meinen Performanztests ziehen.</div><div class="text"><ul><li> <i>std::ios_base::sync_with_stdio(false)</i> kann eine starke Auswirkung auf deiner Plattform besitzen. Du verlierst aber dadurch die Zusicherung thread-sicher zu sein.</li><li><i>std::endl </i>ist nicht so schlecht wie sein Ruf. Daher werde ich meine Gewohnheit nicht ändern.</li></ul></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Es gibt nur eine Regel in den Abschnitten<i> regex, chrono </i>und der C Standard Bibliothek. Daher werde ich in meinem nächsten Artikel improvisieren müssen.<br></div><div class="simple-translate-result-wrapper"><br> <br></div>
