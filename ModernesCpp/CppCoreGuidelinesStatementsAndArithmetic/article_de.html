<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150279692_801dbce3da.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="vorspann">Heute schließe ich mit den verbleibenden Regeln zu Anweisungen ab. Dazu gibt es die sehr wichtigen Regeln zur Arithmetik. Werden diese nicht eingehalten, lauert undefiniertes Verhalten.</div>
<div class="text">Vier Regeln zu Anweisungen sind noch auf meiner To-do-Liste:<br></div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-noname" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-noname" alt="%7B%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-noname%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-noname%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.84%3A%20Don%C2%92t%20%28try%20to%29%20declare%20a%20local%20variable%20with%20no%20name%22%2C%22version%22%3A1%7D" class="">ES.84: Don’t (try to) declare a local variable with no name</a> </li><li> <a alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-empty%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-empty%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.85%3A%20Make%20empty%20statements%20visible%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-empty" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-empty">ES.85: Make empty statements visible</a> </li><li> <a class="" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.86%3A%20Avoid%20modifying%20loop%20control%20variables%20inside%20the%20body%20of%20raw%20for-loops%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-loop-counter%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-loop-counter%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-loop-counter" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-loop-counter">ES.86: Avoid modifying loop control variables inside the body of raw for-loops</a> </li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-if" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-if" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-if%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-if%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.87%3A%20Don%C2%92t%20add%20redundant%26nbsp%3B%3D%3D%26nbsp%3Bor%26nbsp%3B%21%3D%26nbsp%3Bto%20conditions%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D" class="">ES.87: Don’t add redundant&nbsp;==&nbsp;or&nbsp;!=&nbsp;to conditions</a></li></ul></div>
<div class="text">Die erste Regel ist sehr offensichtlich.</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-noname" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-noname" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-noname%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-noname%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22ES.84%3A%20Don%C2%92t%20%28try%20to%29%20declare%20a%20local%20variable%20with%20no%20name%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="">ES.84: Don’t (try to) declare a local variable with no name</a></b> <br> </div>
<div class="text">Das Deklarieren einer lokalen Variable ohne Name besitzt keine Auswirkung. Mit dem abschließenden Strichpunkt verliert die Variable ihre Gültigkeit:</div>
<div class="pre">void f()<br>{<br>&nbsp;&nbsp;&nbsp; lock&lt;mutex&gt;{mx};&nbsp;&nbsp; // Bad<br>&nbsp;&nbsp;&nbsp; // critical region<br>}</div>
<div class="text">Typischerweise unterdrückt der Optimierer das Erzeugen temporärer Objekten, wenn diese nicht das beobachtbare Verhalten des Programms betreffen. Dies ist die sogenannte <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fas_if%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fas_if%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22as-if%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D" class="" href="http://en.cppreference.com/w/cpp/language/as_if" title="Link auf http://en.cppreference.com/w/cpp/language/as_if">as-if</a>-Regel. Falls der Konstruktor beobachtbares Verhalten wie die Veränderungen des globales Zustands des Programms besitzt, darf der Optimierer die Erzeugung des temporären Objektes nicht unterdrücken. <br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-empty" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-empty" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.85%3A%20Make%20empty%20statements%20visible%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-empty%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-empty%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" class="">ES.85: Make empty statements visible</a></b> <br> </div>
<div class="text">Um ehrlich zu sein, verstehe ich den Grund für diese Regel nicht. Warum sollte ich leere Anweisungen verwenden? Für mich sind beide Beispiele nur schlechter Programmierstil: </div>
<div class="pre">for (i = 0; i &lt; max; ++i);&nbsp;&nbsp; // BAD: the empty statement is easily overlooked<br>v[i] = f(v[i]);<br><br>for (auto x : v) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // better<br>&nbsp;&nbsp;&nbsp; // nothing<br>}<br>v[i] = f(v[i]);<br></div>
<div class="text"><b><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-loop-counter%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-loop-counter%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.86%3A%20Avoid%20modifying%20loop%20control%20variables%20inside%20the%20body%20of%20raw%20for-loops%22%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-loop-counter" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-loop-counter">ES.86: Avoid modifying loop control variables inside the body of raw for-loops</a></b> <br></div>
<div class="text">Klar, das ist in zweifacher Hinsicht ein sehr schlechter Programmierstil. Zuerst einmal, solltest du keine nackten Schleifen verwenden und stattdessen Algorithmen der Standard Template Library einsetzen. Darüber hinaus gilt, dass du die Kontrollvariable im Körper der nackten Schleife nicht modifizieren solltest. Hier kommt der schlechte Programmierstil:</div>
<div class="pre">for (int i = 0; i &lt; 10; ++i) {<br>&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp; if (/* something */) ++i; // BAD<br>&nbsp;&nbsp;&nbsp; //<br>}<br><br>bool skip = false;<br>for (int i = 0; i &lt; 10; ++i) {<br>&nbsp;&nbsp;&nbsp; if (skip) { skip = false; continue; }<br>&nbsp;&nbsp;&nbsp; //<br>&nbsp;&nbsp;&nbsp; if (/* something */) skip = true;&nbsp; // Better: using two variable for two concepts.<br>&nbsp;&nbsp;&nbsp; //<br>}<br></div>
<div class="text">Insbesondere die zweite Schleife ist schwer zu durchschauen, da sie unter der Decke zwei verschachtelte, abhängige Schleifen enthält. </div>
<div class="text"><b><a class="" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-if%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-if%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.87%3A%20Don%C2%92t%20add%20redundant%26nbsp%3B%3D%3D%26nbsp%3Bor%26nbsp%3B%21%3D%26nbsp%3Bto%20conditions%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-if" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-if">ES.87: Don’t add redundant&nbsp;==&nbsp;or&nbsp;!=&nbsp;to conditions</a></b></div>
<div class="text">Schuldig im Sinne der Anklage. In meinen ersten Jahren als professioneller C++-Entwickler habe ich oft überflüssige <i>==</i> oder <i>!=</i> in Bedingungen verwendet. Natürlich habe ich mittlerweile meine Praxis angepasst.<br></div>
<div class="pre">// p is not a nullptr<br>if (p) { ... }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // good<br>if (p != nullptr) { ... } // redundant <br><br>// p is a nullptr<br>if (!p) { ... }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // good<br>if (p == 0) { ... }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // redundant <br><br>for (string s; cin &gt;&gt; s;)&nbsp; // the istream operator returns bool<br>v.push_back(s);<br></div>
<div class="text">Dies waren die Regeln zu Anweisungen. Weiter geht es mit den Regeln zur Arithmetik. Hier sind die ersten sieben Regeln:<br></div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-mix" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-mix" alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-mix%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-mix%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22ES.100%3A%20Don%C2%92t%20mix%20signed%20and%20unsigned%20arithmetic%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="">ES.100: Don’t mix signed and unsigned arithmetic</a> </li><li> <a class="" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unsigned%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unsigned%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22text%22%3A%22ES.101%3A%20Use%20unsigned%20types%20for%20bit%20manipulation%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unsigned" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unsigned">ES.101: Use unsigned types for bit manipulation</a> </li><li> <a alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.102%3A%20Use%20signed%20types%20for%20arithmetic%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-signed%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-signed%22%2C%22type%22%3A%22E%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-signed" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-signed">ES.102: Use signed types for arithmetic</a> </li><li> <a class="" alt="%7B%22version%22%3A1%2C%22text%22%3A%22ES.103%3A%20Don%C2%92t%20overflow%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-overflow%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-overflow%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-overflow" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-overflow">ES.103: Don’t overflow</a> </li><li> <a class="" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-underflow%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-underflow%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.104%3A%20Don%C2%92t%20underflow%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-underflow" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-underflow">ES.104: Don’t underflow</a> </li><li> <a alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.105%3A%20Don%C2%92t%20divide%20by%20zero%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-zero%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-zero%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-zero" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-zero">ES.105: Don’t divide by zero</a> </li><li><a class="" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nonnegative%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nonnegative%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.106%3A%20Don%C2%92t%20try%20to%20avoid%20negative%20values%20by%20using%26nbsp%3Bunsigned%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nonnegative" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nonnegative">ES.106: Don’t try to avoid negative values by using&nbsp;unsigned</a></li></ul></div>
<div class="text">Ehrlich gesagt, ich habe oft nicht so viel zu den Regeln hinzuzufügen. Der Vollständigkeit (und Wichtigkeit) halber will ich sie in diesem Artikel kurz und bündig vorstellen. <br></div>
<div class="text"><b><a class="" alt="%7B%22user_params%22%3A%22%22%2C%22text%22%3A%22ES.100%3A%20Don%C2%92t%20mix%20signed%20and%20unsigned%20arithmetic%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-mix%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-mix%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-mix" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-mix">ES.100: Don’t mix signed and unsigned arithmetic</a></b> <br> </div>
<div class="text">Wenn du vorzeichenbehaftete (<i>signed</i>) und vorzeichenlose (<i>unsigned</i>) Arithmetik vermischst, erhältst du nicht das erwartete Ergebnis: <br></div>
<div class="pre">#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp; int x = -3;<br>&nbsp; unsigned int y = 7;<br><br>&nbsp; std::cout &lt;&lt; x - y &lt;&lt; std::endl;&nbsp; // 4294967286<br>&nbsp; std::cout &lt;&lt; x + y &lt;&lt; std::endl;&nbsp; // 4<br>&nbsp; std::cout &lt;&lt; x * y &lt;&lt; std::endl;&nbsp; // 4294967275<br>&nbsp; std::cout &lt;&lt; x / y &lt;&lt; std::endl;&nbsp; // 613566756<br>&nbsp; <br>}<br></div>
<div class="text">Sowohl der GCC, der Clang als auch der Microsoft-Compiler produzierten das gleiche Ergebnis.<br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unsigned" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unsigned" class="" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unsigned%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unsigned%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.101%3A%20Use%20unsigned%20types%20for%20bit%20manipulation%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D">ES.101: Use unsigned types for bit manipulation</a></b> <br> </div>
<div class="text">Der Grund für die Regel ist sehr naheliegend. Bitoperationen auf vorzeichenbehafteten Datentypen sind implementation-defined.<br></div>
<div class="text"><b><a alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22ES.102%3A%20Use%20signed%20types%20for%20arithmetic%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-signed%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-signed%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-signed" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-signed">ES.102: Use signed types for arithmetic</a></b> <br> </div>
<div class="text">Zuerst einmal sollten bei der Arithmetik vorzeichenbehaftete Datentypen verwendet werden. Darüber hinaus sollten keine vorzeichenbehafteten und vorzeichenlosen Datentypen zum Einsatz kommen. Sonst ist der Überraschungseffekt groß:</div>
<div class="pre">#include &lt;iostream&gt;<br><br>template&lt;typename T, typename T2&gt;<br>T subtract(T x, T2 y){<br>&nbsp;&nbsp;&nbsp; return x - y;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int s = 5;<br>&nbsp;&nbsp;&nbsp; unsigned int us = 5;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; subtract(s, 7) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -2<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; subtract(us, 7u) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp; // 4294967294<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; subtract(s, 7u) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -2<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; subtract(us, 7) &lt;&lt; '\n';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4294967294<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; subtract(s, us + 2) &lt;&lt; '\n';&nbsp; // -2<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; subtract(us, s + 2) &lt;&lt; '\n';&nbsp; // 4294967294<br><br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-overflow" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-overflow" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.103%3A%20Don%C2%92t%20overflow%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-overflow%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-overflow%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D">ES.103: Don’t overflow</a> and <a class="" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-underflow%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-underflow%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.104%3A%20Don%C2%92t%20underflow%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-underflow" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-underflow">ES.104: Don’t underflow</a></b> </div>
<div class="text">Beide Regeln lassen sich schön zusammen beschreiben. Der Effekt eines Überlaufs oder eines Unterlaufs ist derselbe: <i>memory corruption</i> und <i>undefined behaviour</i>. Ein einfacher Test mit einem int-Array zeigt das Unheilspotenzial. Wie lange läuft das folgende Programm, indem jenseits der Array-Grenzen gelesen und geschrieben wird?<br></div>
<div class="pre">// overUnderflow.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int a[0];<br>&nbsp;&nbsp;&nbsp; int n{};<br><br>&nbsp;&nbsp;&nbsp; while (true){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(n % 100)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "a[" &lt;&lt; n &lt;&lt; "] = " &lt;&lt; a[n] &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ", a[" &lt;&lt; -n &lt;&lt; "] = " &lt;&lt; a[-n] &lt;&lt; "\n";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[n] = n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[-n] = -n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++n;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>}<br><br></div>
<div class="text">Beunruhigend lange. Das Programm schreibt jeden hundertsten Array-Wert auf <i>std::cout</i>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150279698_cd942cd1c7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-zero" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-zero" class="" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-zero%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-zero%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.105%3A%20Don%C2%92t%20divide%20by%20zero%22%2C%22user_params%22%3A%22%22%7D">ES.105: Don’t divide by zero</a></b> </div>
<div class="text">Falls dein Programm abstürzen soll, hilft eine einfache Division durch 0. Das Teilen durch 0 kann aber in logischen Ausdrücken OK sein.<br></div>
<div class="pre">bool res = false and (1/0);<br></div>
<div class="text">Da das Ergebnis des Ausdrucks (1/0) nicht für das Gesamtergebnis relevant ist, wird es nicht ausgewertet. Diese Technik nennt sich <a title="Link auf https://en.wikipedia.org/wiki/Short-circuit_evaluation" href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" alt="%7B%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FShort-circuit_evaluation%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FShort-circuit_evaluation%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22short%20circuit%20evaluation%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D" class="">short circuit evaluation</a> und ist ein Spezialfall der Bedarfsauswertung.<br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nonnegative" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-nonnegative" class="" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.106%3A%20Don%C2%92t%20try%20to%20avoid%20negative%20values%20by%20using%26nbsp%3Bunsigned%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nonnegative%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-nonnegative%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D">ES.106: Don’t try to avoid negative values by using&nbsp;unsigned</a></b></div>
<div class="text">Wende keine vorzeichenlosen Datentypen an, falls du negative Werte vermeiden willst. Die Konsequenzen sind weitreichend. Die Charakteristik der Arithmetik ändert sich dadurch und dein Programm wird anfällig für Fehler rund um die vorzeichenbehaftete/vorzeichenlose Arithmetik.</div>
<div class="text">Hier sind zwei Beispiel aus den Guidelines, die vorzeichenbehaftete und vorzeichenlose Arithmetik vermischen:</div>
<div class="pre">unsigned int u1 = -2;&nbsp;&nbsp; // Valid: the value of u1 is 4294967294<br>int i1 = -2;<br>unsigned int u2 = i1;&nbsp;&nbsp; // Valid: the value of u2 is 4294967294<br>int i2 = u2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Valid: the value of i2 is -2<br><br><br>unsigned area(unsigned height, unsigned width) { return height*width; } <br>// ...<br>int height;<br>cin &gt;&gt; height;<br>auto a = area(height, 2);&nbsp;&nbsp; // if the input is -2 a becomes 4294967292</div>
<div class="text">Wie die Guidelines bemerken, gibt es eine interessante Beziehung. Wenn ein vorzeichenlose <i>int</i> mit einer -1 initialisiert wird, wird diese zu größten vorzeichenlosen <i>int.</i></div>
<div class="text">Nun aber zu dem interessanteren Fall. Das Verhalten der Arithmetik unterscheidet sich bei vorzeichenbehafteten und vorzeichenlosen Datentypen. </div>
<div class="text">Los geht es mit einem einfachen Programm:</div>
<div class="pre">// modulo.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int max{100000};&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned short x{0};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::size_t count{0};<br>&nbsp;&nbsp;&nbsp; while (x &lt; max &amp;&amp; count &lt; 20){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; x &lt;&lt; " ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += 10000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++count;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>}</div>
<div class="text">Der entscheidende Punkt des Programms ist es, dass die fortwährende Addition auf x in Zeile (1) keinen Überlauf erzeugt. Die fortwährende Addition erzeugt eine Modulo-Operation, wenn der Wertebereich von x endet. Der Grund ist, dass x eine vorzeichenlose <i>unsigned short</i> (1) ist.<br></div>
<div class="pre">// overflow.cpp<br><br>#include &lt;cstddef&gt;<br>#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int max{100000};&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; short x{0};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::size_t count{0};<br>&nbsp;&nbsp;&nbsp; while (x &lt; max &amp;&amp; count &lt; 20){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; x &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += 10000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++count;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "\n\n";<br>}<br></div>
<div class="text">Eine kleine Modifikation des Programms <i>modulo.cpp </i>besitzt weitreichende Konsequenzen. Die vorzeichenlose Variable <i>x </i>(2) bekam ein Vorzeichen. Die Auswirkung ist, dass das Programm jetzt einen Überlauf erzeugt.</div>
<div class="text">Die entscheidenen Stelle der Ausgabe ist rot markiert;</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150279700_1debd83a1b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Jetzt gilt es noch eine brennende Frage zu beantworten: Wie lässt sich der Überlauf erkennen? Ersetze einfach die fehlerhafte Zuweisung&nbsp;<i> x += 1000</i> durch einen Ausdruck mit geschweiften Klammern: <i>x&nbsp; = {x + 1000}</i>, Der Unterschied ist, dass der Compiler prüft, ob verengenden Konvertierung (<i>narrowing conversion</i>) vorliegt. Hier ist die Ausgabe des GCC:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150279706_768c7ec9bc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Ausdrücke (<i>x += 1000</i>) und (<i>x = {x + 1000}</i>) sind mit der Performanzbrille betrachtet nicht identisch. Der zweite Ausdruck kann eine temporären Wert für&nbsp; x + 1000 erzeugen. In dem konkreten Fall machte mein Optimierer einen erstklassigen Job und er erzeugt dieselben Assembler-Anweisungen. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Ich bin bereits fast fertig mit den Regeln zur Arithmetik. Das heißt, dass ich mich in meinem nächsten Artikel bereits den Regeln zur Performanz widmen werde. <br></div>
