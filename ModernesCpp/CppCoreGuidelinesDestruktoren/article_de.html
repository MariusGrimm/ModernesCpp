<div class="vorspann">Benötigt meine Klasse einen Destruktor? Das ist eine Frage,&nbsp; die häufig vernommen wird. Meistens ist die Antwort nein, und man wendest die <a class="" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Nullerregel%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" href="https://www.heise.de/-3813435" title="Link auf https://www.heise.de/-3813435">Nullerregel</a> an. Manchmal ist die Antwort ja, und damit ist man bei der <a href="https://www.heise.de/-3813435" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22F%C3%BCnferregel%22%2C%22target%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" class="" title="Link auf https://www.heise.de/-3813435">Fünferregel</a>. Um genauer zu sein: Die Guidelines bieten acht Regeln für Destruktoren an.</div>
<div class="text">Hier sind die acht Regeln: </div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor" class="" alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.30%3A%20Define%20a%20destructor%20if%20a%20class%20needs%20an%20explicit%20action%20at%20object%20destruction%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor">C.30: Define a destructor if a class needs an explicit action at object destruction</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-release" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-release%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-release%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.31%3A%20All%20resources%20acquired%20by%20a%20class%20must%20be%20released%20by%20the%20class%C2%92s%20destructor%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-release">C.31: All resources acquired by a class must be released by the class’s destructor</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.32%3A%20If%20a%20class%20has%20a%20raw%20pointer%20%28T%2A%29%20or%20reference%20%28T%26amp%3B%29%2C%20consider%20whether%20it%20might%20be%20owning%22%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr">C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr2" alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr2%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr2%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.33%3A%20If%20a%20class%20has%20an%20owning%20pointer%20member%2C%20define%20a%20destructor%22%2C%22custom%22%3A%7B%7D%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr2">C.33: If a class has an owning pointer member, define a destructor</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ref" alt="%7B%22text%22%3A%22C.34%3A%20If%20a%20class%20has%20an%20owning%20reference%20member%2C%20define%20a%20destructor%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ref%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ref%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ref">C.34: If a class has an owning reference member, define a destructor</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-virtual" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-virtual" class="" alt="%7B%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-virtual%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-virtual%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.35%3A%20A%20base%20class%20destructor%20should%20be%20either%20public%20and%20virtual%2C%20or%20protected%20and%20nonvirtual%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D">C.35: A base class destructor should be either public and virtual, or protected and nonvirtual</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-fail" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.36%3A%20A%20destructor%20may%20not%20fail%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-fail%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-fail%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-fail">C.36: A destructor may not fail</a> <br></li><li><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept" class="" alt="%7B%22text%22%3A%22C.37%3A%20Make%20destructors%20noexcept%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-noexcept%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-noexcept%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept">C.37: Make destructors noexcept</a></li></ul></div>
<div class="text">Jede der Regel verdient einen genaueren Blick.</div>
<div class="ztitel">Regeln für Destruktoren<br></div>
<div class="text"><b><a alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.30%3A%20Define%20a%20destructor%20if%20a%20class%20needs%20an%20explicit%20action%20at%20object%20destruction%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor">C.30: Define a destructor if a class needs an explicit action at object destruction</a></b></div>
<div class="text">Es ist charakteristisch für C++, dass der Destruktor eines Objekts automatisch am Ende seiner Lebenszeit aufgerufen wird. Um noch genauer zu sein: Der Destruktor eines Objekts wird genau dann aufgerufen, wenn dieses seinen Gültigkeitsbereich verlässt. Dank dieses vollständig deterministischen Verhaltens kann man kritische Ressourcen im Destruktor freigeben.</div>
<div class="text">Locks oder Smart Pointer nützen diese Charakteristik aus. Beide geben automatische ihre zugrunde liegende Ressource frei, wenn sie ihren Gültigkeitsbereich verlassen.</div>
<div class="pre">void func(){<br>&nbsp; std::unique_ptr&lt;int&gt; uniqPtr = std::make_unique&lt;int&gt;(2011);<br>&nbsp; std::lock_guard&lt;std::mutex&gt; lock(mutex);<br>&nbsp; . . .<br>} // automatically released</div>
<div class="text"><i>uniqPtr</i> gibt sein<i> int </i>frei und<i> lock </i>seinen Mutex. Beide setzen das RAII-Idiom (Resource Acquisition Is Initialization) um. Wer sich für die Details zu RAII interessiert, hier ist mein Artikel "<a href="http://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Garbage%20Collection%20%5B--%5D%20No%20Thanks%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke">Garbage Collection [--] No Thanks</a>", der eine Anmerkung von Bjarne Stroustrup zu RAII enthält.</div>
<div class="text">Man kann die Regel auch anders herum interpretieren. Falls alle Mitglieder einer Klasse einen Default-Destruktor besitzen, sollte man keinen definieren.</div>
<div class="pre">class Foo {&nbsp;&nbsp; // bad; use the default destructor<br>public:<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; ~Foo() { s = ""; i = 0; vi.clear(); }&nbsp; // clean up<br>private:<br>&nbsp;&nbsp;&nbsp; string s;<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; vector&lt;int&gt; vi;<br>}; </div>
<div class="text"><b><a class="" alt="%7B%22text%22%3A%22C.31%3A%20All%20resources%20acquired%20by%20a%20class%20must%20be%20released%20by%20the%20class%C2%92s%20destructor%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-release%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-release%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-release" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-release">C.31: All resources acquired by a class must be released by the class’s destructor</a></b> <br> </div>
<div class="text">Die Regel hört sich ziemlich einleuchtend an und hilft, Ressourcenlecks zu vermeiden. Aber man muss im Kopf behalten, welche deiner Klassenmitglieder einen vollen Satz an Default-Operationen besitzt. Damit sind wir wieder bei der Nuller- oder Fünferregel. </div>
<div class="text">Eventuell besitzt die Klasse <i>File</i> im Gegensatz zur Klasse <i>std::ifsteam </i>keinen Destruktor. Somit bekommen wir unter Umständen ein Speicherleck, falls eine Instanz von <i>MyClass</i> ihren Gültigkeitsbereich verlässt. </div>
<div class="pre">class MyClass{<br>&nbsp;&nbsp;&nbsp; std::ifstream fstream;&nbsp;&nbsp; // may own a file<br>&nbsp;&nbsp;&nbsp; File* file_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // may own a file<br>&nbsp;&nbsp;&nbsp; ... <br>};</div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.32%3A%20If%20a%20class%20has%20a%20raw%20pointer%20%28T%2A%29%20or%20reference%20%28T%26amp%3B%29%2C%20consider%20whether%20it%20might%20be%20owning%22%2C%22user_params%22%3A%22%22%7D" class="">C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning</a></b> <br> </div>
<div class="text">Es gibt eine Frage, die man beantworten muss, wenn eine Klasse einen Zeiger oder eine Referenz besitzt: Wer ist der Besitzer der Ressource? Falls es deine Klasse ist, musst du die Ressource natürlich löschen.<br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr2" class="" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr2%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ptr2%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.33%3A%20If%20a%20class%20has%20an%20owning%20pointer%20member%2C%20define%20a%20destructor%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ptr2">C.33: If a class has an owning pointer member, define a destructor</a> <br></b> </div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ref" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-ref" alt="%7B%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ref%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-ref%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.34%3A%20If%20a%20class%20has%20an%20owning%20reference%20member%2C%20define%20a%20destructor%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" class="">C.34: If a class has an owning reference member, define a destructor</a></b> <br> </div>
<div class="text">Die Regeln C.33 und C.34 sind ziemlich einfach zu beschreiben. Falls man einen Zeiger oder eine Ressource besitzt, verwendet man einen Smart Pointer wie <i>std::unique_ptr</i>. Er ist per Design so effizient wie ein nackter Zeiger. Daher besitzt er keinen Overhead in Zeit oder Speicher, bietet aber einen deutlichen Mehrwert an: Er löscht automatisch die zugrunde liegende Ressource. Hier sind meine Artikel zu <a class="" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Smart%20Pointern%22%2C%22custom%22%3A%7B%7D%7D" href="http://www.grimm-jaud.de/index.php/blog/tag/smart-pointer" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/smart-pointer">Smart Pointern</a> in C++.<br></div>
<div class="text"><b><a alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-virtual%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-virtual%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.35%3A%20A%20base%20class%20destructor%20should%20be%20either%20public%20and%20virtual%2C%20or%20protected%20and%20nonvirtual%22%2C%22user_params%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-virtual" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-virtual">C.35: A base class destructor should be either public and virtual, or protected and nonvirtual</a></b> <br> </div>
<div class="text">Die Regel hört sich sehr interessant für Klassen an, die virtuelle Methoden besitzen. Lasst mich die Regeln in ihre zwei Komponenten trennen.</div>
<div class="text"><b>Public und virtueller Destruktor</b><br></div>
<div class="text">Falls eine Klasse ein public und virtuellen Destruktor besitzt, kann man Instanzen einer abgeleiteten Klasse durch einen Zeiger auf die Basiskasse löschen. Dasselbe gilt für Referenzen.</div>
<div class="pre">struct Base {&nbsp; // no virtual destructor<br>&nbsp;&nbsp;&nbsp; virtual void f(){};<br>};<br><br>struct Derived : Base {<br>&nbsp;&nbsp;&nbsp; string s {"a resource needing cleanup"};<br>&nbsp;&nbsp;&nbsp; ~D() { /* ... do some cleanup ... */ }<br>};<br><br>...<br><br>Base* b = new Derived();<br>delete b;</div>
<div class="text">Der Compiler erzeugt für <i>Base</i> einen nichtvirtuellen Destruktor. Das Löschen eines Objects vom Typ <i>Derived </i>mittel eines Zeiger auf die Basisklasse <i>Base </i>stellt undefiniertes Verhalten dar, falls der Destruktor der Basisklasse nichtvirtuell ist.</div>
<div class="text"><b>Protected und nichtvirtueller Destruktor</b></div>
<div class="text">Das ist einfach nachzuvollziehen. Falls der Destruktor der Basisklasse <i>protected</i> ist, kann man Instanzen von abgeleiteten Klassen nicht mittel eines Zeigers auf die Basisklasse löschen. Daher muss er nicht virtuell sein. </div>
<div class="text">Diesen Punkt zu Datentypen (keine Zeiger und Referenzen) will ich noch genauer herausarbeiten:</div>
<div class="text"><ul><li> Falls der Destruktor einer Klasse<i> Base private</i> ist, kann&nbsp; man den Datentyp nicht verwenden.</li><li>Falls der Destruktor einer Klasse <i>Base protected</i> ist, kann man nur<i> Derived </i>von <i>Base</i> ableiten und Instanzen vom Typ <i>Derived</i> verwenden.</li></ul></div>
<div class="pre">struct Base{<br>&nbsp;&nbsp;&nbsp; protected:<br>&nbsp;&nbsp;&nbsp; ~Base() = default;<br>};<br><br>struct Derived: Base{};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; Base b;&nbsp;&nbsp; // Error: Base::~Base is protected within this context<br>&nbsp;&nbsp;&nbsp; Derived d;<br>}</div>
<div class="text">Der Aufruf <i>Base b </i>verursacht einen Fehler.<br></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-fail" class="" alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.36%3A%20A%20destructor%20may%20not%20fail%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-fail%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-fail%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-fail">C.36: A destructor may not fail</a> <br></b></div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept" class="" alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.37%3A%20Make%20destructors%20noexcept%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-noexcept%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-dtor-noexcept%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept">C.37: Make destructors noexcept</a></b></div>
<div class="text">Die Meta-Regel für die Regeln C.36 und C.36 besitzt einen breiten Fokus. Ein Destruktor soll nicht fehlschlagen, und man sollte ihn daher als <i>noexcept</i> deklarieren. Ich denke, ich sollte auf <i>noexcept </i>ein wenig eingehen.</div>
<div class="text"><ul><li> <b>noexcept</b>: Falls man eine Funktion wie einen Destruktor als <i>noexcept</i> deklarierst, bewirkt eine Ausnahme einen <i> <a title="Link auf http://en.cppreference.com/w/cpp/error/terminate" href="http://en.cppreference.com/w/cpp/error/terminate" class="" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Aterminate%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D">std::terminate</a></i>-Aufruf. <i>std::terminate</i> ruft den <i><a class="" alt="%7B%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate_handler%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ferror%2Fterminate_handler%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Aterminate_handler%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" href="http://en.cppreference.com/w/cpp/error/terminate_handler" title="Link auf http://en.cppreference.com/w/cpp/error/terminate_handler">std::terminate_handler</a></i> auf. Dieser ruft wiederum <i><a class="" alt="%7B%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fprogram%2Fabort%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22std%3A.abort%22%2C%22custom%22%3A%7B%7D%7D" href="http://en.cppreference.com/w/cpp/utility/program/abort" title="Link auf http://en.cppreference.com/w/cpp/utility/program/abort">std:.abort</a></i> auf, und dein Programm beendet sich unmittelbar. Indem man eine Funktion als <i>void func() noexcept;</i> deklariert, legst man das folgende Verhalten beim Auftreten einer Ausnahme fest:</li><ul><li>Meine Funktion wirft keine Ausnahme.</li><li>Wenn meine Funktion eine Ausnahme wirft, kümmere ich mich nicht darum und beende sofort das Programm.</li></ul></ul></div>
<div class="text">Der Grund, dass man deinen Destruktor explizit als <i>noexcept</i> deklarieren sollte, ist ziemlich offensichtlich. Es gibt keinen Königsweg, fehlerfreien Code zu schreiben, falls der Destruktor eine Ausnahme werfen darf. Falls alle Mitglieder einer Klasse einen <i>noexcept-</i>Destruktor besitzen, ist der benutzerdefinierte und der vom Compiler automatisch erzeugte Destruktor implizit<i> noexcept</i>.</div>
<div class="ztitel">Weiterführende Informationen:</div>
<div class="text"><ul><li> Nuller- und Fünferregel: <a title="Link auf https://www.heise.de/-3813435" href="https://www.heise.de/-3813435" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3813435%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" class="">https://www.heise.de/-3813435</a></li><li>RAII (Resource Acquisition Is Initialization): <a title="Link auf http://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" href="http://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" class="" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Garbage%20Collection%20%5B--%5D%20No%20Thanks%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D">Garbage Collection [--] No Thanks</a></li><li>Smart Pointer in C++: <a alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Smart%20Pointer%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fsmart-pointer%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" class="" href="http://www.grimm-jaud.de/index.php/blog/tag/smart-pointer" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/smart-pointer">Smart Pointer</a></li></ul></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Vielleicht hört es sich ein wenig seltsam an, aber nach den Regeln für Destruktoren kommen in den Guidelines die für Konstruktoren. Genau um diese 10 Regeln für Konstruktoren geht es im nächsten Artikel.</div>
<div class="ztitel">Frisch veröffentlicht: Mein neues Buch "Concurrency with Modern C++" </div>
<div class="text">"Concurrency with Modern C++" stellt auf gut 300 Seiten und mehr als hundert Beispiel Gleichzeitigkeit mit modernem C++ vor. Um den Jahreswechsel wird es wohl auch in Deutsch und Koreanisch erhältlich sein. Hier sind ein paar Wort zum Inhalt.</div>
<div class="text">"Concurrency with Modern C++ is a journey through current and upcoming concurrency in C++".<br> </div>
<div class="text"><ul><li><b>C++11 </b>and <b>C++14 </b>have the basic building blocks for creating concurrent or parallel programs.</li><li>With <b>C++17</b> we got the parallel algorithms of the Standard Template Library (STL). That means, most of the algorithms of the STL can be executed sequential, parallel, or vectorized.</li><li>The concurrency story in C++ goes on. With <b>C++20</b> we can hope for extended futures, coroutines, transactions, and more. <img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_140272654_ad6ded5fac.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=3>" style="max-height: 25px; max-width: 25px;"> <br></li></ul></div>
<div class="text">Genauere Details liefert der Link: <a class="" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fleanpub.com%2Fconcurrencywithmodernc%22%2C%22href%22%3A%22https%3A%2F%2Fleanpub.com%2Fconcurrencywithmodernc%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22https%3A%2F%2Fleanpub.com%2Fconcurrencywithmodernc%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" href="https://leanpub.com/concurrencywithmodernc" title="Link auf https://leanpub.com/concurrencywithmodernc">https://leanpub.com/concurrencywithmodernc</a><br></div>
