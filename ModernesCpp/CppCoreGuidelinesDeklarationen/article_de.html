<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_146518875_37f58dfe9c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Es gibt relativ viele Regeln für Ausdrücke und Anweisungen in den C++ Core Guidelines. Um genau zu sein, mehr als 50 Regeln beschäftigen sich mit Deklarationen, Ausdrücken, Anweisungen und arithmetischen Ausdrücken.</div>
<div class="text">Ich vergaß, zwei Regeln zu erwähnen, die schlicht <i>general</i> genannt werden. Mit diesen beginnt dieser Artikel. </div>
<div class="text"><b><a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lib" class="" alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.1%3A%20Prefer%20the%20standard%20library%20to%20other%20libraries%20and%20to%20%5C%22handcrafted%20code%5C%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-lib%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-lib%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lib">ES.1: Prefer the standard library to other libraries and to "handcrafted code"</a></b></div>
<div class="text">Es gibt keinen Grund, die Summe eines Vektors von Fließkommazahlen mit einer expliziten Schleife zu berechnen:</div>
<div class="pre">int max = v.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad: verbose, purpose unstated<br>double sum = 0.0;<br>for (int i = 0; i &lt; max; ++i)<br>&nbsp;&nbsp;&nbsp; sum = sum + v[i];</div>
<div class="text">Verwende einfach den <i>std::accumulate</i>-Algorithmus der STL:</div>
<div class="pre">auto sum = std::accumulate(begin(a), end(a), 0.0); // good</div>
<div class="text">Diese Regel erinnert mich an einen Satz von Sean Parent auf der CppCon 2013: "If you want to improve the code quality in your organization, replace all your coding guidelines with one goal: No raw loops!"</div>
<div class="text">Oder um es ein wenig direkter auszudrücken: Falls du eine nackte Schleife verwendest, kennst du vermutlich die Algorithmen der STL nicht gut genug. </div>
<div class="text"><b><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-abstr" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-abstr%22%2C%22text%22%3A%22ES.2%3A%20Prefer%20suitable%20abstractions%20to%20direct%20use%20of%20language%20features%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-abstr%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-abstr" class="">ES.2: Prefer suitable abstractions to direct use of language features</a></b> <br></div>
<div class="text">Das nächste Déjà vu. In einem meiner letzten C++-Seminare gab es eine lange Diskussion, gefolgt von einer noch längeren Analyse zu ein paar ziemlich cleveren Funktionen für das Lesen und Schreiben eines <a title="Link auf http://en.cppreference.com/w/cpp/io/strstream" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22strstreams%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fio%2Fstrstream%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fio%2Fstrstream%22%7D" href="http://en.cppreference.com/w/cpp/io/strstream">strstreams</a>. Die Teilnehmer mussten diese Funktionen verstehen und erweitern, um ihren Legacy-Code zu pflegen. Ihr Kampf ging schon in die zweite Woche. <br></div>
<div class="text">Ihr größtes Hindernis, die bestehende Funktionen zu verstehen, bestand darin, dass diese nicht die richtige Abstraktion verwendeten. </div>
<div class="text">Betrachte die selbst gestrickte Funktion für das Lesen eines <i>std::istream</i>: <br></div>
<div class="pre">char** read1(istream&amp; is, int maxelem, int maxstring, int* nread)&nbsp;&nbsp; // bad: verbose and incomplete<br>{<br>&nbsp;&nbsp;&nbsp; auto res = new char*[maxelem];<br>&nbsp;&nbsp;&nbsp; int elemcount = 0;<br>&nbsp;&nbsp;&nbsp; while (is &amp;&amp; elemcount &lt; maxelem) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto s = new char[maxstring];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is.read(s, maxstring);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res[elemcount++] = s;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; nread = &amp;elemcount;<br>&nbsp;&nbsp;&nbsp; return res;<br>}</div>
<div class="text">Im Gegensatz zu der schwer verdaulichen Funktion <i>read1</i> ist die Funktion <i>read2</i> deutlich bekömmlicher:</div>
<div class="pre">vector&lt;string&gt; read1(istream&amp; is)&nbsp;&nbsp; // good<br>{<br>&nbsp;&nbsp;&nbsp; vector&lt;string&gt; res;<br>&nbsp;&nbsp;&nbsp; for (string s; is &gt;&gt; s;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.push_back(s);<br>&nbsp;&nbsp;&nbsp; return res;<br>}<br></div>
<div class="text">Die richtige Abstraktionen bedeutet öfters, dass du dir keine Gedanken zu den Besitzverhältnissen wie in der Funktion <i>read2</i> zu machen brauchst. Das gilt aber nicht für die Funktion <i>read1</i>. Der Aufrufer der Funktion <i>read1</i> ist der Besitzer von <i>result </i>und muss es konsequenterweise auch löschen. </div>
<div class="text">Eine Deklaration führt einen Namen in einen Bereich ein. Um ehrlich zu sein, ich bin zwiegespalten. Einerseits könnten die folgenden Regeln ein wenig langweilig für den Leser sein, denn sie sind recht offensichtlich. Anderseits kenne ich viele Codebasen, die diese Regeln permanent brechen. Zum Beispiel hatte ich erst vor kurzem die Diskussion mit einem ehemaligen Fortran-Programmierer, der behauptete, dass jeder Variablenname aus genau drei Buchstaben bestehen solle. </div>
<div class="text">Egal, ich werde die nächsten Regeln vorstellen, den gute Namen sind der entscheidende Grund, damit Code lesbar, verständlich, pflegbar, erweiterbar ist und bleibt.</div>
<div class="text">Hier sind die ersten sechs Regeln.</div>
<div class="text"><b><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-scope" alt="%7B%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-scope%22%2C%22text%22%3A%22ES.5%3A%20Keep%20scopes%20small%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-scope%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-scope" class="">ES.5: Keep scopes small</a></b> <br></div>
<div class="text">Halte Bereiche so klein, dass sie auf den Bildschirm passen. Damit erhältst du sofort eine Idee, was in dem Code steckt. Falls der Bereich zu groß wird, solltest du deinen Code in Funktionen und Objekte strukturieren. Identifiziere dazu logische Einheiten und verwende selbsterklärende Funktionsname in deiner Refaktorisierung. Danach ist es wieder deutlich einfacher, den Code zu verstehen.</div>
<div class="text"><b><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-cond" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-cond%22%2C%22text%22%3A%22ES.6%3A%20Declare%20names%20in%20for-statement%20initializers%20and%20conditions%20to%20limit%20scope%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-cond%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-cond" class="">ES.6: Declare names in for-statement initializers and conditions to limit scope</a></b> <br></div>
<div class="text">Seit dem ersten C++-Standard können wir Variablen direkt in einer <i>for</i>-Schleife deklarieren. Mit C++17 können wir das sogar in einer <i>if</i>- oder <i>switch</i>-Anweisung:&nbsp; <br></div>
<div class="pre">std::map&lt;int,std::string&gt; myMap;<br><br>if (auto result = myMap.insert(value); result.second){&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; useResult(result.first); &nbsp;<br>&nbsp;&nbsp;&nbsp; // ...<br>} <br>else{<br>&nbsp;&nbsp;&nbsp; // ...<br>} // result is automatically destroyed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)</div>
<div class="text">Die Variable <i>result</i> (1) ist nur im Bereich des <i>if-</i> und <i>else</i>-Zweigs der <i>if</i>-Anweisung gültig. <i>result</i> verschmutzt nicht den umgebenden Bereich und wird automatisch zerstört (2). Das war vor C++17 nicht möglich. <i>result</i> musste in diesem Fall im umgebenden Bereich deklariert werden (3):</div>
<div class="pre">std::map&lt;int,std::string&gt; myMap;<br>auto result = myMap.insert(value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>if (result.second){&nbsp; <br>&nbsp;&nbsp;&nbsp; useResult(result.first);&nbsp; <br>&nbsp;&nbsp;&nbsp; // ...<br>} <br>else{<br>&nbsp;&nbsp;&nbsp; // ...<br>} </div>
<div class="text"><b><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-name-length" class="" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-name-length" alt="%7B%22text%22%3A%22ES.7%3A%20Keep%20common%20and%20local%20names%20short%2C%20and%20keep%20uncommon%20and%20nonlocal%20names%20longer%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-name-length%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-name-length%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D">ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer</a></b> <br></div>
<div class="text">Obwohl sich diese Regel zuerst einmal seltsam anhört, wenden wir sie schon lange an. Indem du eine Variable <i>i </i>oder<i> j </i>nennst oder ihr den Namen <i>T </i>gibst, machst du deine Absicht sofort klar: <i>i</i> und <i>j </i>sind Indizes, und <i>T </i>ist ein Typ-Parameter eines Templates:<br></div>
<div class="pre">template&lt;typename T&gt;&nbsp;&nbsp;&nbsp; // good<br>void print(ostream&amp; os, const vector&lt;T&gt;&amp; v)<br>{<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; v.size(); ++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os &lt;&lt; v[i] &lt;&lt; '\n';<br>}</div>
<div class="text">Hinter dieser Regel verbirgt sich eine Metaregel. Ein Name sollte selbsterklärend sein. In einem kleinen Bereich ist auf einen Blick ersichtlich, für was der Name steht. Das gilt aber nicht automatisch für einen größeren Kontext, der mehrere Bereiche umfasst. Daher werden diese Variablennamen länger sein.&nbsp; </div>
<div class="text"><b><a alt="%7B%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-name-similar%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.8%3A%20Avoid%20similar-looking%20names%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-name-similar%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-name-similar" class="" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-name-similar">ES.8: Avoid similar-looking names</a></b> <br></div>
<div class="text">Kannst du das Beispiel lesen, ohne mit der Wimper zu zucken?<br></div>
<div class="pre">if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();</div>
<div class="text">Um ehrlich zu sein, ich habe öfters Probleme mit der Zahl 0 und dem großen Buchstaben O. Abhängig vom verwendeten Font können die beiden Zeichen sehr ähnlich aussehen. Vor kurzer Zeit benötigte ich mehrere Versuche, mich in einen Server einzuloggen. Das automatisch erzeugte Passwort enthielt das Zeichen O. </div>
<div class="text"><b><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-not-CAPS" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-not-CAPS%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.9%3A%20Avoid%20ALL_CAPS%20names%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-not-CAPS%22%7D" class="" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-not-CAPS">ES.9: Avoid ALL_CAPS names</a></b> <br></div>
<div class="text">Falls du<i> All_CAPS</i> verwendest, besteht immer die Gefahr von Makrosubstitutionen, da <i>ALL_CAPS</i> typischerweise für Makros verwendet werden. Daher ist das folgende Programmschnipsel immer für eine Überraschung gut:<br></div>
<div class="pre">// somewhere in some header:<br>#define NE !=<br><br>// somewhere else in some other header:<br>enum Coord { N, NE, NW, S, SE, SW, E, W };<br><br>// somewhere third in some poor programmer's .cpp:<br>switch (direction) {<br>case N:<br>&nbsp;&nbsp;&nbsp; // ...<br>case NE:<br>&nbsp;&nbsp;&nbsp; // ...<br>// ...<br>}</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-name-one" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-name-one" alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-name-one%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-name-one%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.10%3A%20Declare%20one%20name%20%28only%29%20per%20declaration%22%7D">ES.10: Declare one name (only) per declaration</a></b> <br></div>
<div class="text">Hier kommt ein Beispiel. Findest du die zwei Probleme?<br></div>
<div class="pre">char* p, p2;<br>char a = 'a';<br>p = &amp;a;<br>p2 = a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>int a = 7, b = 9, c, d = 10, e = 3;&nbsp; // (2)</div>
<div class="text"><i>p2</i> ist kein Zeiger, aber ein <i>char</i> (1) und <i>c</i> ist nicht initialisiert (2).</div>
<div class="text">Mit C++11 erhalten wir eine Ausnahme der Regeln: strukturierte Bindung. Damit lässt sich die <i>if</i>-Anweisung mit Initialisierer aus der Regel ES.6 sauberer und lesbarer schreiben:<br></div>
<div class="pre">std::map&lt;int,std::string&gt; myMap;<br><br>if (auto [iter, succeeded] = myMap.insert(value); succedded){&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; useResult(iter);&nbsp; <br>&nbsp;&nbsp;&nbsp; // ...<br>} <br>else{<br>&nbsp;&nbsp;&nbsp; // ...<br>} // iter and succeeded are automatically destroyed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Es gibt noch einige Regeln zur Deklaration von Namen. Genau von diesen handelt mein nächster Artikel.</div>
