<div class="vorspann">Concurrency bietet viele Wege an, sich in den eigenen Fuß zu schießen. Die Regeln des heutigen Artikels sollen helfen, diese Gefahren zu kennen und zu vermeiden.<br></div>
<div class="text">Das sind die drei Regel für den heutigen Artikel:</div>
<div class="text"><ul> <li> <a alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data-by-value%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data-by-value%22%2C%22text%22%3A%22CP.31%3A%20Pass%20small%20amounts%20of%20data%20between%20threads%20by%20value%2C%20rather%20than%20by%20reference%20or%20pointer%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data-by-value" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data-by-value">CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer</a> </li> <li> <a alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.32%3A%20To%20share%20ownership%20between%20unrelated%20threads%20use%20shared_ptr%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-shared%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-shared%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-shared" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-shared" class="">CP.32: To share ownership between unrelated threads use shared_ptr</a> </li> <li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-create" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-create" alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-create%22%2C%22text%22%3A%22CP.41%3A%20Minimize%20thread%20creation%20and%20destruction%5Ct%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-create%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D">CP.41: Minimize thread creation and destruction→</a></li></ul></div>
<div class="text">Es gibt noch weitere Regeln, die ich aber ignoriere, da sie zum jetzigen Zeitpunkt keinen Inhalt besitzen. <br></div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data-by-value" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data-by-value" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data-by-value%22%2C%22text%22%3A%22CP.31%3A%20Pass%20small%20amounts%20of%20data%20between%20threads%20by%20value%2C%20rather%20than%20by%20reference%20or%20pointer%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data-by-value%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D">CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer</a><br></div>
<div class="text">Diese Regel ist sehr naheliegend, daher kann ich mich kurz und bündig halten. Wenn du deine Daten per Copy an den Thread übergibst, besitzt dies zwei unmittelbare Vorteile:</div>
<div class="text"><ol><li>Die Daten werden nicht geteilt, und damit sind Data Races nicht möglich. Die Bedingungen an ein Data Race ist geteilter, veränderlicher Zustand. Hier sind die Details: "<a alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regeln%20zur%20Concurrency%20und%20zur%20Parallelit%C3%A4t%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dae8bb5fc891a3b9effed9c0f867f62f8%26rm%3Dopen_article_id%26bid%3D2412302%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22B%22%2C%22destination%22%3A2412302%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" class="" href="/exec/mainmenu.pl?sid=ae8bb5fc891a3b9effed9c0f867f62f8&amp;rm=open_article_id&amp;bid=2412302" title="Link auf Beitrag 2412302">C++ Core Guidelines: Regeln zur Concurrency und zur Parallelität</a>".</li><li>Du musst dir keine Gedanken zur Gültigkeit deiner Variablen machen. Die Gültigkeit der Daten ist an die Gültigkeit des erzeugten Threads gebunden. Dies ist insbesondere wichtig, wenn du auf dem neuen Thread detach aufrufst: "<a alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A2428301%2C%22type%22%3A%22B%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dae8bb5fc891a3b9effed9c0f867f62f8%26rm%3Dopen_article_id%26bid%3D2428301%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Sich%20um%20Kinder-Threads%20k%C3%BCmmern%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="" href="/exec/mainmenu.pl?sid=ae8bb5fc891a3b9effed9c0f867f62f8&amp;rm=open_article_id&amp;bid=2428301" title="Link auf Beitrag 2428301">C++ Core Guidelines: Sich um Kinder-Threads kümmern</a>".</li></ol></div>
<div class="text">Natürlich habe ich noch nicht die entscheidende Frage dieser Regel beantwortet: Was heißt eine kleine Datenmenge angesichts eines Threads? Die C++ Core Guidelines geben hier keine eindeutige Aussage. In der Regel&nbsp;<a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-in" class="" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-in" alt="%7B%22text%22%3A%22F.16%20For%20%C2%93in%C2%94%20parameters%2C%20pass%20cheaply-copied%20types%20by%20value%20and%20others%20by%20reference%20to%20const%20to%20functions%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-in%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rf-in%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D">F.16 For “in” parameters, pass cheaply-copied types by value and others by reference to const to functions</a>&nbsp;stellen sie die folgende Daumenregel <i>4 * sizeof(int)</i> als Entscheidungsregel auf. Das heißt, wenn die Daten kleiner als <i>4 * sizeof(int) </i>sind, sollten sie kopiert werden. Andernfalls, sollen sie mit einem Zeiger oder einer Referenz übergeben werden.</div>
<div class="text">Um die sichere Antwort zu erhalten, führt letztlich kein Weg an einer Performanzmessung vorbei.</div>
<div class="ztitel_kleiner"><a alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.32%3A%20To%20share%20ownership%20between%20unrelated%20threads%20use%20shared_ptr%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-shared%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-shared%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-shared" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-shared" class="">CP.32: To share ownership between unrelated threads use shared_ptr</a><br></div>
<div class="text">Stelle dir vor, du besitzt Objekte, die du zwischen Threads teilen willst. Die entscheidende Frage ist nun: Wer ist der Besitzer des Objekts und damit für das Freigeben des Speichers verantwortlich? Nun stehen zwei Optionen zur Wahl. Wenn du den Speicher nicht freigibst, erhältst du ein Speicherleck. Wenn du den Speicher mehrmals freigibst, besitzt dein Programm undefiniertes Verhalten. Meist wird dies undefinierte Verhalten in einem Absturz zur Laufzeit des Programms enden:<br></div>
<div class="pre">// threadSharesOwnership.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>using namespace std::literals::chrono_literals;<br><br>struct MyInt{<br>&nbsp; int val{2017};<br>&nbsp; ~MyInt(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Good Bye" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>void showNumber(MyInt* myInt){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myInt-&gt;val &lt;&lt; std::endl;<br>}<br><br>void threadCreator(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; MyInt* tmpInt= new MyInt; <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::thread t1(showNumber, tmpInt);&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::thread t2(showNumber, tmpInt);&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; t1.detach();<br>&nbsp;&nbsp;&nbsp; t2.detach();<br>}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; threadCreator();<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Habe Geduld! Das Programm ist absichtlich sehr einfach gehalten. Ich habe den <i>main</i>-Thread nur für eine Sekunde schlafen gelegt, um sicher zu gehen, dass den Threads <i>t1</i> und <i>t2</i> genug Zeit für ihr Arbeitspaket bleibt. Dies ist natürlich keine angemessene Synchronisation, hilft mir aber, mich auf meinen zentralen Punkt zu fokussieren. Der zentrale Punkt ist: Wer ist verantwortlich für die Freigabe von <i>tmpInt</i> (1)? Der Thread <i>t1 </i>(2), der Thread <i>t2</i> (3) oder die Funktion (1) (<i>main</i>-Thread) selbst? Da ich nicht vorhersagen kann, welcher Thread am längsten benötigt, habe ich mich für ein Speicherleck entschieden. Konsequenterweise wird der Destruktor von <i>MyInt</i> (4) nie aufgerufen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153439841_4475b910cc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die ganzen Lebenszeitherausforderungen sind sehr angenehm zu lösen, wenn ich einen <i>std::shared_ptr </i>einsetze.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153439846_e4c84c60a8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="pre">// threadSharesOwnershipSharedPtr.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br>#include &lt;thread&gt;<br><br>using namespace std::literals::chrono_literals;<br><br>struct MyInt{<br>&nbsp; int val{2017};<br>&nbsp; ~MyInt(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Good Bye" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>void showNumber(std::shared_ptr&lt;MyInt&gt; myInt){&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; myInt-&gt;val &lt;&lt; std::endl;<br>}<br><br>void threadCreator(){<br>&nbsp;&nbsp;&nbsp; auto sharedPtr = std::make_shared&lt;MyInt&gt;();&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::thread t1(showNumber, sharedPtr);<br>&nbsp;&nbsp;&nbsp; std::thread t2(showNumber, sharedPtr);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; t1.detach();<br>&nbsp;&nbsp;&nbsp; t2.detach();<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; threadCreator();<br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Zwei kleine Änderungen am Sourcecode waren notwendig. Zuerst wurde der Zeiger in (1) zum <i>std::shared_ptr</i>. Zusätzlich nimmt die Funktion <i>showNumber</i> einen <i>std::shared_ptr</i> statt eines nackten Zeigers an.<br></div>
<div class="ztitel_kleiner"><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-create%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-create%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22CP.41%3A%20Minimize%20thread%20creation%20and%20destruction%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-create" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-create">CP.41: Minimize thread creation and destruction</a></div>
<div class="text">Wie teuer ist ein Thread? Ziemlich teuer! Dies ist der Grund für diese Regel. Zuerst will ich über die Größe eines Threads und dann über die Kosten seiner Erzeugung schreiben. </div>
<div class="text"><b><span class="tx_larger">Größe</span></b></div>
<div class="text">Ein<i> std::thread </i>ist ein dünner Wrapper um den zugrunde liegenden, nativen Thread. Das heißt, dass ich mich für die Größe eines Windows-Thread und eines <a title="Link auf https://en.wikipedia.org/wiki/POSIX_Threads" href="https://en.wikipedia.org/wiki/POSIX_Threads" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPOSIX_Threads%22%2C%22text%22%3A%22POSIX-Thread%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPOSIX_Threads%22%7D">POSIX-Thread</a> interessiere. </div>
<div class="text"><ul><li> Windows-System: Die Antwort gibt der Artikel "<a class="" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686774(v=vs.85).aspx" title="Link auf https://msdn.microsoft.com/en-us/library/windows/desktop/ms686774(v=vs.85).aspx" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fwindows%2Fdesktop%2Fms686774%28v%3Dvs.85%29.aspx%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fwindows%2Fdesktop%2Fms686774%28v%3Dvs.85%29.aspx%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Thread%20Stack%20Size%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">Thread Stack Size</a>": 1 MByte.</li><li>POSIX- System: In diesem Fall hilft die <a alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman3%2Fpthread_create.3.html%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman3%2Fpthread_create.3.html%22%2C%22text%22%3A%22man-page%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://man7.org/linux/man-pages/man3/pthread_create.3.html" class="" href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">man-page</a> zu der Funktion <i>pthread_create: </i>2 MByte. Dies ist die Größe für i386- und x86_64-Architekturen. Falls du die Größen zu weiteren Architekturen wissen willst, die den POSIX-Standard umsetzen, sind hier die Details.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153439853_5aff8f13bb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><b><span class="tx_larger">Erzeugung</span></b></div>
<div class="text">Ich habe keine Zahlen für die Kosten zur Erzeugung eines Threads gefunden. Um aber ein Gefühl dafür zu bekommen, führe ich einen einfachen Performanztest auf Linux und Windows durch.<br></div>
<div class="text">Für meinen Performanztest kommt der GCC 6.2.1 auf einem Desktop-PC und die <i>cl.exe</i> auf einem Windows-Laptop zum Einsatz. Die <i>cl.exe</i> ist Bestandteil von Microsoft Visual Studio 2017. Ich übersetze das Programm mit maximaler Optimierung. Das bedeutet auf Linux das Flag <i>O3</i> und auf Windows das Flag <i>Ox</i>. <br></div>
<div class="text">Hier ist das kleine Testprogramm:</div>
<div class="pre">// threadCreationPerformance.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>static const long long numThreads= 1'000'000;<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; auto start = std::chrono::system_clock::now();<br><br>&nbsp;&nbsp;&nbsp; for (volatile int i = 0; i &lt; numThreads; ++i) std::thread([]{}).detach();<br><br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; dur= std::chrono::system_clock::now() - start;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "time: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Das Programm erzeugt eine Millionen Threads, die eine leere Lambda-Funktion (1) ausführen. Dies sind die Zahlen für Linux und Windows. </div>
<div class="text"><b>Linux:</b></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153439856_ee687ef85b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><b><br></b></div>
<div class="text">Das heißt, die Erzeugung eines Thread kostet ungefähr 14,5 sec/1.000.000 = <b>14,5 Mikrosekunden auf Linux.</b><br></div>
<div class="text"><b>Windows:</b></div>
<div class="text"><b><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153439865_cf4a7280e3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"> <br></b></div>
<div class="text">Die Erzeugung eines Threads schlägt mit 44 sec/1.000.000 = <b>44 Mikrosekunden auf Windows</b> zu Buche.<br></div>
<div class="text"><b>Somit lassen sich 69 Tausend Threads auf Linux und 23 Tausend Threads auf Windows in einer Sekunden erzeugen. </b></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Was ist der einfachste Weg, sich in den Fuß zu schießen? Verwende eine Bedingungsvariable! Du glaubst mir nicht? Warte auf den nächsten Artikel!<br></div>