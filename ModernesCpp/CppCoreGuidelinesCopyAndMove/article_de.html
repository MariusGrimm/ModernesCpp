<div class="vorspann">Die Regeln für das Kopieren und das Verschieben von Objekten sind ziemlich offensichtlich. Bevor ich sie aber vorstelle, muss ich erst auf die letzten zwei verbleibenden Regeln für Konstruktoren eingehen. Diese beschäftigen sich mit dem delegieren und vererben von Konstruktoren.</div>
<div class="text">Hier sind die zwei verbleibenden Regeln:</div>
<div class="ztitel">Regeln für Konstruktoren </div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_141038176_10ed48a466.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-delegating" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.51%3A%20Use%20delegating%20constructors%20to%20represent%20common%20actions%20for%20all%20constructors%20of%20a%20class%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-delegating%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-delegating%22%2C%22ir_link%22%3A1%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-delegating">C.51: Use delegating constructors to represent common actions for all constructors of a class</a> </div>
<div class="text">Seit C++11 kann ein Konstruktor seine Arbeit an einen anderen Konstruktor der gleichen Klasse delegieren. Das ist die moderne Variante, gemeinsame Aktionen aller Konstruktoren in einen Konstruktor zu verschieben. In C++ Code vor C++11 kam dazu typischerweise eine Methode mit dem Name <i>init</i> zum Einsatz.</div>
<div class="pre">class Degree{<br>public:<br>&nbsp; Degree(int deg){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; degree= deg % 360;<br>&nbsp;&nbsp;&nbsp; if (degree &lt; 0) degree += 360;<br>&nbsp; }<br><br>&nbsp; Degree(): Degree(0){}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; Degree(double deg): Degree(static_cast&lt;int&gt;(ceil(deg))){}&nbsp; // (3)<br><br>private:<br>&nbsp; int degree;<br>};</div>
<div class="text">Die Konstruktoren (2) und (3) delegieren ihre Aufgabe an den Konstruktor (1), der seine Argumente prüft. Konstruktoren rekursiv aufzurufen stellt undefiniertes Verhalten dar.</div>
<div class="ztitel_kleiner"><a alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-inheriting%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.52%3A%20Use%20inheriting%20constructors%20to%20import%20constructors%20into%20a%20derived%20class%20that%20does%20not%20need%20further%20explicit%20initialization%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-inheriting%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-inheriting" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-inheriting">C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization</a></div>
<div class="text">Falls du Konstruktoren der Basis-Klasse in der abgeleiteten Klasse wiederverwenden kannst, tue es. Falls du sie nicht wiederverwendest, verletzt du das <a title="Link auf https://de.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself" href="https://de.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself" class="" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FDon%25E2%2580%2599t_repeat_yourself%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FDon%25E2%2580%2599t_repeat_yourself%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22DRY%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%7D">DRY</a> (Don'T Repeat Yourself) Prinzip.</div>
<div class="pre">class Rec {<br>&nbsp;&nbsp;&nbsp; // ... data and lots of nice constructors ...<br>};<br><br>class Oper : public Rec {<br>&nbsp;&nbsp;&nbsp; using Rec::Rec;<br>&nbsp;&nbsp;&nbsp; // ... no data members ...<br>&nbsp;&nbsp;&nbsp; // ... lots of nice utility functions ...<br>};<br><br>struct Rec2 : public Rec {<br>&nbsp;&nbsp;&nbsp; int x;<br>&nbsp;&nbsp;&nbsp; using Rec::Rec;<br>};<br><br>Rec2 r {"foo", 7};<br>int val = r.x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // uninitialized&nbsp; (1) </div>
<div class="text">Beim Vererben von Konstruktoren lauert immer eine Gefahr. Falls die abgeleitete Klasse wie <i>Rec2</i> eigene Datenmitglieder besitzt, werden diese nicht initialisiert (1).</div>
<div class="ztitel">Kopieren und Verschieben</div>
<div class="text">Dieses Abschnitt beginnt mit einer Meta-Regel. Values types, auch bekannt als Datentypen, die sich wie ints verhalten, sollten kopierbar sein, aber Interfaces in Klassenhierarchien nicht. Die letzte Regel C.67 bezieht sich auf diese Meta-Regel.</div>
<div class="text">Hier sind die acht Regeln:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_141038182_ab2a79f481.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=3>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-assignment" alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-assignment%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.60%3A%20Make%20copy%20assignment%20non-virtual%2C%20take%20the%20parameter%20by%20const%26amp%3B%2C%20and%20return%20by%20non-const%26amp%3B%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-assignment%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-assignment" class="">C.60: Make copy assignment non-virtual, take the parameter by const&amp;, and return by non-const&amp;</a> <br></li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-semantic%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.61%3A%20A%20copy%20operation%20should%20copy%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-semantic%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-semantic" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-semantic">C.61: A copy operation should copy</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-self" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-self%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-self%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.62%3A%20Make%20copy%20assignment%20safe%20for%20self-assignment%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-self">C.62: Make copy assignment safe for self-assignment</a> <br></li><li> <a alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-assignment%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-assignment%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.63%3A%20Make%20move%20assignment%20non-virtual%2C%20take%20the%20parameter%20by%20%26amp%3B%26amp%3B%2C%20and%20return%20by%20non-const%26amp%3B%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-assignment" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-assignment">C.63: Make move assignment non-virtual, take the parameter by &amp;&amp;, and return by non-const&amp;</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-semantic" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.64%3A%20A%20move%20operation%20should%20move%20and%20leave%20its%20source%20in%20a%20valid%20state%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-semantic%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-semantic%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-semantic" class="">C.64: A move operation should move and leave its source in a valid state</a> <br></li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-self" alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.65%3A%20Make%20move%20assignment%20safe%20for%20self-assignment%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-self%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-self%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-self">C.65: Make move assignment safe for self-assignment</a> <br></li><li> <a alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-noexcept%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.66%3A%20Make%20move%20operations%20noexcept%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-noexcept%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept">C.66: Make move operations noexcept</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-virtual" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-virtual%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.67%3A%20A%20base%20class%20should%20suppress%20copying%2C%20and%20provide%20a%20virtual%20clone%20instead%20if%20%C2%93copying%C2%94%20is%20desired%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-virtual%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-virtual" class="">C.67: A base class should suppress copying, and provide a virtual clone instead if “copying” is desired</a></li></ul></div>
<div class="text">Die ersten sechs Regeln fürs kopieren und verschieben von Objekten bestehen aus drei sehr ähnlichen Paaren; daher werde ich sie zusammen darstellen.</div>
<div class="text"><ul><li> <b>C.60</b> und <b>C.63 </b>fordert, dass der Copy- (Move-) Zuweisungsoperator nicht virtuell sein und seine Argumente per nicht-konstanter Referenz zurückgeben soll. Es besteht nur ein Unterschied, wie er sein Parameter annehmen soll.</li><ul><li>Copy-Zuweisung soll seine Parameter als <b>konstante Lvalue Referenz (&amp;)</b> annehmen, denn dadurch kann die Quelle der Zuweisung nicht verändert werden.</li><li>Move-Zuweisung soll seine Parameter als <b>nicht-konstante Rvalue Referenz (&amp;&amp;)</b> annehmen, denn die Quelle der Zuweisung wird bei der Operation verändert. <br></li><li>Beide Regeln beschreiben genau das Muster, dem die Zuweisungsoperatoren der Standard Template Library folgen. Hier ist ein vereinfachender Blick auf <i>std::vector</i>:</li></ul></ul></div>
<div class="pre">vector&amp; operator=( const vector&amp; other ); &nbsp;&nbsp;&nbsp; <br>vector&amp; operator=( vector&amp;&amp; other );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (since C++11, until C++17)<br>vector&amp; operator=( vector&amp;&amp; other ) noexcept&nbsp; // since C++17)</div>
<div class="text"><ul><li><b>C.61</b> und <b>C.64 </b>sagen aus, das ein Kopier- (Verschiebe-) Operation tatsächlichen kopieren (verschieben) soll. Das ist die erwartete Semantik für a = b.</li><ul><li>Im Falle des Kopierens bedeutet dies, dass nach dem Kopieren von a und b (a = b) gelten muss, dass beide Werte identisch sind: (a == b).</li><li>Kopieren kann tief (shallow) oder flach (shallow) sein. Tiefes Kopieren bedeutet, dass nach dem Kopieren zwei unabhängige Objekte vorhanden sind (<a title="Link auf https://isocpp.org/wiki/faq/value-vs-ref-semantics" class="" href="https://isocpp.org/wiki/faq/value-vs-ref-semantics" alt="%7B%22destination%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fvalue-vs-ref-semantics%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fvalue-vs-ref-semantics%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22value%20semantic%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">value semantic</a>). Flaches Kopieren bedeutet, dass sich a und b nach dem Kopieren ein gemeinsames Objekt teilen (<a alt="%7B%22href%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fvalue-vs-ref-semantics%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22reference%20semantic%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fvalue-vs-ref-semantics%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" href="https://isocpp.org/wiki/faq/value-vs-ref-semantics" class="" title="Link auf https://isocpp.org/wiki/faq/value-vs-ref-semantics">reference semantic</a>).</li><li>Die Regel C.64 fordert weiter, dass das <i>move-from</i> Objekt danach in einem gültigen Zustand sein soll. Oft ist dies der Defaultzustand der Quelle. Der C++ Standard verlangt, das ein<i> moved-from</i> Objekt danach in einem unspezifizierten, aber gültigen Zustand sein muss.</li></ul></ul></div>
<div class="text"><ul><li><b>C.62 </b>und <b>C.65</b> sind sich einig. Copy- (Move-) Zuweisung sollte vor Selbstzuweisung schützen. Ein Aufruf x = x soll den Wert von x nicht ändern. <br></li><ul><li>Copy- (Move-) Zuweisung schützt für die Container der Standard Template Library, <i>std::string </i>und die fundamentalen Datentypen&nbsp; vor Selbstzuweisung; daher schützt der automatisch erzeugte Copy- (Move-) Zuweisungsoperator in diesem Fall auch vor Selbstzuweisung. Die gleiche Aussage gilt für einen automatisch erzeugen Copy- (Move-) Zuweisungsoperator, der nur Datentypen verwendet, die sicher vor Selbstzuweisung sind.&nbsp;</li></ul></ul></div>
<div class="pre">class Foo {<br>&nbsp;&nbsp;&nbsp; string s;<br>&nbsp;&nbsp;&nbsp; int i;<br>public:<br>&nbsp; Foo&amp; Foo::operator=(const Foo&amp; a){<br>&nbsp;&nbsp;&nbsp; s = a.s;<br>&nbsp;&nbsp;&nbsp; i = a.i;<br>&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp; }<br>&nbsp; Foo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept {<br>&nbsp;&nbsp;&nbsp; s = std::move(a.s);<br>&nbsp;&nbsp;&nbsp; i = a.i;<br>&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp; }<br>&nbsp; // ....<br>}</div>
<div class="text">In dem Codebeispiel ist kein Test auf Selbstzuweisung notwendig. Hier kommt hingegen eine Version des Datentyps <i>Foo,</i> der uberflüssige (teure) Checks in (1) und (2) auf Selbstzuweisung durchführt.</div>
<div class="pre">class Foo {<br>&nbsp;&nbsp;&nbsp; string s;<br>&nbsp;&nbsp;&nbsp; int i;<br>public:<br>&nbsp; Foo&amp; Foo::operator=(const Foo&amp; a){<br>&nbsp;&nbsp;&nbsp; if (this == &amp;a) return *this;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; s = a.s;<br>&nbsp;&nbsp;&nbsp; i = a.i;<br>&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp; }<br>&nbsp; Foo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept {&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; if (this == &amp;a) return *this;<br>&nbsp;&nbsp;&nbsp; s = std::move(a.s);<br>&nbsp;&nbsp;&nbsp; i = a.i;<br>&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp; }<br>&nbsp; // ....<br>};</div>
<div class="ztitel_kleiner"><a alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-noexcept%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.66%3A%20Make%20move%20operations%20noexcept%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-move-noexcept%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept">C.66: Make move operations noexcept</a></div>
<div class="text">Verschiebe Operationen sollten keine Ausnahme werfen; daher solltest du sie als noexcept deklarieren. Der Move-Konstruktor und -Zuweisungsoperator lässt sich so implementiert, dass er keine Ausnahme werfen kann.</div>
<div class="text">Dies ist das Muster, dass die Verschiebeoperatoren der Standard Template Library umsetzen. Hier ist zum Beispiel <i>std::vector</i>.</div>
<div class="pre">template&lt;typename T&gt;<br>class Vector {<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; Vector(Vector&amp;&amp; a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; }<br>&nbsp;&nbsp;&nbsp; Vector&amp; operator=(Vector&amp;&amp; a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; }<br>&nbsp;&nbsp;&nbsp; // ...<br>public:<br>&nbsp;&nbsp;&nbsp; T* elem;<br>&nbsp;&nbsp;&nbsp; int sz;<br>};</div>
<div class="text">Die letzt Regel verdient mehr Aufmerksamkeit. </div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-virtual" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-virtual" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.67%3A%20A%20base%20class%20should%20suppress%20copying%2C%20and%20provide%20a%20virtual%20clone%20instead%20if%20%C2%93copying%C2%94%20is%20desired%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-virtual%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-copy-virtual%22%7D">C.67: A base class should suppress copying, and provide a virtual clone instead if “copying” is desired</a></div>
<div class="text">Der Hauptgrund für diese Regel ist, dass <i>slicing</i> nicht stattfinden soll. <i>Slicing</i> ist eine der Gefahren in C++, vor dem mich meine Kollegen immer gewarnt haben. Auch Wikipedia hat einen Artikel zu <a title="Link auf https://en.wikipedia.org/wiki/Object_slicing" class="" href="https://en.wikipedia.org/wiki/Object_slicing" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FObject_slicing%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22object%20slicing%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FObject_slicing%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D">object slicing</a> verfasst.</div>
<div class="text">Slicing passiert dann, wenn ein Objekt einer abgeleiteten Klasse einem Objekt einer Basisklasse per Copy zugewiesen wird.</div>
<div class="pre">struct Base { int base_; };<br>&nbsp;<br>struct Derived : Base { int derived_; };<br>&nbsp;<br>int main(){<br>&nbsp; Derived d;<br>&nbsp; Base b = d;&nbsp;&nbsp; // slicing, only the Base parts of (d) are copied<br>}</div>
<div class="text">In diesem Beispiel werden die Copy-Operatoren der Basisklasse verwendet. Das bedeutet natürlich, dass nur die Bestandteile der Basisklasse von <i>d </i>kopiert werden. </div>
<div class="text">Mit der OO-Brille betrachtet, ist eine (<a title="Link auf https://en.wikipedia.org/wiki/Is-a" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22is-a%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FIs-a%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FIs-a%22%2C%22ir_link%22%3A1%7D" href="https://en.wikipedia.org/wiki/Is-a" class="">is-a</a>) Instanz von <i>Derived</i> auch eine Instanz von <i>Base. </i>Das bedeutet, immer wenn du eine Instanz von <i>Base</i> benötigst, kann du auch eine von <i>Derived</i> verwenden. Hier ist Vorsicht geboten. Falls du eine Instanz von <i>Base</i> per Kopie (value-semantic) annimmst, erhältst du nur die <i>Base</i> Anteile von einer Instanz von <i>Derived.</i> </div>
<div class="pre">void needBase(Base b){ .... };<br><br>Derived der;<br>needBase(der);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // slicing kicks in<br></div>
<div class="text">Dies ist die Rettung, die die Guidelines empfehlen: Die Basisklasse soll kopieren nicht unterstützen und eine virtuelle <i>clone</i> Funktion anbieten, falls kopieren notwendig ist. Die Guidelines verdeutlichen die Regel mit einem Beispiel:<br></div>
<div class="pre">class B { // GOOD: base class suppresses copying<br>&nbsp;&nbsp;&nbsp; B(const B&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; B&amp; operator=(const B&amp;) = delete;<br>&nbsp;&nbsp;&nbsp; virtual unique_ptr&lt;B&gt; clone() { return /* B object */; }<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>class D : public B {<br>&nbsp;&nbsp;&nbsp; string more_data; // add a data member<br>&nbsp;&nbsp;&nbsp; unique_ptr&lt;B&gt; clone() override { return /* D object */; }<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>auto d = make_unique&lt;D&gt;();<br>auto b = d.clone(); // ok, deep clone</div>
<div class="text">Die clone Methode gibt das neu erzeugte Objekt in einem std::unique_ptr zurück. Damit gehen die Besitzverhältnisse direkt an den Aufrufer über. Die <i>clone</i> Methode ist unter den Namen Fabrikmethode deutlich bekannter. Eine Fabrikmethode ist eines der Muster aus dem Buch "<a class="" href="https://en.wikipedia.org/wiki/Design_Patterns" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDesign_Patterns%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Design%20Pattern%3A%20Elements%20of%20Reusable%20Object-Oriented%20Software%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDesign_Patterns%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf https://en.wikipedia.org/wiki/Design_Patterns">Design Pattern: Elements of Reusable Object-Oriented Software</a>", das sich mit dem Erzeugen von Objekten beschäftigt.&nbsp;</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Ein paar Regeln für Default Operationen gibt es noch. Diese betreffen Vergleiche, aber auch die Operationen <i>swap</i> und <i>hash</i> und werden Inhalt des nächsten Artikels sein. </div>
<div class="ztitel">Weitere Informationen:</div>
<div class="text"><ul><li>Delegieren und Vererben von Konstruktoren: <a title="Link auf http://www.linux-magazin.de/Ausgaben/2014/10/C-11" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2014%2F10%2FC-11%22%2C%22text%22%3A%22Sch%C3%B6nes%20Objek%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2014%2F10%2FC-11%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" class="" href="http://www.linux-magazin.de/Ausgaben/2014/10/C-11">Schönes Objek</a>t (freier Artikel für das Linux-Magazin)</li></ul></div>
