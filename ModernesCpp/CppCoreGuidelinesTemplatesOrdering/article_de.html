<div class="vorspann">Mein Artikel heute lehnt sich nur leicht an die C++ Core Guidelines an, denn diese besitzen beim Thema nicht viel Inhalt. Inspiriert durch die Guidelines beschäftige ich mich mit einer generischen <i>isSmaller</i>-Funktion.</div>
<div class="text">&nbsp;Dies sind die Regeln für den heutigen Artikel, an die mich nur sehr leicht anlehne.<br></div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialization" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialization%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialization%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22T.64%3A%20Use%20specialization%20to%20provide%20alternative%20implementations%20of%20class%20templates%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialization" class="">T.64: Use specialization to provide alternative implementations of class templates</a> </li><li> <a alt="%7B%22version%22%3A1%2C%22text%22%3A%22T.65%3A%20Use%20tag%20dispatch%20to%20provide%20alternative%20implementations%20of%20functions%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tag-dispatch%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tag-dispatch%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tag-dispatch" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tag-dispatch">T.65: Use tag dispatch to provide alternative implementations of functions</a> </li><li><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialization2" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialization2%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialization2%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.67%3A%20Use%20specialization%20to%20provide%20alternative%20implementations%20for%20irregular%20type%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialization2">T.67: Use specialization to provide alternative implementations for irregular type</a> </li></ul></div>
<div class="text">Es geht also um Template-Spezialisierung. </div>
<div class="ztitel">Vergleich zweier Accounts: die Erste</div>
<div class="text">Ich möchte gerne einfach anfangen. Daher starte ich mit einer Klasse <i>Accoun</i>t. Für zwei <i>Account</i>s möchte ich wissen, welcher kleiner ist. Kleiner bedeutet in meinem Fall, auf welchem <i>Account</i> sich weniger Geld befindet: </div>
<div class="pre">// isSmaller.cpp<br><br>#include &lt;iostream&gt;<br><br>class Account{<br>public:<br>&nbsp; Account() = default;<br>&nbsp; Account(double b): balance(b){}<br>&nbsp; double getBalance() const {<br>&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp; }<br>private:<br>&nbsp; double balance{0.0};<br>};<br><br>template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp;&nbsp;&nbsp; return fir &lt; sec;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; double firDoub{};<br>&nbsp;&nbsp;&nbsp; double secDoub{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firDoub, secDoub): " &lt;&lt; isSmaller(firDoub, secDoub) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Account firAcc{};<br>&nbsp;&nbsp;&nbsp; Account secAcc{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firAcc, secAcc): " &lt;&lt; isSmaller(firAcc, secAcc) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Um mir die Arbeit einfach zu machen, implementiere ich eine generische <i>isSmaller-</i>Funktion (1). Leider klappt das nicht, da sich zwei <i>Account</i>s nicht vergleichen lassen.. Ich habe den <i>operator&lt;</i> nicht implementiert.<br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164052363_eb126db567.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Bevor ich das Problem in verschieden Varianten lösen werden, möchte ich einen kleinen Umweg zu regulären und semiregulären Datentypen machen. Dies aus dem einfachen Grund, da Alexander Stepanovs ursprüngliche Definition von regulären Datentypen von der der C++20 Concepts in einem Punkt abweicht: Ordnung. </div>
<div class="ztitel">Semireguläre und reguläre Datentypen<br></div>
<div class="text">Die Regel <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialization2" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialization2%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-specialization2%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.67%3A%20Use%20specialization%20to%20provide%20alternative%20implementations%20for%20irregular%20type%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-specialization2">T.67: Use specialization to provide alternative implementations for irregular type</a> bezieht sich auf nichtreguläre Datentypen. Der Begriff "nichtregulär" steht für Datentypen, die weder <i>SemiRegular</i> noch <i>Regular</i> sind. Hier ist als kleine Erinnerungsstütze die Definition von semiregulären und regulären Datentypen:</div>
<div class="ztitel_kleiner"><i>Regular</i></div>
<div class="text"><ul><li><i>DefaultConstructible</i></li><li><i>CopyConstructible, CopyAssignable</i></li><li><i>MoveConstructible, MoveAssignable</i></li><li><i>Destructible</i></li><li><i>Swappable</i></li><li><i>EqualityComparable</i></li></ul></div>
<div class="ztitel_kleiner"><i>SemiRegular</i></div>
<div class="text"><ul><li><i>SemiRegular - EqualityComparable</i></li></ul></div>
<div class="text">Wenn du mehr Details zu Regular und SemiRegular wissen willst, findest du diese in meinem Artikel "<a href="/exec/mainmenu.pl?sid=1363636abdcd20e3114d1e53830f4dad&amp;rm=open_article_id&amp;bid=2547804" alt="%7B%22target%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D1363636abdcd20e3114d1e53830f4dad%26rm%3Dopen_article_id%26bid%3D2547804%22%2C%22ir_link%22%3A1%2C%22destination%22%3A2547804%2C%22type%22%3A%22B%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regul%C3%A4re%20und%20semiregu%C3%A4re%20Datentypen%22%2C%22version%22%3A1%7D" title="Link auf Beitrag 2547804" class="">C++ Core Guidelines: Reguläre und semireguäre Datentypen</a>". </div>
<div class="text"><i>Account</i> ist semireguär aber nicht regulär:<br></div>
<div class="pre">// accountSemiRegular.cpp<br><br>#include &lt;experimental/type_traits&gt;<br>#include &lt;iostream&gt;<br><br>class Account{<br>public:<br>&nbsp; Account() = default;<br>&nbsp; Account(double b): balance(b){}<br>&nbsp; double getAccount() const {<br>&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp; }<br>private:<br>&nbsp; double balance{0.0};<br>};<br><br>template&lt;typename T&gt;<br>using equal_comparable_t = decltype(std::declval&lt;T&amp;&gt;() == std::declval&lt;T&amp;&gt;());<br><br>template&lt;typename T&gt;<br>struct isEqualityComparable: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::experimental::is_detected&lt;equal_comparable_t, T&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {};<br><br>template&lt;typename T&gt;<br>struct isSemiRegular: std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_default_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_destructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_swappable&lt;T&gt;::value &gt;{};<br><br>template&lt;typename T&gt;<br>struct isRegular: std::integral_constant&lt;bool, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSemiRegular&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isEqualityComparable&lt;T&gt;::value &gt;{};<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSemiRegular&lt;Account&gt;::value: " &lt;&lt; isSemiRegular&lt;Account&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isRegular&lt;Account&gt;::value: " &lt;&lt; isRegular&lt;Account&gt;::value &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die Ausgabe des Programms zeigt, dass <i>Account</i> nicht regulär ist. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164052363_eb126db567.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Details zu dem Programm gibt es auch in dem bereits veröffentlichten Artikel "<a class="" title="Link auf Beitrag 2547804" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regul%C3%A4re%20und%20semiregu%C3%A4re%20Datentypen%22%2C%22version%22%3A1%2C%22destination%22%3A2547804%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D1363636abdcd20e3114d1e53830f4dad%26rm%3Dopen_article_id%26bid%3D2547804%22%2C%22target%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22B%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="/exec/mainmenu.pl?sid=1363636abdcd20e3114d1e53830f4dad&amp;rm=open_article_id&amp;bid=2547804">C++ Core Guidelines: Reguläre und semireguäre Datentypen</a>". </div>
<div class="text">Indem ich dem Datentyp [i]Account[/i] einen Gleichheitsoperator (<i>operator ==</i>) spendiere, wird dieser regulär: </div>
<div class="pre">// accountRegular.cpp<br><br>#include &lt;iostream&gt;<br><br>class Account{<br>public:<br>&nbsp;&nbsp;&nbsp; Account() = default;<br>&nbsp;&nbsp;&nbsp; Account(double b): balance(b){}<br>&nbsp;&nbsp;&nbsp; friend bool operator == (Account const&amp; fir, Account const&amp; sec) {&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() == sec.getBalance();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; double getBalance() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; double balance{0.0};<br>};<br><br>template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp;&nbsp;&nbsp; return fir &lt; sec;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; double firDou{};<br>&nbsp;&nbsp;&nbsp; double secDou{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firDou, secDou): " &lt;&lt; isSmaller(firDou, secDou) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Account firAcc{};<br>&nbsp;&nbsp;&nbsp; Account secAcc{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firAcc, secAcc): " &lt;&lt; isSmaller(firAcc, secAcc) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Leider lassen sich <i>Account</i>s immer noch nicht vergleichen. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164052363_eb126db567.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die ist der entscheidende Unterschied zwischen regulären Datentypen, wie sie Alexander Stepanov beschreibt, und dem Concept Regular, wie sie C++20 definiert. Laut Stepanov sollte ein regulärer Datentyp eine totale Ordnung unterstützen.</div>
<div class="text">Jetzt komme ich wieder zu meinem ursprünglichen Plan zurück. </div>
<div class="ztitel">Vergleich zweier Accounts: die Zweite</div>
<div class="text">Die zentrale Idee meiner Variationen ist es, dass sich konkrete <i>Account</i>s mit der generischen<i> isSmaller-</i>Funktion vergleichen lassen.<br></div>
<div class="ztitel_kleiner">Überladen des <i>operator &lt;</i><br></div>
<div class="text">Dies ist offensichtlich die naheliegendste Lösung. Selbst die Fehlermeldung des Programms<i> isSmaller.cpp</i> hat mich darauf hingewiesen: <br></div>
<div class="pre">// accountIsSmaller1.cpp<br><br>#include &lt;iostream&gt;<br><br>class Account{<br>public:<br>&nbsp;&nbsp;&nbsp; Account() = default;<br>&nbsp;&nbsp;&nbsp; Account(double b): balance(b){}<br>&nbsp;&nbsp;&nbsp; friend bool operator == (Account const&amp; fir, Account const&amp; sec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() == sec.getBalance();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; friend bool operator &lt; (Account const&amp; fir, Account const&amp; sec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() &lt; sec.getBalance();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; double getBalance() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; double balance{0.0};<br>};<br><br>template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp;&nbsp;&nbsp; return fir &lt; sec;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; double firDou{};<br>&nbsp;&nbsp;&nbsp; double secDou{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firDou, secDou): " &lt;&lt; isSmaller(firDou, secDou) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Account firAcc{};<br>&nbsp;&nbsp;&nbsp; Account secAcc{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firAcc, secAcc): " &lt;&lt; isSmaller(firAcc, secAcc) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="ztitel_kleiner"><i>Vo</i>llständige Spezialisierung der Funktion isSmaller<br></div>
<div class="text">Falls du die Definition von <i>Account</i> nicht ändern kannst, kannst du zumindest <i>isSmaller </i>für<i> Account</i> vollständig spezialisieren:<br></div>
<div class="pre">// accountIsSmaller2.cpp<br><br>#include &lt;iostream&gt;<br><br>class Account{<br>public:<br>&nbsp;&nbsp;&nbsp; Account() = default;<br>&nbsp;&nbsp;&nbsp; Account(double b): balance(b){}<br>&nbsp;&nbsp;&nbsp; friend bool operator == (Account const&amp; fir, Account const&amp; sec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() == sec.getBalance();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; double getBalance() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; double balance{0.0};<br>};<br><br>template&lt;typename T&gt;<br>bool isSmaller(T fir, T sec){<br>&nbsp;&nbsp;&nbsp; return fir &lt; sec;<br>}<br><br>template&lt;&gt;<br>bool isSmaller&lt;Account&gt;(Account fir, Account sec){<br>&nbsp;&nbsp;&nbsp; return fir.getBalance() &lt; sec.getBalance();<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; double firDou{};<br>&nbsp;&nbsp;&nbsp; double secDou{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firDou, secDou): " &lt;&lt; isSmaller(firDou, secDou) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Account firAcc{};<br>&nbsp;&nbsp;&nbsp; Account secAcc{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firAcc, secAcc): " &lt;&lt; isSmaller(firAcc, secAcc) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Nebenbei gesagt, eine nichtgenerische Funktion <i>bool isSmaller(Account fir, Account sec) </i>hätte diesen Job auch erfüllt.</div>
<div class="ztitel_kleiner">Erweiterung von <i>isSmaller</i> um eine binäres Prädikat<br></div>
<div class="text">Es gibt eine weitere Variante für die generische Funktion <i>isSmaller</i>. <i>isSmaller</i> erhält einen zusätzlichen Typ-Parameter für ein binäres Prädikat. Diese Strategie wird häufig in der Standard Template Library verwendet:<br> </div>
<div class="pre">// accountIsSmaller3.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>class Account{<br>public:<br>&nbsp;&nbsp;&nbsp; Account() = default;<br>&nbsp;&nbsp;&nbsp; Account(double b): balance(b){}<br>&nbsp;&nbsp;&nbsp; friend bool operator == (Account const&amp; fir, Account const&amp; sec) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() == sec.getBalance();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; double getBalance() const {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return balance;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; double balance{0.0};<br>};<br><br>template &lt;typename T, typename Pred = std::less&lt;T&gt; &gt;&nbsp;&nbsp;&nbsp; // (1)<br>bool isSmaller(T fir, T sec, Pred pred = Pred() ){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; return pred(fir, sec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; double firDou{};<br>&nbsp;&nbsp;&nbsp; double secDou{2014.0};<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firDou, secDou): " &lt;&lt; isSmaller(firDou, secDou) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; Account firAcc{};<br>&nbsp;&nbsp;&nbsp; Account secAcc{2014.0};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto res = isSmaller(firAcc, secAcc, [](const Account&amp; fir, const Account&amp; sec){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.getBalance() &lt; sec.getBalance(); <br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firAcc, secAcc): " &lt;&lt;&nbsp; res &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string firStr = "AAA";<br>&nbsp;&nbsp;&nbsp; std::string secStr = "BB";<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firStr, secStr): " &lt;&lt;&nbsp; isSmaller(firStr, secStr) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; auto res2 = isSmaller(firStr, secStr, [](const std::string&amp; fir, const std::string&amp; sec){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fir.length() &lt; sec.length(); <br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSmaller(firStr, secStr): " &lt;&lt;&nbsp; res2 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die generische Funktion wendet <i>std::less&lt;T&gt;</i> als Default-Ordnung (1) an. Dazu wird das binäre Prädikat in der Zeile (2) instanziiert und in der Zeile (3) verwendet. Wenn du dieses Prädikat nicht setzt, kommt <i>std::less&lt;T&gt;</i> zum Einsatz. Zusätzlich lässt sich ein binäres Prädikat wie in Zeile (4) oder (5) verwenden. Eine Lambda-Funktion ist der ideale Kandidat für diesen Anwendungsfall. </div>
<div class="text">Zum Abschluss kommt die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164052363_eb126db567.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Worin unterscheiden sich die drei Variationen? </div>
<div class="ztitel">Vergleich zweier Accounts: die Dritte</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164052385_20916c19c0.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die vollständige Spezialisierung ist keine allgemeine Lösung, denn sie funktioniert nur für <i>isSmaller</i>. Im Gegensatz dazu lässt sich der Vergleichsoperator (<i>operator &lt;</i>) sehr häufig anwenden. Entsprechend kann das Prädikat für jeden Datentyp verwendet werden. Der Vergleichsoperator und die vollständige Spezialisierung sind statisch. Das heißt, dass die Ordnung zur Compilezeit definiert wird und in dem Datentyp oder der generischen Funktion codiert ist. Im Gegensatz dazu lässt sich die Erweiterung mit verschiedenen Prädikaten aufrufen. Diese Entscheidung fällt erst zur Laufzeit. Der Vergleichsoperator erweitert den Datentyp, die beiden Varianten die generische Funktion. Die Erweiterung durch das Prädikat ist die einzige Variante, die verschiedene Ordnung unterstützt. So lassen sich zum Beispiel Strings lexikographisch oder aufgrund ihrer Länge vergleichen. </div>
<div class="text">Basierend auf diesem Vergleich ist es eine einfache Daumenregel, den Vergleichsoperator (<i>operator &lt;</i>) für deinen Datentyp zu implementieren und dann eine generische Funktion mit einem Erweiterungspunkt zu versehen, wenn dies notwendig ist. Damit verhalten sich deine Datentypen im Sinne von Alexander Stepanov regulär und können auf verschiedene Arten verglichen werden.<br></div>
<div class="ztitel">Wie geht's weiter ?</div>
<div class="text">Im nächsten Artikel geht es mit Templates weiter. Insbesondere geht um Templates und Ableitungshierarchie. </div>