<div class="vorspann">Mein letzter Artikel zu den C++ Core Guidelines "<a class="" title="Link auf https://www.heise.de/-3985896" href="https://www.heise.de/-3985896" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22To%20Switch%20or%20not%20to%20Switch%2C%20that%20is%20the%20Question%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3985896%22%2C%22target%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3985896%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D">To Switch or not to Switch, that is the Question</a>" wurde sehr intensiv diskutiert. Der Einsatz einer Hashtabelle anstelle einer switch Anweisung scheint ein sehr emotionales Thema zu sein. Daher habe ich meinen ursprünglichen Plan geändert. Heute werde ich verschiedene Kontrollstrukturen vorstellen. Los geht es mit der if und switch Anweisung, weiter mit der Hashtabelle und zum Abschluss werde ich auf dynamischen und statischen Polymorphismus eingehen. Zusätzlich werde ich die verschiedenen Kontrollstrukturen bzgl. ihrer Pflege und Performanz vergleichen.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149901715_005ab66bf9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die klassische Kontrollstruktur ist die <i>if</i>-Anweisung. Daher ist sie auch mein Startpunkt in diesem Artikel.<br> </div>
<div class="ztitel_kleiner"><i>if</i>-Anweisungen<br> </div>
<div class="text">Hier ist bereits das einfache Programm, dass ich im Laufe des Artikels mit verschiedenen Kontrollstrukturen umsetzen werde.<br></div>
<div class="pre">// dispatchIf.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>enum class MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; information,<br>&nbsp;&nbsp;&nbsp; warning,<br>&nbsp;&nbsp;&nbsp; fatal,<br>};<br><br>auto start = std::chrono::steady_clock::now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br><br>void writeElapsedTime(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>void writeInformation(){ std::cerr &lt;&lt; "information" &lt;&lt; std::endl; }<br>void writeWarning(){ std::cerr &lt;&lt; "warning" &lt;&lt; std::endl; }<br>void writeUnexpected(){ std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl; }<br><br>void writeMessage(MessageSeverity messServer){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; writeElapsedTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; if (MessageSeverity::information == messServer){<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; writeInformation();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else if (MessageSeverity::warning == messServer){<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; writeWarning();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; writeUnexpected();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; <br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessage(MessageSeverity::information);<br>&nbsp;&nbsp;&nbsp; writeMessage(MessageSeverity::warning);<br>&nbsp;&nbsp;&nbsp; writeMessage(MessageSeverity::fatal);<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die Funktion<i> writeMessage</i> in Zeile (1) stellt die verstrichene Zeit (3) seit dem Programmstart in Sekundenauflösung und eine Log-Nachricht dar. Sie verwendet eine Aufzählung (2) für die Ernsthaftigkeit der Nachricht. Ich wende den Startzeitpunkt (4) und die aktuelle Zeit (5) an, um die verstrichene Zeit zu berechnen. Wie es der Name des Zeitgebers <i>std::steady_clock</i> bereits andeutet, kann dieser nicht angepasst werden. Genau aus diesem Grund ist er der ideale Zeitgeber für Zeitmessungen. Der entscheidende Teil des Programms ist die Funktion <i>writeMessage</i> (2). In ihr treffe ich die Entscheidung mithilfe der <i>if-else</i> Anweisung, welche Nachricht dargestellt werden soll. </div>
<div class="text">Um ehrlich zu sein. Damit ich die <i>if-else</i>-Anweisung umsetzen konnte, musste ich die genaue Syntax nachschlagen.&nbsp;</div>
<div class="text">Hier ist die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149901716_2e53980cb8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Für den Rest des Artikels werde ich auf die Ausgaben der Programme verzichten, denn diese unterscheiden sich nur bezüglich des Zeitstempels.<br></div>
<div class="ztitel_kleiner"><i>switch</i>-Anweisungen<br> </div>
<div class="text">Das folgende Programm ist dem vorherigen sehr ähnlich. Lediglich die Implementierung der Funktion <i>writeMessage</i> hat sich geändert. <br></div>
<div class="pre">// dispatchSwitch.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>enum class MessageSeverity{<br>&nbsp;&nbsp;&nbsp; information,<br>&nbsp;&nbsp;&nbsp; warning,<br>&nbsp;&nbsp;&nbsp; fatal,<br>};<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>void writeInformation(){ std::cerr &lt;&lt; "information" &lt;&lt; std::endl; }<br>void writeWarning(){ std::cerr &lt;&lt; "warning" &lt;&lt; std::endl; }<br>void writeUnexpected(){ std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl; }<br><br>void writeMessage(MessageSeverity messSever){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; writeElapsedTime();<br><br>&nbsp;&nbsp;&nbsp; switch(messSever){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MessageSeverity::information:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeInformation();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MessageSeverity::warning:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeWarning();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeUnexpected();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp; }<br>&nbsp; <br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessage(MessageSeverity::information);<br>&nbsp;&nbsp;&nbsp; writeMessage(MessageSeverity::warning);<br>&nbsp;&nbsp;&nbsp; writeMessage(MessageSeverity::fatal);<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Jetzt kann ich mich kurz fassen. Weiter geht es mit der Hashtabelle.</div>
<div class="ztitel_kleiner">Hashtabellen<br> </div>
<div class="text">Für eine deutlich tiefere Diskussion der Hashtabelle und der switch Anweisung, möchte ich gerne auf meinen vorherigen Artikel verweisen: <a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3985896%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3985896%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20To%20Switch%20or%20not%20to%20Switch%2C%20that%20is%20the%20Question%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://www.heise.de/-3985896" class="" href="https://www.heise.de/-3985896">C++ Core Guidelines: To Switch or not to Switch, that is the Question</a>. <br></div>
<div class="pre">// dispatchHashtable.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;unordered_map&gt;<br><br>enum class MessageSeverity{<br>&nbsp; information,<br>&nbsp; warning,<br>&nbsp; fatal,<br>};<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>void writeInformation(){ std::cerr &lt;&lt; "information" &lt;&lt; std::endl; }<br>void writeWarning(){ std::cerr &lt;&lt; "warning" &lt;&lt; std::endl; }<br>void writeUnexpected(){ std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl; }<br><br>std::unordered_map&lt;MessageSeverity, std::function&lt;void()&gt;&gt; mess2Func{<br>&nbsp;&nbsp;&nbsp; {MessageSeverity::information, writeInformation},<br>&nbsp;&nbsp;&nbsp; {MessageSeverity::warning, writeWarning},<br>&nbsp;&nbsp;&nbsp; {MessageSeverity::fatal, writeUnexpected}<br>};<br><br>void writeMessage(MessageSeverity messServer){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; writeElapsedTime();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; mess2Func[messServer]();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; writeMessage(MessageSeverity::information);<br>&nbsp; writeMessage(MessageSeverity::warning);<br>&nbsp; writeMessage(MessageSeverity::fatal);<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Ist dies das Ende? Nein! In C++ besitzen wir dynamischen und statischen Polymorphismus. Einige meiner Leser erwähnten sie bereits in der Diskussion zu meinem vorherigen Artikel. Im Falle der <i>if-else-</i> oder der <i>switch</i>-Anweisung, wendete ich Aufzähler an, um den Kontrollfluss richtig zu steuern. Der Schlüssel in der Hashtabelle verhält sich sehr ähnlich wie die Aufzähler.<br></div>
<div class="text">Dynamischer oder statischer Polymorphismus wendet eine vollkommen andere Logik an. Anstelle eines Aufzählers oder eines Schlüssels, um den Programmfluss zu steuern, wissen die Objekte selbst, welche Entscheidung zur Laufzeit (dynamischer Polymorphismus) oder zur Compilezeit (statischer Polymorphismus) gefällt werden muss.</div>
<div class="text">Weiter geht es mit dem dynamischen Polymorphismus.<br></div>
<div class="ztitel_kleiner">Dynamischer Polymorphismus<br> </div>
<div class="text">Nun ist die Entscheidungslogik direkt in der Klassenhierarchie implementiert.<br></div>
<div class="pre">// dispatchDynamicPolymorphism.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>struct MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; virtual void writeMessage() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct MessageInformation: MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; void writeMessage() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "information" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct MessageWarning: MessageSeverity{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; void writeMessage() const override {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "warning" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct MessageFatal: MessageSeverity{};<br><br>void writeMessageReference(const MessageSeverity&amp; messServer){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; writeElapsedTime();<br>&nbsp;&nbsp;&nbsp; messServer.writeMessage();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>void writeMessagePointer(const MessageSeverity* messServer){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; writeElapsedTime();<br>&nbsp;&nbsp;&nbsp; messServer-&gt;writeMessage();<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef1 = messInfo;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef2 = messWarn;<br>&nbsp;&nbsp;&nbsp; MessageSeverity&amp; messRef3 = messFatal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef2);<br>&nbsp;&nbsp;&nbsp; writeMessageReference(messRef3);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin1 = new MessageInformation;<br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin2 = new MessageWarning;<br>&nbsp;&nbsp;&nbsp; MessageSeverity* messPoin3 = new MessageFatal;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (9)<br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin2);<br>&nbsp;&nbsp;&nbsp; writeMessagePointer(messPoin3);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Die Klassen (1), (2) und (3) wissen, wie sie sich zu verhalten haben. Die zentrale Idee ist es, dass sich der statische Typ <i>MessageSeverity</i> vom dynamischen Typ wie zum Beispiel in MessageInformation (4) unterscheidet. Daher wendet die C++-Laufzeit späte Bindung an und die <i>writeMessage</i> Methoden (5), (6), und (7) der dynamischen Typen werden verwendet. Dynamischer Polymorphismus benötigt eine Art Indirektion. Das bedeutet, dass diese erst mit Referenzen (8) oder Zeigern (9) zur Verfügung steht. Mit der Performanzbrille betrachtet, geht dies schneller in C++. Mit statischen Polymorphismus lässt sich die Entscheidungslogik von der Laufzeit auf die Compilezeit vorziehen. </div>
<div class="ztitel_kleiner">Statischer Polymorphismus<br> </div>
<div class="text">Statischer Polymorphismus wird auch gerne CRTP genannt. CRTP steht für das beliebte C++-Idiom <b>C</b>uriously<b> R</b>ecurring Template <b>P</b>attern. Coriously, da bei diesem Idiom eine Klasse von einem Klassen-Template abgeleitet wird, das die Klasse selbst als Template-Argument verwendet. <br></div>
<div class="pre">// dispatchStaticPolymorphism.cpp<br><br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>auto start = std::chrono::steady_clock::now();<br><br>void writeElapsedTime(){<br>&nbsp;&nbsp;&nbsp; auto now = std::chrono::steady_clock::now();<br>&nbsp;&nbsp;&nbsp; std::chrono::duration&lt;double&gt; diff = now - start;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; diff.count() &lt;&lt; " sec. elapsed: ";<br>}<br><br>template &lt;typename ConcreteMessage&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>struct MessageSeverity{<br>&nbsp; void writeMessage(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; static_cast&lt;ConcreteMessage*&gt;(this)-&gt;writeMessageImplementation();<br>&nbsp; }<br>&nbsp; void writeMessageImplementation() const {<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct MessageInformation: MessageSeverity&lt;MessageInformation&gt;{<br>&nbsp; void writeMessageImplementation() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "information" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct MessageWarning: MessageSeverity&lt;MessageWarning&gt;{<br>&nbsp; void writeMessageImplementation() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "warning" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct MessageFatal: MessageSeverity&lt;MessageFatal&gt;{};&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br><br>template &lt;typename T&gt;<br>void writeMessage(T&amp; messServer){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; writeElapsedTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; messServer.writeMessage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageInformation messInfo;<br>&nbsp;&nbsp;&nbsp; writeMessage(messInfo);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageWarning messWarn;<br>&nbsp;&nbsp;&nbsp; writeMessage(messWarn);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MessageFatal messFatal;<br>&nbsp;&nbsp;&nbsp; writeMessage(messFatal);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">In diesem Fall leite ich alle konkreten Klassen (3), (4) und (5) von der Basisklasse<i> MessageSeverity</i> ab. Die Methode <i>writeMessag</i>e stellt das Interface dar, das die Aufrufe auf die konkreten Implementierung&nbsp; <i>writeMessageImplementation</i> abbildet. Damit das stattfindet, konvertiere ich die Objekte auf den Typ <i>ConcreteMessage:&nbsp;&nbsp;static_cast&lt;ConcreteMessage*&gt;(this)-&gt;writeMessageImplementation()</i>;. Genau dies ist der statische Dispatch und gibt diesem C++ Idiom seinen Namen: Statischer Polymorphismus.</div>
<div class="text">Um ehrlich zu sein, habe ich einige Zeit benötigt, um mit dieser besonderen Technik vertraut zu werden. Dies gilt nicht für ihren Einsatz in der Zeile (6). Falls das curiously recurring template pattern noch curiously für dich ist, verweise ich gerne auf den Artikel, denn ich darüber geschrieben habe: <a class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/c-ist-doch-lazy" href="http://www.grimm-jaud.de/index.php/blog/c-ist-doch-lazy" alt="%7B%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20ist%20doch%20lazy%21%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-ist-doch-lazy%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-ist-doch-lazy%22%7D">C++ ist doch lazy!</a> <br></div>
<div class="text">Zum Abschluss möchte ich gerne die vorgestellten Techniken kurz vergleichen.</div>
<div class="ztitel">Mein einfacher Vergleich<br> </div>
<div class="text">Zuerst möchte ich auf den Aspekt eingehen, diese Kontrollstrukturen zu implementieren und zu pflegen. Es hängt natürlich von deinem Hintergrund ab, welche Konstrollstrukturen dir am vertrautesten ist. Als C-Programmierer ist es vermutlich die <i>if</i>- und <i>switch</i>-Anweisung. Falls du häufig einen Interpreter wie Python einsetzt, wohl eher die Hashtabelle. Mit einem objektorientierten Hintergrund, wirst du vermutlich den dynamische Polymorphismus vorziehen. Hingegen ist der statische Polymorphismus relativ ungewohnt. Es benötigt eine Zeit, um mit ihm vertraut zu werden. Danach lässt es sich einfach wie ein Kochrezept einsetzen. </div>
<div class="text">Aus dem Sicherheitsblickwinkel betrachtet, möchte ich kurz auf den Bezeichner <i>override</i> eingehen. Dieser bringt explizit auf den Punkt, dass eine Methode wie zum Beispiel <i>writeMessage</i> eine virtuelle Methode einer Basisklasse überschreiben soll. Falls dies nicht zutrifft, moniert der Compiler das sofort mit einer eindeutigen Fehlermeldung.</div>
<div class="text">Nun zu der deutlich interessanteren Frage: Was sind die Performanzunterschiede der vorgestellten Techniken? Ich werde nur ein grobe Idee ohne konkrete Zahlen liefern. Falls du eine lange Folge von if Anweisungen hast, wird dies dank der vielen Vergleiche ziemlich teuer. Der dynamische Polymorphismus und die Hashtabelle sind daher schneller und befinden sich in derselben Performanzliga, da in beiden Fällen eine Zeigerindirektion involviert ist. Die switch Anweisung und der statische Polymorphismus fällen ihre Entscheidung zur Compilezeit. Damit sind sie die schnellsten Kontrollstrukturen.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nun hoffe ich, dass ich mit diesem Artikel die Diskussion zu den Kontrollstrukturen abschließen kann. Somit werde ich im nächsten Artikel auf die verbleibenden Regeln zu Anweisungen eingehen und mit den Regeln zu arithmetischen Ausdrücken beginnen. </div>
