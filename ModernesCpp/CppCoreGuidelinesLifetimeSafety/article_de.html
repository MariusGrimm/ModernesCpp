<div class="vorspann">Das Lifetime-Safety-Profil der C++ Core Guidelines lässt sich auf einen Punkt reduzieren: Dereferenziere keinen Zeiger, der möglicherweise ungültig ist. Ein Zeiger kann ungültig sein, wenn er nicht initialisiert oder ein Nullzeiger ist. Ein Zeiger kann aber auch ungültig sein, wenn er auf ein Element außerhalb seines Gültigkeitsbereichs oder auf ein bereits gelöschtes Element verweist</div><div class="text">Wenn du einen möglicherweise ungültigen Zeiger nicht dereferenzierst, besitzt dies laut den C++ Core Guidelines einige Auswirkungen auf dein Programm:</div><div class="text"><ul><li>Du eliminierst eine der wichtigsten Ursachen für hässliche Fehler in C++.</li><li>Du eliminierst die wichtigste Ursache für mögliche Sicherheitsprobleme.</li><li>Du verbesserst die Performanz, da du auf sich häufig wiederholende "paranoide" Checks verzichten kannst.</li><li>Dein Vertrauen in die Richtigkeit deines Programms wächst.</li><li>Du vermeidest undefiniertes Verhalten, da du eine wichtige C++ Regel einhältst.<br></li></ul></div><div class="text">Für mich besitzt der Umgang mit Zeigern eine noch größere Dimension: Besitzverhältnisse. Besitzverhältnisse meint, dass zu jedem Zeitpunkt klar sein muss, wer für die Lebenszeit eines Objekts verantwortlich ist. Vereinfachend gesagt, kennt C++11 sechs verschiedene Besitzverhältnisse:<br></div><div class="text"><ul><li> Lokale Objekte: Die C++-Laufzeit als Besitzer verwaltet automatisch den Lebenszyklus seiner Ressourcen. Dasselbe gilt für globale Objekte oder Mitglieder einer Klasse. Die Guidelines nennen diese lokalen Objekte "scoped objects".</li><li>Referenzen: Ich bin nicht der Besitzer. Ich habe mir die Ressource, die nicht null sein kann, nur ausgeliehen.</li><li>Nackte Zeiger: Ich bin nicht der Besitzer. Ich habe mir die Ressource, die null sein kann, nur ausgeliehen. Ich darf die Ressource nicht freigeben.</li><li><span class="tx_code">std::unique_ptr</span>: Ich bin der exklusive Besitzer der Ressource. Ich darf die Ressource freigeben.</li><li><span class="tx_code">std::shared_ptr</span>: Ich teile mir die Ressource mit anderen Besitzern. Ich darf meine Besitzverhältnisse explizit freigeben.</li><li><span class="tx_code">std::weak_ptr</span>: Ich bin nicht der Besitzer der Ressource, aber ich kann zeitweise zum geteilten Besitzer werden, indem ich die Methode<span class="tx_code"> std::weak_ptr::lock</span> verwende.</li></ul></div><div class="text">Vergleich doch diese feinjustierbaren Besitzverhältnisse mit einem nackten Zeiger. Genau das ist der Punkt, den ich an modernem C++ sehr schätze.<br></div><div class="text">Nun stellst du dir vermutlich die Fragen: Schön, dass wir Regeln haben, aber wie lässt sich prüfen, ob mein Sourcecode diese Regeln einhält? Dank der Guidelines Support Library (GSL) lassen sich die Regeln der C++ Core Guidelines automatisch prüfen.<br></div><div class="ztitel">Die Regeln der Guidelines automatisch prüfen<br></div><div class="text">Die GSL ist eine kleine Bibliothek, die die Regeln der C++ Core Guidelines unterstützt. Es gibt ein paar Implementierungen der GSL: Die GSL besteht nur aus Headerdateien, sodass sich ihre Funktionen und Datentypen recht einfach anwenden lassen. Die bekannteste Umsetzung ist die von Microsoft, die auf GitHub gehostest ist: <a alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoft%2FGSL%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Microsoft%2FGSL%22%7D" href="https://github.com/Microsoft/GSL" title="Link auf https://github.com/Microsoft/GSL">Microsoft/GSL</a>. Die Microsoft-Implementierung setzt C++14 voraus und kann auf vielen Plattformen verwendet werden. Hier sind ein paar der populären Plattformen: <br></div><div class="text"><ul><li>Windows using Visual Studio 2015</li><li>Windows using Visual Studio 2017</li><li>Windows using Visual Studio 2019</li><li>Windows using Clang/LLVM 3.6</li><li>Windows using Clang/LLVM 7.0.0</li><li>Windows using GCC 5.1</li><li>Windows using Intel C++ Compiler 18.0</li><li>GNU/Linux using Clang/LLVM 3.6-3.9</li><li>GNU/Linux using Clang/LLVM 4.0</li><li>GNU/Linux using Clang/LLVM 5.0</li><li>GNU/Linux using Clang/LLVM 6.0</li><li>GNU/Linux using Clang/LLVM 7.0</li><li>GNU/Linux using GCC 5.1</li></ul></div><div class="text">Lasse mich ausprobieren, welche Einsicht ich zu einer einfachen Sourcecodedatei mit der GSL erhalte. Das folgenden Programm bricht die Profile <a title="Link auf https://heise.de/-4519568" href="https://heise.de/-4519568" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Type%20Safety%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4519568%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4519568%22%2C%22type%22%3A%22E%22%7D">Type Safety</a>, <a title="Link auf https://heise.de/-4542136" href="https://heise.de/-4542136" alt="%7B%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4542136%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4542136%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Bounds%20Safety%22%2C%22custom%22%3A%7B%7D%7D">Bounds Safety</a> und Lifetime Safety.<br></div><div class="ztitel_kleiner">Bruch der Profile Type Safety, Bounds Safety und Lifetime Safety<br></div><div class="pre">// gslCheck.cpp<br><br>#include &lt;iostream&gt;<br><br>void f(int* p, int count) {<br>}<br><br>void f2(int* p) {<br>&nbsp;&nbsp;&nbsp; int x = *p;<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; // Break of type safety<br>&nbsp;&nbsp;&nbsp; // use of a c-cast<br>&nbsp;&nbsp;&nbsp; double d = 2;<br>&nbsp;&nbsp;&nbsp; auto p = (long*)&amp;d;<br>&nbsp;&nbsp;&nbsp; auto q = (long long*)&amp;d;<br><br>&nbsp;&nbsp;&nbsp; // Break of bounds safety<br>&nbsp;&nbsp;&nbsp; // array to pointer decay<br>&nbsp;&nbsp;&nbsp; int myArray[100];<br>&nbsp;&nbsp;&nbsp; f(myArray, 100);<br><br>&nbsp;&nbsp;&nbsp; // Break of Lifetime Safety<br>&nbsp;&nbsp;&nbsp; // a is not valid<br>&nbsp;&nbsp;&nbsp; int* a = new int;<br>&nbsp;&nbsp;&nbsp; delete a;<br>&nbsp;&nbsp;&nbsp; f2(a);<br><br>}<br></div><div class="text">Die Kommentare in dem Sourcecode dokumentieren eindeutig meine Verletzungen der Profile. Nun werde ich Visual Studio 2019 verwenden und meine Schritte vorstellen, um meine Verletzungen zu detektieren. <br></div><div class="ztitel_kleiner">Codeanalyse im Buildprozess verwenden<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_181333592_0e6c863c2b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Du musst die Checkbox aktivieren. Per Default sind die Regeln zur <a href="https://heise.de/-4519568" title="Link auf https://heise.de/-4519568" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4519568%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4519568%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Type%20Safety%22%2C%22subject%22%3A%22%22%7D">Type Safety</a>, <a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4542136%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4542136%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Bounds%20Safety%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" title="Link auf https://heise.de/-4542136" href="https://heise.de/-4542136">Bounds Safety</a> und Lifetime Safety kein Bestandteil der Native Recommended Rules von Microsoft.<br></div><div class="ztitel_kleiner">Konfiguriere deine zu verwendenden Regeln<br></div><div class="text">Wie du aus dem Screenshot erkennen kannst, habe ich meine eigene Kollektion von Regeln definiert und diese unter den Namen CheckProfile gespeichert. Diese Kollektion besteht aus den Regeln C++ Core Guidelines Bounds Rules, C++ Core Guidelines Type Rules und C++ Core Guidelines Lifetime Rules.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_181333602_5b4facc77d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="ztitel_kleiner">Führe die Codeanalyse aus</div><div class="text">Die Anwendung meines eigenen Regelsatzes war sehr erfolgreich: <br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_181333619_0876e3e0ef.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Alle Verletzungen der Profile wurden erkannt. Für jede Verletzung wie zum Beispiel die der ersten erhalte ich die Zeilennummer (17) und die Regel des betroffenen Profils (type.4).</div><div class="ztitel_kleiner">Warnungen unterdrücken<br></div><div class="text">Manchmal sollen spezifische Warnungen unterdrückt werden. Dies lässt sich mit Attributen erreichen. In meinem nächsten Beispiel wende ich zweimal eine Array-to-Zeiger-Vereinfachung (decay) an. Nur der zweite Aufruf führt zu einer Warnung:<br></div><div class="pre">// gslCheckSuppress.cpp<br><br>#include &lt;iostream&gt;<br><br>void f(int* p, int count) {<br>}<br><br>int main() {<br><br>&nbsp;&nbsp;&nbsp; int myArray[100];<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // Break of bounds safety<br>&nbsp;&nbsp;&nbsp; [[gsl::suppress(bounds.3)]] {&nbsp;&nbsp; // suppress warning<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(myArray, 100);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; f(myArray, 100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // warning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>}<br></div><div class="text">Das Attribut <span class="tx_code">gsl::suppress(bounds.3)</span> erfüllt seinen Job wie erwartet. Es ist nur in seinem Bereich gültig. Lediglich die zweite Verletzung der Bounds Safety führt zu einer Warnung:<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_181333625_55e3ce2649.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Ich werde die nächste Sektion der C++ Core Guidelines überspringen, da ich bereits einen Artikel zu der <a title="Link auf https://heise.de/-3780760" href="https://heise.de/-3780760" alt="%7B%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3780760%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3780760%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Guidelines%20Support%20Library%22%7D">Guidelines Support Library</a> geschrieben habe. Ich denke aber, dass der darauffolgende Abschnitt zu kontroversen Reaktionen führt: "Naming and layout rules". <br></div><div class="simple-translate-result-wrapper"><br> <br></div>
