<div class="vorspann">Die C++ Core Guidelines verwenden den Begriff String als eine Sequenz von Zeichen. Konsequenterweise beschäftigen sich daher die Guidelines mit dem C-String, dem C++-String, dem C++17 <i>std::string_view</i> und dem C++17 <i>std::byte</i>.<br></div><div class="text">Ich werde mich in diesem Artikel nicht allzu streng an die Guidelines halten und die Strings ignorieren, die wie <i>gsl.:string_span, zstring</i> und<i> czstring</i> Bestandteil der <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22text%22%3A%22Guidelines%20Support%20Library%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl">Guidelines Support Library</a> sind. Der Einfachheit halber bezeichne ich den <i>std::string </i>als C++-String und <i>const char*</i> als C-String. <br></div><div class="text">Los geht es mit der ersten Regel.</div><div class="ztitel"><a alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-string%22%2C%22text%22%3A%22SL.str.1%3A%20Use%20std%3A%3Astring%20to%20own%20character%20sequences%26nbsp%3B%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-string%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-string" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-string">SL.str.1: Use std::string to own character sequences&nbsp;</a><br></div><div class="text">Ich vermute, du kennst einen anderen String, der eine Zeichensequenz besitzt: den C-String. Verwende keinen C-String! Warum? Mit einem C-String musst du dich um das Speichermanagement, das String-Endzeichen und die Länge des String selbst kümmern:<br></div><div class="pre">// stringC.c<br><br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>&nbsp;<br>int main( void ){<br>&nbsp;<br>&nbsp; char text[10];<br>&nbsp;<br>&nbsp; strcpy(text, "The Text is too long for text.");&nbsp;&nbsp; // (1) text is too big<br>&nbsp; printf("strlen(text): %u\n", strlen(text));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) text has no termination character '\0'<br>&nbsp; printf("%s\n", text);<br>&nbsp;<br>&nbsp; text[sizeof(text)-1] = '\0';<br>&nbsp; printf("strlen(text): %u\n", strlen(text));<br>&nbsp;<br>&nbsp; return 0;<br>}<br></div><div class="text">Das einfache Programm <i>stringC.c</i> besitzt in der Zeile (1) und in der Zeile (2) undefiniertes Verhalten. Wird es mit einem leicht angestaubten GCC 4.8 übersetzt, scheint alles zu funktionieren:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175508323_5b8c8c0067.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Die C++-Variante besitzt nicht die gleichen Probleme:</div><div class="pre">// stringCpp.cpp <br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>int main(){<br>&nbsp;<br>&nbsp; std::string text{"The Text is not too long."};&nbsp; <br>&nbsp;<br>&nbsp; std::cout &lt;&lt; "text.size(): " &lt;&lt; text.size() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; text &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; text +=" And can still grow!";<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; "text.size(): " &lt;&lt; text.size() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; text &lt;&lt; std::endl;<br>&nbsp;<br>}<br></div><div class="text">Die Ausgabe des Programms sollte nicht überraschend sein:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175508331_f8748b08bc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Im Fall des C++-Strings gibt es keine Möglichkeit, Fehler zu machen. Die C++-Laufzeit kümmert sich automatisch um das Speichermanagement und das String-Endzeichen. Wenn du darüber hinaus noch auf die Elemente des C++-Strings mit dem at- und nicht mit dem Index-Operator zugreifst, sind Zugriffe außerhalb des C++-Strings nicht möglich. Die Details zum at-Operator lassen sich schön in meinem vorherigen Artikel "<a title="Link auf Beitrag 2693463" alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Db7eff80d4eaeb6f501e80e3582720990%26rm%3Dopen_article_id%26bid%3D2693463%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Greife%20nicht%20%C3%BCber%20den%20Container%20hinaus%22%2C%22destination%22%3A2693463%2C%22ir_link%22%3A1%7D" href="/exec/mainmenu.pl?sid=b7eff80d4eaeb6f501e80e3582720990&amp;rm=open_article_id&amp;bid=2693463">C++ Core Guidelines: Greife nicht über den Container hinaus</a>" nachlesen.</div><div class="text">Weißt du, was seltsam in C++ einschließlich C++11 war? Es gab keine Möglichkeit, einen C++-String zu erzeugen, der nicht von einem C-String ausging. Dies war seltsam, da doch der C++-String eingeführt wurde, um den C-String loszuwerden. Diese Inkonsistenz gibt es nicht mehr mit C++14. </div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-s" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-s" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-s%22%2C%22version%22%3A1%2C%22text%22%3A%22SL.str.12%3A%20Use%20the%20s%20suffix%20for%20string%20literals%20meant%20to%20be%20standard-library%20strings%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-s%22%7D">SL.str.12: Use the s suffix for string literals meant to be standard-library strings</a> <br></div><div class="text">Mit C++14 haben wir C++-String-Literale erhalten. Dies ist eine C-String-Literal mit einem Suffix <i>s</i>: "<i>cStringLiteral"s</i>. </div><div class="text">Das nächste Beispiel bringt meine Kernaussage auf den Punkt: C-String-Literale sind keine C++-String-Literale:<br></div><div class="pre">// stringLiteral.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; using namespace std::string_literals;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; std::string hello = "hello";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; auto firstPair = std::make_pair(hello, 5);<br>&nbsp;&nbsp;&nbsp; auto secondPair = std::make_pair("hello", 15);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; // auto secondPair = std::make_pair("hello"s, 15);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (firstPair &lt; secondPair) std::cout &lt;&lt; "true" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text">Es ist schade, dass ich den Namensraum <i>std::string_literals</i> in Zeile (1) inkludieren muss, um C++-String-Literale zu verwenden. Die Zeile (2) ist die entscheidende Zeile des Beispiels. Ich verwende in ihr ein C-String-Literal<i> "hello"</i>, um den C++-String zu erzeugen. Dies ist der Grund, dass der Datentyp von <i>firstPai</i>r (<i>std::string, int</i>), aber der Datentyp von <i>secondPair</i> (<i>const char*, int</i>) ist. Daher schlägt der Vergleich in der Zeile (5) fehl, denn unterschiedliche Datentypen können nicht verglichen werden. Betrachte dazu sorgfältig die letzte Zeile der folgenden Fehlermeldung:<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175508338_e1c2c54294.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Wenn ich hingegen den C++-String-Literal in Zeile (4) anstelle des C-String-Literals in Zeile (3) verwende, verhält sich das Programm wie erwartet:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_175508344_76c6911500.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">C++-String-Literale waren ein C++14-Feature. Nun springe ich drei Jahre weiter in die Zukunft. Mit C++17 haben wir <i>std::string_view</i> und <i>std::byte</i> erhalten. Insbesondere zu <i>std::string_view</i> habe ich schon einiges geschrieben. Daher werde ich nur die wichtigsten Fakten wiederholen.</div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-view" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-view%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-view%22%2C%22text%22%3A%22SL.str.2%3A%20Use%20std%3A%3Astring_view%20or%20gsl%3A%3Astring_span%20to%20refer%20to%20character%20sequences%26nbsp%3B%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-view">SL.str.2: Use std::string_view or gsl::string_span to refer to character sequences&nbsp;</a><br></div><div class="text">Ein <i>std::string_view</i> referenziert nur eine Zeichensequenz. Gerne drücke ich das noch expliziter aus: Ein <i>std::string_view</i> besitzt nicht eine Zeichensequenz. Er stellt nur eine Sicht auf Zeichensequenzen dar. Diese Zeichensequenz kann ein C++- oder ein C-String sein. Ein <i>std::string_view</i> benötigt nur zwei Informationen: den Zeiger auf die Zeichensequenz und deren Länge. Er bietet das lesende Teil des Interface eines <i>std::string</i> an. Zusätzlich zu einem <i>std::string</i> unterstützt er zwei modifizierende Operationen: <i>remove_prefix</i> und <i>remove_suffix</i>.</div><div class="text">Vermutlich wunderst du dich gerade: Warum benötigen wir einen <i>std::string_view</i>? Ein <i>std::string_view </i>ist sehr billig zu kopieren und benötigt keinen Speicher. Mein früherer Artikel "<a alt="%7B%22version%22%3A1%2C%22text%22%3A%22Vermeide%20Kopieren%20mit%20std%3A%3Astring_view%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-vermeide-kopieren-mit-std-string-view%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-vermeide-kopieren-mit-std-string-view%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/c-17-vermeide-kopieren-mit-std-string-view" href="https://www.grimm-jaud.de/index.php/blog/c-17-vermeide-kopieren-mit-std-string-view">Vermeide Kopieren mit std::string_view</a>" zeigt die beeindruckenden Performanzzahlen eines <i>std::string_view</i>.</div><div class="text">Wie ich es bereits erwähnt habe, haben wir in C++17 auch den neuen Datentyp <i>std::byte </i>erhalten.&nbsp; </div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-char*" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-char*" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-char%2A%22%2C%22version%22%3A1%2C%22text%22%3A%22SL.str.4%3A%20Use%20char%2A%20to%20refer%20to%20a%20single%20character%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-char%2A%22%7D">SL.str.4: Use char* to refer to a single character</a> and <a alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22SL.str.5%3A%20Use%20std%3A%3Abyte%20to%20refer%20to%20byte%20values%20that%20do%20not%20necessarily%20represent%20characters%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-byte%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rstr-byte%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-byte" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rstr-byte">SL.str.5: Use std::byte to refer to byte values that do not necessarily represent characters</a> <br></div><div class="text">Wenn du nicht der Regel str.4 folgst und <i>const char*</i> als C-String verwendest, findest du dich vielleicht in einer ähnlichen Situation wieder:<br></div><div class="pre">char arr[] = {'a', 'b', 'c'}; <br><br>void print(const char* p) { <br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; p &lt;&lt; '\n'; <br>} <br><br>void use() { <br>&nbsp;&nbsp;&nbsp; print(arr); // run-time error; potentially very bad <br>}<br></div><div class="text"><i>arr</i> wird auf einen Zeiger reduziert, falls er als Argument der Funktion <i>print </i>verwendet wird. Das undefinierte Verhalten ist, dass <i>arr</i> kein String-Endzeichen besitzt. Falls du nun glaubst, du kannst<i> std::byte</i> als ein Zeichen verwendet, ist dies falsch.</div><div class="text"><i>std::byte</i> ist ein Datentyp, der das Konzept eines Bytes umsetzt, wie es im C++-Standard definiert wird. Nun wissen wir, was ein Byte ist. Es ist nicht eine Ganzahl oder ein Buchstabe und daher gegen diese Art von Fehler gefeit. Sein Job ist es, auf Speicher zuzugreifen. Konsequenterweise besteht sein Interface nur aus Methoden für bitweise, logische Operationen:<br> </div><div class="pre">namespace std { <br><br>&nbsp;&nbsp;&nbsp; template &lt;class IntType&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr byte operator&lt;&lt;(byte b, IntType shift); <br>&nbsp;&nbsp;&nbsp; template &lt;class IntType&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr byte operator&gt;&gt;(byte b, IntType shift); <br>&nbsp;&nbsp;&nbsp; constexpr byte operator|(byte l, byte r); <br>&nbsp;&nbsp;&nbsp; constexpr byte operator&amp;(byte l, byte r); <br>&nbsp;&nbsp;&nbsp; constexpr byte operator~(byte b); <br>&nbsp;&nbsp;&nbsp; constexpr byte operator^(byte l, byte r); <br><br>} <br></div><div class="text">Du kannst die Funktion<i> std::to_integer(std::byte b) </i>verwenden, um einen<i> std::byte</i> in eine Ganzzahl zu konvertieren. Der Aufruf <i>std::byte{integer}</i> konvertiert genau in die andere Richtung. <i>integer</i> muss eine positive Zahl sein, die kleiner als <i>std::numeric_limits&lt;unsigned_char&gt;::max()</i> ist.<br></div><div class="ztitel">Wie geht's weiter?<br></div><div class="text">Ich habe nahezu alle Regeln zur C++-Standardbibliothek beschrieben. Lediglich ein paar Regeln zu den Ein- und Ausgabestreams und der C-Standardbibliothek fehlen noch. Du kannst dir denken, worüber ich meinen nächsten Artikel schreibe.<br></div><div class="simple-translate-result-wrapper"><br> <br></div>
