<div class="vorspann">Im letzten Artikel begann ich unsere Reise zum Überladen von Funktionen und Operatoren. Heute setzte ich diese Reise sowohl fort und schließe sie zugleich ab.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_144379843_ed83ee81e9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um den Faden des <a alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3879406%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3879406%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22%22%2C%22text%22%3A%22letzten%20Artikels%22%7D" href="https://www.heise.de/-3879406" class="" title="Link auf https://www.heise.de/-3879406">letzten Artikels</a> wieder aufzunehmen. Hier sind die zehn Regeln.</div>
<div class="text"><ul><li>C.160: Define operators primarily to mimic conventional usage<br></li><li>C.161: Use nonmember functions for symmetric operators<br></li><li>C.162: Overload operations that are roughly equivalent<br></li><li>C.163: Overload only for operations that are roughly equivalent<br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C.164%3A%20Avoid%20conversion%20operators%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion" class="">C.164: Avoid conversion operators</a> <br></li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-custom" alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-custom%22%2C%22text%22%3A%22C.165%3A%20Use%20using%20for%20customization%20points%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-custom%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-custom">C.165: Use using for customization points</a> <br></li><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-address-of%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-address-of%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.166%3A%20Overload%20unary%20%26amp%3B%20only%20as%20part%20of%20a%20system%20of%20smart%20pointers%20and%20references%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-address-of" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-address-of">C.166: Overload unary &amp; only as part of a system of smart pointers and references</a> <br></li><li> <a alt="%7B%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-overload%22%2C%22text%22%3A%22C.167%3A%20Use%20an%20operator%20for%20an%20operation%20with%20its%20conventional%20meaning%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-overload%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-overload" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-overload">C.167: Use an operator for an operation with its conventional meaning</a> <br></li><li>C<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-namespace" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-namespace" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-namespace%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-namespace%22%2C%22text%22%3A%22.168%3A%20Define%20overloaded%20operators%20in%20the%20namespace%20of%20their%20operands%22%7D">.168: Define overloaded operators in the namespace of their operands</a> <br></li><li><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-lambda" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-lambda" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-lambda%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-lambda%22%2C%22text%22%3A%22C.170%3A%20If%20you%20feel%20like%20overloading%20a%20lambda%2C%20use%20a%20generic%20lambda%22%7D">C.170: If you feel like overloading a lambda, use a generic lambda</a></li></ul></div>
<div class="text">Die Reise geht mit der sehr wichtigen Regel 164 weiter. <br></div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-conversion" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.164%3A%20Avoid%20conversion%20operators%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-conversion%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D">C.164: Avoid conversion operators</a></div>
<div class="text">Falls du viel Spass haben willst, dann überlade den Operator bool und setzte ihn nicht auf <i>explicit. </i>Das heißt, dass&nbsp; implizite Typkonveritierungen von <i>bool</i> to <i>int</i> implizit stattfinden können.</div>
<div class="text">Doch ich sollte seriöser argumentieren. Das folgenden Codebeispiel enthält die Klasse <i>MyHouse.</i> Objekte vom Typ <i>MyHouse</i> können von einer Familie gekauft werden kann, sofern es leer ist. Daher ist es natürlich sehr praktisch den Operator bool zu überladen, um einfach zu testen, ob ein Haus bereits von einer Familie gekauft wurde. <br></div>
<div class="pre">// implicitConversion.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br><br>struct MyHouse{<br>&nbsp; MyHouse() = default;<br>&nbsp; MyHouse(const std::string&amp; fam): family(fam){}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; operator bool(){ return not family.empty(); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; // explicit operator bool(){ return not family.empty(); }&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::string family = "";<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; MyHouse firstHouse;<br>&nbsp; if (not firstHouse){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "firstHouse is already sold." &lt;&lt; std::endl;<br>&nbsp; };<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; MyHouse secondHouse("grimm");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; if (secondHouse){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Grimm bought secondHouse." &lt;&lt; std::endl;<br>&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; int myNewHouse = firstHouse + secondHouse;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; auto myNewHouse2 = (20 * firstHouse - 10 * secondHouse) / secondHouse;<br><br>&nbsp; std::cout &lt;&lt; "myNewHouse: " &lt;&lt; myNewHouse &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "myNewHouse2: " &lt;&lt; myNewHouse2 &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>}</div>
<div class="text">Schnell lässt sich mit dem Operator bool prüfen (1), ob eine Familie (4) oder keine Familie (3) in dem Haus wohnt. Dank des impliziten Operators bool, lassen sich nun aber auch Häuser in arithmetischen Ausdrücken (5) verwenden. Das war aber nicht in meiner Absicht.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_144379847_ba55bf374d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><i>MyHouse</i> bietet ein viel zu mächtiges Interface an. Seit C++11 lässt sich ein Konvertierungsoperator als explizit deklarieren. Damit wendet der Compiler keine implizite Konvertierung nach <i>int</i> an. Kommt hingegen der explizite Operator bool zum Einsatz (2), ist die Addition&nbsp; von Häusern nicht mehr zulässig. Jedoch lassen sich Häuser in logischen Ausdrücken verwenden. </div>
<div class="text">Nun schlägt die Übersetzung des Programms fehl.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_144379847_ba55bf374d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-custom" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-custom%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-custom%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.165%3A%20Use%20using%20for%20customization%20points%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-custom">C.165: Use using for customization points</a></div>
<div class="text">Diese Regel ist ziemlich speziell. Daher werde ich es kurz machen. Es gibt rund 50 überladene Version von <i><a alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fswap%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Aswap%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Falgorithm%2Fswap%22%2C%22version%22%3A1%7D" href="http://en.cppreference.com/w/cpp/algorithm/swap" class="" title="Link auf http://en.cppreference.com/w/cpp/algorithm/swap">std::swap</a></i> im C++-Standard. Darüber hinaus kommt es häufig vor, dass bereits eigene swap Methoden für eigene Datentypen verwenden werden: <a href="https://www.heise.de/-3839412" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3839412%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3839412%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Vergleiche%20und%20die%20Funktionen%20swap%20und%20hash%22%7D" title="Link auf https://www.heise.de/-3839412" class="">C++ Core Guidelines: Vergleiche und die Funktionen swap und hash</a>.</div>
<div class="pre">namespace N {<br>&nbsp;&nbsp;&nbsp; My_type X { /* ... */ };<br>&nbsp;&nbsp;&nbsp; void swap(X&amp;, X&amp;);&nbsp;&nbsp; // optimized swap for N::X<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Dank Argument-Dependent Lookup (siehe C.168) findet der Compiler die Implementierung der Funktion swap in Namesraum<i> N</i>. Es ist aber eine gute Idee, die generische Funktione <i>std::swap</i> als eine Art Fallback zu verwenden. <i>std::swap</i> wird vermutlich nicht für deinen Datentyp optimiert sein, lässt sich aber zu mindestens verwenden. Die <i>using</i> Anweisung im folgenden Beispiel verfolgt genau diese Ziel. </div>
<div class="pre">void f3(N::X&amp; a, N::X&amp; b)<br>{<br>&nbsp;&nbsp;&nbsp; using std::swap;&nbsp;&nbsp; // make std::swap available<br>&nbsp;&nbsp;&nbsp; swap(a, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calls N::swap if it exists, otherwise std::swap<br>}</div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-address-of" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C.166%3A%20Overload%20unary%20%26amp%3B%20only%20as%20part%20of%20a%20system%20of%20smart%20pointers%20and%20references%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-address-of%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-address-of%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-address-of">C.166: Overload unary &amp; only as part of a system of smart pointers and references</a></div>
<div class="text">Um ehrlich zu sein: Die Regel C.166 ist viel zu speziell, um sie in diesem Artikel genauer vorzustellen. Falls du den unären Operator &amp; überlädts, um einen Stellvertreter zu erzeugen, solltest du die Konsequenzen kennen.</div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-overload" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-overload%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-overload%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.167%3A%20Use%20an%20operator%20for%20an%20operation%20with%20its%20conventional%20meaning%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-overload">C.167: Use an operator for an operation with its conventional meaning</a></div>
<div class="text">Die Regel C.167 ist der Regel C.160 sehr ählich:&nbsp; C.160: Define operators primarily to mimic conventional usage. Ich schrieb bereits über C.160 in meinem letzten Artikel: <a class="" title="Link auf https://www.heise.de/-3879406" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3879406%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3879406%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20%C3%9Cberladen%20von%20Funktionen%20und%20Operatoren.%22%7D" href="https://www.heise.de/-3879406">C++ Core Guidelines: Überladen von Funktionen und Operatoren.</a></div>
<div class="text">Die Regel lässt sich auf viele Operatoren anwenden.</div>
<div class="text"><ul><li>&lt;&lt;, &gt;&gt;: Ein- und Ausgabe<br></li><li>==, !=, &lt;, &lt;=, &gt;, and &gt;=: Vergleiche<br></li><li>+, -, *, /, and %: Arithmetic<br></li><li>., -&gt;, unary *, and []: Zugriff<br></li><li>=: Zuweisung</li></ul></div>
<div class="ztitel_kleiner">C<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-namespace" alt="%7B%22text%22%3A%22.168%3A%20Define%20overloaded%20operators%20in%20the%20namespace%20of%20their%20operands%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-namespace%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-namespace%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-namespace" class="">.168: Define overloaded operators in the namespace of their operands</a></div>
<div class="text">ADL ist eine besondere Art Namen aufzulösen, die das Leben eines Entwicklers deutlich einfacher werden lässt. ADL steht für Argument-Dependet Lookup, wird aber auch gelegentlich Koenig Lookup genannt. Die besondere Art Namen aufzulösen besteht darin, dass für einen <b>unqualifizierten</b> Funktionsaufruf Funktionen im Namensraum der Funktionsargumente auch berücksichtigt werden. Mehr Details zu ADL gibt es hier: <a alt="%7B%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fadl%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22argument-dependent%20lookup%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fadl%22%2C%22target%22%3A%22_blank%22%7D" href="http://en.cppreference.com/w/cpp/language/adl" class="" title="Link auf http://en.cppreference.com/w/cpp/language/adl">argument-dependent lookup</a>. </div>
<div class="text">Hier kommt eine kleine Erinnerungsstütze. Dank ADL findet die C++-Laufzeit in folgendem Beispiel den richtigen Operator == im Namensraum der Funktionsargumente.. </div>
<div class="pre">namespace N {<br>&nbsp;&nbsp;&nbsp; struct S { };<br>&nbsp;&nbsp;&nbsp; bool operator==(S, S);&nbsp;&nbsp; // OK: in the same namespace as S, and even next to S<br>}<br><br>N::S s;<br><br>bool x = (s == s);&nbsp; // finds N::operator==() by ADL</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-lambda" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-lambda%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.170%3A%20If%20you%20feel%20like%20overloading%20a%20lambda%2C%20use%20a%20generic%20lambda%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Ro-lambda%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ro-lambda" class="">C.170: If you feel like overloading a lambda, use a generic lambda</a></div>
<div class="text">Diese Regel ist sehr leich zu verdauen. Du kannst einen Lambda-Ausdruck nicht überladen. Mit C++14 gilt diese Einschränkung nicht mehr, denn C++14 kennt generische Lambda-Ausdrücke.</div>
<div class="pre">auto g = [](int) { /* ... */ };<br>auto g = [](double) { /* ... */ };&nbsp;&nbsp; // error: cannot overload lambdas<br><br>auto h = [](auto) { /* ... */ };&nbsp;&nbsp; // OK</div>
<div class="text">Ein Lambda-Ausdruck ist eine Instanz einer Klasse, für die der Aufrufeoperator überladen wurde. Gerne werden diese Instanzen auch Funktionsobjekte genannt. Darüber hinaus ist eine generische Lambda-Funktion ein Funktionsobjekt mit einem templifizierten Aufrufoperator. Das war bereits die ganze Theorie.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Für den speziellen Klassentyp <i>union</i> gibt es vier Regeln. Mir ist noch nicht klar, ob ich den ganzen nächsten Artikel benötige, um diese Regeln vorzustellen. Danach habe ich auf jeden Fall alle Regeln für Klassen und Klassenhierarchien vorgestellt und ich werde über Aufzählungen <i>(enum)</i> schreiben. <br></div>
<div class="ztitel">Weitere Informationen</div>
<div class="text"><ul><li>Ich bin froh, dass ich es geschafft habe, diese Artikel noch rechtzeitig zu schreiben. Auf dem <a class="" title="Link auf http://meetingcpp.com/" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fmeetingcpp.com%2F%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Meeting%20C%2B%2B%20in%20Berlin%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fmeetingcpp.com%2F%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="http://meetingcpp.com/">Meeting C++ in Berlin</a>&nbsp; hatte ich dieses Jahr wieder ein volles Programm aus kurzen und langen Vorträgen und einer Fragestunde. Dazu kamen natürlich auch die vielen Diskussionen zur Zukunft von C++. <br></li><li>Für meine drei offenen Seminare im ersten Halbjahr 2018 sind noch Plätze frei. Ich freue mich immer darauf, meine Leidenschaft vermitteln zu können.<br></li><ul><li> <a title="Link auf http://www.modernescpp.de/index.php/c" class="" href="http://www.modernescpp.de/index.php/c" alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Embedded%20Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%7D">Embedded Programmierung mit modernem C++</a>: 16.01 - 18.01 </li><li> <a alt="%7B%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%3A%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="http://www.modernescpp.de/index.php/c" class="" title="Link auf http://www.modernescpp.de/index.php/c">C++11 und C++14:</a> 13.03 - 15.03 </li><li> <a title="Link auf http://www.modernescpp.de/index.php/c" class="" href="http://www.modernescpp.de/index.php/c" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Multithreading%20mit%20modernem%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D">Multithreading mit modernem C++</a>: 08.05 - 09.05 </li></ul></ul></div>
