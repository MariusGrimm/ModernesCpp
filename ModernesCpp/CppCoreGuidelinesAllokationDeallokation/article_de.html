<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_145774999_f194778629.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Die Guidelines besitzen sechs Regeln für das explizite Anfordern und Freigeben von Speicher. Das ist sehr überraschend. Lautet eine einfache Regel in modernem C++ doch schlicht: "Verwende kein explizites new und delete." Offensichtlich ist die C++-Welt doch nicht so einfach.</div>
<div class="text">Hier sind die sechs Regeln:</div>
<div class="text"><ul><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-mallocfree" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-mallocfree%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22R.10%3A%20Avoid%20malloc%28%29%20and%20free%28%29%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-mallocfree%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-mallocfree">R.10: Avoid malloc() and free()</a> <br></li><li> <a class="" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-newdelete%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22R.11%3A%20Avoid%20calling%20new%20and%20delete%20explicitly%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-newdelete%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete">R.11: Avoid calling new and delete explicitly</a> <br></li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-immediate-alloc" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22R.12%3A%20Immediately%20give%20the%20result%20of%20an%20explicit%20resource%20allocation%20to%20a%20manager%20object%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-immediate-alloc%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-immediate-alloc%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-immediate-alloc">R.12: Immediately give the result of an explicit resource allocation to a manager object</a> <br></li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-single-alloc" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-single-alloc%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-single-alloc%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.13%3A%20Perform%20at%20most%20one%20explicit%20resource%20allocation%20in%20a%20single%20expression%20statement%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-single-alloc">R.13: Perform at most one explicit resource allocation in a single expression statement</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ap" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ap" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ap%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22R.14%3A%20%3F%3F%3F%20array%20vs.%20pointer%20parameter%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ap%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="">R.14: ??? array vs. pointer parameter</a> <br></li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-pair" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-pair" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-pair%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22R.15%3A%20Always%20overload%20matched%20allocation%2Fdeallocation%20pairs%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-pair%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" class="">R.15: Always overload matched allocation/deallocation pairs</a></li></ul></div>
<div class="text">Ich werde kein Wort über die letzten zwei Regeln verlieren. Zum einen ist die Regel R.14 nur ein Fragment, zum anderen ist mir die Regel R.15 zu speziell für allgemeine Empfehlungen. Wenn du mehr zu dem Überladen von <i>new</i> und <i>delete</i> wissen willst, kannst du meine Artikel zur <a alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fnew%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fnew%22%2C%22text%22%3A%22Speicheranforderung%20und%20-freigabe%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/new" href="http://www.grimm-jaud.de/index.php/blog/tag/new" class="">Speicheranforderung und -freigabe</a> durchlesen.</div>
<div class="text">Bevor ich tiefer in die Regel eintauche, ist noch ein wenig Hintergrundwissen notwendig, um diese besser zu verstehen. Das Erzeugen eines Objekts mit <i>new</i> besteht in C++ aus zwei Schritten.&nbsp;</div>
<div class="text"><ol><li> Anfordern des Speichers für das Objekt</li><li>Initialisieren des Objekts in dem angeforderten Speicherbereich</li></ol></div>
<div class="text"><a class="" href="http://en.cppreference.com/w/cpp/memory/new/operator_new" title="Link auf http://en.cppreference.com/w/cpp/memory/new/operator_new" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fmemory%2Fnew%2Foperator_new%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22operator%20new%20or%20operator%20new%20%5B%5D%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fmemory%2Fnew%2Foperator_new%22%7D">operator new or operator new []</a> übernehmen den ersten Schritt; der Konstruktor übernimmt den zweiten. Dieselbe Strategie findet bei der Destruktion des Objekts in umgekehrter Reihenfolge statt. Zuerst wird der Destruktor (falls vorhanden) aufgerufen, und dann wird der Speicher mittels <a class="" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22operator%20delete%20or%20operator%20delete%20%5B%5D%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fmemory%2Fnew%2Foperator_delete%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fmemory%2Fnew%2Foperator_delete%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" title="Link auf http://en.cppreference.com/w/cpp/memory/new/operator_delete" href="http://en.cppreference.com/w/cpp/memory/new/operator_delete">operator delete or operator delete []</a> freigegeben. Diese zweistufige Erzeugen und die Destruktion sind der Grund für die vier Regeln. Jetzt geht es los mit den Regeln.</div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-mallocfree" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-mallocfree%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-mallocfree%22%2C%22text%22%3A%22R.10%3A%20Avoid%20malloc%28%29%20and%20free%28%29%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-mallocfree" class="">R.10: Avoid malloc() and free()</a></b></div>
<div class="text">Was ist der Unterschied zwischen <i>new</i> und <i>malloc</i> bzw. <i>delete</i> und <i>free</i>? Die C-Funktionen<i> malloc</i> und<i> free </i>tun nur die Hälfte ihres Jobs. <i>malloc</i> fodert lediglich den Speicher an, den <i>free</i> wieder freigibt. Weder ruft <i>malloc</i> den Konstruktor auf noch <i>free</i> den Destruktor.</div>
<div class="text">Das bedeutet, wenn du ein Objekt verwendest, das mit malloc<i> erzeugt </i>wurde, erhältst du undefiniertes Verhalten. </div>
<div class="pre">// mallocVersusNew.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>struct Record{<br>&nbsp; Record(std::string na = "Record"): name(na){}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; std::string name;<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Record* p1 = static_cast&lt;Record*&gt;(malloc(sizeof(Record)));&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; p1-&gt;name &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp;&nbsp;&nbsp; auto p2 = new Record;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; p2-&gt;name &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>}</div>
<div class="text">Ich fordere lediglich in (1) Speicher für mein <i>Record</i>-Objekt an. Das Ergebnis ist, dass die Ausgabe <i>p1-&gt;name</i> in (3) undefiniertes Verhalten darstellt. Im Gegensatz dazu, stößt der Ausdruck (2) den Konstruktor in Zeile (4) an. Undefiniertes Verhalten bedeutet schlicht, dass keine verbindlichen Annahmen zu dem Programm mehr möglich sind.</div>
<div class="text">Abhängig von der verwendeten Plattform und dem verwendeten GCC Compiler verhält sich das Programm vollkommen unterschiedlich. </div>
<div class="text"><ul><li> GCC 4.8.5 produziert einen Core Dump auf meinem lokalen PC.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_145775009_b21e174e02.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><ul><li>GCC 4.9 (auf cppreference.com) produziert keine Ausgabe.</li></ul></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_145775014_447535930b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><ul><li>GCC 7.1 (auf cppreference.com ) produziert die <i>erwartete</i> Ausgabe.</li></ul></div>
<div class="text">&nbsp;<img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_145775021_07a3d33890.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-newdelete%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-newdelete%22%2C%22text%22%3A%22R.11%3A%20Avoid%20calling%20new%20and%20delete%20explicitly%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete" class="">R.11: Avoid calling new and delete explicitly</a></b></div>
<div class="text">Diese Regel solltest du im Kopf behalten. Die Betonung in dieser Regel liegt auf dem Wort <b>explizit</b>, denn Smart Pointer oder die Container der Standard Template Library verwenden <b>implizit </b><i>new</i> und <i>delete</i>. <br> </div>
<div class="text"><b><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-immediate-alloc" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.12%3A%20Immediately%20give%20the%20result%20of%20an%20explicit%20resource%20allocation%20to%20a%20manager%20object%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-immediate-alloc%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-immediate-alloc%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-immediate-alloc">R.12: Immediately give the result of an explicit resource allocation to a manager object</a></b></div>
<div class="text">R.12 ist der entscheidende Grund, um Smart Pointer wie <i>std::unique_ptr&lt;int&gt; upInt(new int))</i> zu verwenden, und gilt nicht für das Gegenbeispiel aus den Guidelines. Falls die Speicheranforderung des Puffer buffer fehlschlägt, geht der Filehandle&nbsp; verloren.</div>
<div class="pre">void f(const std::string&amp; name)<br>{<br>&nbsp;&nbsp;&nbsp; FILE* f = fopen(name, "r");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // open the file<br>&nbsp;&nbsp;&nbsp; std::vector&lt;char&gt; buf(1024);<br>&nbsp;&nbsp;&nbsp; fclose(f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // close the file<br>}<br> </div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-single-alloc" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-single-alloc%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-single-alloc%22%2C%22text%22%3A%22R.13%3A%20Perform%20at%20most%20one%20explicit%20resource%20allocation%20in%20a%20single%20expression%20statement%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-single-alloc" class="">R.13: Perform at most one explicit resource allocation in a single expression statement</a></b></div>
<div class="text">Die Regel ist ein wenig knifflig. </div>
<div class="pre">void func(std::shared_ptr&lt;Widget&gt; sp1, std::shared_ptr&lt;Widget&gt; sp2){<br>&nbsp;...<br>}<br><br>func(std::shared_ptr&lt;Widget&gt;(new Widget(1)), <br>&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Widget&gt;(new Widget(2)));</div>
<div class="text">Der Aufruf der Funkion <i>func</i> ist nicht exception-safe und kann daher in einem Speicherleck enden. Warum? Der Grund ist, dass vier Operationen ausgeführt werden müssen, um die zwei Shared Pointer zu initialisieren. </div>
<div class="text"><ol><li>Speicheranforderung für <i>Widget(1)</i></li><li>Aufruf des Konstruktors für<i> Widget(1)</i><br></li><li>Speicheranforderung für <i>Widget(2)</i></li><li>Aufruf des Konstruktors für <i>Widget(2)</i></li></ol></div>
<div class="text">Der Compiler kann aber durchaus erst den Speicher für <i>Widget(1) </i>und <i>Widget(2)</i> anfordern, bevor er die Konstruktoren aufruft.</div>
<div class="text"><ol><li>Speicheranforderung für <i>Widget(1)</i></li><li><i>Speicheranforderung für Widget(2)</i></li><li>Aufruf des Konstruktors für<i> Widget(1)</i><br></li><li>Aufruf des Konstruktors für <i>Widget(2)</i></li></ol></div>
<div class="text">Falls nun einer der Konstruktoren eine Ausnahme wirft, wird der Speicher des anderen Objekts nicht automatisch freigegeben, und wir erhalten ein Speicherleck.</div>
<div class="text">Dies Problem lässt sich sehr einfach durch die Fabrikfunktion <i>std::make_shared</i> lösen, die einen <i>std::shared_ptr</i> erzeugt. </div>
<div class="pre">func(std::make_shared&lt;Widget&gt;(1), std::make_shared&lt;Widget&gt;(2));</div>
<div class="text"><i>std::make_shared </i>sichert zu, dass die Funktion keinen Effekt besitzt, falls eine Ausnahme geworfen wird. Für das Pendant <i>std::make_unique</i>, um eine <i>std::unique_ptr</i> zu erzeugen, gibt dieselbe Garantie. </div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Die nächsten Regeln zum Umgang mit Ressourcen werden der Regel R.11 folgen: avoid calling new and delete explicitly. Daher geht es im nächsten Artikel rund um die Smart Pointer<i> std::unique_ptr, std::shared</i>_ptr und <i>std::weak_ptr</i>. </div>
<div class="ztitel">Weitere Informationen:</div>
<div class="text"><ul><li> Die neuen PDF-Päckchen <b>stehen zum Download bereit:</b><br></li><ul><li>Deutsch: <a class="" href="http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Multithreading%3A%20The%20High-Level%20Schnittstelle%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle">Multithreading: The High-Level Schnittstelle</a> <br></li><li>Englisch:<a class="" href="http://www.modernescpp.com/index.php/the-new-pdf-bundle-is-available-embedded-performance-matters" title="Link auf http://www.modernescpp.com/index.php/the-new-pdf-bundle-is-available-embedded-performance-matters" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22%20Embedded%3A%20Performance%20Matters%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-available-embedded-performance-matters%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-available-embedded-performance-matters%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%7D"> Embedded: Performance Matters</a></li></ul><li><b>Für meine drei offenen Seminare im ersten Halbjahr 2018 sind noch Plätze frei:</b><br></li><ul><li> <a href="http://www.modernescpp.de/index.php/c" title="Link auf http://www.modernescpp.de/index.php/c" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22ir_link%22%3A1%7D" class="">Embedded-Programmierung mit modernem C++</a>: 16. bis 18. Januar 2018 </li><li> <a title="Link auf http://www.modernescpp.de/index.php/c" alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="http://www.modernescpp.de/index.php/c" class="">C++11 und C++14</a>: 13. bis 15. März 2018<br></li><li> <a href="http://www.modernescpp.de/index.php/c" title="Link auf http://www.modernescpp.de/index.php/c" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Multithreading%20mit%20modernem%20C%2B%2B%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" class="">Multithreading mit modernem C++</a>: 8. bis 9. Mai. 2018</li></ul></ul></div>
