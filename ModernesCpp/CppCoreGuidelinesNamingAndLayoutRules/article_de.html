<div class="vorspann">Die C++ Core Guidelines besitzen rund zwanzig Regeln zu Namen und zum Layout von Sourcecode. Einige dieser Regeln sind sehr offensichtlich, andere deutlich kontroverser. Auf diese werde ich genauer eingehen.</div><div class="ztitel">Regeln zu Namen und zum Layout des Codes<br></div><div class="text">Zuerst einmal ist es wichtiger, die Konsistenz mit dem bestehenden Sourcecode zu wahren als neuen Regeln zu folgen, die die Namen und das Layout des Codes bestimmen. Mit diesem Vorgedanken möchte ich meinen Artikel beginnen. Diese Regeln stehen heute auf meiner Agenda:</div><div class="text"><ul><li>NL.1: Don’t say in comments what can be clearly stated in code</li><li>NL.2: State intent in comments</li><li>NL.3: Keep comments crisp</li><li>NL.4: Maintain a consistent indentation style</li><li>NL.5: Don’t encode type information in names</li><li>NL.7: Make the length of a name roughly proportional to the length of its scope</li><li>NL.8: Use a consistent naming style</li><li>NL.9: Use ALL_CAPS for macro names only</li><li>NL.10: Avoid CamelCase</li><li>NL.11: Make literals readable</li><li>NL.15: Use spaces sparingly</li><li>NL.16: Use a conventional class member declaration order</li><li>NL.17: Use K&amp;R-derived layout</li><li>NL.18: Use C++-style declarator layout</li><li>NL.19: Avoid names that are easily misread</li><li>NL.20: Don’t place two statements on the same line</li><li>NL.21: Declare one name (only) per declaration</li><li>NL.25: Don’t use void as an argument type</li><li>NL.26: Use conventional const notation</li></ul></div><div class="text">Ich werde nichts zu den Regeln schreiben, die bereits ausreichend Dokumentation in den Guidelines besitzen. Ich werde nur zu den Regeln schreiben, die zusätzliche Erläuterungen benötigen oder in meinen Seminaren diskutiert werden.</div><div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-comments" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-comments" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-comments%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-comments%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22NL.1%3A%20Don%C2%92t%20say%20in%20comments%20what%20can%20be%20clearly%20stated%20in%20code%22%7D">NL.1: Don’t say in comments what can be clearly stated in code</a>&nbsp;<br></div><div class="text">Ehrlich gesagt bin ich kein Freund davon, jedes Stück Code zu dokumentieren. Wenn du das tust, ist das für mich ein Anzeichen auf ein Geschmäckle (code smell), denn dein Code ist zu kompliziert. Ich folge eher der Python-Regel: Explicit is better than implicit. Ich schreibe nur einen Kommentar, wenn ich einen Trick anzuwenden habe, der nicht offensichtlich ist. So neigen zum Beispiel unerfahrene Programmierer dazu, geschweifte Klammer aus dem Code mit genau der Einstellung zu entfernen, mit der sie überflüssige geschweifte Klammern aus arithmetischen Ausdrücken entfernen. Wenn du mir nicht glaubst, besuche meine Schulungen. Geschweifte Klammer sind aber oft essenziell, um RAII-Objekten wie Locks oder Smart-Pointern einen Bereich vorzugeben. Werden die geschweiften Klammern in diesem Fall von einem Lock entfernt, erhältst du im beste Fall ein langsameres Programm und im schlechtesten Fall ein Deadlock. Das führt dazu, dass viele meiner Kunden die folgende Anwendung von geschweiften Klammern dokumentieren:</div><div class="pre">std::mutex mut;<br>{&nbsp;&nbsp; // necessary to manage the lifetime of the lock<br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lock(mut);<br>&nbsp;&nbsp;&nbsp; ...<br>}<br></div><div class="text">Das Schlechte an Kommentaren ist, dass sie automatisch veralten. Das ist per Definition für den Sourcecode nicht möglich. Dieser ist immer auf dem aktuellen Stand. Als Berufseinsteiger bestand mein Job häufig darin, bestehenden Code zu analysieren oder zu refaktorieren. Ehrlich gesagt hatte ich oft keine Ahnung, welche Intention der Code hatte, und war daher sehr frustriert. Zu meiner Rettung fand ich aber ein paar Kommentare. Leider waren die Kommentare total veraltet. Es dauerte oft einige Zeit, bis mir das bewusst wurde. Du kannst dir wohl denken, wie frustrierend das war. Kommentare müssen mit der gleichen Sorgfalt wie Sourcecode gepflegt werden. Das trifft aber oft nicht zu.</div><div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-name-type" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-name-type" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22NL.5%3A%20Don%C2%92t%20encode%20type%20information%20in%20names%26nbsp%3B%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-name-type%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-name-type%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D">NL.5: Don’t encode type information in names&nbsp;</a></div><div class="text">Wirklich? Muss dies immer noch als Regel postuliert werden? Ich dachte, wir haben die ungarische Notation wie das letzte Jahrtausend hinter uns gelassen. Ich meine die <i>guten alten Zeite</i>n, in den unsere Variablen noch keine Typen besaßen. <a alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHungarian_notation%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHungarian_notation%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Ungarische%20Notation%22%7D" href="https://en.wikipedia.org/wiki/Hungarian_notation" title="Link auf https://en.wikipedia.org/wiki/Hungarian_notation">Ungarische Notation</a> ist dank der Typprüfung des Compilers überflüssig, widerspricht der generischen Programmierung und [--] dies ist mein Hauptargument [--] veraltet ähnlich schnell wie Kommentare. Kannst du erraten, für welche Datentypen die folgenden Variablen stehen?</div><div class="pre">bBusy;<br>fBusy;<br>pFoo;<br>szLastName;<br>fnFunction;<br>pszOwner;<br>rgfpBalances;<br>lpszBar;<br>g_nWhells;<br>m_whells;<br>_whells;<br></div><div class="text">Falls du es nicht weißt, hier ist die Lösung: <a title="Link auf https://en.wikipedia.org/wiki/Hungarian_notation" href="https://en.wikipedia.org/wiki/Hungarian_notation" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHungarian_notation%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHungarian_notation%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Ungarische%20Notation%22%7D">Ungarische Notation</a>.</div><div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-name-length" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-name-length" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-name-length%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22NL.7%3A%20Make%20the%20length%20of%20a%20name%20roughly%20proportional%20to%20the%20length%20of%20its%20scope%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-name-length%22%7D">NL.7: Make the length of a name roughly proportional to the length of its scope</a></div><div class="text">Obwohl sich diese Regel zuerst einmal seltsam anhört, wenden wir sie schon lange an. Indem du eine Variable<i>&nbsp;</i><span class="tx_code">i</span>&nbsp;oder<span class="tx_code">&nbsp;j</span><i>&nbsp;</i>nennst oder ihr den Namen&nbsp;<span class="tx_code">T</span>&nbsp;gibst, machst du deine Absicht sofort klar:&nbsp;<span class="tx_code">i</span>&nbsp;und&nbsp;<span class="tx_code">j</span><i>&nbsp;</i>sind Indizes, und&nbsp;<span class="tx_code">T</span>&nbsp;ist der Typ-Parameter eines Templates:</div><div class="pre">template&lt;typename T&gt; // good<br>void print(ostream&amp; os, const vector&lt;T&gt;&amp; v)<br>{<br>&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; v.size(); ++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os &lt;&lt; v[i] &lt;&lt; '\n';<br>}</div><div class="text">Hinter dieser Regel verbirgt sich eine Metaregel. Ein Name sollte selbsterklärend sein. In einem kleinen Bereich ist auf einen Blick ersichtlich, für was der Name steht. Das gilt aber nicht automatisch für einen größeren Kontext, der mehrere Bereiche umfasst. Daher werden diese Variablennamen länger sein.</div><div class="ztitel_kleiner"><a alt="%7B%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-order%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22NL.16%3A%20Use%20a%20conventional%20class%20member%20declaration%20order%26nbsp%3B%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-order%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-order" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-order">NL.16: Use a conventional class member declaration order&nbsp;</a><br></div><div class="text">Das ist eine einfache und sehr hilfreiche Regel.</div><div class="text"><ul><li> Wenn du eine Klasse deklarierst, verwende die folgende Reihenfolge: die Konstruktoren, Zuweisungsoperatoren und Destruktoren vor den Funktionen und die wiederum vor den Daten.</li><li>Dasselbe gilt für die Zugriffsspezifizierer: <span class="tx_code">public</span> vor <span class="tx_code">protected</span> und dies vor <span class="tx_code">private</span><i>.</i> <br></li><li>Verwende einen Zugriffsspezifizierer nicht mehrmals:</li></ul></div><div class="pre">class X {&nbsp;&nbsp; // bad<br>public:<br>&nbsp;&nbsp;&nbsp; void f();<br>public:<br>&nbsp;&nbsp;&nbsp; int g();<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div><div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-misread" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-misread" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-misread%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22NL.19%3A%20Avoid%20names%20that%20are%20easily%20misread%26nbsp%3B%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-misread%22%7D">NL.19: Avoid names that are easily misread&nbsp;</a><br></div><div class="text">Kannst du das Beispiel lesen, ohne mit der Wimper zu zucken?</div><div class="pre">if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();</div><div class="text">Um ehrlich zu sein, ich habe öfters Probleme mit der Zahl 0 und dem großen Buchstaben O. Abhängig vom verwendeten Font können die beiden Zeichen sehr ähnlich aussehen. Vor kurzer Zeit benötigte ich mehrere Versuche, mich in einen Server einzuloggen. Das automatisch erzeugte Passwort enthielt das Zeichen O.<br></div><div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-stmt" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-stmt" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-stmt%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rl-stmt%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22NL.20%3A%20Don%C2%92t%20place%20two%20statements%20on%20the%20same%20line%26nbsp%3B%22%7D">NL.20: Don’t place two statements on the same line&nbsp;</a></div><div class="text">Hier ist ein Beispiel. Findest du die zwei Probleme?</div><div class="pre">char* p, p2;<br>char a = 'a';<br>p = &amp;a;<br>p2 = a; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // (1)<br><br>int a = 7, b = 9, c, d = 10, e = 3; // (2)</div><div class="text"><span class="tx_code">p2</span>&nbsp;ist kein Zeiger, aber ein&nbsp;<span class="tx_code">char</span>&nbsp;(1) und&nbsp;<span class="tx_code">c</span>&nbsp;ist nicht initialisiert (2).</div><div class="text">Mit C++17 erhalten wir eine Ausnahme der Regeln: strukturierte Bindung. Strukturierte Bindung erlaubt es in eleganter Weise, mehrere Namen in einer Deklaration zu erklären (Zeile 1):<br></div><div class="pre">std::map&lt;int,std::string&gt; myMap;<br><br>if (auto [iter, succeeded] = myMap.insert(value); succedded){ // (1)<br> useResult(iter); <br> // ...<br>} <br>else{<br> // ...<br>} // iter and succeeded are automatically destroyed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Fertig! Nach mehr als einhundert Artikel zu den <a title="Link auf https://www.grimm-jaud.de/index.php/blog/category/heise-news" href="https://www.grimm-jaud.de/index.php/blog/category/heise-news" alt="%7B%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fheise-news%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fheise-news%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D">C++ Core Guidelines</a> habe ich zwei gute Nachrichten.<br></div><div class="text">Zuerst einmal werde ich ein Buch zu den C++ Core Guidelines schreiben. In diesem werde ich mein Bestes geben und eine kompakte Geschichte zu dem sehr wertvollen Inhalt zu erzählen. Meine Idee ist es, meine Geschichte auf C++17 zu basieren und die Regeln der C++ Core Guidelines zu verwenden, die notwendig für modernes C++ sind. Klar, modernes C++ steht für C++, das typsicher ist, die Grenzen von Container beachtet und die Lebenszeit von Variablen automatisch verwaltet. Ich werde in den nächsten Tagen beginnen und ab und zu eine Wasserstandsmeldung geben.</div><div class="text">Meine Artikelserie zu den C++ Core Guidelines endet und damit beginnt meine neue Artikelserie zu dem hochaktuellen C++20-Standard. Meine Artikel zu C++20 werden mit einer Suche in die Breite starten und mit einer Suche in die Tiefe enden. C++20 ist ähnlich mächtig wie C++11. Daher kannst du annehmen, dass ich einiges zur Zukunft von C++ zu schreiben habe.<br></div><div class="simple-translate-result-wrapper"><br> <br></div><div class="simple-translate-result-wrapper"><br> <br></div>
