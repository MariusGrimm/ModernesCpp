<div class="vorspann">Insbesondere eine Regel zu Template Interfaces habe ich noch nicht vorgestellt, die sehr interessant ist: T.47: Avoid highly visible unconstrained templates with common names. Diese Regel ist oft der Grund für unerwartetes Verhalten, da die falsche Funktion aufgerufen wird.</div>
<div class="text">Obwohl ich heute hauptsächlich über die Regel T.47 schreibe, habe ich mehr zu sagen.</div>
<div class="text"><ul><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-visible" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-visible" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22T.47%3A%20Avoid%20highly%20visible%20unconstrained%20templates%20with%20common%20names%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-visible%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-visible%22%2C%22anchor%22%3A%22%22%7D">T.47: Avoid highly visible unconstrained templates with common names</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concept-def" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concept-def" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22T.48%3A%20If%20your%20compiler%20does%20not%20support%20concepts%2C%20fake%20them%20with%20enable_if%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concept-def%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concept-def%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D">T.48: If your compiler does not support concepts, fake them with enable_if</a> </li><li> <a alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-erasure%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-erasure%22%2C%22text%22%3A%22T.49%3A%20Where%20possible%2C%20avoid%20type-erasure%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-erasure" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-erasure">T.49: Where possible, avoid type-erasure</a></li></ul></div>
<div class="text">Um die Regel T.47 besser zu verstehen, werde ich einen kleinen Umweg machen. In diesem geht es um Argument-Dependent Lookup (ADL), auch bekannt unter den Namen Koenig Lookup, benannt nach <a alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAndrew_Koenig_%28programmer%29%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAndrew_Koenig_%28programmer%29%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Andrew%20Koenig%22%2C%22ir_link%22%3A1%7D" title="Link auf https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)" href="https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)" class="">Andrew Koenig</a>. <br></div>
<div class="ztitel">Argument-Dependent Lookup (ADL)<br></div>
<div class="text">Hier ist die Definition von ADL:</div>
<div class="einrueckung"><b>Argument-Dependent Lookup</b> ist eine Menge von Regeln, um nicht qualifizierte Funktionsnamen aufzulösen. Für die Auflösung nichtqualifizierte Funktionsnamen wird zusätzlich der Namensraum der Funktionsargumente verwendet.</div>
<div class="text">Nichtqualifizierte Funktionsnamen sind Funktionsnamen ohne den Bereichsoperator (::). Ist Argument-Dependent Lookup schlecht? Natürlich nicht. Dank ihm wird unser Leben als Programmierer deutlich einfacher. Hier ist ein Beispiel:<br></div>
<div class="pre">#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Argument-dependent lookup";&nbsp; <br>}</div>
<div class="text">Lass mich den Syntactic Sugar zur Überladung von Operatoren entfernen und die Funktion direkt aufrufen:</div>
<div class="pre">#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; operator&lt;&lt;(std::cout, "Argument-dependent lookup");<br>}</div>
<div class="text">Das folgende äquivalente Programm zeigt sehr schön, was unter der Decke stattfindet. Die Funktion [i]operator&lt;&lt;[/i] wird mit den zwei Argumenten [i]std::cout[/i] und dem C-String "Argument-dependent lookup" aufgerufen. </div>
<div class="text">Natürlich taucht jetzt die Frage auf: "Wo befindet sich die Definition der Funktion <i>operator&lt;&lt;</i> ?". Offensichtlich wird sie nicht im globalen Namensraum definiert. [i]operator&lt;&lt;[/i] ist ein nichtqualifizierter Funktionsname. Daher kommt ADL zum Einsatz, und der Namensraum der Argumente wird zusätzlich verwendet, um die Funktion aufzulösen. In diesem konkreten Fall wird dank des Funktionsarguments <i>std::cout </i>der Namensraum <i>std</i> durchsucht. Das Ergebnis ist <i>std::operator&lt;&lt;(std::ostream&amp;, const char*)</i>. Oft findet ADL genau die Funktion, die du benötigst, aber nicht immer.</div>
<div class="text">Jetzt ist der richtige Zeitpunkt, die Regel T.47 genauer zu betrachten.<span class="co1"><br></span></div>
<div class="ztitel"><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-visible%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-visible%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22T.47%3A%20Avoid%20highly%20visible%20unconstrained%20templates%20with%20common%20names%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-visible" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-visible">T.47: Avoid highly visible unconstrained templates with common names</a> <br> </div>
<div class="text">In dem Ausdruck <i>std::cout &lt;&lt; "Argument-dependent lookup" </i>ist der überladene Operator <i>operator &lt;&lt;</i> ein weit sichtbarer, häufig verwendeter Name, denn er wird im Namensraum [i]std[/i] definiert. Das folgende Programm, das auf dem Programm der C++ Core Guidelines basiert, zeigt den entscheidenden Punkt:</div>
<div class="pre">// argumentDependentLookup.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>namespace Bad{<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; struct Number{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m; <br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; template&lt;typename T1, typename T2&gt; // generic equality&nbsp; (5)<br>&nbsp;&nbsp;&nbsp; bool operator==(T1, T2){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp; <br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>namespace Util{<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; bool operator==(int, Bad::Number){&nbsp;&nbsp; // equality to int (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; void compareSize(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bad::Number badNumber{5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "5 == badNumber: " &lt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5 == badNumber) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "vec.size() == badNumber: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vec.size() == badNumber) &lt;&lt; std::endl; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main(){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; Util::compareSize();<br><br>}</div>
<div class="text">Ich erwarte, dass in beiden Fällen (2 und 3) der überladene Operator == in Zeile (4) aufgerufen wird, denn es verlangt ein Argument vom Typ <i>Bad::Number</i>(1). In Summe bedeutet das, dass ich zweimal <i>true</i> erhalte. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_163119251_627e3c7740.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Was ist hier passiert? Der Aufruf in Zeile (3) wird durch den generischen Gleichheitsoperator in Zeile (5) aufgelöst. Der Grund für meine Überraschung ist, dass <i>vec.size() </i>einen Datentyp vom Typ<i> std::size_type</i> zurückgibt. Das bedeutet, dass der Gleichheitsoperator in der Zeile eine Konvertierung nach <i>int </i>anwenden muss. Das gilt aber nicht für den generischen Gleichheitsoperator in Zeile (5), denn in diesem Fall wird keine Konvertierung&nbsp; angewandt. Dank des Argumente-Dependent Lookup gehört der generische Gleichheitsoperator zu der Menge der möglichen Überladungen. &nbsp; </div>
<div class="text">Die Regel lautet: ""Avoid highly visible unconstrained templates with common names". Was passiert nun, wenn ich der Regel folge und den generischen Gleichheitsoperator entferne. Hier ist der angepasste Sourcecode:</div>
<div class="pre">// argumentDependentLookupResolved.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>namespace Bad{<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; struct Number{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m; <br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; <br>}<br><br>namespace Util{<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; bool operator==(int, Bad::Number){&nbsp;&nbsp; // compare to int (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; void compareSize(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bad::Number badNumber{5};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; vec{1, 2, 3, 4, 5};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "5 == badNumber: " &lt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5 == badNumber) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "vec.size() == badNumber: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vec.size() == badNumber) &lt;&lt; std::endl; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main(){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; Util::compareSize();<br><br>}</div>
<div class="text">Nun entspricht das Ergebnis meiner Erwartung:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_163119258_9f2b81f1c2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Hier sind meine Anmerkungen zu den letzten zwei Regeln zu Interfaces für Templates.<br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concept-def" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concept-def" alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22T.48%3A%20If%20your%20compiler%20does%20not%20support%20concepts%2C%20fake%20them%20with%20enable_if%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concept-def%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-concept-def%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D">T.48: If your compiler does not support concepts, fake them with enable_if</a> <br> </div>
<div class="text">Wenn ich <i>std::enable_if</i> in meinen Seminaren vorstelle, sind einige Teilnehmer leicht verängstigt. Hier ist eine vereinfachte, generische Variante des Algorithmus zur Bestimmung des größten gemeinsamen Teilers zweier Zahlen:<br></div>
<div class="pre">// enable_if.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>template&lt;typename T,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type= 0&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>T gcd(T a, T b){<br>&nbsp;&nbsp;&nbsp; if( b == 0 ){ return a; }<br>&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gcd(b, a % b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd(100, 10)= " &lt;&lt;&nbsp; gcd(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd(3.5, 4)= " &lt;&lt; gcd(3.5, 4.0) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Der Algorithmus ist viel zu generisch. Er sollte nur für Ganzzahlen zum Einsatz kommen. Zu meiner Rettung gibt es <i>std::enable_if </i>(Zeile 1) aus der <a alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Typ-Traits%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" class="" href="https://en.cppreference.com/w/cpp/header/type_traits">Typ-Traits</a>-Bibliothek.</div>
<div class="text">Der Ausdruck <i>std::is_integral</i> (Zeile 2) ist entscheidend, um das Programm zu verstehen. Diese Zeile bestimmt, ob der Parameter T eine Ganzzahl ist. Falls T keine Ganzzahl ist und damit der Rückgabetyp <i>false</i> ist, wird der Compiler keine Template-Instanziierung für diese konkreten Fall durchführen. </div>
<div class="text">Nur wenn <i>std::enable_if true</i> zurückgibt,&nbsp; besitzt <i>std::enable_if das </i>Attribut <i>type.</i> Wenn nicht, ist der Ausdruck nicht gültig. Dies ist aber kein Fehler.</div>
<div class="text">Der C++-Standard sagt: Wenn das Substituieren des ermittelten Datentyps fehlschlägt, ist dies kein Fehler, sondern diese Spezialisierung wird aus der Menge aller möglichen Spezialisierung entfernt. Für diese Regel hat sich eine Abkürzung etabliert: <a alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SFINAE%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fsfinae%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="" href="http://en.cppreference.com/w/cpp/language/sfinae" title="Link auf http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> (Substitution Failure Is Not An Error).</div>
<div class="text">Die fehlerhafte Kompilierung (<i>enable_if.cpp: 20:49</i>) zeigt es schön. Es gibt keine Template-Spezialisierung für den Datentyp <i>double.</i></div>
<div class="text"><i><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_163119262_fee41efde4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></i></div>
<div class="text">Die Ausgabe zeigt aber noch mehr<i>: </i><i>(enable_if.cpp:7:71): "no named `type* in struct std::enable_if&lt;false, double&gt;".</i></div>
<div class="ztitel"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-erasure" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-erasure" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-erasure%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-erasure%22%2C%22text%22%3A%22T.49%3A%20Where%20possible%2C%20avoid%20type-erasure%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D">T.49: Where possible, avoid type-erasure</a></div>
<div class="text">Seltsam, ich habe zwei Artikel zu Type Erasure geschrieben (<a alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A2497126%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D378d2c848b214f5ceda51c36e0603c6d%26rm%3Dopen_article_id%26bid%3D2497126%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Type%20Erasure%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22B%22%7D" href="/exec/mainmenu.pl?sid=378d2c848b214f5ceda51c36e0603c6d&amp;rm=open_article_id&amp;bid=2497126" class="" title="Link auf Beitrag 2497126">C++ Core Guidelines: Type Erasure</a> und <a alt="%7B%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D378d2c848b214f5ceda51c36e0603c6d%26rm%3Dopen_article_id%26bid%3D2501583%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Type%20Erasure%20mit%20Templates%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22B%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A2501583%2C%22version%22%3A1%7D" class="" href="/exec/mainmenu.pl?sid=378d2c848b214f5ceda51c36e0603c6d&amp;rm=open_article_id&amp;bid=2501583" title="Link auf Beitrag 2501583">C++ Core Guidelines: Type Erasure mit Templates</a>) und die recht anspruchsvolle Technik erklärt. Jetzt soll ich sie aber lieber vermeiden.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mit meinem nächsten Artikel springe ich direkt von den Interfaces zu der Implementierung von Tempates.</div>
<div class="ztitel">C++-Schulungen im Großraum Stuttgart</div>
<div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div>
<div class="text"><ul><li> <a alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F17-embedded-programmierung-mit-modernem-c20170911213829%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Embedded-Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F17-embedded-programmierung-mit-modernem-c20170911213829%22%7D" class="" href="https://www.modernescpp.de/index.php/c/2-c/17-embedded-programmierung-mit-modernem-c20170911213829" title="Link auf https://www.modernescpp.de/index.php/c/2-c/17-embedded-programmierung-mit-modernem-c20170911213829">Embedded-Programmierung mit modernem C++</a>: 15. bis 17.01. (Termingarantie; noch drei Plätze frei)</li><li> <a href="https://www.modernescpp.de/index.php/c/2-c/3-c-11-und-c-14" class="" title="Link auf https://www.modernescpp.de/index.php/c/2-c/3-c-11-und-c-14" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F3-c-11-und-c-14%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F3-c-11-und-c-14%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D">C++11 und C++14</a>: 11. bis 13.03.<br></li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/18-generische-programmierung-templates-mit-c" class="" href="https://www.modernescpp.de/index.php/c/2-c/18-generische-programmierung-templates-mit-c" alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Generische%20Programmierung%20%28Templates%29%20mit%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F18-generische-programmierung-templates-mit-c%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F18-generische-programmierung-templates-mit-c%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D">Generische Programmierung (Templates) mit C++</a>: 02. bis 04.04 </li></ul> </div>
<div>Die Details zu meinen C++- und Python-Schulungen gibt es auf <a alt="%7B%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="" href="https://www.modernescpp.de/" title="Link auf https://www.modernescpp.de/">www.ModernesCpp.de</a>. </div>
