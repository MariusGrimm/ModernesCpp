<div class="vorspann">Das Thema des Blogbeitrags ist dann sehr wichtig, wenn du eigene Datentypen entwirfst: reguläre und semireguläre Datentypen.</div>
<div class="text">Genau um diese Regel geht es heute:</div>
<div class="ztitel"><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-regular%22%2C%22text%22%3A%22T.46%3A%20Require%20template%20arguments%20to%20be%20at%20least%20Regular%20or%20SemiRegular%26nbsp%3B%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-regular%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-regular" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-regular" class="">T.46: Require template arguments to be at least Regular or SemiRegular&nbsp;</a></div>
<div class="text">Die erste Frage, die ich zu beantworten habe, ist recht offensichtlich. Was ist ein regulärer oder ein semiregulärer Datentyp? Meine Antwort basiert auf dem Proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf" class="" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf" alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0898r3.pdf%22%2C%22text%22%3A%22p0898%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0898r3.pdf%22%2C%22version%22%3A1%7D">p0898</a>: Ich denke, du ahnst es bereits. <i>Regular</i> und <i>SemiRegular</i> sind Concepts, die auf elementareren Concepts basieren.&nbsp; </div>
<div class="ztitel_kleiner"><i>Regular</i></div>
<div class="text"><ul><li><i>DefaultConstructible</i></li><li><i>CopyConstructible, CopyAssignable</i></li><li><i>MoveConstructible, MoveAssignable</i></li><li><i>Destructible</i></li><li><i>Swappable</i></li><li><i>EqualityComparable</i></li></ul></div>
<div class="ztitel_kleiner"><i>SemiRegular</i></div>
<div class="text"><ul><li><i>Regular [--] EqualityComparable</i></li></ul></div>
<div class="text">Der Begriff <i>Regular</i> geht auf <a alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Alexander%20Stephanov%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAlexander_Stepanov%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAlexander_Stepanov%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://en.wikipedia.org/wiki/Alexander_Stepanov" class="" href="https://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stephanov</a>, den Vater der Standard Template Library zurück. Er führte ihn in seinem Buch "Fundamentals of Generic Programming" ein (zum Buch gibt es hier einen <a class="" href="http://stepanovpapers.com/DeSt98.pdf" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22kleinen%20Auszug%22%2C%22destination%22%3A%22http%3A%2F%2Fstepanovpapers.com%2FDeSt98.pdf%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fstepanovpapers.com%2FDeSt98.pdf%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf http://stepanovpapers.com/DeSt98.pdf">kleinen Auszug</a>). Es ist relativ einfach, die acht Concepts im Kopf zu behalten, die einen regulären Datentyp definieren. Zuerst einmal gibt es die sehr bekannte <a class="" href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Die-Nuller-Fuenfer-oder-Sechserregel-3813435.html" alt="%7B%22target%22%3A%22%22%2C%22text%22%3A%22Sechserregel.%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Die-Nuller-Fuenfer-oder-Sechserregel-3813435.html%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Die-Nuller-Fuenfer-oder-Sechserregel-3813435.html%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Die-Nuller-Fuenfer-oder-Sechserregel-3813435.html">Sechserregel.</a></div>
<div class="text"><ul><li>Default constructor: <i>X()</i></li><li>Copy constructor: <i>X(const X&amp;)</i></li><li>Copy assignment: <i>operator=(const X&amp;)</i></li><li>Move constructor: <i>X(X&amp;&amp;)</i></li><li>Move assignment: <i>operator=(X&amp;&amp;)</i></li><li>Destructor: <i>~X()</i></li></ul></div>
<div class="text">Füge nun lediglich die Concepts <i>Swappable</i> und<i> EqualityComparable </i>hinzu und du erhältst das Concept <i>Regular.</i> Es gibt eine deutlich umgangssprachlichere Art, auszudrücken, dass ein Datentyp regulär ist: T is regulär, wenn er sich wie ein <i>int</i> anfühlt. </div>
<div class="text">Um nun <i>SemiRegular</i> zu erhalten, musst du lediglich <i>EqualityComparable </i>von dem Concept <i>Regular</i> subtrahieren. </div>
<div class="text">Ich höre bereits deine nächste Frage: Warum sollen unsere Template-Argumente zumindest regulär oder semiregulär sein oder sich wie ints verhalten? Die STL-Container und die Algorithmen insbesondere sind für reguläre Datentypen konzipiert. </div>
<div>Was ist nun ein häufig verwendeter aber nicht regulärer Datentyp? Genau, eine Referenz.</div>
<div class="ztitel_kleiner">Referenzen sind nicht regulär</div>
<div class="text">Dank der <a alt="%7B%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Type-Traits%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" href="https://en.cppreference.com/w/cpp/header/type_traits" class="">Type-Traits</a>-Bibliothek prüft das folgende Programm zu Compile-Zeit, ob <i>int&amp;</i> ein semiregulärer Datentyp ist: <br></div>
<div class="pre">// semiRegular.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;type_traits&gt;<br><br>int main(){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_default_constructible&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_default_constructible&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_copy_constructible&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_copy_constructible&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_copy_assignable&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_copy_assignable&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_move_constructible&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_move_constructible&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_move_assignable&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_move_assignable&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_destructible&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_destructible&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "std::is_swappable&lt;int&amp;&gt;::value: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::is_swappable&lt;int&amp;&gt;::value &lt;&lt; std::endl;&nbsp; // requires C++17<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Zuerst einmal setzt die Funktion <i>std::is_swappable</i> den C++17-Standard voraus. Hier ist die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_162789567_6d83861da9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Du siehst, eine Referenz wie <i>int&amp;</i> besitzt keinen Default-Konstruktor. Die Ausgabe zeigt, dass eine Referenz nicht semiregulär und damit auch nicht regulär ist. Um zur Compile-Zeit zu prüfen, ob ein Datentyp regulär ist, benötige ich die Funktion <i>isEqualityComparable.</i> Diese Funktion ist nicht Bestandteil der Type-Traits-Bibliothek. Selbst ist der Entwickler. </div>
<div class="ztitel_kleiner"><i>isEqualityComparable</i></div>
<div class="text">In C++20 werden wir wohl das <a alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fexperimental%2Fis_detected%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Detection-Idiom%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fexperimental%2Fis_detected%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://en.cppreference.com/w/cpp/experimental/is_detected" href="https://en.cppreference.com/w/cpp/experimental/is_detected" class="">Detection-Idiom</a> erhalten, das Bestandteil des l<a alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2015%2Fn4562.html%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2015%2Fn4562.html%22%2C%22text%22%3A%22ibrary%20fundamental%20TS%20v2%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html" class="">ibrary fundamental TS v2</a> ist. Damit ist es ein Kinderspiel, <i>isEqualityComparable</i> zu implementieren:<br></div>
<div class="pre">// equalityComparable.cpp<br><br>#include &lt;experimental/type_traits&gt;&nbsp; // (1)<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>using equal_comparable_t = decltype(std::declval&lt;T&amp;&gt;() == std::declval&lt;T&amp;&gt;());&nbsp; <br><br>template&lt;typename T&gt;<br>struct isEqualityComparable: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::experimental::is_detected&lt;equal_comparable_t, T&gt;{};&nbsp; // (3)<br><br>struct EqualityComparable { };&nbsp; // (4)<br>bool operator == (EqualityComparable const&amp;, EqualityComparable const&amp;) { return true; }<br><br>struct NotEqualityComparable { };&nbsp; // (5)<br>&nbsp;<br>int main() {<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isEqualityComparable&lt;EqualityComparable&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isEqualityComparable&lt;EqualityComparable&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isEqualityComparable&lt;NotEqualityComparable&gt;::value: " &lt;&lt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isEqualityComparable&lt;NotEqualityComparable&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Das neue Feature gehört zum <i>experimental</i> Namensraum (1). Die Zeile (3) ist die entscheidende. Diese Zeile ermittelt, ob der Ausdruck (2) gültig für den Datentyp<i> T </i>ist. Das Type-Traits <i>isEqualityComparable</i> gibt die richtige Antwort für den Datentyp <i>EqualityComparable</i> (4) und <i>NotEqualityComparable</i> (5). Lediglich <i>EqualityComparable</i> gibt <i>true</i> zurück, da ich den Gleichheitsoperator überladen habe.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_162789572_5fc39c8ea1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Bis C++20 wurden die Vergleichsoperatoren lediglich für arithmetische Datentypen, Aufzähler und mit Einschränkungen für Zeiger automatisch erzeugt. Das wird sich wohl mit C++20 dank des <a class="" href="https://en.cppreference.com/w/cpp/language/default_comparisons" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdefault_comparisons%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Spaceship-Operators%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdefault_comparisons%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/language/default_comparisons">Spaceship-Operators</a> <i>&lt;=&gt;</i> ändern. Wenn mit C++20 eine Klasse den <i>&lt;=&gt;</i> implementiert, werden automatisch die sechs Operatoren <i>==,&nbsp;!=, &lt;, &lt;=, &gt; </i>und<i> &gt;= </i>generiert. Es ist bereits ausreichend, den <i>&lt;=&gt;</i> als default zu deklarieren. Dies zeigt der Datentyp <i>Point:</i> <i><br></i></div>
<div class="pre">class Point {<br>&nbsp;&nbsp; int x;<br>&nbsp;&nbsp; int y;<br>public:<br>&nbsp;&nbsp; auto operator&lt;=&gt;(const Point&amp;) const = default;<br>&nbsp;&nbsp; ....<br>};<br>// compiler generates all six relational operators</div>
<div class="text">In diesem Fall sorgt der Compiler für die Implementierung. Der Default-Operator &lt;=&gt; wendet lexikografische Vergleiche an, in dem er mit seinen Basisklassen (von links nach rechts; zuerst in die Tiefe) beginnt und dann seinen Vergleich mit den nicht-statischen Attributen in ihrer Deklarationsreihenfolge fortsetzt. Diese Vergleiche wenden <a class="" href="https://de.wikipedia.org/wiki/Kurzschlussauswertung" alt="%7B%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Kurzschlussauswertung%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FKurzschlussauswertung%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FKurzschlussauswertung%22%7D" title="Link auf https://de.wikipedia.org/wiki/Kurzschlussauswertung">Kurzschlussauswertung</a> an. Das heißt, dass die Evaluierung eines logischen Ausdrucks dann endet, wenn das Ergebnis bereits feststeht. </div>
<div class="text">Jetzt sind alle Bestandteile verfügbar um <i>Regular</i> und <i>SemiRegular</i> zu definieren. Hier sind meine neuen Type-Traits:</div>
<div class="pre">// isRegular.cpp<br><br>#include &lt;experimental/type_traits&gt;<br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>using equal_comparable_t = decltype(std::declval&lt;T&amp;&gt;() == std::declval&lt;T&amp;&gt;());<br><br>template&lt;typename T&gt;<br>struct isEqualityComparable: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::experimental::is_detected&lt;equal_comparable_t, T&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {};<br><br>template&lt;typename T&gt;<br>struct isSemiRegular: std::integral_constant&lt;bool,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_default_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_copy_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_constructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_move_assignable&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_destructible&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::is_swappable&lt;T&gt;::value &gt;{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>template&lt;typename T&gt;<br>struct isRegular: std::integral_constant&lt;bool, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSemiRegular&lt;T&gt;::value &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isEqualityComparable&lt;T&gt;::value &gt;{};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSemiRegular&lt;int&gt;::value: " &lt;&lt; isSemiRegular&lt;int&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isRegular&lt;int&gt;::value: " &lt;&lt; isRegular&lt;int&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isSemiRegular&lt;int&amp;&gt;::value: " &lt;&lt; isSemiRegular&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "isRegular&lt;int&amp;&gt;::value: " &lt;&lt; isRegular&lt;int&amp;&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Durch die Verwendung der neuen Type-Traits <i>isSemiRegula</i>r und <i>isRegular</i> ist das Programm deutlich einfacher zu lesen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_162789576_7f54520dff.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?<br></div>
<div class="text">Mit meinem nächsten Blogbeitrag springe ich direkt in die Definition von Templates.</div>