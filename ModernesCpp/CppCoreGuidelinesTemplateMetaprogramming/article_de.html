<div class="vorspann">Ja, du hast es richtig gelesen. Heute geht es in meinem Artikel um Template-Metaprogrammierung. Sie ist Programmierung mit Datentypen und nicht mit Werten.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742726_cfbc0cee94.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Einleitung zur Template-Metaprogrammierung in den Guidelines endet einzigartig: "The syntax and techniques needed are pretty horrendous." Entsprechend enthalten die Regel vor allem Don'ts und besitzen nicht viel Inhalt.</div>
<div class="text"><ul><li> <a alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-metameta%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-metameta%22%2C%22text%22%3A%22T.120%3A%20Use%20template%20metaprogramming%20only%20when%20you%20really%20need%20to%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-metameta" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-metameta">T.120: Use template metaprogramming only when you really need to</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-emulate" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-emulate" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-emulate%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-emulate%22%2C%22text%22%3A%22T.121%3A%20Use%20template%20metaprogramming%20primarily%20to%20emulate%20concepts%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" class="">T.121: Use template metaprogramming primarily to emulate concepts</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tmp" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-tmp" class="" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tmp%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22T.122%3A%20Use%20templates%20%28usually%20template%20aliases%29%20to%20compute%20types%20at%20compile%20time%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-tmp%22%7D">T.122: Use templates (usually template aliases) to compute types at compile time</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fct" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fct" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fct%22%2C%22text%22%3A%22T.123%3A%20Use%20constexpr%20functions%20to%20compute%20values%20at%20compile%20time%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fct%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" class="">T.123: Use constexpr functions to compute values at compile time</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22text%22%3A%22T.124%3A%20Prefer%20to%20use%20standard-library%20TMP%20facilities%22%7D" class="">T.124: Prefer to use standard-library TMP facilities</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22text%22%3A%22T.125%3A%20If%20you%20need%20to%20go%20beyond%20the%20standard-library%20TMP%20facilities%2C%20use%20an%20existing%20library%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="">T.125: If you need to go beyond the standard-library TMP facilities, use an existing library</a></li></ul></div>
<div class="text">Ich finde Template-Metaprogrammierung nicht so grauenhaft, aber es steckt noch einiges Potenzial in der Syntax. Gerne will ich sie ein wenig entmystifizieren und über die Programmierung zur Compilezeit im Allgemeinen schreiben. Während dieser Einführung in die Programmierung zur Compilezeit, werde ich explizit auf die Type-Traits Bibliothek (<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-tmp" class="" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22text%22%3A%22T.124%3A%20Prefer%20to%20use%20standard-library%20TMP%20facilities%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-tmp%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">T.124: Prefer to use standard-library TMP facilities</a>) und <i>constexpr</i> Funktionen (<a alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fct%22%2C%22text%22%3A%22T.123%3A%20Use%20constexpr%20functions%20to%20compute%20values%20at%20compile%20time%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-fct%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fct" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-fct">T.123: Use constexpr functions to compute values at compile time</a>) eingehen und die weiteren Regeln zur Template-Metaprogrammierung implizit adressieren. </div>
<div class="text">Hier ist mein Plan: Ich gebe eine Einführung zur Template-Metaprogrammierung, zeige, wie die Type-Traits-Bibliothek Template-Metaprogrammierung in einer wohldefinierten und plattformunabhängigen Form anbietet und wie sich <i>constexpr</i>-Funktionen verwenden lassen, um Template-Metaprogrammierung durch gewöhnliche Funktionen zu ersetzen.<br></div>
<div class="ztitel">Template-Metaprogrammierung</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742735_1786066898.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">1994 stellte <a class="" alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.erwin-unruh.de%2Fprimorig.html%22%2C%22text%22%3A%22Erwin%20Unruh%22%2C%22href%22%3A%22http%3A%2F%2Fwww.erwin-unruh.de%2Fprimorig.html%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://www.erwin-unruh.de/primorig.html" href="http://www.erwin-unruh.de/primorig.html">Erwin Unruh</a> bei einem C++-Standardisierungsmeeting ein Programm vor, das sich nicht übersetzen ließ. Dies ist wohl das berühmteste Programm, das nicht erfolgreich kompiliert werden konnte:<br></div>
<div class="pre">// Prime number computation by Erwin Unruh<br>template &lt;int i&gt; struct D { D(void*); operator int(); };<br><br>template &lt;int p, int i&gt; struct is_prime {<br>&nbsp;&nbsp;&nbsp; enum { prim = (p%i) &amp;&amp; is_prime&lt;(i &gt; 2 ? p : 0), i -1&gt; :: prim };<br>&nbsp;&nbsp;&nbsp; };<br><br>template &lt; int i &gt; struct Prime_print {<br>&nbsp;&nbsp;&nbsp; Prime_print&lt;i-1&gt; a;<br>&nbsp;&nbsp;&nbsp; enum { prim = is_prime&lt;i, i-1&gt;::prim };<br>&nbsp;&nbsp;&nbsp; void f() { D&lt;i&gt; d = prim; }<br>&nbsp;&nbsp;&nbsp; };<br><br>struct is_prime&lt;0,0&gt; { enum {prim=1}; };<br>struct is_prime&lt;0,1&gt; { enum {prim=1}; };<br>struct Prime_print&lt;2&gt; { enum {prim = 1}; void f() { D&lt;2&gt; d = prim; } };<br>#ifndef LAST<br>#define LAST 10<br>#endif<br>main () {<br>&nbsp;&nbsp;&nbsp; Prime_print&lt;LAST&gt; a;<br>&nbsp;&nbsp;&nbsp; } </div>
<div class="text">Unruh verwendete den Metaware-Compiler. Da das Programm kein gültiges C++ mehr darstellt, hat der Autor <a href="http://www.erwin-unruh.de/prim.html" title="Link auf http://www.erwin-unruh.de/prim.html" alt="%7B%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22hier%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.erwin-unruh.de%2Fprim.html%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.erwin-unruh.de%2Fprim.html%22%7D" class="">hier</a> eine moderne Variante hinterlegt. Warum ist das Programm so berühmt? Hier ist ein Blick auf seine Fehlermeldungen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742737_2c025e91e3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich habe die wichtigen Komponenten der Fehlermeldung in rot hinterlegt. Ich denke, du siehst das Pattern. Das Programm berechnet zur Übersetzungszeit die ersten 30 Primzahlen. Das heißt, Template-Metaprogrammierung kann dazu verwendet werden, zur Übersetzungszeit zu rechnen. Es wird noch besser. Template-Metaprogrammierung ist <a alt="%7B%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTuring_completeness%22%2C%22text%22%3A%22Turing-complete%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTuring_completeness%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" class="" href="https://en.wikipedia.org/wiki/Turing_completeness" title="Link auf https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a>. Damit lässt sich jedes berechenbare Problem lösen. (Klar, die Turing-Vollständigkeit gilt nur in Theorie für die Template-Metaprogrammierung, denn die Rekursionstiefe (zumindest 1024 mit C++11) und die Länge der Namen, die der Compiler während der Template-Instanziierung erzeugt, sind limitierende Faktoren.)</div>
<div class="ztitel">Wie funktioniert die ganze Magie?</div>
<div class="text">Ich möchte traditionell beginnen.</div>
<div class="text"><b>Berechnungen zur Compilezeit</b></div>
<div class="text">Die Berechnung der Fakultät einer Zahl stellt das "Hello World" der Template-Metaprogrammierung dar:</div>
<div class="pre">// factorial.cpp<br><br>#include &lt;iostream&gt;<br><br>template &lt;int N&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>struct Factorial{<br>&nbsp;&nbsp;&nbsp; static int const value = N * Factorial&lt;N-1&gt;::value;<br>};<br><br>template &lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>struct Factorial&lt;1&gt;{<br>&nbsp;&nbsp;&nbsp; static int const value = 1;<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Factorial&lt;5&gt;::value: " &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Factorial&lt;10&gt;::value: " &lt;&lt; Factorial&lt;10&gt;::value &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Der Aufruf <i>factorial&lt;5&gt;::value</i> in Zeile (1) stößt die Instanziierung des primären oder allgemeinen Templates in Zeile (2) an. Während dieser Instanziierung, wird <i>Factorial&lt;4&gt;::value</i> instanziiert. Diese Rekursion endet, wenn das vollständig spezialisierte Klasse-Template <i>Factorial&lt;1&gt;::value</i> zum Zuge kommt. Vielleicht ziehst du ein Bild meiner Erklärung vor:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742743_981e9973ea.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Hier ist die Ausgabe des Programms:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742750_181564c07e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Jetzt habe ich doch beinahe vergessen zu beweisen, dass die Werte bereits zur Compilezeit berechnet werden. Dies ist der Beweis mithilfe des <a href="https://godbolt.org/" title="Link auf https://godbolt.org/" alt="%7B%22text%22%3A%22Compiler%20Explorer%22%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" class="">Compiler Explorer</a>. Der Einfachheit halber stellte ich nur das <i>main</i>-Programm und die entsprechenden Assembler Befehle gegenüber:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742756_2a6ab5a40a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164742764_c323da891f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die erste gelbe und die erste lilafarbene Zeile bringen es auf den Punkt. Die Fakultäten von 5 und 10 sind Konstanten, die bereits zur Compilezeit berechnet wurden. Zugegeben, das Fakultätsprogramm ist ein nettes Beispiel, aber nicht idiomatisch für Template Metaprogrammierung. </div>
<div class="text"><b>Typmodifikationen zur Compilezeit<br></b></div>
<div class="text">Die Modifikation von Datentypen zur Compilezeit ist typisch für die Template-Metaprogrammierung. Falls du mir nicht glaubst, studiere <a alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fmove%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22%5Bi%5Dstd%3A%3Amove%5B%2Fi%5D%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Fmove%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%7D" class="" href="https://en.cppreference.com/w/cpp/utility/move" title="Link auf https://en.cppreference.com/w/cpp/utility/move">[i]std::move[/i]</a>. Der kleine Codeschnipsel zeigt, was konzeptionell hinter <i>std::move</i> steckt:</div>
<div class="pre">static_cast&lt;std::remove_reference&lt;decltype(arg)&gt;::type&amp;&amp;&gt;(arg);</div>
<div class="text"><i>std::move</i> nimmt ein Argument <i>arg</i> an, deduziert seinen Datentyp (<i>decltype(arg)</i>), entfernt gegebenenfalls von diesem die Referenz (<i>remove_reverence</i>) und konvertiert diesen zu einer Rvalue-Referenz (<i>static_cast&lt;...&gt;::type&amp;&amp;&gt;</i>). <i>std::move</i> gibt immer eine Rvalue-Referenz zurück. Damit kann Move-Semantik angewandt werden.</div>
<div class="text">Wie funktioniert nun <i>std::remove_reference</i> aus der <a title="Link auf https://en.cppreference.com/w/cpp/header/type_traits" href="https://en.cppreference.com/w/cpp/header/type_traits" class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Type-Traits%20Bibliothek%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%7D">Type-Traits Bibliothek</a>? Hier ist ein Codeschnipsel, das zeigt, wie sich die Konstanz seines Argument entfernen lässt:<br></div>
<div class="pre">template&lt;typename T &gt; <br>struct removeConst{ <br>&nbsp;&nbsp;&nbsp; typedef T type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>};<br><br>template&lt;typename T &gt; <br>struct removeConst&lt;const T&gt; { <br>&nbsp;&nbsp;&nbsp; typedef T type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>};<br><br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, removeConst&lt;int&gt;::type&gt;::value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, removeConst&lt;const int&gt;::type&gt;::value;&nbsp; // true<br>&nbsp; <br>}<br></div>
<div class="text">ich habe <i>removeConst</i> in der Art als Klassen-Template implementiert, wie es wohl auch von Type-Traits-Bibliothek unter dem Namen <i>std::remove_const</i> angeboten wird. <i>std::is_same </i>ist eine praktische Funktion aus der Type-Traits Bibliothek, die zur Compilezeit die Frage beantwortet, ob zwei Datentypen identisch sind. Im Falle des <i>removeConst&lt;int&gt;</i>-Aufrufs kommt das allgemeine oder auch primäre Template zum Einsatz; im Falle von <i>removeCost&lt;const int&gt;</i> wählt der Compiler die teilweise Spezialisierung für <i>const T</i> aus. Die entscheidende Beobachtung ist es, dass beide Klassen-Templates den zugrunde liegenden nichtkonstanten Datentyp in Zeile (1) zurückgeben. <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Im nächsten Artikel geht meine Einführung in die Programmierung zum Compilezeit weiter. Das heißt insbesondere, dass ich Funktionen und Metafunktionen vergleiche, bevor ich mich mit der Type-Traits-Bibliothek beschäftige.</div>
