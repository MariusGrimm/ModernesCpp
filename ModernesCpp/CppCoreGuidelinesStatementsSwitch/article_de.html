<div class="text"><b>Zuerst einmal muss ich mich entschuldigen. Heute wollte ich meine Reise durch die C++ Core Guidelines mit den arithmetischen Ausdrücken fortsetzen. In meiner Schulung in dieser Woche gab es aber eine lange Diskussion zu <i>switch </i>Anweisungen in C/C++ und wie diese immer mehr unwartbar werden. Ehrlich gesagt, bin ich kein Freund von <i>switch</i>-Anweisungen und ich verkünde gerne: Es gibt ein Leben nach switch-Anweisungen.</b></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149644630_feda0f6649.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bevor ich mich aber auf die Diskussion beziehen und insbesondere darüber schreibe, wie sich <i>switch-A</i>nweisungen überwinden lassen, möchte ich erst mal meinen Plan für heute vorstellen.</div>
<div class="text"><ul><li><a alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-break%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22ES.78%3A%20Always%20end%20a%20non-empty%26nbsp%3Bcase%26nbsp%3Bwith%20a%26nbsp%3Bbreak%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-break%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-break" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-break" class="">ES.78: Always end a non-empty&nbsp;case&nbsp;with a&nbsp;break</a></li><li><a alt="%7B%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-default%22%2C%22text%22%3A%22ES.79%3A%20Use%26nbsp%3Bdefault%26nbsp%3Bto%20handle%20common%20cases%20%28only%29%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-default%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-default" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-default">ES.79: Use&nbsp;default&nbsp;to handle common cases (only)</a></li></ul></div>
<div class="text">Und los geht es mit den <i>switch</i> Anweisungen.<br></div>
<div class="ztitel_kleiner"><a alt="%7B%22text%22%3A%22ES.78%3A%20Always%20end%20a%20non-empty%26nbsp%3Bcase%26nbsp%3Bwith%20a%26nbsp%3Bbreak%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-break%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-break%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-break" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-break">ES.78: Always end a non-empty&nbsp;case&nbsp;with a&nbsp;break</a><br></div>
<div class="text">Ich habe <i>switch-</i>Anweisungen in Sourcecode gesehen, die aus mehr als 100 <i>case</i>-Zweigen bestanden. Falls dann noch nicht-leere <i>case-</i>Zweige ohne eine <i>break-</i>Anweisung verwendet wurden, endeten die <i>switch-</i>Anweisung in einem Alptraum, der nicht mehr zu warten war. Hier ist das erste Beispiel der Guidelines.</div>
<div class="pre">switch (eventType) {<br>case Information:<br>&nbsp;&nbsp;&nbsp; update_status_bar();<br>&nbsp;&nbsp;&nbsp; break;<br>case Warning:<br>&nbsp;&nbsp;&nbsp; write_event_log();<br>&nbsp;&nbsp;&nbsp; // Bad - implicit fallthrough<br>case Error:<br>&nbsp;&nbsp;&nbsp; display_error_window();<br>&nbsp;&nbsp;&nbsp; break;<br>}<br></div>
<div class="text">Der Zweig <i>Warning</i> besitzt keine <i>break</i> Anweisung. Daher wird der <i>Error</i> Zweig auch ausgeführt. <br></div>
<div class="text">Seit C++17 kennt C++ ein Heilmittel in der Form des <i>[[fallthrough]] </i>Attributes. Jetzt kannst du dein Anliegen direkt ausdrücken. <i>[[fallthrough]]</i> muss unmittelbar vor eine <i>case</i> Bezeichner alleine in einer Zeile stehen. Es drückt aus, dass ein Durchrutschen beabsichtigt ist und daher keine Compilerwarnung erzeugen soll.</div>
<div class="text">Das kleine Beispiel zeigt das C++17-Feature in der Anwendung. <br></div>
<div class="pre">void f(int n) {<br>&nbsp; void g(), h(), i();<br>&nbsp; switch (n) {<br>&nbsp;&nbsp;&nbsp; case 1:<br>&nbsp;&nbsp;&nbsp; case 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[fallthrough]];<br>&nbsp;&nbsp;&nbsp; case 3: // no warning on fallthrough (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h(); <br>&nbsp;&nbsp;&nbsp; case 4: // compiler may warn on fallthrough (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[fallthrough]]; // ill­formed, not before a case label (3)<br>&nbsp; }<br>}<br></div>
<div class="text">Das <i>[[fallthrough]]</i> Attribute in Zeile (1) unterdrückt die Compiler Warnung. Das gilt nicht für die Zeile 2. Der Compiler kann eine Warnung ausgeben. Zeile (3) hingegen stellt einen Fehler dar, da keine <i>case</i> Bezeichner folgt.</div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-default" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.79%3A%20Use%26nbsp%3Bdefault%26nbsp%3Bto%20handle%20common%20cases%20%28only%29%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-default%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-default%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-default" class="">ES.79: Use&nbsp;default&nbsp;to handle common cases (only)</a></div>
<div class="text">Hier ist mein konstruiertes Beispiel, um die Regel verständlich zu machen.<br></div>
<div class="pre">// switch.cpp<br><br>#include &lt;iostream&gt;<br><br>enum class Message{<br>&nbsp; information,<br>&nbsp; warning,<br>&nbsp; error,<br>&nbsp; fatal<br>};<br><br>void writeMessage(){ std::cerr &lt;&lt; "message" &lt;&lt; std::endl; }<br>void writeWarning(){ std::cerr &lt;&lt; "warning" &lt;&lt; std::endl; }<br>void writeUnexpected(){ std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl; }<br><br>void withDefault(Message mess){<br><br>&nbsp; switch(mess){<br>&nbsp;&nbsp;&nbsp; case Message::information:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeMessage();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case Message::warning:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeWarning();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeUnexpected();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp; }<br>&nbsp; <br>}<br><br>void withoutDefaultGood(Message mess){<br><br>&nbsp; switch(mess){<br>&nbsp;&nbsp;&nbsp; case Message::information:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeMessage();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case Message::warning:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeWarning();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // nothing can be done&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp; }<br>&nbsp; <br>}<br><br>void withoutDefaultBad(Message mess){<br><br>&nbsp; switch(mess){<br>&nbsp;&nbsp;&nbsp; case Message::information:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeMessage();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case Message::warning:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeWarning();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp; }<br>&nbsp; <br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; withDefault(Message::fatal);<br>&nbsp; withoutDefaultGood(Message::information);<br>&nbsp; withoutDefaultBad(Message::warning);<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Die Implementierung der Funktionen <i>withDefault</i> und <i>withoutDefaultGood </i>drücken deutlich ihre Absicht aus. Eine Programmier, der das Programm überarbeitet, weiß aufgrund des Kommentars (1), dass die<i> switch-</i>Anweisung keinen&nbsp;<i>default-</i>Zweig besitzt. Vergleiche doch die Funktion <i>withDefaultGood</i> und <i>withDefaultBad</i> aus der Wartungsperspektive. Weißt du, ob der Implementierer der Funktion <i>withoutDefaultBad </i>den default-Zweig schlicht vergessen hat oder ob die Aufzähler <i>Message::error</i> und <i>Message::fatal</i> erst später dazu kamen? Zumindest musst du den Sourcecode analysieren oder den Entwickler der Funktion fragen, falls das noch möglich ist.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149644638_aa4ad37c0f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich habe ja bereits erwähnt, dass ich in meiner letzten Schulung eine intensive Diskussion zur <i>switch</i>-Anweisungen in C/C++ hatte. Ich vergaß aber zu erwähnen, dass ich eine Python-Schulung gab. Python kennt keine <i>switch-</i>Anweisung. Es gibt daher ein Leben nach der <i>switch</i>-Anweisung in Python und vielleicht auch in C++. Die Datenstruktur, die in Python ein Dictionary genannt wird, wird in C++ als Hashtabelle oder ungeordnete assoziativer Container bezeichnet. Der offizielle Name ist <i>std::unordered_map</i>. Diese Datenstruktur sichert im Schnitt konstante Zugriffszeit (constant amortized time) zu. Das bedeute, dass unabhängig von der seiner Größe, ein <i>std::unordered_map</i> immer die Antwort in der gleichen Zeit liefert. </div>
<div class="text">Mein zentraler Punkt ist aber ein anderer. Ein <i>std::unordered_map</i> ist nicht nur eine Datenstruktur, sie ist auch eine Kontrollstruktur. Mit ihr keine eine <i>switch</i>-Anweisung umsetzt werden. Diese Technik heißt offiziell <a alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDispatch_table%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDispatch_table%22%2C%22text%22%3A%22dispatch%20table%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%7D" title="Link auf https://en.wikipedia.org/wiki/Dispatch_table" href="https://en.wikipedia.org/wiki/Dispatch_table" class="">dispatch table</a>. Ich schrieb bereits einen Artikel darüber: <a title="Link auf http://www.grimm-jaud.de/index.php/blog/funktional-in-c-dispatch-table" alt="%7B%22text%22%3A%22Funktional%20in%20C%2B%2B%3A%20Dispatch%20Table%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffunktional-in-c-dispatch-table%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffunktional-in-c-dispatch-table%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="http://www.grimm-jaud.de/index.php/blog/funktional-in-c-dispatch-table" class="">Funktional in C++: Dispatch Table</a>.</div>
<div class="text">Um meinen Punkt zu beweisen, implementiere ich das Programm<i> switch.cpp </i>nochmals. In diesem Fall verwende ich aber eine <i>std::unordered_map</i>. Der Einfachheit halber kommt in dem Beispiel eine globale Hashtabelle zum Einsatz.<br></div>
<div class="pre">// switchDict.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;unordered_map&gt;<br><br>enum class Message{<br>&nbsp; information,<br>&nbsp; warning,<br>&nbsp; error,<br>&nbsp; fatal<br>};<br><br>void writeMessage(){ std::cerr &lt;&lt; "message" &lt;&lt; std::endl; }<br>void writeWarning(){ std::cerr &lt;&lt; "warning" &lt;&lt; std::endl; }<br>void writeUnexpected(){ std::cerr &lt;&lt; "unexpected" &lt;&lt; std::endl; }<br><br>std::unordered_map&lt;Message, std::function&lt;void()&gt;&gt; mess2Func{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; {Message::information, writeMessage},<br>&nbsp;&nbsp;&nbsp; {Message::warning, writeWarning}<br>};<br><br>void withDefault(Message mess){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; auto pair = mess2Func.find(mess);<br>&nbsp; if (pair != mess2Func.end()){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pair-&gt;second();<br>&nbsp; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeUnexpected();<br>&nbsp; }<br>&nbsp; <br>}<br><br>void withoutDefaultGood(Message mess){<br><br>&nbsp; auto pair = mess2Func.find(mess);<br>&nbsp; if (pair != mess2Func.end()){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pair-&gt;second();<br>&nbsp; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Nothing can be done<br>&nbsp; }<br>&nbsp; <br>}<br><br>void withoutDefaultBad(Message mess){<br>&nbsp; <br>&nbsp; auto pair = mess2Func.find(mess);<br>&nbsp; if (pair != mess2Func.end()){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pair-&gt;second();<br>&nbsp; }<br>&nbsp; <br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; withDefault(Message::fatal);<br>&nbsp; withoutDefaultGood(Message::information);<br>&nbsp; withoutDefaultBad(Message::warning);<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Zeile (1) enthält die <i>std::unorderedMap</i>. Ich verwende sie in den drei Funktionen <i>withDefault,</i> <i>withoutDefaultGood </i>und <i>withoutDefaultBad</i>. Die Ausgabe des Programms <i>switchDict</i> ist genau dieselbe wie die Ausgabe des Programms <i>switch</i>. <br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149644644_f23bbc1c1f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Natürlich gibt es ein paar Unterschiede zwischen der <i>switch-</i>Anweisung und der Hashtabelle. Zuerst einmal gilt, dass die Hashtabelle eine veränderliche Datenstruktur ist. Daher kann sie kopiert oder verändert werden. Darüber hinaus erlaubt sie es nicht, durch die Abfragen wie bei den <i>case-</i>Anweisungen durchzurutschen. Dies musst du implementieren, indem du zum Beispiel eine Funktion mehr wie einmal für einen Schlüssel verwendest: <i>mess2Func[Message::error] = writeWarning;.</i> Jetzt wird dieselbe Aktion für die Schlüssel <i>Message::warning</i> und <i>Message::error</i> ausgeführt.</div>
<div class="text">Ich werde mich nicht auf die Performanz eingehen, denn abhängig von dem Anwendungsfall kann die Dispatch Tabelle auch zur Compilezeit ausgewertet werden. Dies ist zum Beispiel mit <i>constexpr</i>-Funktionen möglich. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Nochmals sorry für den Umweg, aber die Diskussion in meiner letzten Schulung war sehr intensiv. Im nächsten Artikel schließe ich die Regeln für Anweisungen ab und beginne mit den Regeln zu arithmetischen Ausdrücken.<br></div>
