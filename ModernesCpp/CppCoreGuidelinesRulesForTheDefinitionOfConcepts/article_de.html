<div class="vorspann">Obwohl die Regel T.11 lautet: "<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-std-concepts" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Whenever%20possible%20use%20standard%20concepts%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-std-concepts%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" class="">Whenever possible use standard concepts</a>", steht ab und zu die Aufgabe an, ein Concept zu definieren. Hierzu gibt es Regeln zu beachten. </div>
<div class="text">Die C++ Core Guidelines besitzen neun Regeln für die Definition von Concepts. Sieben von ihnen besitzen einen Inhalt. Hier sind die ersten vier: </div>
<div class="text"><ul><li> <a class="" alt="%7B%22text%22%3A%22T.20%3A%20Avoid%20%5C%22concepts%5C%22%20without%20meaningful%20semantics%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-low%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-low%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-low" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-low">T.20: Avoid "concepts" without meaningful semantics</a> </li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-complete%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22T.21%3A%20Require%20a%20complete%20set%20of%20operations%20for%20a%20concept%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-complete%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-complete" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-complete" class="">T.21: Require a complete set of operations for a concept</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-axiom" alt="%7B%22text%22%3A%22T.22%3A%20Specify%20axioms%20for%20concepts%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-axiom%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-axiom%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-axiom">T.22: Specify axioms for concepts</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-refine" alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-refine%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-refine%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22T.23%3A%20Differentiate%20a%20refined%20concept%20from%20its%20more%20general%20case%20by%20adding%20new%20use%20patterns%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-refine">T.23: Differentiate a refined concept from its more general case by adding new use patterns</a></li></ul></div>
<div class="text">Los geht es mit der Semantik von Concepts:<br></div>
<div class="ztitel"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-low%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22T.20%3A%20Avoid%20%5C%22concepts%5C%22%20without%20meaningful%20semantics%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-low%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-low" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-low" class="">T.20: Avoid "concepts" without meaningful semantics</a> <br> </div>
<div class="text">Diese Regel ist ziemlich offensichtlich, doch was heißt bedeutungsvolle Semantik (meaningful semantic)? Sie besteht nicht nur aus einfachen Einschränkungen wie zum Beispiel <i>has_plus</i>, sondern auch aus Concepts wie <i>Number</i>, <i>Range</i> oder <i>InputIterator</i>. </div>
<div class="text">Zum Beispiel fordert das Concept <i>Addable</i> lediglich die Unterstützung von <i>has_plus </i>und wird damit bereits durch einen String unterstützt: </div>
<div class="pre">template&lt;typename T&gt;<br>concept Addable = has_plus&lt;T&gt;;&nbsp;&nbsp;&nbsp; // bad; insufficient<br><br>template&lt;Addable N&gt; auto algo(const N&amp; a, const N&amp; b) // use two numbers<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return a + b;<br>}<br><br>int x = 7;<br>int y = 9;<br>auto z = algo(x, y);&nbsp;&nbsp; // z = 16<br><br>string xx = "7";<br>string yy = "9";<br>auto zz = algo(xx, yy);&nbsp;&nbsp; // zz = "79"</div>
<div class="text">Ich nehme an, dies war nicht deine Absicht, denn das Funktions-Template <i>algo</i> sollte nur Zahlen annehmen. Es soll aber nicht Objekte akzeptieren, die nur addierbar sind. Die Lösung ist einfach: Definiere ein Concept <i>Number,</i> das eine bedeutungsvolle Semantik besitzt:</div>
<div class="pre">template&lt;typename T&gt;<br>// The operators +, -, *, and / for a number <br>// are assumed to follow the usual mathematical rules<br>concept Number = has_plus&lt;T&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; has_minus&lt;T&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; has_multiply&lt;T&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; has_divide&lt;T&gt;;<br><br>template&lt;Number N&gt; auto algo(const N&amp; a, const N&amp; b)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return a + b;<br>}</div>
<div class="text">Nun gibt der Funktionsaufruf von <i>algo</i> mit einem String einen Fehler aus. Die nächste Regel ist ein Spezialfall dieser Regel.<br></div>
<div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-complete" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-complete" alt="%7B%22text%22%3A%22T.21%3A%20Require%20a%20complete%20set%20of%20operations%20for%20a%20concept%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-complete%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-complete%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" class="">T.21: Require a complete set of operations for a concept</a> <br> </div>
<div class="text">Was ist eine vollständige Menge (complete set) eines Concepts? Die Guidelines stellen zwei Beispiele vor:<i> Arithmetic </i>und <i>Comparable</i>: </div>
<div class="text"><ul><li>Arithmetic: +, -, *, /, +=, -=, *=, /=</li><li>Comparable: &lt;, &gt;, &lt;=, &gt;=, ==, !=</li></ul></div>
<div class="text">Für was steht das Akronym POLA? Für <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPrinciple_of_least_astonishment%22%2C%22text%22%3A%22Principle%20Of%20Least%20Astonishment%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPrinciple_of_least_astonishment%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://en.wikipedia.org/wiki/Principle_of_least_astonishment" class="">Principle Of Least Astonishment</a>. Dieses Prinzip guten Softwareentwurfs lässt sich einfach brechen, indem ein Concepts nur teilweise implementiert wird. Hier ist ein Beispiel der Guidelines; das Concept <i>Minimal</i> unterstützt in diesem Fall<i> ==,</i> und<i> +</i>:</div>
<div class="pre">void f(const Minimal&amp; x, const Minimal&amp; y)<br>{<br>&nbsp;&nbsp;&nbsp; if (!(x == y)) { /* ... */ }&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; if (x != y) { /* ... */ }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // surprise! error<br><br>&nbsp;&nbsp;&nbsp; while (!(x &lt; y)) { /* ... */ }&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; while (x &gt;= y) { /* ... */ }&nbsp;&nbsp;&nbsp; // surprise! error<br><br>&nbsp;&nbsp;&nbsp; x = x + y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; x += y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // surprise! error<br>}<br></div>
<div class="ztitel"><a class="" alt="%7B%22text%22%3A%22T.22%3A%20Specify%20axioms%20for%20concepts%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-axiom%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-axiom%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-axiom" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-axiom">T.22: Specify axioms for concepts</a> <br> </div>
<div class="text">Was ist ein Axiom? Hier die Definition aus <a href="https://en.wikipedia.org/wiki/Axiom" title="Link auf https://en.wikipedia.org/wiki/Axiom" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAxiom%22%2C%22text%22%3A%22Wikipedia%3A%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAxiom%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" class="">Wikipedia:</a></div>
<div class="einrueckung">An <b>axiom</b> or <b>postulate</b> is a statement that is taken to be true, to serve as a premise or starting point for further reasoning and arguments.</div>
<div class="text">Da C++ keine Axiome unterstützt, lassen sie sich nur durch Kommentare ausdrücken. Falls C++ Axiome in der Zukunft unterstützen wird, ist es im Wesentlichen ausreichend, das Kommentarsymbol <i>//</i> aus dem folgenden Beispiel zu entfernen: <br></div>
<div class="pre">template&lt;typename T&gt;<br>&nbsp;&nbsp;&nbsp; // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }<br>&nbsp;&nbsp;&nbsp; concept Number = requires(T a, T b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {a + b} -&gt; T;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {a - b} -&gt; T;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {a * b} -&gt; T;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {a / b} -&gt; T;<br>&nbsp;&nbsp;&nbsp; }<br></div>
<div class="text">Das Axiom bedeutet in dem Fall, dass <i>Number</i> den mathematischen Regeln folgen soll. Im Gegensatz dazu fordert das Concept, dass <i>Number </i>die binären Operationen <i>+</i>, <i>-</i>, <i>* </i>und<i> / </i>unterstützen muss und das Ergebnis nach <i>T</i> konvertiert ist. <i>T</i> ist der Typ der Argumente.</div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-refine" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-refine%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-refine%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22T.23%3A%20Differentiate%20a%20refined%20concept%20from%20its%20more%20general%20case%20by%20adding%20new%20use%20patterns%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-refine" class="">T.23: Differentiate a refined concept from its more general case by adding new use patterns</a> </div>
<div class="text">Falls zwei Concepts dieselben Anforderungen stellen, sind sie logisch äquivalent. Dies heißt, dass der Compiler diese nicht unterscheiden kann und daher nicht automatisch die richtige Variante wählt, wenn Funktionen überladen werden. Um diese Regel anschaulich zu beschreiben, habe ich vereinfachte Versionen der Concepts <i>BidirectionalIterator</i> und <i>RandomAccessIterator</i> implementiert:</div>
<div class="pre">template&lt;typename I&gt;<br>concept bool BidirectionalIterator = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ForwardIterator&lt;I&gt; &amp;&amp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires(I iter){ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --iter; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter--; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;<br><br>template&lt;typename I&gt;<br>concept bool RandomAccessIterator = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BidirectionalIterator&lt;I&gt; &amp;&amp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer&lt;N&gt; &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires(I iter, I iter2, N n&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter += n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // increment or decrement an iterator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter -= n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n + iter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // return a temp iterator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter + n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter - n; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter[n];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access the element<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter1 - iter2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // subtract two iterators<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter1 &lt; iter2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compare two iterators <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter1 &lt;= iter2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter1 &gt; iter2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter1 &gt;= iter2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</div>
<div class="text"><i>std::advance(i,&nbsp; n)</i> inkrementiert einen Iterator <i>i</i> um <i>n </i>Elemente. Wenn der Iterator <i>i </i>ein bidirektionaler Iterator ist, muss <i>std::advance</i> elementweise <i>n</i> Schritte vorwärts oder rückwärts gehen. Wenn der Iterator <i>i </i>im Random Access Iterator ist, wird lediglich einmalig <i>n</i> auf den Iterator <i>i </i>addiert: </div>
<div class="pre">template&lt;BidirectionalIterator I&gt;<br>void advance(I&amp; iter, int n){...}<br><br>template&lt;RandomAccessIterator I&gt;<br>void advance(I&amp; iter, int n){...}<br><br>std::list&lt;int&gt; lst{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>std::list&lt;int&gt;::iterator listIt = lst.begin();<br>std::advance(listIt, 2);&nbsp;&nbsp; // BidirectionalIterator<br><br>std::vector&lt;int&gt; vec{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>std::vector&lt;int&gt;::iterator vecIt = vec.begin();<br>std::advance(vecIt, 2);&nbsp;&nbsp;&nbsp; // RandomAccessIterator<br></div>
<div class="text">Im Falle eines <i>std::vector&lt;int&gt;,</i> gibt <i>vec.begin()</i> einen Random Access Iterator zurück. Somit wird die schnellere Variante von <i>std::advance</i> verwendet. </div>
<div class="text">Jeder Container der Standard Template Library erzeugt einen Iterator, der seine Struktur widerspiegelt. Hier ist ein Überblick zu den Containern und ihren Iteratoren: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160385861_ef39a9f3b6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Drei Reglen für die Defintion von Concepts sind noch übrig. Insbesondere die nächste Regel "T.24: Use tag classes or traits to differentiate concepts that differ only in semantics." klingt sehr interessant. Im nächsten Artikel schaue ich mir an, was Tag Classes oder Traits Classes sind. <br></div>
