<div class="vorspann">Vereinfachend gesagt, sind Profile Teilemengen von Regeln der C++ Core Guidelines, die sich mit einem besonderen Aspekt beschäftigen. Er kann Type Safety, Bound Safety oder auch Lifetime Safety sein. Dank der Guidelines Support Library lassen sich diese Aspekte prüfen.</div><div class="text">Es gibt zwei Gründe für die Profile.</div><div class="text"><ol><li> Du musst dich mit bestehendem Code auseinandersetzen und es ist daher nicht möglich, alle Regel in einem Schritt anzuwenden. In diesem Fall bietet es sich an, die Regeln schrittweise einzuführen.</li><li>Manche Regeln können wichtiger für deine Codebasis sein als andere. Genau hier passen die Profile ins Bild, da sie spezifische Aspekte wie die Vermeidung von Zugriffsfehlern oder die richtige Verwendung von Datentypen adressieren. Regeln, die einen besonderen Aspekt im Fokus haben, werden Profile genannt. <br></li></ol></div><div class="text">Nun aber zu der formalen Definition eines Profils aus den C++ Core Guidelines:<br></div><div class="text"><ul><li> <b>Profile:</b> <i>A “profile” is a set of deterministic and portably enforceable subset rules (i.e., restrictions) that are designed to achieve a specific guarantee.<br></i></li></ul></div><div class="text">Zwei Begriffe der Definition sind besonders interessant:</div><div class="text"><ul><li>deterministic: Die Probleme sollen sich lokal analysieren und in einem Compiler implementieren lassen.</li><li>portably enforcable: Verschiedene Werkzeuge auf verschieden Plattformen sollen das äquivalente Ergebnis erzeugen.<br></li></ul></div><div class="text">Nun stellt sich natürlich die Frage: Wann setzt dein Code ein Profil richtig um? Die Antwort ist einfach: Es darf keine Warnung mehr geben, die sich aufgrund dieses Profils ergeben. Die C++ Core Guidelines besitzt drei Profile:</div><div class="text"><ul><li> <a alt="%7B%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-type%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-type%22%2C%22text%22%3A%22Type%20safety%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-type" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-type">Type safety</a> </li><li> <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-bounds" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-bounds" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-bounds%22%2C%22text%22%3A%22Bounds%20safety%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-bounds%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D">Bounds safety</a> </li><li> <a title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-lifetime" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-lifetime" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Lifetime%20safety%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-lifetime%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-lifetime%22%7D">Lifetime safety</a> </li></ul></div><div class="text">Entsprechend der C++ Core Guidelines werden in Zukunft eventuell zusätzliche Profile definiert werden. Diese können sich mit Aspekten wie undefined und unspecified behaviour beschäftigen. Der Einfachheit halber werde ich von nun an von undefiniertem und unspezifizierten Verhalten sprechen. Bevor ich mich in meinem nächsten Artikel tiefer mit den Profilen beschäftige, möchte ich erst klären, worin der Unterschied zwischen undefinierten und unspezifizierten Verhalten besteht. Hier kommt mein kleiner Ausflug.</div><div class="ztitel">Undefiniertes und unspezifiziertes Verhalten<br></div><div class="text">Dies sind die Definitionen der zwei Begriffe aus dem aktuellen C++20-Standard-Entwurf. Er ist in amerikanischen Englisch verfasst.</div><div class="text"><ul><li><b>Undefined behavior</b> (3.27): behavior for which this document imposes no requirements.</li><li><b>Unspecified behavior </b>(3.28): behavior, for a well-formed program, construct and correct data, that depends on the implementation.</li></ul></div><div class="text">Diese Begriffe muss ich genauer erklären:</div><div class="ztitel_kleiner">Undefiniertes Verhalten<br></div><div class="text">Vereinfachend formuliert besagt undefiniertes Verhalten für ein Programm, dass keine verlässlichen Aussagen zu einem Programm mehr möglich sind. Das Ergebnis des Programms kann daher das vermeintlich erwartete sein, es kann aber auch ein falsches Ergebnis ausgeben, die Kompilierung des Programms kann aber auch scheitern oder es gibt einen Laufzeitfehler. Das Verhalten kann von der Plattform, dem Compiler, der Compilerversion, dem Optimierungslevel oder einfach nur dem Zustand des Computers abhängen. Diese Aufzählung ließe sich noch deutlich verlängern; ich höre aber aus gutem Grunde auf. Die Aktion, die im Falle eines undefined behaviours ansteht, ist hingegen sehr einfach: <b>Beseitige das undefinierte Verhalten!</b></div><div class="text">Hier ist eine Aufzählung von typischen undefinierten Verhalten:<br></div><div class="text"><ul><li> Zugriff auf die Elemente eines C-Arrays oder eines Containers der STL jenseits seiner Grenzen</li><li>Verwendung von nichtinitialisierten Variablen</li><li>Dereferenzieren eines Null-Zeigers</li><li>Teilen durch null</li><li>Undefined order of evaluation (Nichtdefinierte Reihenfolge von Auswertungen)</li></ul></div><div class="text">Abgesehen vom letzten Punkt sollte die Aufzählung verschiedener undefinierter Verhalten offensichtlich sein.</div><div class="text">Informell ausgedrückt bedeutet "undefined order of evaluation" eines Ausdrucks A, der von einem Teil B gefolgt wird, dass der Compiler A und B in einer beliebigen Reihenfolge auswerten kann. Nun benötigen wir die Zusicherung, dass A vor B ausgewertet wird (<i>sequenced_before</i>). Diese Zusicherung oder auch Etablierung einer <i>sequenced_before-</i>Relation geben zum Beispiel logische Operatoren, vollständige Ausdrücke (<i>a = c;</i>), der Aufruf oder das Verlassen einer Funktion oder auch die Initialisierung einer Variable. Zugegeben, dies war eine vereinfachte Vorstellung der "order of evaluation". Mehr Details gibt es auf <a title="Link auf https://en.cppreference.com/w/cpp/language/eval_order" href="https://en.cppreference.com/w/cpp/language/eval_order" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22cppreference.com%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Feval_order%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Feval_order%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D">cppreference.com</a>.&nbsp; <br></div><div class="text">Das kleine Programm sollte die Begrifflichkeit auf den Punkt bringen. Wenn ich das folgende Programm mit C++14 ausführe, erhalte ich drei Warnungen: <br></div><div class="pre">// undefinedBehaviour.cpp<br><br>#include &lt;array&gt;<br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 1&gt; myArr{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (0)<br><br>&nbsp;&nbsp;&nbsp; int i{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (0)<br><br>&nbsp;&nbsp;&nbsp; myArr[i] = i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; "&nbsp; " &lt;&lt; i++ &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; int n = ++i + i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "n: " &lt;&lt; n &lt;&lt; std::endl;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Ich verwende in der Zeile (0) geschweifte Klammern, um beide Datentypen zu initialisieren. Die drei Ausdrücke in den Zeilen (1) und (2) besitzen mit C++14 undefiniertes Verhalten. Der Grund ist, das die Ausdrücke erst vollständig am Ende des Ausdrucks vollständig ausgewertet sein müssen. Das Ende des Ausdrucks ist in diesem Fall der Strickpunkt. Der Clang-Compiler bringt dies unmissverständlich mit einer Warnung auf den Punkt.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179796986_b0c10badb4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">"Unsequend Evaluation" bedeutet, dass die Operation in einer beliebigen Reihenfolge ausgeführt werden und sich sogar überlappen können. Dies ist selbst in einer Single-threaded-Ausführung möglich, denn die zugrunde liegenden Assemblerinstruktionen können sich überlappen. Das war jedoch noch nicht die ganze Wahrheit. Die Zeilen (1) besitzen undefiniertes Verhalten in C++14, aber unspezifiziertes Verhalten in C++17.</div><div class="ztitel_kleiner">Unspezifiziertes Verhalten<br></div><div class="text">Unspezifiziertes Verhalten bedeutet, dass die Implementierung nicht dokumentieren muss, wie sich diese in diesem Kontext verhält. Zum Beispiel ist es nicht spezifiziert, in welcher Reihenfolge die Argumente eines Funktionsaufrufs ausgewertet werden. </div><div class="text">Hierzu habe ich ein interessantes Beispiel, dass in C++14 undefiniertes Verhalten und in C++17 unspezifiziertes Verhalten besitzt:</div><div class="pre">#include &lt;iostream&gt;<br><br>void func(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "(" &lt;&lt; fir &lt;&lt; "," &lt;&lt; sec &lt;&lt; ")" &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; int i = 0;<br>&nbsp;&nbsp;&nbsp; func(i++, i++);<br>}</div><div class="text">Wenn ich das Programm ausführe, erhalten ich verschiedene Ergebnisse mit dem GCC und dem Clang-Compiler. Ich erhalte also weder das gleiche Ergebnis noch findet die Auswertung der Funktionsargumente von links nach rechts statt. </div><div><ul><li>GCC</li></ul></div><div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179796994_a45b7ae65a.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div><ul><li>Clang</li></ul></div><div><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_179796998_60487c5a32.png" title="<ir_inline itemname=bilder_mvp_bild:4 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Unspezifiziertes Verhalten mit C++17 gibt dir die Zusicherung, dass jedes Element zuerst vollständig ausgewertet wird, bevor das nächste Argument ausgewertet wird. Es gibt aber noch immer keine Zusicherung, in welcher Reihenfolge die Argumente ausgewertet werden.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Nach diesem notwendigen Umweg zu undefiniertem und unspezifizierten Verhalten werde ich in meinem nächsten Artikel über die drei Profile type safety, bounds safety und lifetime safety schreiben.</div><div class="ztitel">Die nächsten pdf-Päckchen stehen fest:</div><div class="text">Die Details zur Wahl stehen fest. Die PDF-Päckchen gibt es in ein bis zwei Wochen.<br></div><div><ul><li>Deutscher Blog (Concurrency mit C++17 und C++20): <a alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6%22%2C%22text%22%3A%22Welches%20PDF-P%C3%A4ckchen%20soll%20ich%20zusammenstellen%3F%20Mache%20dein%20Kreuz%21%20%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6" href="https://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-6">Welches PDF-Päckchen soll ich zusammenstellen? Mache dein Kreuz! </a> </li><li>Englischer Blog (C++ Core Guidelines: Performance): <a alt="%7B%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice-5%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice-5%22%2C%22text%22%3A%22Which%20PDF%20bundle%20should%20I%20provide%3F%20Make%20your%20choice%21%22%2C%22subject%22%3A%22%22%7D" href="http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice-5" title="Link auf http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice-5">Which PDF bundle should I provide? Make your choice!</a><br></li></ul></div>