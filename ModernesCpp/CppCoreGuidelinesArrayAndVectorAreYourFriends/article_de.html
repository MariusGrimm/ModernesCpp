<div class="vorspann">In 99 Prozent aller Anwendungsfälle für einen sequentiellen Container sind <i>std::array</i> und <i>std::vector</i> die idealen Kandidaten. Höre ich Bedenken? Hier ist meine Antwort. <br></div><div class="text">Heute kann ich mich wirklich kurzfassen. Dies ist die Faustregel:<b> Falls du Elemente von deinem Container entfernen oder hinzufügen willst, ist <i>std::vector </i>dein idealer Kandidat, wenn nicht, verwende ein <i>std::array</i>.</b> </div><div class="text">Das war es schon für heute, falls du sehr beschäftigst bist; falls nicht, lies weiter.</div><div class="ztitel">Die Details<br></div><div class="text">Die C++ Core Guidelines liefern eine Begründung für die Faustregel in der folgenden Guideline: <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-vector" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-vector%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22SL.con.2%3A%20Prefer%20using%20STL%20vector%20by%20default%20unless%20you%20have%20a%20reason%20to%20use%20a%20different%20container.%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rsl-vector%22%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rsl-vector">SL.con.2: Prefer using STL vector by default unless you have a reason to use a different container.</a></div><div class="text"><i>std::array</i> und <i>std::vector</i> können mit den folgenden Eigenschaften punkten:</div><div class="text"><ol><li>the fastest general-purpose access (random access, including being vectorization-friendly);</li><li>the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly);</li><li>the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly).</li></ol></div><div class="text">In meinem letzten Artikel "<a alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dc5f388188b0f5568fec0ad831768398f%26rm%3Dopen_article_id%26bid%3D2680658%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A2680658%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Die%20Standard-Bibliothek%22%2C%22anchor%22%3A%22%22%7D" title="Link auf Beitrag 2680658" href="/exec/mainmenu.pl?sid=c5f388188b0f5568fec0ad831768398f&amp;rm=open_article_id&amp;bid=2680658">C++ Core Guidelines: Die Standard-Bibliothek</a>" bin ich bereits ausführlich auf den Punkt drei eingegangen. Der erste Punkt, dass beide Container den beliebigen Zugriff mittels des Index-Operators unterstützen, ist offensichtlich. Da ich mich vermutlich nicht mit einem Autoritätsbeweis aus der Affäre ziehen kann, will ich über den Punkt zwei genauer schreiben. Den vollständigen Überblick zu den sequenziellen Containern der STL gibt die folgende Tabelle:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174583737_de5f77de63.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Es gibt fünf sequenzielle Container in der Standard Template Library. Abhängig von deinem Anwendungsfall passt der <i>std::vector</i> in 95 Prozent aller Fälle. Meist musst du zum Container Elemente hinzufügen oder löschen. Die Tabelle besitzt noch deutlich mehr Informationen.<br></div><div class="text">0(i) bezeichnet die Komplexität (Laufzeit) einer Operation. Dabei bedeutet 0(1), dass die Laufzeit einer Operation auf einem Container konstant ist, und 0(n), dass die Laufzeit einer Operation linear von der Anzahl seiner Elemente abhängt. Das heißt im konkreten Fall eines std::vector oder std::array, dass die Zugriffszeit auf seine Elemente immer gleich schnell ist und damit unabhängig von der Anzahl seiner Elemente. Hingegen ist das Einfügen oder Löschen eines beliebigen Elements bei k zusätzlichen Elementen um den Faktor k langsamer. Wie bereits gesagt, gilt der letzte Satz nur für einen <i>std::vector</i>.<br></div><div class="text"><i>std::array</i> und <i>std::vector</i> bieten ähnliche Zugriffszeiten, aber sie besitzen einen weiteren großen Unterschied, den viele Entwickler nicht im Blick haben. Das <i>std::array </i>wird typischerweise auf dem Stack angelegt und der <i>std::vector</i> verwaltet seine Elemente auf dem Heap. Das bedeutet, dass ein <i>std::array </i>nur eine eingeschränkte Anzahl von Elementen besitzen kann, während ein <i>std::vector </i>eine unbeschränkte Anzahl von Elementen besitzen kann.&nbsp;</div><div class="text"><i>std::vector</i> und <i>std::deque</i> unterstützen mit C++11 die neue Methode<i> shrink_to_fit</i>. Die Anzahl der Elemente, die ein <i>std::vector</i> oder ein <i>std::deque </i>besitzt (size), ist in der Regel kleiner als die Anzahl der Elemente, die für einen <i>std::vector</i> oder <i>std::deque </i>reserviert sind (capacity). Dies hat einen einfachen Grund. Eine Vergrößerung eines <i>std::vector</i> oder eines <i>std::deque</i> führt nicht automatisch zu einer neuen teuren Anforderung von Speicher. Die neue Methode <i>shrink_to_fit</i> erlaubt es, die Kapazität eines <i>std::vector </i>oder <i>std::deque</i> auf seine Größe zu reduzieren. Dieser Aufruf ist aber nicht bindend. Das heißt, dass die Laufzeit ihn ignorieren kann. Auf allen populären Plattformen hat <i>shrink_to_fit</i> aber den gewünschten Effekt gehabt. <br></div><div class="text">Auch wenn der Zugriff auf die Elemente eines <i>std::vector</i> genau so wie der Zugriff auf ein <i>std::deque</i> die Komplexität 0(1) besitzt, so bedeutet das in keinem Fall, dass beide Operationen gleich schnell sind.</div><div class="text">Die Komplexitätszusicherung 0(1) für das Einfügen oder Löschen neuer Elemente in eine doppelt oder einfach verkettete Liste <i>std::list</i> bzw. <i>std::forward_list</i> gilt nur unter der Annahme, dass ein Iterator bereits auf das Element verweist.</div><div class="text">Du musst einen überzeugenden Grund besitzen, um den sehr speziellen sequenziellen Container <i>std::forward_list</i> zu verwenden. <i>std::forward_list</i> ist auf minimale Speicheranforderung und hohe Performanz optimiert und kann dann verwendet werden, wenn das Hinzufügen, Extrahieren oder auch Löschen von Elementen nur benachbarte Elemente betrifft. Der Grund für dieses besondere Verhalten ist offensichtlich. <i>std::forward_list </i>als einfach verknüpfter Container kennt nur einen Vorwärts-Iterator und nicht seine Größe. Damit lässt sich eine <i>std::forward_list</i> in vielen Algorithmen der STL nicht verwenden.<br></div><div class="ztitel">Vorhersagbarkeit von Speicherzugriffen</div><div class="text">Ich habe bereits gesagt, dass die Zugriffszeit O(1) auf ein Element eines <i>std::vector</i> oder ein <i>std::deque </i>nicht dasselbe bedeutet. Gleich präsentiere ich mein einfaches Experiment, das ich bereits im Artikel "<a alt="%7B%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Die%20verbleibenden%20Regeln%20zur%20Performanz%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A2408729%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dc5f388188b0f5568fec0ad831768398f%26rm%3Dopen_article_id%26bid%3D2408729%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22B%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf Beitrag 2408729" href="/exec/mainmenu.pl?sid=c5f388188b0f5568fec0ad831768398f&amp;rm=open_article_id&amp;bid=2408729">C++ Core Guidelines: Die verbleibenden Regeln zur Performanz</a>" behandelt habe. Dies ist genau der Grund, warum ich meine Erläuterungen einfach halten werde.</div><div class="text">Wenn eine Variable <i>int</i> vom Hauptspeicher gelesen wird, werden tatsächlich deutlich mehr als 4 Bytes vom Speicher gelesen. Eine ganze Cacheline wird gelesen und im Cache gespeichert. Auf modernen Architekturen besitzt eine Cacheline typischerweise 64 Bytes. Wenn nun nochmals eine Variable aus dem Hauptspeicher angefordert wird und sich die Variable bereits im Cache befindet, verwendet die Leseoperation direkt den Cache und ist damit deutlich schneller. </div><div class="text">Ich möchte gerne testen, was diese Aussage für einen <i>std::vector,</i> eine <i>std::deque</i>, ein <i>std::list </i>und eine <i>std::forward_list </i>bedeutet. Aufgrund der limitierenden Größe ignoriere ich ein <i>std::array</i> in meinem Test.<br></div><div class="text">Das war die Theorie zu den Cachelines. Jetzt bin ich neugierig, ob es einen Unterschied ausmacht, die Elemente eines <i>std::vector</i>, einer <i>std::deque,</i> einer <i>std::list </i>oder einer <i>std::forward_list</i> zu addieren. Das kleine Programm soll die Antwort liefern: <br></div><div class="pre">// memoryAcess.cpp<br><br>#include &lt;forward_list&gt;<br>#include &lt;chrono&gt;<br>#include &lt;deque&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;numeric&gt;<br>#include &lt;random&gt;<br><br>const int SIZE = 100'000'000; <br><br>template &lt;typename T&gt;<br>void sumUp(T&amp; t, const std::string&amp; cont){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);<br><br>&nbsp; auto begin= std::chrono::steady_clock::now();<br>&nbsp; std::size_t res = std::accumulate(t.begin(), t.end(), 0LL);<br>&nbsp; std::chrono::duration&lt;double&gt; last=&nbsp; std::chrono::steady_clock::now() - begin;<br>&nbsp; std::cout &lt;&lt; cont &lt;&lt;&nbsp; std::endl;<br>&nbsp; std::cout &lt;&lt; "time: " &lt;&lt; last.count() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::random_device seed;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::mt19937 engine(seed());<br>&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;int&gt; dist(0, 100);<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; randNumbers;<br>&nbsp;&nbsp;&nbsp; randNumbers.reserve(SIZE);<br>&nbsp;&nbsp;&nbsp; for (int i=0; i &lt; SIZE; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; randNumbers.push_back(dist(engine));<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myVec,"std::vector&lt;int&gt;");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::deque&lt;int&gt;myDec(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myDec,"std::deque&lt;int&gt;");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::list&lt;int&gt;myList(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myList,"std::list&lt;int&gt;");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::forward_list&lt;int&gt;myForwardList(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myForwardList,"std::forward_list&lt;int&gt;");&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; <br>}</div><div class="text">Das Programm <i>memoryAccess.cpp</i> erzeugt zuerst einmal 100 Millionen Zufallszahlen zwischen 0 und 100 (1). Dann summiert es die Zahlen mit einem <i>std::vector</i> (2), einer <i>std::deque</i> (3), einer <i>std::list </i>(4) und einer <i>std::forward_list</i> (5) zusammen. Die eigentliche Arbeit findet in der Funktion <i>sumUp </i>(6) statt.</div><div class="text">Ich übersetzte das Programm mit maximaler Optimierung unter Linux und Windows. Mich interessiert in diesem Fall nicht der Performanzunterschied zwischen Linux und Windows, da dies ein Vergleich zwischen einem Desktop-PC und einem Laptop wäre. Mich interessiert die Leseperformanz der vier Container. Hier ist sie:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174583753_1e5ddbc38b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Um meine Performanztest einfach zu visualisieren, stellt sie die folgende Grafik dar.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_174583731_4751d424b4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Ich will die Performanzzahlen nicht überbewerten, aber eine Beobachtung lässt sich auf jeden Fall ableiten. Je optimierter eine Datenstrukur für Cachelines ist, desto schneller ist die Zugriffszeit: <i>std::vector </i>&gt; <i>std::deque</i> &gt; (<i>std::list, std::forward_list</i>).</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Ich denke, ich werde einen ähnlichen Artikel zu den assoziativen Containern der Standard Template Library schreiben. Für mein Gefühl sind sie in den C++ Core Guidelines unterrepräsentiert. Im nächsten Artikel geht es daher um assoziative Container wie <i>std::map </i>und <i>std::unordered_map.</i> <br> </div><div class="simple-translate-result-wrapper"><br> <br></div>