<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147148723_1bf6021a6a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Weiter mit der Tour durch die Regeln für Ausdrücke und Anweisungen in den C++ Core Guidelines. Dieser Artikel macht bei den Deklarationen und Initialisierungen halt.</div>
<div class="text">Um ehrlich zu sein, die meisten dieser Regeln sind ziemlich offensichtlich. Sie bieten aber oft die eine oder andere interessante Einsicht an. Daher wird sich dieser Artikel auf diese besondere Einsichten fokussieren. Hier sind die Regeln, die uns in diesem Artikel beschäftigen.</div>
<div class="text"><ul><li><a alt="%7B%22text%22%3A%22ES.11%3A%20Use%26nbsp%3Bauto%26nbsp%3Bto%20avoid%20redundant%20repetition%20of%20type%20names%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-auto%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-auto%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-auto" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-auto">ES.11: Use&nbsp;auto&nbsp;to avoid redundant repetition of type names</a></li><li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-reuse" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-reuse" alt="%7B%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22ES.12%3A%20Do%20not%20reuse%20names%20in%20nested%20scopes%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-reuse%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-reuse%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%7D">ES.12: Do not reuse names in nested scopes</a></li><li><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-always" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-always" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-always%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-always%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.20%3A%20Always%20initialize%20an%20object%22%7D">ES.20: Always initialize an object</a></li><li><a alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.21%3A%20Don%C2%92t%20introduce%20a%20variable%20%28or%20constant%29%20before%20you%20need%20to%20use%20it%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-introduce%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-introduce%22%2C%22target%22%3A%22_blank%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-introduce" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-introduce">ES.21: Don’t introduce a variable (or constant) before you need to use it</a></li><li><a alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-init%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-init%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.22%3A%20Don%C2%92t%20declare%20a%20variable%20until%20you%20have%20a%20value%20to%20initialize%20it%20with%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-init" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-init">ES.22: Don’t declare a variable until you have a value to initialize it with</a></li><li><a alt="%7B%22text%22%3A%22ES.23%3A%20Prefer%20the%26nbsp%3B%7B%7D-initializer%20syntax%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-list%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-list%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list" class="">ES.23: Prefer the&nbsp;{}-initializer syntax</a></li><li><a alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.24%3A%20Use%20a%26nbsp%3Bunique_ptr%26lt%3BT%26gt%3B%26nbsp%3Bto%20hold%20pointers%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unique%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unique%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unique" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unique">ES.24: Use a&nbsp;unique_ptr&lt;T&gt;&nbsp;to hold pointers</a></li></ul></div>
<div class="text"><b><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-auto%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-auto%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22ES.11%3A%20Use%26nbsp%3Bauto%26nbsp%3Bto%20avoid%20redundant%20repetition%20of%20type%20names%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-auto" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-auto">ES.11: Use&nbsp;auto&nbsp;to avoid redundant repetition of type names</a></b></div>
<div class="text">Das Beispiel aus den Guidelines ist mir nicht überzeugend genug. Daher werde ich ein anderes Beispiel präsentieren. Falls&nbsp;<i>auto</i>&nbsp;zum Einsatz kommt, wird das Modifizieren des Codes zu einem Kinderspiel.</div>
<div class="text">Das folgende Beispiel basiert vollständig auf&nbsp;<i>auto</i>. Daher musst du dich nicht mit den Datentypen beschäftigen und kannst somit [--] und das ist entscheidend [--] keinen Fehler machen. Das bedeutet in dem konkreten Fall, dass der Datentyp von&nbsp;<i>res</i>&nbsp;am Ende des Programmschnipsel <i>int</i> sein wird.&nbsp;</div>
<div class="pre">auto a = 5;<br>auto b = 10;<br>auto sum =&nbsp; a * b * 3;<br>auto res = sum + 10; <br>std::cout &lt;&lt; typeid(res).name();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i<br></div>
<div class="text">Falls jetzt aber aus dem Literal<i> b</i> vom Datentyp <i>int</i> ein double (2) oder anstelle des Datentyps<i> int</i> ein <i>float</i>-Literal (3) verwendet werden soll, kein Problem. Das regelt die C++-Laufzeit automatisch.</div>
<div class="pre">auto a = 5;<br>auto b = 10.5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>auto sum = a * b * 3;<br>auto res = sum * 10; &nbsp;<br>std::cout &lt;&lt; typeid(res).name();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // d<br>&nbsp; <br>auto a = 5;<br>auto b = 10;<br>auto sum = a * b * 3.1f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>auto res = sum * 10; &nbsp;<br>std::cout &lt;&lt; typeid(res).name();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // f</div>
<div class="text"><b><a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.12%3A%20Do%20not%20reuse%20names%20in%20nested%20scopes%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-reuse%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-reuse%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-reuse" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-reuse" class="">ES.12: Do not reuse names in nested scopes</a></b><br></div>
<div class="text">Dies ist eine der ziemlich offensichtlichen Regeln. Du solltest aus Lesbarkeit- und Wartbarkeitgründen keine Namen in verschachtelten Bereichen verwenden.</div>
<div class="pre">// shadow.cpp<br><br>#include &lt;iostream&gt;<br><br>int shadow(bool cond){<br>&nbsp; int d = 0;<br>&nbsp; if (cond){<br>&nbsp;&nbsp;&nbsp; d = 1;<br>&nbsp; }<br>&nbsp; else {<br>&nbsp;&nbsp;&nbsp; int d = 2;<br>&nbsp;&nbsp;&nbsp; d = 3;<br>&nbsp; }<br>&nbsp; return d;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; shadow(true) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; shadow(false) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Welche Ausgabe produziert das Programm? Verwirrt durch die "d"s? Hier ist die Ausgabe.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147148726_e0ee31ae62.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Das war einfach! Dasselbe Phänomen birgt aber eines an Überraschungspotenzial in Klassenhierarchien.</div>
<div class="pre">// shadowClass.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>struct Base{<br>&nbsp;&nbsp;&nbsp; void shadow(std::string){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base::shadow" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct Derived: Base{<br>&nbsp;&nbsp;&nbsp; using Base::shadow;<br>&nbsp;&nbsp;&nbsp; void shadow(int){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived::shadow" &lt;&lt; std::endl;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; Derived derived;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; derived.shadow(std::string{});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp; derived.shadow(int{});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Beide Strukturen <i>Base</i> und <i>Derived</i> besitzen eine Method <i>shadow</i>. Die eine in der Basisklasse nimmt einen <i>std::string</i> (1) an, die anderen einen <i>int </i>(2). Wenn ich nun das Objekt <i>derived</i> mit einem default-konstruierten <i>std::string </i>(3) verwende, nehme ich doch an, dass die <i>Base-</i>Variante aufgerufen wird. Falsch! Da die Methode <i>shadow</i> auch in der abgeleiteten Klasse <i>Derived</i> implementiert ist, wird die Methode in der Klasse <i>Base</i> beim Auflösen der Namen nicht berücksichtigt. Hier ist die Ausgabe meines GCCs. <br></div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147148741_3c85d27037.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Um das Problem zu lösen, reicht es aus, die Methode <i>shadow</i> in <i>Derived</i> bekannt zu machen.<br></div>
<div class="pre">struct Derived: Base{<br>&nbsp;&nbsp;&nbsp; using Base::shadow;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp;&nbsp;&nbsp; void shadow(int){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived::shadow" &lt;&lt; std::endl;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>};</div>
<div class="text">Durch den Ausdruck <i>using Base::shadow</i> (1) kennt die Klasse <i>Derived</i> die Methode <i>shadow</i> und das Programmverhalten entspricht unseren Erwartungen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147148742_6e8e57ad9a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div>
<div class="text"><b><a alt="%7B%22text%22%3A%22ES.20%3A%20Always%20initialize%20an%20object%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-always%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-always%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-always" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-always">ES.20: Always initialize an object</a></b></div>
<div class="text">Die Regeln, wann Objekt initialisiert werden, sind recht haarig in C++. Hier ist ein einfaches Beispiel.</div>
<div class="pre">struct T1 {};<br>class T2{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; T2() {} <br>};<br><br>int n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br><br>int main(){<br>&nbsp; int n2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ERROR<br>&nbsp; std::string s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp; T1 t1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp; T2 t2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}&nbsp; <br></div>
<div class="text"><i>n</i> ist eine globale Variable und wird daher mit 0 initialisiert. Das gilt aber nicht für <i>n2</i>, da dies eine lokale Variable ist und somit nicht initialisiert wird. Wenn jedoch ein benutzerdefinierter Typ wie <i>std::string</i>, <i>T1</i> oder <i>T2</i> in einem lokalen Bereich zum Einsatz kommt, wird dieser initialisiert. </div>
<div class="text">Falls das zu kompliziert ist, gibt es eine einfache Lösung. Verwende <i>auto.</i> Nun kannst du das Initialisieren nicht mehr vergessen. Der C++-Laufzeit stellt das sicher.</div>
<div class="pre">struct T1 {};<br>class T2{<br>&nbsp;public:<br>&nbsp;&nbsp;&nbsp; T2() {}<br>};<br><br>auto n = 0;<br><br>int main(){<br>&nbsp; auto n2 = 0;<br>&nbsp; auto s = ""s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; auto t1 = T1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; auto t2 = T2();<br>} </div>
<div class="text"><b><a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.21%3A%20Don%C2%92t%20introduce%20a%20variable%20%28or%20constant%29%20before%20you%20need%20to%20use%20it%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-introduce%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-introduce%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-introduce" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-introduce">ES.21: Don’t introduce a variable (or constant) before you need to use it</a></b><br></div>
<div class="text">Diese Regel ist selbsterkärend. Wir programmieren C++, nicht C.<br></div>
<div class="text"><b><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-init" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-init" alt="%7B%22text%22%3A%22ES.22%3A%20Don%C2%92t%20declare%20a%20variable%20until%20you%20have%20a%20value%20to%20initialize%20it%20with%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-init%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-init%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%7D">ES.22: Don’t declare a variable until you have a value to initialize it with</a></b><br></div>
<div class="text">Falls diese Regel nicht eingehalten wird, kann es zum used-befor-set-Fehler kommen. Hier ist das Beispiel aus den Guidelines.<br></div>
<div class="pre">int var;&nbsp; <br><br>if (cond)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // some non-trivial condition<br>&nbsp;&nbsp;&nbsp; Set(&amp;var);<br>else if (cond2 || !cond3) {<br>&nbsp;&nbsp;&nbsp; var = Set2(3.14);<br>}<br><br>// use var&nbsp; <br></div>
<div class="text">Bist du dir sicher, dass eine der Bedingungen immer zuschlagen wird? Falls nicht, wird die lokale Variable <i>var</i> nichtinitialisiert verwendet.</div>
<div class="text"><b><a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.23%3A%20Prefer%20the%26nbsp%3B%7B%7D-initializer%20syntax%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-list%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-list%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list">ES.23: Prefer the&nbsp;{}-initializer syntax</a></b></div>
<div class="text">Es gibt viele gute Gründe, {}-Initialisierung zu verwenden:</div>
<div class="text"><ul><li> immer anwendbar</li><li>überwindet den ärgerlichsten Parserfehler (<i>most vexing parse</i>)</li><li>verhindert verengende Konvertierung</li></ul></div>
<div class="text">Eine Regel gilt es aber, bei {}-Initialisierung in Kombination mit <i>auto</i> im Gedächtnis zu behalten. Falls du <i>auto </i>in Kombination mit {}-Initialisierung verwendest, erhältst du nur in C++11 und C++14 eine&nbsp;<i>std::initializer_list</i>, aber nicht in C++17. </div>
<div class="text">Die Details dazu gibt es in meinem Artikel zu <a title="Link auf http://www.grimm-jaud.de/index.php/blog/initialisierung" class="" href="http://www.grimm-jaud.de/index.php/blog/initialisierung" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Finitialisierung%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Finitialisierung%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22%7B%7D-Initialisierung%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D">{}-Initialisierung</a>. </div>
<div class="text"><b><a alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unique%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-unique%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.24%3A%20Use%20a%26nbsp%3Bunique_ptr%26lt%3BT%26gt%3B%26nbsp%3Bto%20hold%20pointers%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unique" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-unique">ES.24: Use a&nbsp;unique_ptr&lt;T&gt;&nbsp;to hold pointers</a></b></div>
<div class="text">Ich werde es kurz machen. Ein <i>std::unique_ptr</i> ist per Design so effizient wie ein nackter Zeiger, besitzt aber einen großen Mehrwert. Er passt auf seine ihm anvertraute Ressource auf. Das heißt: Verwende keine nackten Zeiger. Falls dir das als Information zu wenig ist, kannst du die Details zu <i><a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22std%3A%3Aunique_ptr%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Funique-ptr%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Funique-ptr%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%7D" href="http://www.grimm-jaud.de/index.php/blog/tag/unique-ptr" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/unique-ptr">std::unique_ptr</a></i> in meinen früheren Artikel nachlesen. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wir sind mit den Regeln für Deklarationen noch nicht fertig. Der verbleibenden werden im nächsten Artikel folgen. <br></div>
<div class="ztitel">Weitere Informationen</div>
<div class="text">Für mein offenes Seminar sind noch Plätze frei. Es wird definitiv stattfinden.<br></div>
<div class="text"><ul><li> C++11 und C++14: 13. bis 15. März 2018</li></ul></div>
