<div class="vorspann">Heute schließe ich die Regeln zur Concurrency ab und knüpfe direkt mit den Regeln zur lock-freien Programmierung an. Ja, du hast richtig gelesen: Lock-freie Programmierung.</div>
<div class="text">Bevor ich zur lock-freien Programmierung schreibe, möchte ich noch die drei verbleibenden Regeln zur Concurrency vorstellen:<br></div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-time" class="" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-time%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-time%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.43%3A%20Minimize%20time%20spent%20in%20a%20critical%20section%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-time">CP.43: Minimize time spent in a critical section</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex" class="" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.44%3A%20Remember%20to%20name%20your%20lock_guards%20and%20unique_locks%22%2C%22anchor%22%3A%22%22%7D">CP.44: Remember to name your lock_guards and unique_locks</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex" class="" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22CP.50%3A%20Define%20a%20mutex%20together%20with%20the%20data%20it%20guards.%20Use%20synchronized_value%26lt%3BT%26gt%3B%20where%20possible%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex">CP.50: Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible</a></li></ul></div>
<div class="text">Da die Regeln ziemlich offensichtlich sind, kann ich mich kurz halten.<br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-time" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-time" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-time%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-time%22%2C%22text%22%3A%22CP.43%3A%20Minimize%20time%20spent%20in%20a%20critical%20section%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" class="">CP.43: Minimize time spent in a critical section</a> <br> </div>
<div class="text">Je kürzer du eine Mutex lockst, desto länger kann ein anderer Thread ausgeführt werden. Dies gilt zum Beispiel für die Benachrichtigung einer Bedingungsvariable. Das ganze Beispielprogramm gibt es in dem Artikel <a href="/exec/mainmenu.pl?sid=f5c0d8f8db59f098819f5a7ad458b1ce&amp;rm=open_article_id&amp;bid=2435822" class="" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Df5c0d8f8db59f098819f5a7ad458b1ce%26rm%3Dopen_article_id%26bid%3D2435822%22%2C%22destination%22%3A2435822%2C%22type%22%3A%22B%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Sei%20dir%20der%20Fallen%20von%20Bedingungsvariablen%20bewusst%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf Beitrag 2435822">C++ Core Guidelines: Sei dir der Fallen von Bedingungsvariablen bewusst</a>. </div>
<div class="pre">void setDataReady(){<br>&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; dataReady = true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Data prepared" &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp; condVar.notify_one(); <br>}</div>
<div class="text">Der Mutex <i>mutex_</i> wird am Beginn der Funktion gelockt und an ihrem Ende wieder freigegeben. Dies ist nicht notwendig. Lediglich der Ausdruck <i>dataReady = true</i> (1) ist zu schützen.</div>
<div class="text">Erstens gilt, dass <i>std::cout</i> thread-sicher ist. Der C++11-Standard sichert zu, dass jeder Buchstabe atomar geschrieben wird und dass jeder Buchstabe in der richtigen Reihenfolge ausgegeben wird. Zweitens gilt, dass die Benachrichtigung <i>condVar.notify_one</i> thread-sicher ist.</div>
<div class="text">Hier ist verbesserte Version der Funktion <i>setDataReady</i>:</div>
<div class="pre">void setDataReady(){<br>&nbsp;&nbsp;&nbsp; {&nbsp; // Don't remove because of the lifetime of the mutex (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataReady = true;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Data prepared" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Wenn ich diese Regel in meiner Schulungen zur Concurrency vorstelle, gibt es häufig eine Frage: Ist der künstliche Bereich zu dokumentieren, der die Lebenszeit des Locks <i>std::lock_guard </i>und damit des Mutex einschränkt (Zeilen (1) und (2))? Die meisten Teilnehmer und ich plädieren für ja. Falls nicht, ist die Gefahr sehr groß, dass eine Überarbeitung des Codes dazu führt, dass die zwei zusätzlichen geschweiften Klammern als überflüssig angesehen und entfernt werden. Am Ende führt dies zur Version 1. <br></div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22CP.44%3A%20Remember%20to%20name%20your%20lock_guards%20and%20unique_locks%22%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex">CP.44: Remember to name your lock_guards and unique_locks</a> <br> </div>
<div class="text">Zugegeben, beim ersten Lesen dieser Regel war ich ein wenig verwundert. Hier ist das kleine Sourcecode Beispiel aus den Guidelines:</div>
<div class="pre">unique_lock&lt;mutex&gt;(m1);<br>lock_guard&lt;mutex&gt; {m2};<br>lock(m1, m2);</div>
<div class="text">Der <i>unique_lock</i> und der <i>lock_guard</i> sind lediglich temporäre Variablen, die in einem Schritt erzeugt und wieder destruiert werden. <i>unique_lock</i> und <i>lock_guard</i> locken ihre Mutexe in ihrem Konstruktor und geben diese wieder in ihrem Destruktor frei. Dieses Pattern besitzt den Namen RAII. Hier gibt es die Details dazu: <a title="Link auf https://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" class="" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Garbage%20Collection%20-%20No%20thanks%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22user_params%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke">Garbage Collection - No thanks</a>.</div>
<div class="text">Mein kleines Beispiel stellt das prinzipielle Verhalten eines einfachen <i>std::lock_guard </i>vor. Sein großer Bruder <i>std::unique_lock</i> bietet ein deutlich mächtigeres Interface an.</div>
<div class="pre">// myGuard.cpp<br><br>#include &lt;mutex&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>class MyGuard{<br>&nbsp; T&amp; myMutex;<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; MyGuard(T&amp; m):myMutex(m){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMutex.lock();<br>&nbsp;&nbsp;&nbsp; &nbsp; std::cout &lt;&lt; "lock" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~MyGuard(){<br>&nbsp;&nbsp;&nbsp; &nbsp; myMutex.unlock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "unlock" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::mutex m;<br>&nbsp; MyGuard&lt;std::mutex&gt; {m};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::cout &lt;&lt; "CRITICAL SECTION" &lt;&lt; std::endl;&nbsp;&nbsp; // (2)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}&nbsp; </div>
<div class="text">[i]MyGuard[/i] ruft [i]lock[/i] und [i]unlock[/i] in seinem Konstruktor und Destruktor auf. Aufgrund der temporären Variablen, finden beide Aufrufe genau in der Zeile (1) statt. Das bedeutet insbesondere, dass der Destruktor in Zeile (1) aufgerufen und nicht [--] wie vermutet [--] in der Zeile (3). Konsequenterweise wird der kritische Bereich in Zeile (2) ohne Synchronisation ausgeführt.</div>
<div class="text">Die Ausführung des Programms bringt es ans Licht: "<i>output</i>" wird vor "<i>CRITICAL SECTION</i>" ausgegeben. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_154770917_f240b2468f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.50%3A%20Define%20a%20mutex%20together%20with%20the%20data%20it%20guards.%20Use%20synchronized_value%26lt%3BT%26gt%3B%20where%20possible%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-mutex%22%2C%22user_params%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-mutex">CP.50: Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible</a></div>
<div class="text">Die zentrale Idee dieser Regel ist es, dass du den Mutex direkt in der Datenstruktur anlegst, die es zu schützen gilt. Wenn standardisiertes C++ zum Einsatz kommt, bietet sich die folgende Umsetzung an:<br></div>
<div class="pre">struct Record {<br>&nbsp;&nbsp;&nbsp; std::mutex m;&nbsp;&nbsp; // take this mutex before accessing other members<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br></div>
<div class="text">Mit zukünftigen C++-Standard, kann man diese Regel deutlich eleganter implementieren. Die nächste Implementierung basiert auf <i>synchronized_value&lt;T&gt;</i>, das wohl mit C++20/23 standardisiert werden wird. <br></div>
<div class="pre">class MyClass {<br>&nbsp;&nbsp;&nbsp; struct DataRecord {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; synchronized_value&lt;DataRecord&gt; data; // Protect the data with a mutex<br>};<br></div>
<div class="text">Anthony Williams stellt im Proposal <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4033.html" class="" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4033.html%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4033.html%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22N4033%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4033.html">N4033</a> die Grundidee von <i>synchronized_value&lt;T&gt;</i> genauer vor: "The basic idea is that [i]synchronized_value&lt;T&gt;[/i] stores a value of type T and a mutex. It then exposes a pointer interface, such that derefencing the pointer yields a special wrapper type that holds a lock on the mutex, and that can be implicitly converted to T for reading, and which forwards any values assigned to the assignment operator of the underlying T for writing."</div>
<div class="text">Dies bedeutet im Wesentlichen, dass die Operation auf s in dem folgenden Codeschnipsel thread-sicher sind.</div>
<div class="pre">synchronized_value&lt;std::string&gt; s;<br><br>std::string readValue()<br>{<br>&nbsp;&nbsp;&nbsp; return *s;<br>}<br><br>void setValue(std::string const&amp; newVal)<br>{<br>&nbsp;&nbsp;&nbsp; *s=newVal;<br>}<br>&nbsp;<br>void appendToValue(std::string const&amp; extra)<br>{<br>&nbsp;&nbsp;&nbsp; s-&gt;append(extra);<br>}<br></div>
<div class="text">Nun, wie bereits angekündigt, zu etwas ganz anderem. </div>
<div class="utitel">Lock-freie Programmierung<br></div>
<div class="text">Beginnen möchte ich mit einer Meta-Regel.</div>
<div class="ztitel">Programmiere nicht lock-frei<br></div>
<div class="text">Klar, du glaubst mir nicht, aber basierend auf meiner Erfahrung aus vielen Schulungen und Workshops zur Concurrency, ist dies <b>meine</b> erste Regel. Ehrlich gesagt, bin ich damit im Tenor der meistgeschätzten und bekannten C++ Experten weltweit. Gerne zitiere ich ein paar Aussagen und Zitate ihrer Vorträge:</div>
<div class="text"><ul><li><b>Herb Sutter</b>: "Lock-freie Programmierung ist wie das Spielen mit Messern."</li><li><b>Anthony Williams</b>: "Lock-free programming is about how to shoot yourself in the foot."</li><li><b>Tony Van Eerd:</b>&nbsp; "Lock-free coding is the last thing you want to do."</li><li><b>Fedor Pikus</b>: "Writing correct lock-free programs is even harder."</li><li><b>Harald Böhm</b>: "The rules are not obvious."</li></ul></div>
<div class="text">Das Bild bringt die Aussagen und Zitate nochmals auf den Punkt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_154770923_6a43f86d09.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Du glaubst mir immer noch nicht? C++11 definierte die Speicherordnung <i>std::memory_order_consume</i>. Sieben Jahre später sind dies die offizielen Worte dazu: "<i>The specification of release-consume ordering is being revised, and the use of memory_order_consume is temporarily discouraged.</i>" (<a class="" alt="%7B%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_order%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_order%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22memory_order%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://en.cppreference.com/w/cpp/atomic/memory_order" href="https://en.cppreference.com/w/cpp/atomic/memory_order">memory_order</a>)</div>
<div class="text">Im Falle, du weißt, was du tust, denke über das <a title="Link auf https://heise.de/-3740324" class="" alt="%7B%22text%22%3A%22ABA%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3740324%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3740324%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" href="https://heise.de/-3740324">ABA</a>-Problem in der Regel CP.100 nach. </div>
<div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lockfree" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-lockfree" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lockfree%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-lockfree%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.100%3A%20Don%C2%92t%20use%20lock-free%20programming%20unless%20you%20absolutely%20have%20to%26nbsp%3B%22%7D" class="">CP.100: Don’t use lock-free programming unless you absolutely have to&nbsp;</a><br></div>
<div class="text">Das folgend kleine Codebeispiel der C++ Guidelines besitzt einen Bug.<br></div>
<div class="pre">extern atomic&lt;Link*&gt; head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the shared head of a linked list<br><br>Link* nh = new Link(data, nullptr);&nbsp;&nbsp;&nbsp; // make a link ready for insertion<br>Link* h = head.load();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read the shared head of the list<br><br>do {<br>&nbsp;&nbsp;&nbsp; if (h-&gt;data &lt;= data) break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if so, insert elsewhere<br>&nbsp;&nbsp;&nbsp; nh-&gt;next = h;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // next element is the previous head<br>} while (!head.compare_exchange_weak(h, nh));&nbsp;&nbsp;&nbsp; // write nh to head or to h</div>
<div class="text">Finde den Bug und schreibe eine E-Mail oder einen Kommentar. Ich werde auf die beste Problemanalyse in meinen nächsten Artikel eingehen und, falls du willst, deinen Namen nennen.</div>
<div class="utitel">Wie geht's weiter?</div>
<div class="text">Klar, ich werde erst das ABA-Problem im nächsten Artikel auflösen. Danach geht meine Geschichte zur lock-freien Programmierung weiter.</div>
