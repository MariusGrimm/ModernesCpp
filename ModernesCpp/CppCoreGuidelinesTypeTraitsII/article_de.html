<div class="vorspann">Die Type-Traits-Bibliothek unterstützt Typprüfungen, Typvergleiche und Typmodifikationen zur Compilezeit. Genau: Heute geht es um Typmodifikationen zur Compilezeit.</div>
<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166199271_95a264f544.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Die Type-Traits-Bibliothek</div>
<div class="text">Es mag verwunderlich klingen, aber Typmodifikationen ist die Domäne von Template-Metaprogrammierung und daher auch der Type-Traits-Bibliothek.</div>
<div class="ztitel_kleiner">Typmodifikationen</div>
<div class="text">Ich denke, du bist neugierig, was zur Compilezeit möglich ist: viel! Hier sind die spannendsten Metafunktionen.</div>
<div class="pre">// const-volatile modifications:<br>remove_const;<br>remove_volatile;<br>remove_cv;<br>add_const;<br>add_volatile;<br>add_cv;<br>&nbsp;&nbsp; <br>// reference modifications:<br>remove_reference;<br>add_lvalue_reference;<br>add_rvalue_reference;<br><br>// sign modifications:<br>make_signed;<br>make_unsigned;<br>&nbsp;<br>// pointer modifications:<br>remove_pointer;<br>add_pointer;<br>&nbsp;<br>// other transformations:<br>decay;<br>enable_if;<br>conditional;<br>common_type;<br>underlying_type;</div>
<div class="text">Um einen<i> int</i> von einem <i>int </i>oder einem <i>const int</i> zu erhalten, reicht eine einfache Anfrage nach dem Type mit <i>::type</i>.</div>
<div class="pre">int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, std::remove_const&lt;int&gt;::type&gt;::value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, std::remove_const&lt;const int&gt;::type&gt;::value;// true<br>&nbsp; <br>}</div>
<div class="text">Seit C++14 gibt die Metafunktion direkt mit<i> _t</i> wie bei <i>std::remove_const_t </i>ihren Typ preis.<i><br></i></div>
<div class="pre">int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, std::remove_const_t&lt;int&gt;&gt;::value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true<br>&nbsp;&nbsp;&nbsp; std::is_same&lt;int, std::remove_const_t&lt;const int&gt;&gt;::value;&nbsp; // true<br>}</div>
<div class="text">Um eine Idee zu bekommen, wie mächtig diese Metafunktionen sind, sind hier ein paar Anwendungsfälle:</div>
<div class="text"><ul><li><b><i>remove_reference:</i></b> <i>std::move</i> und <i>std::forward</i> verwendet diese Funktion, um die Referenz von seinem Argument zu entfernen. Hier ist <i>std::move</i> in einer Zeile.<br></li><ul><li><i>static_cast&lt;std::remove_reference&lt;decltype(arg)&gt;::type&amp;&amp;&gt;(arg);</i></li></ul></ul><ul><li><b><i>decay</i></b>: <i>std::thread</i> wendet <i>std::decay</i> auf seine Argumente an. Diese ist die Funktion <i>f,</i> die er ausführt und die Funktionsargumente <i>args</i>. Decay steht für die implizite Konvertierung von Arrays zu Zeigern, Funktion zu Funktionszeigern und das Entfernen der <i>const/volatile-</i>Qualifizierer und Referenzen.&nbsp; <br></li><ul><li>&nbsp;<i>std::invoke(decay_copy(std::forward&lt;Function&gt;(f)), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decay_copy(std::forward&lt;Args&gt;(args))...);</i></li></ul><li><i><b>enable_if:</b> std::enable_if </i>ist eine einfache Form, SFINAE anzuwenden.&nbsp;SFINAE steht für Substitution Failure Is Not An Error und wird während der Überladung von Funktions-Templates angewandt. Es bedeutet: Wenn bei der Ersetzung der Template-Parameter ein Fehler auftritt, ist dies kein Fehler. Diese Instantiierung der Template-Parameter wird aus der Menge aller Funktionsüberladungen einfach entfernt. <i>std::enable_if</i> wird sehr häufig in <i>std::tuple </i>verwendet.</li><li><b><i>conditional:</i></b> <i>std::conditional</i> ist der ternäre Operator zur Compilezeit.</li><li><b><i>common_type</i></b>: <i>std::common_type </i>bestimmt den gemeinsamen Datentyp einer Menge von Datentypen.</li><li><b><i>underlying_type</i></b>: <i>std::underlying_type</i> ermittelt den Datentyp einer Aufzählung. <br></li></ul></div>
<div class="text">Eventuell habe ich dich noch nicht überzeugt, warum die Type-Traits so wichtig sind? Daher will ich meine Geschichte zu den Type-Traits mit ihren zwei größten Vorteilen beenden: Korrektheit und Performanz.</div>
<div class="ztitel_kleiner">Korrektheit</div>
<div class="text">Korrektheit bedeutet einerseits, dass die Type-Traits-Bibliothek dazu verwendet werden kann, Concepts wie <i>Integral, SignedIntegral</i> oder <i>UnsignedIntegral</i> zu implementieren. <br></div>
<div class="pre">template &lt;class T&gt;<br>concept bool Integral() {<br>&nbsp;&nbsp;&nbsp; return is_integral&lt;T&gt;::value;<br>}<br><br>template &lt;class T&gt;<br>concept bool SignedIntegral() {<br>&nbsp;&nbsp;&nbsp; return Integral&lt;T&gt;() &amp;&amp; is_signed&lt;T&gt;::value;<br>}<br><br>template &lt;class T&gt;<br>concept bool UnsignedIntegral() {<br>&nbsp;&nbsp;&nbsp; return Integral&lt;T&gt;() &amp;&amp; !SignedIntegral&lt;T&gt;();<br>}</div>
<div class="text">Korrektheit bedeutet auch, dass sie eingesetzt werden kann, um Algorithmen typsicherer anzubieten. Ich wendete in meinem Artikel <a alt="%7B%22text%22%3A%22Immer%20sicherer%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fimmer-sicherer%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fimmer-sicherer%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/immer-sicherer" href="https://www.grimm-jaud.de/index.php/blog/immer-sicherer" class="">Immer sicherer</a> die Funktionen <i>std::is_integral, std::conditional, std::common_type</i> und <i>std::enable_if </i>der Type-Traits-Bibliothek an um den <i>gcd</i>-Algorithmus sukzessiv sicherer zu implementieren.</div>
<div class="text">Damit du eine bessere Idee von dem Artikel <a title="Link auf https://www.grimm-jaud.de/index.php/blog/immer-sicherer" class="" href="https://www.grimm-jaud.de/index.php/blog/immer-sicherer" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fimmer-sicherer%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22Immer%20sicherer%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fimmer-sicherer%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%7D">Immer sicherer</a> erhältst: Hier ist der Startpunkt meines generischen <i>gcd-</i>Algorithmus.</div>
<div class="pre">// gcd.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>T gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "gcd(100, 10)= " &lt;&lt;&nbsp; gcd(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "gcd(100, 33)= " &lt;&lt; gcd(100, 33) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "gcd(100, 0)= " &lt;&lt; gcd(100, 0)&nbsp; &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; gcd(3.5, 4.0)&lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::cout &lt;&lt; gcd("100", "10") &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; std::cout &lt;&lt; gcd(100, 10L) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<i><br></i></div>
<div class="text">Die Ausgabe des Programms bringt zwei Probleme ans Tageslicht.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_166199282_09e87f898a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Erstens ist die Verwendung des Modulo-Operators für den Datentype <i>double</i> in Zeile 1 und den C-String in Zeile 2 nicht gültig. Zweitens, sollte die Verwendung des Datentyps <i>int</i> und <i>long in</i>t in Zeile 3 möglich sein. Beide Probleme können elegant mit der Type-Traits-Bibliothek gelöst werden.</div>
<div class="text">Bei der Type-Traits-Bibliothek geht es nicht nur um Korrektheit, es geht auch um Optimierung.</div>
<div class="ztitel_kleiner">Optimierung</div>
<div class="text">Die zentrale Idee der Type-Traits-Bibliothek ist einfach. Der Compiler analysiert die verwendeten Datentypen und trifft auf Grundlage seiner Analyse eine Entscheidung, welcher Code ausgeführt werden soll. Im Falle der Algorithmen <i>std::copy, std::fill</i> oder <i>std::equal</i> der Standard Template Library bedeutet dies, dass die Algorithmen entweder auf jedes Element des Bereiches oder auf den ganzen Speicherbereich sukzessive angewandt werden. Im zweiten Fall kommen dann die schnellen C-Funktionen&nbsp;<a href="https://en.cppreference.com/w/cpp/string/byte/memset" class="" title="Link auf https://en.cppreference.com/w/cpp/string/byte/memset" alt="%7B%22text%22%3A%22memset%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemset%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemset%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D">memset</a>, <a title="Link auf https://en.cppreference.com/w/cpp/string/byte/memcpy" class="" href="https://en.cppreference.com/w/cpp/string/byte/memcpy" alt="%7B%22text%22%3A%22memcpy%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemcpy%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemcpy%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D">memcpy</a>, oder <a title="Link auf https://en.cppreference.com/w/cpp/string/byte/memmove" class="" href="https://en.cppreference.com/w/cpp/string/byte/memmove" alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemmove%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fstring%2Fbyte%2Fmemmove%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22memmove%22%7D">memmove</a> zum Einsatz. Im Gegensatz zu <i>memcpy</i> erlaubt <i>memmove</i> überlappende Speicherbereiche.&nbsp; </div>
<div class="pre">// fill &nbsp;<br>// Specialization: for char types we can use memset.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>template&lt;typename _Tp&gt;<br>&nbsp; inline typename<br>&nbsp; __gnu_cxx::__enable_if&lt;__is_byte&lt;_Tp&gt;::__value, void&gt;::__type&nbsp; // (1)<br>&nbsp; __fill_a(_Tp* __first, _Tp* __last, const _Tp&amp; __c)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; const _Tp __tmp = __c;<br>&nbsp;&nbsp;&nbsp; if (const size_t __len = __last - __first)<br>&nbsp;&nbsp;&nbsp; __builtin_memset(__first, static_cast&lt;unsigned char&gt;(__tmp), __len);<br>&nbsp; }<br><br>// copy<br><br>template&lt;bool _IsMove, typename _II, typename _OI&gt;<br>&nbsp; inline _OI<br>&nbsp; __copy_move_a(_II __first, _II __last, _OI __result)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; typedef typename iterator_traits&lt;_II&gt;::value_type _ValueTypeI;<br>&nbsp;&nbsp;&nbsp; typedef typename iterator_traits&lt;_OI&gt;::value_type _ValueTypeO;<br>&nbsp;&nbsp;&nbsp; typedef typename iterator_traits&lt;_II&gt;::iterator_category _Category;<br>&nbsp;&nbsp;&nbsp; const bool __simple = (__is_trivial(_ValueTypeI)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; __is_pointer&lt;_II&gt;::__value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; __is_pointer&lt;_OI&gt;::__value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; __are_same&lt;_ValueTypeI, _ValueTypeO&gt;::__value);<br><br>&nbsp;&nbsp;&nbsp; return std::__copy_move&lt;_IsMove, __simple,<br>&nbsp; }<br><br>// lexicographical_compare<br><br>template&lt;typename _II1, typename _II2&gt;<br>&nbsp; inline bool<br>&nbsp; __lexicographical_compare_aux(_II1 __first1, _II1 __last1,<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; _II2 __first2, _II2 __last2)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; typedef typename iterator_traits&lt;_II1&gt;::value_type _ValueType1;<br>&nbsp;&nbsp;&nbsp; typedef typename iterator_traits&lt;_II2&gt;::value_type _ValueType2;<br>&nbsp;&nbsp;&nbsp; const bool __simple =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (__is_byte&lt;_ValueType1&gt;::__value &amp;&amp; __is_byte&lt;_ValueType2&gt;::__value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !__gnu_cxx::__numeric_traits&lt;_ValueType1&gt;::__is_signed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !__gnu_cxx::__numeric_traits&lt;_ValueType2&gt;::__is_signed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; __is_pointer&lt;_II1&gt;::__value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; __is_pointer&lt;_II2&gt;::__value);<br><br>&nbsp; return std::__lexicographical_compare&lt;__simple&gt;::__lc(__first1, __last1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __first2, __last2);<br>&nbsp; }</div>
<div class="text">Die Zeilen 1, 2 und 3 zeigen, dass die Type-Traits-Bibliothek zum Einsatz kommt, um besseren Code zu erzeugen. In meinem Artikel <a alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftype-traits-performanz-zaehlt%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftype-traits-performanz-zaehlt%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Type-Traits%20Performanz%22%7D" class="" href="https://www.grimm-jaud.de/index.php/blog/type-traits-performanz-zaehlt" title="Link auf https://www.grimm-jaud.de/index.php/blog/type-traits-performanz-zaehlt">Type-Traits Performanz</a> gehe ich tiefer auf diese Optimierung ein und präsentiere beeindruckende Performanzzahlen für den GCC und MSVC. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mit <i>constexpr</i> entflieht die Programmierung der Compilezeit ihrer Expertennische und wird zum Mainstream. <i>constexpr</i> ist Programierung zur Compilezeit mit der gewohnten C++-Syntax. </div>
<div class="ztitel">C++-Schulungen im Großraum Stuttgart</div>
<div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div>
<div class="text"><ul><li> <a alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F3-c-11-und-c-14%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F3-c-11-und-c-14%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/3-c-11-und-c-14" class="" title="Link auf https://www.modernescpp.de/index.php/c/2-c/3-c-11-und-c-14">C++11 und C++14</a>: 11. bis 13.03.<br></li><li> <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F18-generische-programmierung-templates-mit-c%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Generische%20Programmierung%20%28Templates%29%20mit%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F18-generische-programmierung-templates-mit-c%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/18-generische-programmierung-templates-mit-c" class="" title="Link auf https://www.modernescpp.de/index.php/c/2-c/18-generische-programmierung-templates-mit-c">Generische Programmierung (Templates) mit C++</a>: 02. bis 04.04 </li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" class="" href="https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" alt="%7B%22text%22%3A%22Embedded%20Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%7D">Embedded Programmierung mit modernem C++</a>: 21. bis 23.05 </li></ul> </div>
<div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a alt="%7B%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22ir_link%22%3A1%7D" class="" href="https://www.modernescpp.de/" title="Link auf https://www.modernescpp.de/">www.ModernesCpp.de</a>. </div>