<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151170602_c44fa7f59d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">In diesem Artikel geht meine Reise durch die Regeln zur Performanz in den C++ Core Guidelines weiter. Insbesondere beschäftige ich mich dem Softwareentwurf, der die Optimierung im Fokus hat.</div>
<div class="text">Hier sind die zwei Stationen für heute.</div>
<div class="text"><ul><li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-efficiency" title="Link auf https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-efficiency" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Per.7%3A%20Design%20to%20enable%20optimization%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-efficiency%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-efficiency%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D">Per.7: Design to enable optimization</a> </li><li> <a alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-type%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Per.10%3A%20Rely%20on%20the%20static%20type%20system%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-type%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-type" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-type" class="">Per.10: Rely on the static type system</a></li></ul></div>
<div class="text"><b><a class="" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-efficiency" title="Link auf https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-efficiency" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-efficiency%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Per.7%3A%20Design%20to%20enable%20optimization%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-efficiency%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">Per.7: Design to enable optimization</a></b> <br> </div>
<div class="text">Als ich diesen Titel zum ersten Mal las, kam mir sofort die Move-Semantik in den Sinn. Warum? Du solltest deine Algorithmen mit Move- und nicht mit Copy-Semantik implementieren. Damit erhältst du sofort ein paar Vorteile.</div>
<div class="text"><ol><li> Klar, anstelle einer teuren Copy- kommt eine billige Move-Operation zum Einsatz.<br></li><li>Dein Algorithmus ist deutlicher stabiler, da er keinen Speicher benötigt und somit keine <a alt="%7B%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fmemory%2Fnew%2Fbad_alloc%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22std%3A%3Abad_alloc%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fmemory%2Fnew%2Fbad_alloc%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://en.cppreference.com/w/cpp/memory/new/bad_alloc" href="http://en.cppreference.com/w/cpp/memory/new/bad_alloc" class="">std::bad_alloc</a>-Ausnahme geworfen werden kann.</li><li>Du kannst deinen Algorithmus mit Datentypen wie <i>std::unique_ptr </i>verwenden, die nicht kopiert, sondern nur verschoben werden können. <br></li></ol></div>
<div class="text">Verstanden! Da implementiere ich doch gleich einen generischen <i>swap</i>-Algorithmus, der die Move-Semantik anwendet:</div>
<div class="pre">// swap.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;cstddef&gt; <br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>void swap(T&amp; a, T&amp; b) noexcept {<br>&nbsp;&nbsp;&nbsp; T tmp(std::move(a));<br>&nbsp;&nbsp;&nbsp; a = std::move(b);<br>&nbsp;&nbsp;&nbsp; b = std::move(tmp);<br>}<br><br>class BigArray{<br><br>public:<br>&nbsp;&nbsp;&nbsp; BigArray(std::size_t sz): size(sz), data(new int[size]){}<br><br>&nbsp;&nbsp;&nbsp; BigArray(const BigArray&amp; other): size(other.size), data(new int[other.size]){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Copy constructor" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(other.data, other.data + size, data);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; BigArray&amp; operator=(const BigArray&amp; other){&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Copy assignment" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this != &amp;other){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = nullptr;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = other.size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new int[size];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(other.data, other.data + size, data);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ~BigArray(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] data;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; std::size_t size;<br>&nbsp;&nbsp;&nbsp; int* data;<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; BigArray bigArr1(2011);<br>&nbsp; BigArray bigArr2(2017);<br>&nbsp; swap(bigArr1, bigArr2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>};</div>
<div class="text">Das war einfach. Leider nicht. Mein Kollege gab mir seinen Datentyp <i>BigArray. BigArray</i> besitzt ein paar Probleme. Über den Copy-Zuweisungsoperator (1) werde ich später schreiben. Zuerst einmal gibt es ein ernsthaftes Problem. <i>BigArray</i> unterstützt nur Move-, aber nicht die Copy-Semantik. Was passiert, wenn ich zwei <i>BigArray</i>s in Zeile (2) austausche? Mein <i>swap</i>-Algorithmus verwendet unter der Decke die Move-Semantik. Das probiere ich gleich aus:</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151170605_a9c3fb2d83.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Nichts passiert. Es funktioniert einfach. Die traditionelle Copy-Semantik springt ein, und ich erhalte das klassische Verhalten. Die Copy-Semantik ist eine Art Fallback für die Move-Semantik. Du kannst es aber auch anders herum sehen. Verschieben ist ein optimiertes Kopieren. </div>
<div class="text">Wie ist das möglich? Ich habe explizit die Move-Semantik in meinen swap-Algorithmus angefordert. Der Grund ist, dass <i>std::move</i> einen Rvalue zurückgibt. Eine konstante Lvalue-Referenz kann einen Rvalue binden und der Copy-Konstruktor und der Copy-Zuweisungsoperator besitzen eine konstante Lvalue-Referenz als Argument. Falls <i>BigArray</i> einen Move-Konstruktor und einen Move-Zuweisungsoperator besitzen würde, die jeweils eine Rvalue-Referenz erwarten, besitzen beide eine höhere Priorität als ihre Copy-Pendants. </div>
<div class="text">Wenn in Algorithmen Move-Semantik verwendet wird, kommt sie automatisch zum Einsatz, wenn die Datentypen Move-Semantik unterstützen. Falls nicht, springt die Copy-Semantik als Fallback ein. Schlimmstenfalls erhältst du daher das klassische Verhalten. </div>
<div class="text">Ich habe bereits angedeutet, dass der Copy-Zuweisungsoperator einige Probleme besitzt. Hier sind sie:</div>
<div class="pre">BigArray&amp; operator=(const BigArray&amp; other){ <br>&nbsp;&nbsp;&nbsp; if (this != &amp;other){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] data; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = nullptr; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = other.size; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = new int[size];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(other.data, other.data + size, data); // (3) <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; return *this; <br>}<br></div>
<div class="text"><ol><li>Ich muss auf Selbstzuweisung prüfen. Meist findet Selbstzuweisung nicht statt. Trotzdem prüfe ich den speziellen Fall.</li><li>Falls die Speicherallokierung fehlschlägt, wurde <i>this</i> bereits modifiziert. Die <i>size</i> ist falsch und <i>data</i> bereits gelöscht. Das bedeutet, dass der Copy-Zuweisungsoperator nur die <b>basic exception guarantee</b> besitzt, aber nicht die <b>strong exception guarantee</b>. Die basic exception guarantee sichert zu, das keine Speicherleck nach einer Ausnahme auftritt. Die strong exception guarantee sichert hingegen bei einer Ausnahme zu, dass das Programm auf den Zustand vor der Ausnahme zurückgesetzt werden kann. Mehr Informationen zur Exception-Sicherheit gibt es in dem Wikipedia-Artikel: <a alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FException_safety%22%2C%22text%22%3A%22exception%20safety%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FException_safety%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" class="" title="Link auf https://en.wikipedia.org/wiki/Exception_safety" href="https://en.wikipedia.org/wiki/Exception_safety">exception safety</a>. <br></li><li>Diese Zeile ist identisch zu der Zeile aus dem Copy-Konstruktor.</li></ol></div>
<div class="text">All die Probleme lassen sich meistern, wenn <i>BigArray</i> eine eigene <i>swap</i>-Funktion besitzt, wie es die C++ Core Guidelines empfehlen: <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-swap" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-swap" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-swap%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.83%3A%20For%20value-like%20types%2C%20consider%20providing%20a%26nbsp%3Bnoexcept%26nbsp%3Bswap%20function%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-swap%22%7D">C.83: For value-like types, consider providing a&nbsp;noexcept&nbsp;swap function</a>. Hier ist der verbesserte Datentyp <i>BigArray</i>, der eine Funktion <i>swap</i> besitzt und diese in seinem Copy-Zuweisungsoperator verwendet: <br></div>
<div class="pre">class BigArray{<br><br>public:<br>&nbsp;&nbsp;&nbsp; BigArray(std::size_t sz): size(sz), data(new int[size]){}<br><br>&nbsp;&nbsp;&nbsp; BigArray(const BigArray&amp; other): size(other.size), data(new int[other.size]){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Copy constructor" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(other.data, other.data + size, data);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; BigArray&amp; operator = (BigArray other){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swap(*this, other);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ~BigArray(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] data;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; friend void swap(BigArray&amp; first, BigArray&amp; second){&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::swap(first.size, second.size);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::swap(first.data, second.data);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>private:<br>&nbsp;&nbsp;&nbsp; std::size_t size;<br>&nbsp;&nbsp;&nbsp; int* data;<br>};<br></div>
<div class="text">Die <i>swap</i>-Funktion in Zeile (1) ist kein Klassenmitglied, daher verwendet sie den Aufruf <i>swap(bigArray1, bigArray2)</i>. Vermutlich verwundert dich die Signatur des Copy-Zuweisungsoperators in Zeile (2). Dank der Copy ist kein Test auf Selbstzuweisung notwendig. Zusätzlich gilt die strong exception guarantee und der Sourcecode des Copy-Konstruktors wird nicht dupliziert. Diese Technik ist unter dem Namen <a class="" href="https://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap" title="Link auf https://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikibooks.org%2Fwiki%2FMore_C%2B%2B_Idioms%2FCopy-and-swap%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikibooks.org%2Fwiki%2FMore_C%2B%2B_Idioms%2FCopy-and-swap%22%2C%22text%22%3A%22copy-and-swap%22%2C%22user_params%22%3A%22%22%7D">copy-and-swap</a>-Idiom bekannt. </div>
<div class="text">Es gibt viele Überladungen der <i>swap</i>-Funktion. Der C++-Standard bietet bereits 50 an.<br></div>
<div class="text"><b><a title="Link auf https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-type" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rper-type" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-type%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%2Fblob%2Fmaster%2FCppCoreGuidelines.md%23Rper-type%22%2C%22text%22%3A%22Per.10%3A%20Rely%20on%20the%20static%20type%20system%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D">Per.10: Rely on the static type system</a></b></div>
<div class="text">Diese Regel ist eine Art Meta-Regel in C++. Entdecke Fehler zur Compilezeit. Meine Erläuterung zu dieser Regel kann ich relativ kurz halten, da ich schon einige Artikel zu dieser sehr wichtigen Regel geschrieben habe.</div>
<div class="text"><ul><li> Verwende automatische Typableitung mit <i>auto </i>(<a alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fautomatisch-initialisiert%22%2C%22text%22%3A%22automatisch%20Initialisiert%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fautomatisch-initialisiert%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/automatisch-initialisiert" title="Link auf https://www.grimm-jaud.de/index.php/blog/automatisch-initialisiert" class="">automatisch Initialisiert</a>) in Kombination mit <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Finitialisierung%22%2C%22text%22%3A%22%7B%7D-Initialisierung%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Finitialisierung%22%2C%22ir_link%22%3A1%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/initialisierung" href="https://www.grimm-jaud.de/index.php/blog/initialisierung" class="">{}-Initialisierung</a> und du wirst viele Vorteile besitzen. <br></li><ol><li>Der Compiler kennt immer den Typ: <i>auto f = 5.0f.</i></li><li>Du kannst das Initialisieren einer Variable nicht vergessen, da ein Ausdruck <i>auto a</i>; nicht gültig ist. <br></li><li>Du kannst mit der {}-Initialisierung prüfen, ob eine verengende Konvertierung stattfindet. Damit kannst du sicherstellen, dass der erwartetet Typ der Typ ist, den der Compiler ableitet:<i> int i = {f}</i>. Der Compiler prüft in dem Ausdruck, dass <i>f</i> vom Typ int ist. Falls nicht, erhälst du eine Warnung. Das ist aber nicht der Fall, wenn du keine geschweiften Klammern anwendest:<i> int i = f;</i>.</li></ol><li>Prüfe mit <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstatisch-geprueft%22%2C%22text%22%3A%22static_assert%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstatisch-geprueft%22%2C%22ir_link%22%3A1%7D" href="https://www.grimm-jaud.de/index.php/blog/statisch-geprueft" title="Link auf https://www.grimm-jaud.de/index.php/blog/statisch-geprueft" class="">static_assert</a> und der <a class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/type-traits" href="https://www.grimm-jaud.de/index.php/blog/tag/type-traits" alt="%7B%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftype-traits%22%2C%22text%22%3A%22Typ-Traits-Bibliothek%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftype-traits%22%2C%22alias%22%3A%22%22%7D">Typ-Traits-Bibliothek</a> Eigenschaften von Datentypen zur Compilezeit. Falls der Check fehlschlägt, erhältst du einen Fehler zur Compilezeit: <i>static_assert&lt;std::is_integral&lt;T&gt;::value, "T should be an integral type!")</i>.</li><li>Wende typsichere Arithmetik mit den benutzerdefinierten und den neuen Built-in-Literalen (<a title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/benutzerdefinierte-literale" href="https://www.grimm-jaud.de/index.php/blog/tag/benutzerdefinierte-literale" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fbenutzerdefinierte-literale%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fbenutzerdefinierte-literale%22%2C%22text%22%3A%22benutzerdefinierte%20Literale%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D">benutzerdefinierte Literale</a>) an: <i>auto distancePerWeek=</i>&nbsp; (<i>5 * 120_km + 2 * 1500m - 5 * 400m)&nbsp; /&nbsp; 5;</i>.</li><li> <a class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/override-und-final" href="https://www.grimm-jaud.de/index.php/blog/override-und-final" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Foverride-und-final%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Foverride-und-final%22%2C%22text%22%3A%22override%20und%20final%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">override und final</a> bieten Garantien zu virtuellen Methoden. Der Compiler prüft mit <i>override</i>, ob diese Methode tatsächlich eine Methode überschreibt. Der Compiler garantiert darüber hinaus, dass eine als <i>final</i> deklarierte Methode nicht überschrieben werden kann. <br></li><li> <a alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdie-null-zeiger-konstante-nullptr%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdie-null-zeiger-konstante-nullptr%22%2C%22text%22%3A%22Die%20Null-Zeiger-Konstante%20nullptr%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.grimm-jaud.de/index.php/blog/die-null-zeiger-konstante-nullptr" title="Link auf https://www.grimm-jaud.de/index.php/blog/die-null-zeiger-konstante-nullptr" class="">Die Null-Zeiger-Konstante nullptr</a> räumt in C++11 mit der Mehrdeutigkeit der Zahl 0 und dem Makro NULL auf. <br></li></ul></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Meine Reise durch die Regeln zur Performanz in den C++ Core Guidelines ist noch nicht abgeschlossen. Im nächsten Artikel werde ich mich insbesondere damit beschäftigen, wie sich Berechnung von der Laufzeit auf die Compilezeit vorziehen lassen. </div>
