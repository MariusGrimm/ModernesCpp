<div class="text">Dieser und die nächsten Artikel beschäftigen sich mit dem wohl wichtigsten Aspekt im Programmieren: Ressourcenverwaltung. Die C++ Core Guidelines bieten Regeln für Ressourcenverwaltung in Allgemeinen, aber auch Regeln für das Anfordern und Freigeben von Speicher und Smart Pointern im Besonderen an. Los geht es in diesem Artikel mit den allgemeinen Regeln für die Ressourcenverwaltung.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_145388684_4dafe1b045.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Am Anfangs steht die Frage. Was ist eine Ressource? Eine Ressource ist etwas, das es zu verwalten gilt. Das bedeutet, dass du eine Ressource anfordern und auch wieder freigeben musst, den Ressourcen sind knappe Güter oder müssen geschützt werden. Es lässt sich&nbsp; nur eine begrenzte Menge an Speicher, Sockets, Prozessen oder auch Threads anfordern; nur ein Prozess kann seine Ressource Datei oder ein Thread kann seine geteilte Ressource zu einem Zeitpunkt verändern. Falls du diesem Protokoll nicht folgst, sind viele Probleme möglich. </div>
<div class="text">Das Programm kann</div>
<div class="text"><ul><li> der Speicher ausgehen, da du den Speicher nicht freigegeben hast.</li><li>ein Data Race besitzen, da du vergessen hast, eine geteilte Variable vor deren Nutzung zu schützen.</li><li>ein Deadlock besitzen, da du deine geteilten Variablen in verschiedener Ordnung angefordert und freigegeben hast. <br></li></ul></div>
<div class="text">Data Races und Deadlock sind aber keine Domäne von geteilten Variablen. Zum Beispiel lassen sie sich auch mit Datein erzeugen.</div>
<div class="text">Wenn du genauer über Ressourcenverwaltung nachdenkst, dann reduziert sich dieses auf einen Punkt: Wer ist der Besitzer? Daher will ich gerne erst das große Bild bieten, bevor ich tiefer in die Regeln eintauche. </div>
<div class="text">Was ich besonders an modernem C++ schätze, ist, dass sich die verschiedenen Besitzverhältnisse direkt im Sourcecode ausdrücken lassen.</div>
<div class="text"><ul><li> <b>Lokale Objekte</b>: Die C++-Laufzeit als Besitzer verwaltet automatisch den Lebenszyklus seiner Ressourcen. Das gleich gilt für globale Objekte oder Mitglieder einer Klasse. Die Guidelines nennen diese lokalen Objekte <i>scoped objects</i>.</li><li><b>Referenzen</b>: Ich bin nicht der Besitzer. Ich habe mir die Ressource, die nicht null sein kann, nur ausgeliehen.</li><li><b>Nackte Zeiger</b>: Ich bin nicht der Besitzer. Ich habe mir die Ressource nur ausgeliehen. Ich darf die Ressource nicht freigeben.</li><li><b><i>std::unique_ptr</i></b>: Ich bin der exclusive Besitzer der Ressource. Ich darf die Ressource freigeben.</li><li><b><i>std::shared_ptr</i></b>: Ich teile mir die Ressoure mit anderen Besitzern. Ich darf meine Besitzverhältnisse explizt freigeben.</li><li><i><b>std::weak_ptr</b>:</i> Ich bin nicht der Besitzer der Ressource, aber ich kann zeitweise zum geteilten Besitzer werden, indem ich die Methode <i>std::weak_ptr::lock</i> verwende.</li></ul></div>
<div class="text">Vergleich doch diese fein-justierbare Besitzverhältnisse mit einem nackten Zeiger. Genau das ist der Punkt, den ich an modernem C++ sehr schätze.</div>
<div class="text">Hier sind die sechs Regeln zu Ressourcenverwaltung im Überblick.<br></div>
<div class="text"><ul><li><a class="" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-raii%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-raii%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22R.1%3A%20Manage%20resources%20automatically%20using%20resource%20handles%20and%20RAII%20%28Resource%20Acquisition%20Is%20Initialization%29%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii">R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-use-ptr" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-use-ptr" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-use-ptr%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22R.2%3A%20In%20interfaces%2C%20use%20raw%20pointers%20to%20denote%20individual%20objects%20%28only%29%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-use-ptr%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D">R.2: In interfaces, use raw pointers to denote individual objects (only)</a> </li><li> <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ptr%22%2C%22text%22%3A%22R.3%3A%20A%20raw%20pointer%20%28a%20T%2A%29%20is%20non-owning%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ptr%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ptr" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ptr" class="">R.3: A raw pointer (a T*) is non-owning</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ref" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ref" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ref%22%2C%22text%22%3A%22R.4%3A%20A%20raw%20reference%20%28a%20T%26amp%3B%29%20is%20non-owning%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ref%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" class="">R.4: A raw reference (a T&amp;) is non-owning</a> </li><li> <a class="" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-scoped%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.5%3A%20Prefer%20scoped%20objects%2C%20don%C2%92t%20heap-allocate%20unnecessarily%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-scoped%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-scoped" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-scoped">R.5: Prefer scoped objects, don’t heap-allocate unnecessarily</a> </li><li> <a alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22R.6%3A%20Avoid%20non-const%20global%20variables%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-global%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-global%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-global" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-global" class="">R.6: Avoid non-const global variables</a></li></ul></div>
<div class="text">Jetzt geht es in die Tiefe.</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-raii%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-raii%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22R.1%3A%20Manage%20resources%20automatically%20using%20resource%20handles%20and%20RAII%20%28Resource%20Acquisition%20Is%20Initialization%29%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii" class="">R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</a></div>
<div class="text"><br></div>
<div class="text">Die Idee ist verblüffend einfach. Du erzeugt eine Art Stellvertreterobjekt für deine Ressource. Der Konstruktor deines Stellvertreters fordert die Ressource an und der Destruktor gibt sie wieder frei. Die zentrale Idee des RAII-Idiom ist es, dass die C++-Laufzeit der Besitzer der <b>lokalen Objekte</b> und damit der Ressource ist. </div>
<div class="text">Zwei typische Beispiel des RAII-Idiom in modernem C++ sind Smart Pointer und Locks. Smart Pointer verwalten ihren Speicher und Locks ihre Mutexe.</div>
<div class="text">Die folgende Klasse ResourceGuard setzt das RAII-Idiom um.<br></div>
<div class="pre">// raii.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;new&gt;<br>#include &lt;string&gt;<br><br>class ResourceGuard{<br>&nbsp; private:<br>&nbsp;&nbsp;&nbsp; const std::string resource;<br>&nbsp; public:<br>&nbsp;&nbsp;&nbsp; ResourceGuard(const std::string&amp; res):resource(res){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Acquire the " &lt;&lt; resource &lt;&lt; "." &lt;&lt;&nbsp; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ~ResourceGuard(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Release the "&lt;&lt; resource &lt;&lt; "." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; ResourceGuard resGuard1{"memoryBlock1"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp; std::cout &lt;&lt; "\nBefore local scope" &lt;&lt; std::endl;<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; ResourceGuard resGuard2{"memoryBlock2"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; "After local scope" &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "\nBefore try-catch block" &lt;&lt; std::endl;<br>&nbsp; try{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResourceGuard resGuard3{"memoryBlock3"};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::bad_alloc();<br>&nbsp; }&nbsp;&nbsp; <br>&nbsp; catch (std::bad_alloc&amp; e){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; e.what();<br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; "\nAfter try-catch block" &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Unabhängig davon, ob der Lebenszyklus der Instanzen von ResoureGuard reguläre (1) und (2) oder irregulär (3) endet, wird der Destruktor der Klasse immer ausgerufen. Das bedeutet natürlich, dass die Ressource freigegeben wird. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_145388671_84b3f0aaf6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=1>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Weitere Details zu dem Beispiel und RAII stehen in meinem Artikel <a alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Garbage%20Collection%20-%20No%20Thanks%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fgarbage-collection-nein-danke%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" href="http://www.grimm-jaud.de/index.php/blog/garbage-collection-nein-danke" class="">Garbage Collection - No Thanks</a>. Selbst Bjarne Stroustrup kommentierte diesen. <br></div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-use-ptr" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-use-ptr%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.2%3A%20In%20interfaces%2C%20use%20raw%20pointers%20to%20denote%20individual%20objects%20%28only%29%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-use-ptr%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-use-ptr">R.2: In interfaces, use raw pointers to denote individual objects (only)</a></div>
<div class="text">Nackte Zeiger sollten nicht für Arrays verwendet werden, denn dies ist sehr fehleranfällig. Das gilt insbesondere, falls deine Funktion einen Zeiger als Argument annimmt.</div>
<div class="pre">void f(int* p, int n)&nbsp;&nbsp; // n is the number of elements in p[]<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; p[2] = 7;&nbsp;&nbsp; // bad: subscript raw pointer<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="text">Es ist viel zu einfach, die falsche Länge des Arrays als Funktionsparameter zu verwenden.</div>
<div class="text">Für Arrays besitzen wir in C++ <i>std::vector</i>. Ein Container der Standard Template Library ist ein exklusiver Besitzer. Es fordert automatisch seinen Speicher an und gibt diesen wieder frei. </div>
<div class="ztitel_kleiner"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ptr%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22R.3%3A%20A%20raw%20pointer%20%28a%20T%2A%29%20is%20non-owning%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ptr%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ptr" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ptr" class="">R.3: A raw pointer (a T*) is non-owning</a></div>
<div class="text">Die Frage der Besitzverhältnisse ist sehr interessant, falls du eine Fabrikfunktion verwendest. Eine Fabrikfunktion ist eine spezielle Funktion, die ein neues Objekt zurückgibt. Die Frage ist nun. Solltest du einen nackten Zeiger, ein Objekt, ein <i>std::unique_ptr</i> oder ein <i>std::shared_ptr</i> verwenden?</div>
<div class="text">Hier sind die vier Variationen. <br></div>
<div class="pre">Widget* makeWidget(int n){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto p = new Widget{n};<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return p;<br>}<br><br>Widget makeWidget(int n){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; Widget g{n};<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return g;<br>}<br><br>std::unique_ptr&lt;Widget&gt; makeWidget(int n){&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto u = std::make_unique&lt;Widget)(n);<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp; return u;<br>}<br><br>std::shared_ptr&lt;Widget&gt; makeWidget(int n){&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; auto s = std::make_shared&lt;Widget)(n);<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp; return s;<br>}<br><br>...<br><br>auto widget = makeWidget(10);<br></div>
<div class="text">Wer soll der Besitzer der Widgets sein? Der Aufrufer oder der Aufgerufene? Ich nehme an, du kannst die Frage für den nackten Zeiger nicht beantworten. Mir geht es auch so. Das bedeutet, wir wissen nicht, wer das Widget letztendlich löschen soll. Im Gegensatz sind die Fälle (2) bis (4) ziemlich offensichtlich. Im Falle des Objekts oder des <i>std::unique_ptr</i> ist der Aufrufer der Besitzer. Im Falle des <i>std::shared_ptr</i> teilen sich der Aufrufer und der Aufgerufene die Besitzverhältnisse. </div>
<div class="text">Eine Frage bleibt aber bestehen. Sollten wir ein Objekt oder Smart Pointer einsetzen. Hier sind meine Gedanken. <br></div>
<div class="text"><ul><li>Falls deine Fabrikfunktion einen virtuellen Konstruktor abbilden soll, musst du Smart Pointer einsetzen. Ich habe bereits über diesen speziellen Anwendungsfall von Fabrikfunktionen geschrieben. Die Details sind in dem Artikel: <a class="" title="Link auf https://www.heise.de/-3825944" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Konstruktoren%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3825944%22%2C%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3825944%22%2C%22version%22%3A1%7D" href="https://www.heise.de/-3825944">C++ Core Guidelines: Konstruktoren</a> (C.50).</li><li>Falls die Objekte billigen zu kopieren sind und der Besitzer der Widgets der Aufrufer sein soll, verwende ein Objekt. Falls sie nicht billig zu kopieren sind, setze einen <i>std::unique_ptr</i> ein.</li><li>Falls der Aufgerufene (die Fabrikfunktion) den Lebenszyklus seiner Widgets verwalten will, verwende einen <i>std::shared_ptr</i>. <br></li></ul> </div>
<div class="ztitel_kleiner"><a class="" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ref%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22R.4%3A%20A%20raw%20reference%20%28a%20T%26amp%3B%29%20is%20non-owning%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-ref%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ref" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-ref">R.4: A raw reference (a T&amp;) is non-owning</a></div>
<div class="text">Zu dieser Regel habe ich nichts hinzuzufügen. Eine nackte Referenz ist kein Besitzer und kann nicht leer sein. <br> </div>
<div class="ztitel_kleiner"><a alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-scoped%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-scoped%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22R.5%3A%20Prefer%20scoped%20objects%2C%20don%C2%92t%20heap-allocate%20unnecessarily%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-scoped" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-scoped" class="">R.5: Prefer scoped objects, don’t heap-allocate unnecessarily</a></div>
<div class="text">Ein <i>scoped object</i> ist ein Objekt mit einem eigenen Bereich. Das kann ein lokaler oder globaler Bereich sein oder auch der Bereich einer Klasse. Entscheidend ist, dass die C++-Laufzeit diese Objekte automatisch verwaltet. Daher ist weder eine Speicheranforderung oder -freigabe notwendig noch ist eine <i>std::bad_alloc</i> Ausnahme möglich. Um es einfach zu machen. Falls möglich, verwende Objekte mit eigenem Bereich. <br> </div>
<div class="ztitel_kleiner"><a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-global" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-global%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-global%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22R.6%3A%20Avoid%20non-const%20global%20variables%22%2C%22type%22%3A%22E%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-global">R.6: Avoid non-const global variables</a></div>
<div class="text">Ich höre immer und immer wieder: Globale Objekte sind bösartig. Das stimmt nicht ganz. Nicht-konstante (veränderliche) globale Objekte sind bösartig. Es gibt so viele Gründe, keine veränderlichen globalen Objekte einzusetzen. Hier sind einige die Gründe. Der Einfachheit nehme ich in den folgenden Punkten an, dass die Funktionen oder Objekte veränderliche Daten besitzen.<br></div>
<div class="text"><ul><li> Kapselung: Funktion oder Objekte lassen sich außerhalb ihres Bereiches verändern. Damit ist es fast unmöglich, Funktionen und Objekte zu analysieren, die veränderliche globale Variablen verwenden.</li><li>Testbarkeit: Du kannst deine Funktion nicht mehr in Isolation testen. Die Auswirkung eines Funktionsaufrufes hängt nur vom Zustand des Programms ab.</li><li>Refaktorierung: Es ist sehr schwierg deine Funktionen zu refaktorieren, falls du dir deine Funktion nicht in Isolation analysieren kannst.</li><li>Optimierung: Der Aufruf der Funktion lässt sich nicht einfach umstellen oder auf anderen Thread ausführen, da die Funktion heimlich Abhängigkeiten besitzt.</li><li>Gleichzeitigkeit: Die notwendige Bedingung für ein Data Race ist nicht-konstanter geteilter Zustand. Genau dies sind veränderlich, geteilte Variablen.<br></li></ul></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel werde ich über eine sehr wichtige Ressource schreiben: Speicher.</div>
<div class="ztitel">Weitere Informationen?</div>
<div class="text"><ul><li> <b>Neue pdf-Päckchen</b>: Die Gewinner der nächsten pdf Päckchen stehen fest. Im Laufe der Woche werde ich die Päckchen veröffentlichen.<br></li><ul><li>Deutsch: <a alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-2%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Multithreading%3A%20The%20High-Level%20Schnittstelle%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-2%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-2" href="http://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-2" class="">Multithreading: The High-Level Schnittstelle</a> <br></li><li>Englisch: <a href="http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice2" title="Link auf http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice2" alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice2%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Embedded%3A%20Performance%20Matters%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice2%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" class="">Embedded: Performance Matters</a></li></ul><li> Source Code: Den Source Code zu den ausführbaren Dateien gibt es auf meinem GitHub-Account: <a title="Link auf https://github.com/RainerGrimm/ModernesCppSource" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FRainerGrimm%2FModernesCppSource%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22ModernesCppSource%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FRainerGrimm%2FModernesCppSource%22%7D" href="https://github.com/RainerGrimm/ModernesCppSource" class="">ModernesCppSource</a>.</li></ul></div>
