<div class="vorspann">Ich denke, dir ist das zusätzliche Schlüsselwort <i>typename</i> oder <i>template</i> bereits vor einem Namen in einem Template aufgefallen. Mir auch. Ehrlich gesagt war ich überrascht. Heute geht es um abhängige Namen und verschiedene Template-Parameter.</div><div class="text">Um abhängige Namen in Template zu verstehen, beginnt dieser Artikel mit Template-Parametern. Sie können Typen, Nichttypen oder Templates sein.<br></div><div class="ztitel_kleiner">Typen</div><div class="text">Typen sind die am häufigsten verwendeten Template-Parameter. Hier sind ein paar Beispiele:</div><div class="pre">std::vector&lt;int&gt; myVec;<br>std::map&lt;std::string, int&gt; myMap;<br>std::lock_guard&lt;std::mutex&gt; myLockGuard;</div><div class="ztitel_kleiner">Nichttypen</div><div class="text">Nichttypen können sein:</div><div class="text"><ul><li> Lvalue-Referenzen</li><li>nullptr</li><li>Zeiger</li><li>Aufzähler</li><li>Integrale</li></ul></div><div class="text">Integrale sind sicher die bekanntesten Nichttypen.<i> std::array </i>ist ein typisches Beispiel, denn sein Datentyp und seine Größe müssen zur Compilezeit angegeben werden:</div><div class="pre">std::array&lt;int, 3&gt; myArray{1, 2, 3};</div><div class="ztitel_kleiner">Templates</div><div class="text">Templates können selbst Template-Parameter sein. In diesem Fall werden sie Template-Templates-Parameter genannt. Die Adaptoren für Container <i>std::stack, std::deque</i> und s<i>td::priority_queue</i> verwenden per Default <i>std::deque</i>, um ihre Argumente zu speichern. Es lässt sich aber auch ein anderer Container einsetzen. Ihr Einsatz sollte kein Überraschungspotenzial bergen:</div><div class="pre">std::stack&lt;int&gt; stack1;<br>stack1.push(5);<br>&nbsp;&nbsp;&nbsp; <br>std::stack&lt;double, std::vector&lt;double&gt;&gt; stack2;<br>stack2.push(10.5);<br></div><div class="text">Ihre Definition hingegen schon:<br></div><div class="pre">// templateTemplateParameters.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br><br>template &lt;typename T, template &lt;typename, typename&gt; class Cont &gt;&nbsp;&nbsp; // (1)<br>class Matrix{<br>public:<br>&nbsp; explicit Matrix(std::initializer_list&lt;T&gt; inList): data(inList){&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; for (auto d: data) std::cout &lt;&lt; d &lt;&lt; " ";<br>&nbsp; }<br>&nbsp; int getSize() const{<br>&nbsp;&nbsp;&nbsp; return data.size();<br>&nbsp; }<br><br>private:<br>&nbsp; Cont&lt;T, std::allocator&lt;T&gt;&gt; data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>};<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; Matrix&lt;int, std::vector&gt; myIntVec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "myIntVec.getSize(): " &lt;&lt; myIntVec.getSize() &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; Matrix&lt;double, std::vector&gt; myDoubleVec{1.1, 2.2, 3.3, 4.4, 5.5}; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "myDoubleVec.getSize(): "&nbsp; &lt;&lt; myDoubleVec.getSize() &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; Matrix&lt;std::string, std::list&gt; myStringList{"one", "two", "three", "four"};&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "myStringList.getSize(): " &lt;&lt; myStringList.getSize() &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text"><i>Matrix</i> ist ein einfaches Klassen-Template, dass sich über eine <i>std::initializer_list</i> (Zeile 2) initialisieren lässt. Eine <i>Matrix</i> kann einen <i>std::vector </i>(Zeile 4 und 5) oder eine <i>std::list</i> (Zeile 6) verwenden, um ihre Werte zu speichern. Soweit, nichts besonderes.<br></div><div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_168377967_f55c393cd3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Stopp, ich habe die Zeilen 1 und 3 ignoriert. Zeile 1 deklariert ein Klasse-Templates, das zwei Template-Parameter benötigt. Der erste Parameter steht für den Datentyp der Elemente und der zweite Parameter für den Container, der die Datenelemente speichert. Insbesondere der zweite Parameter verdient eine genauere Betrachtung: <i>template &lt;typename, typename&gt; class Cont &gt;</i>. Das heißt, das zweite Template-Argument sollte ein Template sein, dass selbst zwei Template-Parameter benötigt. Der erste Template-Parameter steht in diesem Fall für den Datentyp der Elemente, die der Container speichert und der zweite ist der Allokator, den ein Container der Standard Template Library besitzt. Der Allokator besitzt einen Default wie im Fall von <a href="https://en.cppreference.com/w/cpp/container/vector" alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fvector%22%2C%22text%22%3A%22std%3A%3Avector%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fcontainer%2Fvector%22%2C%22version%22%3A1%7D" title="Link auf https://en.cppreference.com/w/cpp/container/vector">std::vector</a>. Der Allokator ist vom Elemente abhängig: <br></div><div class="pre">template&lt;<br>&nbsp;&nbsp;&nbsp; class T,<br>&nbsp;&nbsp;&nbsp; class Allocator = std::allocator&lt;T&gt;<br>&gt; class vector;<br></div><div class="text">Zeile 3 zeigt die Anwendung des Allokators in der Matrix. Matrix kann alle Container verwenden, die nach dem Muster <i>Container&lt; Datentyp der Elemente, Allokator für die Elemente&gt;</i> gestrickt sind. Dies trifft auf die sequenziellen Container wie <i>std::vector, std::deque</i> oder <i>std::list zu. std::array </i>und <i>std::forward_list</i> können nicht verwendet werden, da <i>std::array </i>einen zusätzlichen Parameter besitzt, um seine Größe zur Compilezeit anzugeben und s<i>td::forward_list</i> die <i>size</i>-Methode nicht unterstützt.</div><div class="text">Nun habe ich die Grundlagen gelegt und komme zum zentralen Punkt dieses Artikels.</div><div class="ztitel">Abhängige Namen<br></div><div class="text">Zuerst einmal: Was ist ein abhängiger Name? Er ist im Wesentlichen ein Name, der von einem Template-Parameter abhängt. Hier sind sein paar Beispiel, basierend auf <a alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22cppreference.com%22%2C%22href%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdependent_name%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdependent_name%22%2C%22anchor%22%3A%22%22%7D" title="Link auf https://en.cppreference.com/w/cpp/language/dependent_name" href="https://en.cppreference.com/w/cpp/language/dependent_name">cppreference.com</a>: <br></div><div class="pre">template&lt;typename T&gt;<br>struct X : B&lt;T&gt; // "B&lt;T&gt;" is dependent on T<br>{<br>&nbsp;&nbsp;&nbsp; typename T::A* pa; // "T::A" is dependent on T<br>&nbsp;&nbsp;&nbsp; void f(B&lt;T&gt;* pb) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int i = B&lt;T&gt;::i; // "B&lt;T&gt;::i" is dependent on T<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb-&gt;j++; // "pb-&gt;j" is dependent on T<br>&nbsp;&nbsp;&nbsp; }<br>};</div><div class="text">Jetzt geht es los mit dem Spaß. Ein abhängiger Name kann ein Typ, ein Nichttyp oder ein Template selbst sein. Die Namensauflösung ist der erste große Unterschied zwischen einem nichtabhängigen und einem abhängigen Namen.</div><div class="text"><ul><li> <b>Nichtabhängige</b> Name werden bei der Template-Definition aufgelöst.</li><li><b>Abhängige Namen</b> werden dann aufgelöst, wenn die Template-Argumente bekannt sind. Dies bedeutet leider Template-Instanziierung.</li></ul></div><div class="text">Falls du nun einen abhängigen Namen in einer Template-Deklaration oder einer Template-Defintion verwendest, weiß der Compiler nicht, ob sich der Name auf einen Typen, einen Nichttypen oder ein Template bezieht. In diesem Fall nimmt der Compiler an, dass der abhängig Namen für einen Nichttyp steht. Dies kann natürlich falsch sein. Hier musst du dem Compiler unter die Schulter greifen.</div><div class="text">Bevor ich dir zwei Beispiele zeige, muss ich der Vollständigkeit halber noch auf eine Ausnahme der Regel hinweisen. Du kannst diese Zeile aber gerne ignorieren und zum nächsten Abschnitt springen, wenn du an der zentralen Idee interessiert bist. Hier ist die Ausnahme der Regel: Wenn der Name sich auf die aktuelle Instanziierung bezieht, kann der Compiler den Name bereits zum Zeitpunkt der Template-Definition bestimmen. Hier sind ein paar Beispiele:</div><div class="pre">template &lt;class T&gt; class A {<br>&nbsp;&nbsp;&nbsp; A* p1;&nbsp;&nbsp;&nbsp; // A is the current instantiation<br>&nbsp;&nbsp;&nbsp; A&lt;T&gt;* p2; // A&lt;T&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; ::A&lt;T&gt;* p4; // ::A&lt;T&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; A&lt;T*&gt; p3; // A&lt;T*&gt; is not the current instantiation<br>};<br>template &lt;class T&gt; class A&lt;T*&gt; {<br>&nbsp;&nbsp;&nbsp; A&lt;T*&gt;* p1;&nbsp; // A&lt;T*&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; A&lt;T&gt;* p2;&nbsp;&nbsp; // A&lt;T&gt; is not the current instantiation<br>};<br>template &lt;int I&gt; struct B {<br>&nbsp;&nbsp;&nbsp; static const int my_I = I;<br>&nbsp;&nbsp;&nbsp; static const int my_I2 = I+0;<br>&nbsp;&nbsp;&nbsp; static const int my_I3 = my_I;<br>&nbsp;&nbsp;&nbsp; B&lt;my_I&gt;* b3;&nbsp; // B&lt;my_I&gt; is the current instantiation<br>&nbsp;&nbsp;&nbsp; B&lt;my_I2&gt;* b4; // B&lt;my_I2&gt; is not the current instantiation<br>&nbsp;&nbsp;&nbsp; B&lt;my_I3&gt;* b5; // B&lt;my_I3&gt; is the current instantiation<br>};<br></div><div class="text">Hier ist nochmals der zentrale Punkt meines Artikels. Falls ein abhängiger Name ein Typ, ein Nichttyp oder ein Template sein kann, musst du dem Compiler unter die Schulter greifen. </div><div class="ztitel_kleiner">Verwende <i>typename,</i> falls der abhängige Name ein Typ ist</div><div class="text">Nach solch einer langen Einleitung sollte das nächste Programmbeispiel die Mehrdeutigkeit auf den Punkt bringen:</div><div class="pre">template &lt;typename T&gt;<br>void test(){<br>&nbsp;&nbsp;&nbsp; std::vector&lt;T&gt;::const_iterator* p1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; typename std::vector&lt;T&gt;::const_iterator* p2; // (2)<br>}</div><div class="text">Ohne das Schlüsselwort <i>typename</i> in Zeile 2 würde der Name <i>std::vector&lt;T&gt;::const_iterator </i>in Zeile 2 als Nichttyp interpretiert werden und damit wäre konsequenterweise das * Symbol eine Multiplikation und keine Zeigerdeklaration. Genau das passiert in Zeile 1.&nbsp;</div><div class="text">Entsprechend gilt, falls der abhängige Name ein Template sein soll, dass du dem Compiler einen Hinweis geben musst.<br></div><div class="ztitel_kleiner">Verwende <i>.template,</i> falls der abhängige Name ein Template ist</div><div class="text">Ehrlich gesagt, schaut die Syntax sehr gewöhnungsbedürftig aus:<br></div><div class="pre">template&lt;typename T&gt;<br>struct S{<br>&nbsp;&nbsp;&nbsp; template &lt;typename U&gt; void func(){}<br>}<br>template&lt;typename T&gt;<br>void func2(){<br>&nbsp;&nbsp;&nbsp; S&lt;T&gt; s;<br>&nbsp;&nbsp;&nbsp; s.func&lt;T&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; s.template func&lt;T&gt;();&nbsp;&nbsp;&nbsp; // (2)<br>}<br></div><div class="text">Dieselbe Geschichte wie gerade eben. Vergleiche die Zeilen 1 und 2. Wenn der Compiler den Name <i>s.func</i> liest (Zeile 1), entscheidet er, diesen als Nichttyp zu lesen. Dies bedeutet, dass das &lt;-Zeichen für einen Vergleichsoperator steht, aber nicht für die öffnende Klammer des Template-Arguments der generischen Methode <i>func. </i>In diesem Fall musst du angeben, dass <i>s.func</i> für ein Template steht (Zeile 2):&nbsp;<i> s.template func. </i></div><div class="text">Hier ist die Zentralaussage dieses Artikels in einem Satz:<b> Wenn du einen abhängigen Namen hast, verwende <i>typename</i>, um auszudrücken, dass es sich um einen Typ handelt oder <i>.template, </i>um auszudrücken, dass es sich um ein Template handelt. </b></div><div class="ztitel">Wie geht es weiter?</div><div class="text">Die nächsten Regeln in den C++ Core Guidelines sind über C-Style-Programmierung und Sourcecode-Dateien. Genau davon handelt mein nächster Artikel.<br></div>
