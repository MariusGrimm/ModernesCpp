<div class="vorspann">Wenn ein neuer Thread erzeugt wird, muss die Frage beantwortet werden: Wartet der Erzeuger, bis sein Kind fertig ist, oder trennt er sich von seinem Kind? Wenn sich das Kind von seinem Erzeuger trennt und Variablen verwendet, die an die Lebenszeit seines Erzeugers gebunden sind, gilt es, die nächste dränge Frage zu klären: Sind die Variablen für die Lebenszeit des Kindes gültig?</div>
<div class="text">Falls du dich nicht sorgfältig um die Lebenszeit und die Variablen deines Kinder-Threads kümmerst, besitzt dein Programm sehr schnell undefiniertes Verhalten.</div>
<div class="text">Hier sind die Regeln für den heutigen Artikel, die sich genau mit der Lebenszeitproblematik des Kinder-Threads und seinen Variablen beschäftigen: </div>
<div class="text"><ul><li> <a alt="%7B%22text%22%3A%22CP.23%3A%20Think%20of%20a%20joining%20thread%20as%20a%20scoped%20container%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-join%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-join%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-join" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-join" class="">CP.23: Think of a joining thread as a scoped container</a> </li><li> <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detach%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22CP.24%3A%20Think%20of%20a%20thread%20as%20a%20global%20container%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detach%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detach" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detach">CP.24: Think of a thread as a global container</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-joining_thread" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-joining_thread" class="" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22CP.25%3A%20Prefer%20gsl%3A%3Ajoining_thread%20over%20std%3A%3Athread%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-joining_thread%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-joining_thread%22%2C%22version%22%3A1%7D">CP.25: Prefer gsl::joining_thread over std::thread</a> </li><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detached_thread" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detached_thread" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.26%3A%20Don%C2%92t%20detach%28%29%20a%20thread%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detached_thread%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detached_thread%22%2C%22ir_link%22%3A1%7D">CP.26: Don’t detach() a thread</a></li></ul></div>
<div class="text">Die Regeln für den heutigen Artikel hängen stark voneinander ab. </div>
<div class="text">Die Regel CP.23 und CP.24 zu einem scoped und globalen Container muten recht seltsam an. Sie helfen aber sehr, den Unterschied eines Kinder-Threads auf den Punkt zu bringen, auf den entweder der Erzeuger-Thread wartet (<i>join</i>) oder von dem sich dieser trennt (<i>detach</i>).</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-join" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-join" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-join%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-join%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22CP.23%3A%20Think%20of%20a%20joining%20thread%20as%20a%20scoped%20container%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D">CP.23: Think of a joining thread as a scoped container</a> and<a alt="%7B%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detach%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22%20CP.24%3A%20Think%20of%20a%20thread%20as%20a%20global%20container%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detach%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detach" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detach"> CP.24: Think of a thread as a global container</a></div>
<div class="text">Hier ist eine leichte Variation eines Codebeispiels aus den C++ Core Guidelines:</div>
<div class="pre">void f(int* p)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; *p = 99;<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br><br>int glob = 33;<br><br>void some_fct(int* p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>{<br>&nbsp;&nbsp;&nbsp; int x = 77;<br>&nbsp;&nbsp;&nbsp; std::thread t0(f, &amp;x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; std::thread t1(f, p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; std::thread t2(f, &amp;glob);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; auto q = make_unique&lt;int&gt;(99);<br>&nbsp;&nbsp;&nbsp; std::thread t3(f, q.get());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; t0.join();<br>&nbsp;&nbsp;&nbsp; t1.join();<br>&nbsp;&nbsp;&nbsp; t2.join();<br>&nbsp;&nbsp;&nbsp; t3.join();<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br><br>void some_fct2(int* p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>{<br>&nbsp;&nbsp;&nbsp; int x = 77;<br>&nbsp;&nbsp;&nbsp; std::thread t0(f, &amp;x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad<br>&nbsp;&nbsp;&nbsp; std::thread t1(f, p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad<br>&nbsp;&nbsp;&nbsp; std::thread t2(f, &amp;glob);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br>&nbsp;&nbsp;&nbsp; auto q = make_unique&lt;int&gt;(99);<br>&nbsp;&nbsp;&nbsp; std::thread t3(f, q.get());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; t0.detach();<br>&nbsp;&nbsp;&nbsp; t1.detach();<br>&nbsp;&nbsp;&nbsp; t2.detach();<br>&nbsp;&nbsp;&nbsp; t3.detach();<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Der einzige Unterschied zwischen der Funktion <i>some_fct</i> (1) und <i>some_fct</i>2(2) ist, dass die erste Variante <i>join</i>, dass die zweite Variante <i>detach</i> auf ihren Kinder-Threads aufruft.</div>
<div class="text">Zuerst einmal gilt: Du musst <i>join</i> oder <i>detach</i> auf einem Kinder-Thread aufrufen. Falls du dies nicht tust, erhältst du eine <i>std::terminate-</i>Ausnahme im Destruktor des Kinder-Threads. Darauf komme ich noch in der Regel CP.25 zurück.</div>
<div class="text">Nun aber zu dem Unterschied, <i>join</i> oder <i>detach</i> auf einem Thread aufzurufen.</div>
<div class="text"><ul><li> <i>join</i> auf einem Thread auszurufen, bedeutet entsprechend den Guidelines, dass der Kinder-Thread ein scoped Container ist. Oder anders ausgedrückt: Der Container besitzt einen eigenen Gültigkeitsbereich. Was soll das heißen? Der Grund für die Begrifflichkeit ist, dass der <i>thr.join()</i>-Aufruf auf einem thread <i>thr</i> ein Synchronisationspunkt ist. <i>thr.join()</i> sichert zu, dass der Erzeuger des Kinder-Threads wartet, bis sein Kind mit seiner Arbeit fertig ist. Oder anders herum betrachtet. Der Kinder-Thread kann alle Daten seines Erzeugers des Bereichs (scope) verwenden, in der das Kind erzeugt wurde. Entsprechend sind alle Aufrufe der Threads wohl definiert.</li><li>Im Gegensatz dazu gilt dies nicht, falls auf dem Kinder-Thread <i>detach</i> aufgerufen wurde. <i>detach</i> bedeutet, dass der Erzeuger seinen Verweis auf sein Kind verliert und das Kind länger leben kann als der Erzeuger. Aufgrund dieser Eigenschaft können die Kinder-Threads nur Variablen verwenden, die globale Gültigkeit besitzen. Damit ist der Thread eine Art globaler Container. Verwendet ein Kinder-Thread Variablen aus dem aufrufenden Bereich, stellt dies undefiniertes Verhalten dar.<br></li></ul></div>
<div class="text">Falls dich ein <i>detached</i> Thread immer noch durcheinander bringt, möchte ich eine kleine Analogie anbieten. Wenn du eine Datei anlegst und den Verweis auf diese verlierst, existiert die Datei trotzdem noch. Das Gleiche gilt für einen Thread, auf dem du<i> detach</i> aufgerufen hast. Falls du <i>detach</i> auf einem Thread aufrufst, wird der "thread of execution" weiter ausgeführt, obwohl du den Verweis auf diesen Thread verloren hast. Du ahnst es vermutlich: <i>t0</i> ist lediglich der Verweis auf den "thread of execution", der mit dem Aufruf <i>std::thread t0(f, &amp;x) </i>gestartet wurde. </div>
<div class="text">Wie ich bereits schrieb: Du musst auf einem Kinder-Thread<i> join</i> oder <i>detach</i> aufrufen.<br></div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-joining_thread" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-joining_thread" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-joining_thread%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-joining_thread%22%2C%22text%22%3A%22CP.25%3A%20Prefer%20gsl%3A%3Ajoining_thread%20over%20std%3A%3Athread%22%2C%22user_params%22%3A%22%22%7D">CP.25: Prefer gsl::joining_thread over std::thread</a></div>
<div class="text">Im folgenden Programm habe ich vergessen, <i>join</i> auf dem Kinder-Thread aufzurufen: <br></div>
<div class="pre">// threadWithoutJoin.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>int main(){<br><br>&nbsp; std::thread t([]{std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;});<br><br>}</div>
<div class="text">Die Ausführung des Programms endet sehr abrupt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_153117795_cfb86cbb37.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Und hier kommt die Erklärung: Die Lebenszeit des erzeugten Threads endet mit seiner aufrufbaren Einheit. Diese Einheit ist alles, was sich wie eine Funktion anfühlt. Das kann eine Funktion, ein Funktionsobjekt oder eine Lambda-Funktion wie in diesem Fall sein. Der Erzeuger besitzt zwei Möglichkeiten. Er wartet entweder, bis sein Kind fertig ist (<i>t.join()</i>) oder er trennt sich von seinem Kind: <i>t.detach()</i>. Ein Thread mit einer aufrufbaren Einheit [--] Threads können ohne aufrufbare Einheit erzeugt werden [--] wird joinable genannt, falls weder ein <i>t.join()</i>- oder <i>t.detach()-</i>Aufruf auf ihm stattgefunden hat. Der Destruktor eines joinable Threads wirft eine <i>std::terminate</i>-Ausnahme, die in einem <i>std::abort</i> endet. Daher beendet sich das Programm so abrupt.&nbsp;</div>
<div class="text">Die Regel besitzt den Titel "Prefer <i>gsl::joining_thread </i>over<i> std::thread</i>", denn der <i>gsl::joining_thread</i> ruft <i>join</i> automatisch am Ende seines Gültigkeitsbereichs auf. Leider konnte ich keine Implementierung von <i>gsl::joining_thread</i> in der <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22text%22%3A%22Guidelines%20Support%20Library%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">Guidelines Support Library</a> finden. Dank des <i>scoped_thread</i> von <a title="Link auf https://www.justsoftwaresolutions.co.uk/blog/" class="" href="https://www.justsoftwaresolutions.co.uk/blog/" alt="%7B%22text%22%3A%22Anthony%20Williams%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.justsoftwaresolutions.co.uk%2Fblog%2F%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.justsoftwaresolutions.co.uk%2Fblog%2F%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D">Anthony Williams</a> ist dies aber keine Einschränkung:</div>
<div class="pre">// scoped_thread.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br>#include &lt;utility&gt;<br><br><br>class scoped_thread{<br>&nbsp; std::thread t;<br>public:<br>&nbsp; explicit scoped_thread(std::thread t_): t(std::move(t_)){<br>&nbsp;&nbsp;&nbsp; if ( !t.joinable()) throw std::logic_error("No thread");<br>&nbsp; }<br>&nbsp; ~scoped_thread(){<br>&nbsp;&nbsp;&nbsp; t.join();<br>&nbsp; }<br>&nbsp; scoped_thread(scoped_thread&amp;)= delete;<br>&nbsp; scoped_thread&amp; operator=(scoped_thread const &amp;)= delete;<br>};<br><br>int main(){<br><br>&nbsp; scoped_thread t(std::thread([]{std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;}));<br><br>}<br></div>
<div class="text">Der <i>scoped_thread</i> prüft in seinem Konstruktor, ob der verwendete Thread noch joinable ist und ruft in seinem Destruktor<i> join</i> auf diesem auf.<br></div>
<div class="ztitel_kleiner"><a alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CP.26%3A%20Don%C2%92t%20detach%28%29%20a%20thread%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detached_thread%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detached_thread%22%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detached_thread" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detached_thread" class="">CP.26: Don’t detach() a thread</a></div>
<div class="text">Diese Regel hört sich seltsam an. Der C++11-Standard bietet es zwar an, <i>detach </i>auf einem Thread <i>thr</i> aufzurufen, aber wir sollten es nicht tun! Der Grund ist ganz einfach. Richtig <i>thr.detach() </i>einzusetzen ist anspruchsvoll. Die Regel C.24 bringt es bereits auf den Punkt: "<a alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Think%20of%20a%20thread%20as%20a%20global%20container.%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detach%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-detach%22%2C%22type%22%3A%22E%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detach" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-detach">Think of a thread as a global container.</a>" Klar, du bist immer auf der sicheren Seite, wenn du nur Variablen mit globaler Gültigkeit in deinem Thread, auf dem du <i>detach</i> aufgerufen hast, verwendest. Nein!<br></div>
<div class="pre">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;thread&gt;<br><br>void func(){<br>&nbsp; std::string s{"C++11"};<br>&nbsp; std::thread t([&amp;s]{ std::cout &lt;&lt; s &lt;&lt; std::endl;});<br>&nbsp; t.detach();<br>}<br><br>int main(){<br>&nbsp; func();<br>}</div>
<div class="text">Das war einfach. Die Lambda-Funktion nimmt ihr Argument <i>s</i> per Referenz an. Das ist undefiniertes Verhalten, denn der Kinder-Thread verwendet <i>s</i>, obwohl diese nicht mehr gültig ist. Stopp! Das ist das offensichtliche Problem. Das nicht so offensichtliche Problem ist <i>std::cout.</i> <i>std::cout</i> besitzt einen statischen Gültigkeitsbereich. Das bedeutet, dass der Gültigkeitsbereich von <i>std::cout </i>dann endet, wenn das Programm sich beendet. Dies ist eine <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FBoesartige-Race-Conditions-und-Data-Races-3721793.html%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FBoesartige-Race-Conditions-und-Data-Races-3721793.html%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Race%20Condition%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22%22%7D" href="https://www.heise.de/developer/artikel/Boesartige-Race-Conditions-und-Data-Races-3721793.html" class="" title="Link auf https://www.heise.de/developer/artikel/Boesartige-Race-Conditions-und-Data-Races-3721793.html">Race Condition</a>, denn zu diesem Zeitpunkt kann der thread<i> t std::cout</i> noch verwenden.<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wir sind noch nicht fertig mit den Regeln zur Concurrency in den C++ Core Guidelines. In meinem nächsten Artikel werden weitere Regeln folgen. In diesen beschäftige ich mich mit der Übergabe von Daten an Threads, geteilten Besitzverhältnissen von Threads und den Kosten für das Erzeugen und Destruieren von Threads. <br></div>
