<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_152260880_f8464f5c48.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=0>" style="max-height: 25px; max-width: 25px;">Das Schreiben von Multithreading-Programmen ist sehr anspruchsvoll. Das gilt vor allem, wenn sie korrekt sein sollen. Die Regeln der C++ Core Guidelines geben die notwendige Hilfe an die Hand, um korrekte Programme zu schreiben. Die Regeln in diesem Artikel werden sich mit Themen wie Data Races, dem Teilen von Daten, Tasks und dem berühmt-berüchtigten Schlüsselwort volatile beschäftigen.</div>
<div class="text">Genau um diese vier Regeln geht es heute.</div>
<div class="text"><ul><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-races" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-races" class="" alt="%7B%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-races%22%2C%22text%22%3A%22CP.2%3A%20Avoid%20data%20races%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-races%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D">CP.2: Avoid data races</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data" alt="%7B%22text%22%3A%22CP.3%3A%20Minimize%20explicit%20sharing%20of%20writable%20data%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" class="">CP.3: Minimize explicit sharing of writable data</a> </li><li> <a class="" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-task%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22CP.4%3A%20Think%20in%20terms%20of%20tasks%2C%20rather%20than%20threads%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-task%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-task" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-task">CP.4: Think in terms of tasks, rather than threads</a> </li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-volatile" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-volatile" alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.8%3A%20Don%C2%92t%20try%20to%20use%20volatile%20for%20synchronization%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-volatile%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-volatile%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" class="">CP.8: Don’t try to use volatile for synchronization</a></li></ul></div>
<div class="text">Lass mich direkt mit der ersten Regel beginnen.</div>
<div class="text"><b><a alt="%7B%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-races%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-races%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.2%3A%20Avoid%20data%20races%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-races" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-races">CP.2: Avoid data races</a></b></div>
<div class="text">Im letzten Artikel dieser Serie habe ich bereits den Begriff <a class="" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Regeln-zur-Concurrency-und-zur-Parallelitaet-4029126.html%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Data%20Race%22%2C%22target%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Regeln-zur-Concurrency-und-zur-Parallelitaet-4029126.html%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Regeln-zur-Concurrency-und-zur-Parallelitaet-4029126.html" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Regeln-zur-Concurrency-und-zur-Parallelitaet-4029126.html">Data Race</a> definiert. Daher kann ich mich heute kurz halten. Ein Data Race ist ein gleichzeitiges Lesen und Schreiben von Daten. Das Ergebnis ist undefiniertes Verhalten. Die C++ Core Guidelines bieten dazu ein typisches Beispiel an: eine statische Variable:</div>
<div class="text">int get_id() {<br>&nbsp; static int id = 1;<br>&nbsp; return id++;<br>}</div>
<div class="text">Was läuft schief? Zum Beispiel ist es möglich, dass Thread A und Thread B denselben Wert <i>k</i> für<i> id</i> lesen. Danach schreiben der Thread A und der Thread B den Wert für <i>k + 1</i> zurück. Damit gibt es den Identifier <i>k + 1 </i>zweimal.</div>
<div class="text">Das nächste Beispiel ist deutlich überraschender [--] ein kleiner <i>switch</i>-Block:</div>
<div class="pre">unsigned val;<br><br>if (val &lt; 5) {<br>&nbsp;&nbsp;&nbsp; switch (val) {<br>&nbsp;&nbsp;&nbsp; case 0: // ...<br>&nbsp;&nbsp;&nbsp; case 1: // ...<br>&nbsp;&nbsp;&nbsp; case 2: // ...<br>&nbsp;&nbsp;&nbsp; case 3: // ...<br>&nbsp;&nbsp;&nbsp; case 4: // ...<br>&nbsp;&nbsp;&nbsp; }<br>}<br></div>
<div class="text">Der Compiler setzt typischerweise einen <i>switch</i>-Block mit einer Sprungtabelle um. Diese kann die folgende Form besitzen:</div>
<div class="pre">if (val &lt; 5){<br>&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; functions[val]();<br>}<br></div>
<div class="text">Im diesem Falle steht der Aufruf <i>functions[val]() </i>für die Funktionalität des <i>switch</i>-Blocks, falls <i>val </i>den Wert 3 besitzt. Nun kann es natürlich passieren, dass ein anderer Thread B zum Zuge kommt, wenn sich der ursprüngliche Thread A an der Stelle (1) befindet. Dieser andere Thread B ändert den Wert <i>val</i> so, dass er sich außerhalb des gültigen Bereichs der <i>if</i>-Anweisung befindet. Dies stellt natürlich undefiniertes Verhalten dar.</div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-data" class="" alt="%7B%22text%22%3A%22CP.3%3A%20Minimize%20explicit%20sharing%20of%20writable%20data%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-data%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D">CP.3: Minimize explicit sharing of writable data</a></b></div>
<div class="text">Dies ist eine unmittelbar einleuchtende und sehr wichtige Regel. Falls du Daten teilst, sollten diese konstant sein. Nun gilt es nur noch die Herausforderung zu lösen, dass die geteilten Daten thread-sicher initialisiert werden müssen. C++11 bieten ein paar Möglichkeiten an, dies zu gewährleisten.</div>
<div class="text"><ul><li>Initialisiere die Daten, bevor du einen Thread startest. Dieser einfache Weg ist natürlich unabhängig vom C++11-Standard.<br></li></ul></div>
<div class="pre">const int val = 2011;<br>thread t1([&amp;val]{ .... };<br>thread t2([&amp;val]{ .... };</div>
<div class="text"><ul><li>Verwende konstante Ausdrücke, denn diese werden zur Compilezeit initialisiert.</li></ul></div>
<div class="pre">constexpr auto doub = 5.1;</div>
<div class="text"><ul><li> Verwende die Funktion <i>std::call_once</i> in Kombination mit dem <i>std:once_flag</i>. Dann können die wichtigen Intialisierungsaufgaben direkt in die Funktion <i>onlyOnceFunction</i> verschoben werden. Die C++-Laufzeit sichert zu, dass die Funktion genau einmal erfolgreich durchgeführt wird.</li></ul></div>
<div class="pre">std::once_flag onceFlag;<br>void do_once(){<br>&nbsp; std::call_once(onceFlag, []{ std::cout &lt;&lt; "Important initialisation" &lt;&lt; std::endl; });<br>}<br>std::thread t1(do_once);<br>std::thread t2(do_once);<br>std::thread t3(do_once);<br>std::thread t4(do_once);<br></div>
<div class="text"><ul><li>Verwende statische Variablen mit Blockgültigkeit, denn die C++11-Laufzeit garantiert, dass diese thread-sicher initialisiert werden.</li></ul></div>
<div class="pre">void func(){<br>&nbsp; .... <br>&nbsp; static int val 2011; <br>&nbsp; ....<br>}<br>thread t5{ func() };<br>thread t6{ func() };</div>
<div class="text"><b><a class="" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-task%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.4%3A%20Think%20in%20terms%20of%20tasks%2C%20rather%20than%20threads%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-task%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-task" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-task">CP.4: Think in terms of tasks, rather than threads</a></b></div>
<div class="text">Zuerst einmal, was ist ein Task? Ein Task ist ein Begriff in C++11, der für zwei Komponenten steht: einen Promise und einen Future. Promise gibt es in drei Variationen in C++11: <i>std::async</i>, <i>std::packaged_task</i> und <i>std::promise</i>. Ich habe bereits einige Artikel zu <a href="https://www.grimm-jaud.de/index.php/blog/tag/tasks" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/tasks" alt="%7B%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftasks%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftasks%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Tasks%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%7D" class="">Tasks</a> verfasst. </div>
<div class="text">Einem Thread, einem <i>std::packaged_task</i> und einem <i>std::promise</i> ist gemein, dass die sie Low-level-Werkzeuge sind. Daher beziehe ich mich ab jetzt auf <i>std::async</i>.<br></div>
<div class="text">Das folgende Programmschnipsel zeigt einen Thread und ein Future/Promise-Paar. Beide berechnen die Summe von 3 + 4.<br></div>
<div class="pre">// thread<br>int res;<br>thread t([&amp;]{ res = 3 + 4; });<br>t.join();<br>cout &lt;&lt; res &lt;&lt; endl;<br><br>// task<br>auto fut = async([]{ return 3 + 4; });<br>cout &lt;&lt; fut.get() &lt;&lt; endl;</div>
<div class="text">Was ist nun der fundamentale Unterschied zwischen einem Thread und einem Promise/Future-Paar? <b>Ein Thread legt fest, wie etwas berechnet wird. Ein Task hingegen, was berechnet wird. </b></div>
<div class="text">Diesen Punkt möchte gerne ein wenig vertiefen:</div>
<div class="text"><ul><li> Der Thread verwendet die geteilte Variable<i> res </i>für das Ergebnis der Berechnung. Im Gegensatz dazu verwendet der Promise<i> std::async </i>einen sicheren Datenkanal um sein Ergebnis an den Future<i> fut </i>zu übermitteln. Dies bedeutet im Fall des Threads, dass die geteilte Variable <i>res</i> geschützt werden muss.</li><li>Im Fall des Threads wird explizit ein neuer Thread erzeugt. Das gilt aber nicht im Falle des Tasks, da in diesem Fall nur das Arbeitspaket spezifiziert wird. <br></li></ul></div>
<div class="text"><b><a alt="%7B%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22CP.8%3A%20Don%C2%92t%20try%20to%20use%20volatile%20for%20synchronization%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-volatile%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rconc-volatile%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-volatile" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-volatile">CP.8: Don’t try to use volatile for synchronization</a></b></div>
<div class="text">Falls du in Java oder C# eine atomare Variable benötigst, verwende <i>volatile</i>. Das ist einfach. Falls du ein C++ eine atomare Variable benötigst, verwende <i>volatile</i>. Falsch, ganz falsch. <i>volatile</i> besitzt keine Mulithreading-Semantik in C++. Atomare Variablen heißen in C++11 <i>std::atomic</i>. </div>
<div class="text">Jetzt bin ich neugierig: Was ist die Bedeutung von <i>volatile</i> in C++? <i>volatile</i> steht für besondere Objekte, auf den optimierte Lese- oder Schreibe-Operationen nicht erlaubt sind. </div>
<div class="text"><i>volatile</i> wird typischerweise in der Embedded-Programmierung eingesetzt, um Speicherbereiche auszuzeichnen, die unabhängig vom regulären Programmverlauf modifiziert werden können. Dies sind zum Beispiel Speicherbereiche, die ein externes Device (memory-mapped I/O) repräsentieren. Da diese Speicherbereiche sich unabhängig vom regulären Programmfluss verändern können, werden ihre Werte dank <i>volatile</i> direkt in den Hauptspeicher geschrieben. So findet kein optimiertes Speichern in den Zwischenspeichern (Caches) statt.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Das korrekte Implementieren von Multithreading-Programmen ist sehr anspruchsvoll. Das ist der Grund, warum du jedes Werkzeug verwenden solltest, dass dir hilft, deinen Code zu validieren. Mit dem dynamischen Codeanalysewerkzeug ThreadSanitzer und dem statischen Codeanalysewerkzeug CppMem gibt es zwei hervorragende Werkzeuge, die in die Werkzeugkiste jedes professionellen Programmierers gehört, der sich mit Multithreading beschäftigt. <br></div>
