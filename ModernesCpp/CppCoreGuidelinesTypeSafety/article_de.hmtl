<div class="vorspann">Die C++ Core Guidelines bieten drei Profile an: Type Safety, Bounds Safety und Lifetime Safety. Dank der Guideline Support Library (GSL) lässt sich der Sourcecode gegen die drei Profile testen. Dieser Artikel beschäftigt sich mit der Type Safety.</div><div class="text">Falls du nicht weißt, für was ein Profil steht, lies meinen letzten Artikel: <a href="/exec/mainmenu.pl?sid=c113c6c447dae9777b17c7022222b1ff&amp;rm=open_article_id&amp;bid=2745041" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dc113c6c447dae9777b17c7022222b1ff%26rm%3Dopen_article_id%26bid%3D2745041%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Profile%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A2745041%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D" title="Link auf Beitrag 2745041">C++ Core Guidelines: Profile</a>. Obwohl es die Idee eines Profils ist, ein spezifisches Ziel zu erreichen, benötigt ein Profil Unterstützung der anderen Profile. Dies heißt, dass das Profil Type Safety Unterstützung der Profile Bounds Safety und Lifetime Safety benötigt. Jetzt geht es aber los mit der Type Safety.&nbsp; <br></div><div class="ztitel"><a alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22Type%20Safety%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-type%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-type%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-type" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-type">Type Safety</a> <br></div><div class="text">Type Safey bedeutet, dass du deine Datentypen richtig verwendest und daher nicht gezwungen bist, unsichere Cast und Unions anzuwenden. Type Safey besteht aus acht Regeln, die Type genannt werden. Die Regeln starten mit "don't", "always" oder "avoid" und beziehen sich auf bestehende Regeln der C++ Core Guidelines. Falls es notwendig ist, werde ich zusätzliche Information zu den Regeln hinzufügen.<br></div><div class="ztitel_kleiner">Type 1:</div><div class="text"><ul><li> Don’t use <i>reinterpret_cast</i><br> </li><li> Don’t use <i>static_cast</i> for arithmetic types<br> </li><li> Don’t cast between pointer types where the source type and the target type are the same<br> </li><li>Don’t cast between pointer types when the conversion could be implicit</li></ul></div><div class="text">Die Antwort auf die "don't" lassen sich auf zwei Punkte reduzieren. Vermeide Casts und ziehe, wenn notwendig, benamte C++-Casts vor. </div><div class="text"><ul><li><b>Vermeide Casts</b></li></ul></div><div class="text">Was passiert, wenn ich das Typsystem pervertiere?</div><div class="pre">// casts.cpp<br><br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; double d = 2;<br>&nbsp;&nbsp;&nbsp; auto p = (long*)&amp;d;<br>&nbsp;&nbsp;&nbsp; auto q = (long long*)&amp;d;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; *q &lt;&lt; '\n';<br> <br>}</div><div class="text">Weder das Ergebnis mit dem Visual Studio Compiler</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_180234913_a007cc17a8.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">noch das Ergebnis mit dem GCC- oder Clang-Compiler ist beruhigend:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_180234915_ad1f976ac5.png" title="<ir_inline itemname=bilder_mvp_bild:3 type=2>" style="max-height: 25px; max-width: 25px;"><br> </div><div class="text">Was ist das Problem mit dem C-Cast? Du kannst nicht erkennen, welcher Cast unter der Decke angewandt wurde. Falls du einen C-Cast verwendest, wird vereinfachend gesprochen, eine Kombination von Casts verwendet. Los geht es mit dem&nbsp;<span class="tx_code">static_cast</span>, gefolgt vom&nbsp;<span class="tx_code">const_cast</span><i>&nbsp;</i>und zuletzt der&nbsp;<span class="tx_code">reinterpret_cast</span>.</div><div class="text">Es gibt ein weites Problem mit C-Casts. Es ist ziemlich anspruchsvoll, C-Casts im Sourcecode zu finden. Dies gilt nicht für C++-Casts wie den <span class="tx_code">dynamic_cast</span>, <span class="tx_code">const_cast</span>, <span class="tx_code">static_cast</span> oder <span class="tx_code">reinterpret_cast</span><i>.</i></div><div class="text">Natürlich ahnst du bereits, wie es weitergeht: "Explicit is better than implict."</div><div class="text"><ul><li><b>Ziehe benamte C++-Casts vor</b></li></ul></div><div class="text">Rechne ich die GSL hinzu, bietet C++ acht verschiedene Casts an. Hier sind sie inklusive einer kurzen Beschreibung:</div><div class="text"><ul><li> <span class="tx_code">static_cast</span>: konvertiert zwischen ähnlichen Datentypen wie Zeiger oder numerischen Typen</li><li><span class="tx_code">const_cast</span>: entfernt oder fügt&nbsp;<span class="tx_code">const</span>&nbsp;und&nbsp;<span class="tx_code">volatile</span>&nbsp;hinzu<br></li><li><span class="tx_code">reinterpret_cast</span>: Konvertieren zwischen Zeigern oder zwischen integralen Datentypen und Zeigern<br></li><li><span class="tx_code">dynamic_ cast</span>:&nbsp;konvertiert zwischen polymorphen Zeigern oder Referenzen in derselben Klassenhierarchie<br></li><li><span class="tx_code">std::move</span>:&nbsp;konvertiert in eine Rvalue-Referenz<br></li><li><span class="tx_code">std::forward</span>: konvertiert einen Lvalue in eine Lvalue-Referenz und einen Rvalue in eine Rvalue-Referenz<br></li><li><span class="tx_code">gsl::narrow_cast</span>: wendet ein&nbsp;<span class="tx_code">static_cast</span>&nbsp;an<br></li><li><span class="tx_code">gsl::narrow</span>: wendet ein&nbsp;<span class="tx_code">static_cast&nbsp;</span>an</li></ul></div><div class="text">Okay, die Beschreibung ist zu kompakt. Daher möchte ich zumindest zwei Bemerkungen machen:</div><div class="text"><ol><li>GSL steht für die Guideline Support Library. Dies ist eine Header-Only Library in dem Namensraum <i>gsl</i>. Die GSL lässt sich dazu verwenden, automatisch die Regeln der C++ Core Guidelines und insbesondere die Profile zu prüfen. Über diese Prüfungen werde ich in einem zukünftigen Artikel schreiben. Zur GSL habe ich bereits einen Artikel geschrieben: <a title="Link auf Beitrag 2245170" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A2245170%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20The%20Guideline%20Support%20Library%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dc113c6c447dae9777b17c7022222b1ff%26rm%3Dopen_article_id%26bid%3D2245170%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22version%22%3A1%7D" href="/exec/mainmenu.pl?sid=c113c6c447dae9777b17c7022222b1ff&amp;rm=open_article_id&amp;bid=2245170">C++ Core Guidelines: The Guideline Support Library</a>.</li><li><span class="tx_code">std::move</span>&nbsp;und&nbsp;<span class="tx_code">std::forward</span>&nbsp;sind Casts? Lass mich einen genaueren Blick auf <span class="tx_code">std::move</span> werfen: <span class="tx_code">static_cast&lt;std::remove_reference&lt;decltype(arg)&gt;::type&amp;&amp;&gt;(arg)</span>. Zuerst wird der Typ des Arguments&nbsp;<span class="tx_code">arg</span>&nbsp;mithilfe von&nbsp;<span class="tx_code">decltype(arg)</span><i>&nbsp;bestimmt</i>. Danach werden alle Referenzen entfernt und zwei neue hinzugefügt. Die Funktion&nbsp;<span class="tx_code">std::remove_reference</span>&nbsp;ist aus der Type-Traits-Bibliothek. Ich habe bereits ein paar Artikel zur&nbsp;Type-Traits-Bibliothek&nbsp;geschrieben. Am Ende verlässt <span class="tx_code">arg std::move</span> immer als Rvalue-Referenz.<br></li></ol></div><div class="ztitel_kleiner">Type 2:</div><div class="text"><ul><li>Don’t use <span class="tx_code">static_cast </span>to downcast</li></ul> </div><div class="text">Gerne möchte ich eine kurze Antwort geben: Verwende <span class="tx_code">dynamic_cast</span>. Auch zu diesem Thema habe bereits einen Artikel verfasst: <a title="Link auf https://heise.de/-3875521" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-3875521%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Zugriffe%20auf%20Objekte%20in%20Klassenhierarchien%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-3875521%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://heise.de/-3875521">C++ Core Guidelines: Zugriffe auf Objekte in Klassenhierarchien</a> <br></div><div class="ztitel_kleiner">Type 3:</div><div class="text"><ul><li>Don’t use <span class="tx_code">const_cast</span> to cast away <span class="tx_code">const</span></li></ul></div><div class="text">Jetzt muss ich ein wenig genauer argumentieren.&nbsp;<span class="tx_code">const</span>&nbsp;von einem Objekt wegzucasten, stellt undefiniertes Verhalten dar, falls das Objekt wie&nbsp;<span class="tx_code">constInt</span>&nbsp;nicht veränderlich war:</div><div class="pre">const int constInt = 10;<br>const int* pToConstInt = &amp;constInt;<br> <br>int* pToInt = const_cast&lt;int*&gt;(pToConstInt);<br>*pToInt = 12; // undefined behaviour </div><div class="text">Falls du mir nicht glaubst, es gibt eine Fußnote im C-Standard [ISO/IEC 9899:2011] (subclause 6.7.3, paragraph 4), der auch Relevanz für den C++-Standard besitzt: "The implementation may place a const object that is not volatile in a read-only region of storage. Moreover, the implementation need not allocate storage for such an object if its address is never used." Das heißt, dass eine Modifikation auf einem ursprünglichen konstanten Objekte keine Auswirkung haben kann.<br></div><div class="ztitel_kleiner">Type 4:<br></div><div class="text"><ul><li>Don’t use C-style (T)expression or functional T(expression) casts</li></ul></div><div class="text">Der erste Teil dieses "don't" ist recht einfach zu beantworten: Verwende benamte Casts wie im Type 1. </div><div class="text">Der funktionale <span class="tx_code">T(e)</span> Cast wird dazu verwendet, ein <span class="tx_code">T</span> aus einem Ausdruck <span class="tx_code">e</span> zu erzeugen. Was passiert, wenn der funktionale Cast falsch verwendet wird?<br></div><div class="pre">// functionalCast.cpp<br><br>void f(int x, long y, double d, long long l){<br>&nbsp;&nbsp;&nbsp; char c1(x);&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c2(y);&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c3(d);&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c4(l);<br>}<br><br>int main(){&nbsp; <br>&nbsp; f(3, 3l, 3.0, 3ll);<br>}<br></div><div class="text">Die Funktion <span class="tx_code">f</span> nimmt vier Argumente an und verwendet diese Argumente um <span class="tx_code">char</span><span class="tx_code">s</span> zu initialisieren. Du erhältst in diesem Fall, was du verdienst, und kannst nur auf Warnungen des Compilers hoffen. <a title="Link auf https://cppinsights.io/s/6f300871" alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F6f300871%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Fs%2F6f300871%22%2C%22ir_link%22%3A1%7D" href="https://cppinsights.io/s/6f300871">C++ Insights</a> zeigt explizit, wie dein Code transformiert wird. Ein <span class="tx_code">static_cast</span> wird auf jedes Argument angewandt. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_180234937_c3df56e62c.png" title="<ir_inline itemname=bilder_mvp_bild:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Dieser Prozess wird Narrowing Conversion genannt und sollte durch den Compiler entdeckt werden. Dank der Verwendung von geschweiften Klammern prüft der Compiler, ob Narrowing Conversion vorliegt. Der Compiler muss in diesem Fall eine Warnung schreiben, interpretiert diese Warnung aber typischerweise als Fehler. Falls du auf Nummer sicher gehen willst, dass Narrowing Conversion immer einen Fehler erzeugt, kannst du mit dem GCC und Clang<span class="tx_code"> -Werror=narrowing</span> verwenden. Hier ist das leicht modifizierte Programm: <br></div><div class="pre">// functionalCastCurlyBraces.cpp<br><br>void f(int x, long y, double d, long long l){<br>&nbsp;&nbsp;&nbsp; char c1{x};&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c2{y};&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c3{d};&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; char c4{l};<br>}<br><br>int main(){&nbsp; <br>&nbsp; f(3, 3l, 3.0, 3ll);<br>}</div><div class="text">Der Compiler entdeckt, was schiefläuft.</div><div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_180234931_8a8968382c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter? <br></div><div class="text">Mit meinem nächsten Artikel werde ich die Regeln zu Type Safety vollenden. Bei ihnen geht es um die Initialisierung, Unions und Varargs. Nun muss ich mich aber für eine sehr aufregende Woche vorbereiten. Ich werde einen Zwei-Tages-Workshop zur Concurrency, einen Back-to-Basics-Vortrag und einen Vortrag zu Concepts auf der <a href="https://cppcon.org/" title="Link auf https://cppcon.org/" alt="%7B%22href%22%3A%22https%3A%2F%2Fcppcon.org%2F%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fcppcon.org%2F%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22CppCon%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%7D">CppCon</a> halten. <br></div>