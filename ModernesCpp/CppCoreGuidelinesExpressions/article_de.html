<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147784260_4133565a98.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="vorspann">Entwickler sollten keine komplizierten Ausdrücke anwenden, die Prioritäten für arithmetische oder logische Ausdrücke und die Reihenfolge der Auswertung von Ausdrücken kennen. Wird eine falsche Priorität für Ausdrücke oder Auswertungsreihenfolge von Ausdrücken verwendet, die schlicht falsch oder nicht garantiert ist, dann lauert undefiniertes Verhalten. <br></div>
<div class="text">Hier sind die vier Regeln für heute.</div>
<div class="text"><ul> <li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-complicated" alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.40%3A%20Avoid%20complicated%20expressions%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-complicated%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-complicated%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-complicated" class="">ES.40: Avoid complicated expressions</a> </li> <li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-parens" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.41%3A%20If%20in%20doubt%20about%20operator%20precedence%2C%20parenthesize%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-parens%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-parens%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-parens">ES.41: If in doubt about operator precedence, parenthesize</a> </li> <li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.43%3A%20Avoid%20expressions%20with%20undefined%20order%20of%20evaluation%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order" class="">ES.43: Avoid expressions with undefined order of evaluation</a> </li> <li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order-fct" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order-fct" alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22ES.44%3A%20Don%C2%92t%20depend%20on%20order%20of%20evaluation%20of%20function%20arguments%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order-fct%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order-fct%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D">ES.44: Don’t depend on order of evaluation of function arguments</a></li></ul></div>
<div class="text">Die Regeln zur Priorität und zur Auswertungsreihenfolge von Ausdrücken sind nicht so einfach, wie sie vielleicht klingen. Zusätzlich haben sie sich mit C++17 geändert. Daher beginnt dieser Artikel sehr behutsam.</div>
<div class="text"><b><a alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-complicated%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-complicated%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.40%3A%20Avoid%20complicated%20expressions%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-complicated" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-complicated">ES.40: Avoid complicated expressions</a></b><br></div>
<div class="text">Was bedeutet kompliziert? Hier ist das ursprüngliche Beispiel aus den Guidelines:</div>
<div class="pre">// bad: assignment hidden in subexpression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br>while ((c = getc()) != -1)<br><br>// bad: two non-local variables assigned in a sub-expressions&nbsp;&nbsp; (1)<br>while ((cin &gt;&gt; c1, cin &gt;&gt; c2), c1 == c2)<br><br>// better, but possibly still too complicated&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br>for (char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2 &amp;&amp; c1 == c2;)<br><br>// OK: if i and j are not aliased&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>int x = ++i + ++j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>// OK: if i != j and i != k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>v[i] = v[j] + v[k];<br><br>// bad: multiple assignments "hidden" in subexpressions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br>x = a + (b = f()) + (c = g()) * 7;<br><br>// bad: relies on commonly misunderstood precedence rules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br>x = a &amp; b + c * d &amp;&amp; e ^ f == 7;<br><br>// bad: undefined behavior&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)<br>x = x++ + x++ + ++x;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br></div>
<div class="text">Ich habe ein paar (Zahlen) hinzugefügt. Zuerst einmal gilt, dass alle Ausdrücke, die die Ziffer (1) haben, schlechten Stil darstellen und ein Code-Review nicht überstehen sollten. Weißt du zum Beispiel, was hier passiert:&nbsp; <i>x = a &amp; b + c * d &amp;&amp; e ^ f == 7</i>. Klar, du musst die Regeln für die Priorität von Operationen nachschauen. Ich werde mich auf diese in der nächsten Regel beziehen.&nbsp;</div>
<div class="text">Die Ausdrücke (2) sind dann richtig, wenn folgende Bedingungen gelten: <i>i</i> und<i> j</i> müssen verschieden und die Indizes<i> i,j </i>und<i> i,j</i> müssen paarweise verschieden sein. <br></div>
<div class="text">(3) stellt undefiniertes Verhalten dar, denn es ist nicht definiert, in welcher Reihen <i>x</i> ausgewertet wird. Warum? Der Grund ist das abschließende Semikolonzeichen. ";" ist ein Sequenzpunkt und für diesen gilt die Garantie, dass alle Effekte von Ausdrücken vor diesem bereits stattgefunden haben müssen.<br></div>
<div class="text">Mit C++17 haben sie die Regeln für die Priorität von Operatoren geändert: Es gilt "links nach rechts" für Ausdrücke mit der Ausnahme von Zuweisungen. Für diese gilt "rechts nach links". In der Regel ES.43 werde ich auf die zugesicherte Prioritäten von Operatoren in C++17 genauer eingehen.&nbsp; </div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-parens" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-parens%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-parens%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22ES.41%3A%20If%20in%20doubt%20about%20operator%20precedence%2C%20parenthesize%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-parens" class="">ES.41: If in doubt about operator precedence, parenthesize</a></b><br></div>
<div class="text">Einerseits sagen die Guidelines: Falls du dir bei über die Priorität von Operatoren nicht sicher bist, verwende Klammern (1). Anderseits sagen siee: Du solltest dich gut genug mit den Prioritäten von Operatoren auskennen, um hier (2) keine Klammern zu benötigen.<br></div>
<div class="pre">const unsigned int flag = 2;<br>unsigned int a = flag;<br><br>if (a &amp; flag != 0)&nbsp; // bad: means a&amp;(flag != 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<br><br>if (a &lt; 0 || a &lt;= max) {&nbsp; // good: quite obvious&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="text">Okay. Für einen Experten mag der Ausdruck (1) eine Selbstverständlichkeit sein, für einen Anfänger der Ausdruck (2) eine Herausforderung.</div>
<div class="text">Mir fallen nur zwei Tipps zu dieser Regeln ein.</div>
<div class="text"><ol><li> Falls du Zweifel bei der Priorität von Operatoren hast, verwende Klammer. Denke dabei aber an die Anfänger.</li><li>Behalte die Tabelle zu den Prioritäten der Operatoren unter deinen Kissen.</li></ol></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147784267_06010aa12a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ich springe gleich zu den Regeln ES.43 und ES.44 und werde mich mit der Regel ES.42 erst im nächsten Artikel befassen. Mit C++17 hat sich die Reihenfolge der Auswertung von Ausdrücken geändert.</div>
<div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order" alt="%7B%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22ES.43%3A%20Avoid%20expressions%20with%20undefined%20order%20of%20evaluation%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order" class="">ES.43: Avoid expressions with undefined order of evaluation</a></b><br></div>
<div class="text">In C++14 besitzt der folgende Ausdruck undefiniertes Verhalten:<br></div>
<div class="pre">v[i] = ++i;&nbsp;&nbsp; //&nbsp; the result is undefined<br></div>
<div class="text">Das gilt aber nicht für C++17. Mit C++17 ist die Auswertungsreihenfolge des kleinen Codeschnipsels von "rechts nach links" garantiert; damit verfügt das Programm über wohldefiniertes Verhalten.</div>
<div class="text">Welche Zusicherungen bietet C++17 noch an? <br></div>
<div class="text"><ol><li>Postfix-Ausdrücke werden von links nach rechts ausgewertet. Dies trifft auch auf Funktionsaufrufe und Zugriffe auf Klassenmitglieder. <br></li><li>Zuweisungsausdrücke werden von rechts nach links ausgewertet. Dies schließt die zusammengesetzten Zuweisungen mit ein.</li><li>Die Operatoren von Shift-Operationen werden von links nach rechts ausgewertet.</li></ol></div>
<div class="text">Dies war der sinngemäße Wortlaut des ursprünglichen <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf" class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf" alt="%7B%22text%22%3A%22Proposals%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0145r3.pdf%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0145r3.pdf%22%7D">Proposals</a>. Dazu gibt es noch ein paar Beispiele:</div>
<div class="pre">a.b<br>a-&gt;b<br>a-&gt;*b<br>a(b1, b2, b3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>b @= a<br>a[b]<br>a &lt;&lt; b<br>a &gt;&gt; b<br></div>
<div class="text">Wie sollten die Beispiele gelesen werden? Sehr einfach. Jeder Ausdruck wird in der Reihenfolge a, dann b, dann c und dann d ausgewertet. </div>
<div class="text">Der Ausdruck (1) ist ein wenig trickreicher. Mit C++17 bekommen wir nur die Garantie, dass die Funktion vor ihren Argumenten evaluiert wird, aber die Auswertungsreihenfolge der Argumente ist immer noch nicht spezifiziert. </div>
<div class="text">Mir ist klar. Der letzte Satz war nicht sehr leicht verdaulich. Daher werde ich ein wenig ausholen.</div>
<div class="text"><b><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order-fct" alt="%7B%22text%22%3A%22ES.44%3A%20Don%C2%92t%20depend%20on%20order%20of%20evaluation%20of%20function%20arguments%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order-fct%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-order-fct%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-order-fct">ES.44: Don’t depend on order of evaluation of function arguments</a></b></div>
<div class="text">In den letzten Jahre habe ich sehr viele Fehler gesehen, denn viele Programmierer nahmen irrtümlich an, dass die Argumente einer Funktion von links nach rechts ausgewertet werden. Falsch! Es gibt keine Zusicherungen:</div>
<div class="pre">#include &lt;iostream&gt;<br><br>void func(int fir, int sec){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "(" &lt;&lt; fir &lt;&lt; "," &lt;&lt; sec &lt;&lt; ")" &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; int i = 0;<br>&nbsp;&nbsp;&nbsp; func(i++, i++);<br>}<br></div>
<div class="text">Hier ist der Beweis. Die Ausgaben von GCC und Clang unterscheidet sich. </div>
<div class="text"><b>GCC</b><br><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147784273_d26495a9ae.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text"><b>Clang</b></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_147784279_e11bcb0f02.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Mit C++17 ändert sich das Verhalten nicht. Die Auswertungsreihenfolge der Funktionsargumente ist nicht spezifiziert. Aber zumindestens ist die Auswertungsreihenfolge der folgenden Ausdrücke mit C++17 vorgegeben:</div>
<div class="pre">f1()-&gt;m(f2());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // evaluation left to right&nbsp; (1)<br>cout &lt;&lt; f1() &lt;&lt; f2();&nbsp;&nbsp; // evaluation left to right&nbsp; (2)<br><br>f1() = f(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // evaluation right to left&nbsp; (3)<br></div>
<div class="text">Den Begründung liefere ich gleich mit:</div>
<div class="text">(1): Postfix-Ausdrücke werden von links nach rechts evaluiert. Dies schließt Funktionsaufrufe mit ein.</div>
<div class="text">(2): Die Operanden von Shift-Operatoren werden von links nach rechts evaluiert.</div>
<div class="text">(3): Ausdrucke mit Zuweisungen werden von rechts nach links evaluiert.</div>
<div class="text">Ein Punkt muss ich aber noch ganz explizit betonen. Mit C++14 besitzen die drei letzten Ausdrücke undefiniertes Verhalten. <br></div>
<div class="ztitel">Wie geht's weiter? <br></div>
<div class="text">Zugegeben, das war ein herausfordernder Artikel. Dies ist aber eine Herausforderung, die jeder Programmierer auf seinem Weg zu einem guten Programmierer meistern muss. Das zentrale Thema meines nächsten Artikels werden die Konvertierungsoperatoren in C++ sein.&nbsp; </div>