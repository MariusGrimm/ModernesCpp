<div class="text"><b>Bevor ich auf die gut 15 Regeln für Anweisungen eingehe, möchte ich gerne auf die zwei letzten Regeln für Ausdrücke eingehen. Beide Regeln helfen, das Programm vor undefiniertem Verhalten zu bewahren. </b></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149381986_7a5e4019b5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Hier sind die zwei verbleibenden Regeln.</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-construct" alt="%7B%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-construct%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-construct%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22ES.64%3A%20Use%20the%26nbsp%3BT%7Be%7Dnotation%20for%20construction%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-construct">ES.64: Use the&nbsp;T{e}notation for construction</a>&nbsp;</div>
<div class="text">Der Grund, den Ausdruck <i>T{e}</i> für die Erzeugung eines Wertes zu verwenden, ist sehr offensichtlich. Im Gegensatz zu den Ausdrücken <i>T(e)</i> oder <i>(T)e,</i> erlaubt <i>T{e} </i>keine verengende Konvertierung (narrowing conversion). Verengende Konvertierung ist eine Konvertierung unter Verlust der Datengenauigkeit. Ich nehme an, meist ist das nicht im Sinne des Autors. Hier ist das Beispiel der Guidelines.</div>
<div class="pre">void use(char ch, double d, char* p, long long lng){<br>&nbsp; int x1 = int{ch};&nbsp; // OK, but redundant<br>&nbsp; int x2 = int{d};&nbsp; &nbsp;// error: double-&gt;int narrowing; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a cast if you need to<br>&nbsp; int x3 = int{p};&nbsp; &nbsp;// error: pointer to-&gt;int; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a reinterpret_cast if you really need to<br>&nbsp; int x4 = int{lng}; // error: long long-&gt;int narrowing; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a cast if you need to (1)<br><br>&nbsp; int y1 = int(ch);&nbsp; // OK, but redundant<br>&nbsp; int y2 = int(d);&nbsp; &nbsp;// bad: double-&gt;int narrowing; use a cast if you need to<br>&nbsp; int y3 = int(p);&nbsp; &nbsp;// bad: pointer to-&gt;int; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a reinterpret_cast if you really need to&nbsp; (2)<br>&nbsp; int y4 = int(lng); // bad: long-&gt;int narrowing; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a cast if you need to<br><br>&nbsp; int z1 = (int)ch;&nbsp; // OK, but redundant<br>&nbsp; int z2 = (int)d;&nbsp; &nbsp;// bad: double-&gt;int narrowing; use a cast if you need to<br>&nbsp; int z3 = (int)p;&nbsp; &nbsp;// bad: pointer to-&gt;int; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a reinterpret_cast if you really need to&nbsp; (3)<br>&nbsp; int z4 = (int)lng; // bad: long long-&gt;int narrowing; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// use a cast if you need to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Dies ist die Ausgabe der Codezeilen mit dem GCC ohne eine spezielles Flag.</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149381996_a4a31449ee.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Wenn du genau die Ausgabe der Compilerausgabe studierst, fallen ein paar interessante Punkte ins Auge.</div>
<div class="text"><ul><li>Der Ausdruck (1) erzeugt im ersten Codeblock nur eine Warnung. Die zwei vorherigen Ausdrücke jedoch einen Fehler.</li><li>Nur die Ausdrücke (2) und (3) führen zu einem Fehler. Die weiteren Konvertierungen im zweiten und dritten Codeblock verursachen nicht einmal eine Warnung.</li></ul></div>
<div class="text">Es gibt eine spezielle Regel, die du beachten solltest, wenn du einen Wert mit dem Ausdruck <i>T(e1, e2)</i> oder <i>T{e1, e2}</i> erzeugst. Was passiert, wenn deine Klasse zwei konkurrierende Konstruktoren besitzt? Einen Konstruktor, der zwei <i>int</i>'s annimmt (<i>MyVector(int, int)</i>) und einen anderen Konstruktor, der eine <i>std::initializer_list&lt;int&gt; (MyVector(std::initializer_list&lt;int&gt;)</i> erwartet. Die interessante Frage ist: Führt ein Aufruf <i>MyVector(int, int)</i> oder ein Aufruf <i>MyVector{int, int}</i> zu dem Aufruf des Konstruktors mit zwei <i>int'</i>s oder dem mit der <i>std::initializer_list&lt;int&gt;</i>?</div>
<div class="pre">// constructionWithBraces.cpp<br><br>#include &lt;iostream&gt;<br><br>class MyVector{<br>public:<br>&nbsp;&nbsp;&nbsp; MyVector(int, int){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "MyVector(int, int)" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; MyVector(std::initializer_list&lt;int&gt;){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "MyVector(std::initalizer_list&lt;int&gt;)" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class MyVector1{<br>public:<br>&nbsp;&nbsp;&nbsp; MyVector1(int, int){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "MyVector1(int, int)" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>class MyVector2{<br>public:<br>&nbsp;&nbsp;&nbsp; MyVector2(int, int){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "MyVector(std::initalizer_list&lt;int&gt;)" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MyVector(1, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; MyVector{1, 2};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MyVector1{1, 2};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; MyVector2(1, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}<br></div>
<div class="text">Hier ist die Ausgabe des Programms. Der Aufruf (1) stößt den Konstruktor mit zwei int's an. Der Aufruf (2) stößt den Konstruktor mit den <i>std::initializer_list&lt;int&gt;</i> an. Wenn du <i>MyVector1{1, 2}</i> (3) aufrufst, dient der Konstruktor <i>MyVector(int, int)</i> als eine Art Fallback.&nbsp;</div>
<div class="text">Das gleiche gilt nicht für den Ausdruck (4). In diesem Fall ist der Konstruktor mit der <i>std::initializer_list&lt;int&gt;</i> nicht der Fallback.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_149382158_9486f0b3ef.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Ein Konstruktor, der eine <i>std::initializer_list</i> als Argument annimmt, wird gerne auch Sequenz-Konstruktor genannt. </div>
<div class="text">Ahnst du bereits, warum ich die Klasse in dem Beispiel MyVector genannt habe? Der Grund ist, dass die zwei folgenden Ausdrücke sich vollkommen verschieden verhalten. </div>
<div class="pre">std::vector&lt;int&gt; vec(10, 1);&nbsp; // ten elements with 1<br>std::vector&lt;int&gt; vec2{10, 1}; // two elements 10 and 1</div>
<div class="text">Die erste Zeile erzeugt einen Vektor von 10 Elementen; die zweite Zeile hingegen einen Vektor mit den Werten 10 und 1.</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-deref" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22ES.65%3A%20Don%C2%92t%20dereference%20an%20invalid%20pointer%26nbsp%3B%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-deref%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-deref%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-deref">ES.65: Don’t dereference an invalid pointer&nbsp;</a><br></div>
<div class="text">Lass es mich so formulieren. Falls du einen ungültigen Zeiger wie einen <i>nullptr</i> dereferenzierst, besitzt dein Programm undefiniertes Verhalten. Das ist nicht schön. Der einzige Weg, dieses Verhalten zu verhindern, ist den Zeiger vor seiner Verwendung zu prüfen.</div>
<div class="pre">void func(int* p) {<br>&nbsp; if (p == nullptr) { // do something special<br>&nbsp; }<br>&nbsp; int x = *p;<br>&nbsp; ...<br>}<br></div>
<div class="text">Wie lässt sich das Problem prinzipiell lösen. Verwende keine nackten Zeiger! Verwende einen Smart Pointer wie <i>std::unique_ptr</i> oder <i>std::shared_ptr</i> oder eine Referenz. Ich habe bereits einen Artikel zu den verschieden Arten von Besitzverhältnissen in modernem C++ geschrieben. Hier sind die Details: <a href="https://www.heise.de/developer/artikel/C-Core-Guidelines-Regeln-fuer-die-Ressourcenverwaltung-3907292.html" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Regeln-fuer-die-Ressourcenverwaltung-3907292.html%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FC-Core-Guidelines-Regeln-fuer-die-Ressourcenverwaltung-3907292.html%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Regeln%20f%C3%BCr%20die%20Ressourcenverwaltung%22%7D" class="" title="Link auf https://www.heise.de/developer/artikel/C-Core-Guidelines-Regeln-fuer-die-Ressourcenverwaltung-3907292.html">C++ Core Guidelines: Regeln für die Ressourcenverwaltung</a>.</div>
<div class="text">Und nun zu etwas ganz anderem.</div>
<div class="ztitel">Regeln für Anweisungen</div>
<div class="text">Die Regeln für Anweisungen sind recht offensichtlich. Daher kann ich mich sehr kurz fassen. </div>
<div class="text"><ul><li>Du solltest eine <i>switch</i>-Anweisung einer <i>if</i>-Anweisung vorziehen, falls dies möglich ist (<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-switch-if" class="" alt="%7B%22text%22%3A%22ES.70%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-switch-if%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-switch-if%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-switch-if">ES.70</a>). Eine <i>switch</i>-Anweisung ist typischerweise lesbarer und kann besser optimiert werden.</li><li>Das gleiche gilt für eine Range-basierte <i>for</i>-Schleife (<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-for-range" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.71%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-for-range%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-for-range%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-for-range">ES.71</a>) im Gegensatz zu einer <i>for</i>-Schleife. Zuerst einmal ist eine Range-basierte <i>for</i>-Schleife einfacher zu lesen und zweitens immun gegen das Verzählen oder das Ändern des Schleifenindex während des Schleifendurchlaufs.<br></li><li>Wenn du eine offensichtliche Schleifenvariable verwendest, solltest du eine <i>for</i>-Schleife einer <i>while</i>-Anweisung vorziehen (<a alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22ES.72%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-for-while%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-for-while%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-for-while" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-for-while" class="">ES.72</a>); falls nicht, solltest du die <i>while</i>-Anweisung vorziehen (<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-while-for" class="" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22ES.73%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-while-for%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-while-for%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-while-for">ES.73</a>).</li></ul></div>
<div class="text">Der Ausdruck (1) zeigt ein Beispiel für den Fall, dass eine <i>for</i>-Schleife verwendet werden soll. Der Ausdruck (2) hingegen, falls eine <i>while</i>-Anweisung zum Einsatz kommen sollte. <br></div>
<div class="pre">for (gsl::index i = 0; i &lt; vec.size(); i++) {&nbsp; // (1)<br>&nbsp; // do work<br>}<br><br>int events = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>while (wait_for_event()) {&nbsp;&nbsp; <br>&nbsp; ++events;<br>&nbsp; // ...<br>}<br></div>
<div class="text"><ul><li>Die Schleifen-Variable sollte direkt in der <i>for</i>-Schleife deklariert werden (<a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-for-init" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-for-init" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22ES.74%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-for-init%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-for-init%22%7D">ES.74</a>). Das gilt seit C++17 nicht nur für die <i>for</i>-Schleife, sondern auch für die <i>if</i>- oder <i>switch</i>-Anweisung. Hier gibt es die Details: <a href="http://www.grimm-jaud.de/index.php/blog/c-17-kern" alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-kern%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-kern%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22C%2B%2B17%3A%20Was%20gibts%20Neues%20in%20der%20Kernsprache%3F%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/c-17-kern">C++17: Was gibts Neues in der Kernsprache?</a></li><li>Vermeide <i>do</i>-Anweisungen (<a alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22ES.75%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-do%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-do%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-do" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-do" class="">ES.75</a>), <i>goto</i>-Anweisungen (<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-goto" alt="%7B%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22ES.76%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-goto%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-goto%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-goto">ES.76</a>) und minimiere den Einsatz der Anweisungen <i>break</i> und <i>continue</i> in Schleifen (<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-continue" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22ES.77%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-continue%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Res-continue%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-continue">ES.77</a>), denn diese sind schwer zu lesen. Falls etwas schwer zu lesen ist, ist es automatisch fehleranfällig. <br></li></ul></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Ein paar Regeln für Anweisungen sind noch übrig. Mit diesen wird mein nächster Artikel beginnen. Danach wird es mit dem Regeln zur Arithmetik deutlich spannender. <br></div>