<div class="vorspann">Variadic Templates sind ein typisches Feature von C++: Aus Sicht der Anwender sind sie einfach einzusetzen, aus Sicht der Implementierer wirken sie recht furchteinflößend. Im heutigen Artikel geht es um die Sicht der Implementierer.</div>
<div class="text">Bevor ich über Variadic Templates schreibe, möchte ich meine Einleitung um eine Anmerkung ergänzen. Ich trage oft zwei Hüte, wenn ich eine C++-Schulung gebe: einen für den Anwender und einen für den Implementierer. Features von C++ wie Templates sind einfach zu verwenden, aber anspruchsvoll zu implementieren. Dieser signifikante Graben ist typisch für C++ und wohl tiefer als in anderen Mainstream-Programmiersprachen wie Python, Java und auch C. Ehrlich gesagt, ich habe kein Problem mit diesem Graben. Ich nenne ihn Abstraktion, und er ist ein wesentlicher Bestandteil der Mächtigkeit von C++. Die Kunst des Implementierers einer Bibliothek oder eines Frameworks ist es, ein einfach zu verwendendes und stabiles Interface zu entwickeln. Falls dies zu vage war, warte auf den nächsten Abschnitt, wenn ich <i>std::make_unique</i> entwickle.</div>
<div class="text">Der heutige Artikel beschäftigt sich mit drei Regeln der C++ Core Guidelines:<br></div>
<div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22T.100%3A%20Use%20variadic%20templates%20when%20you%20need%20a%20function%20that%20takes%20a%20variable%20number%20of%20arguments%20of%20a%20variety%20of%20types%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-variadic%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-variadic%22%2C%22alias%22%3A%22%22%7D">T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic-pass" class="" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-variadic-pass%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-variadic-pass%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22T.101%3A%20%3F%3F%3F%20How%20to%20pass%20arguments%20to%20a%20variadic%20template%20%3F%3F%3F%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic-pass">T.101: ??? How to pass arguments to a variadic template ???</a> </li><li> <a alt="%7B%22text%22%3A%22T.102%3A%20%3F%3F%3F%20How%20to%20process%20arguments%20to%20a%20variadic%20template%20%3F%3F%3F%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-variadic-process%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rt-variadic-process%22%2C%22anchor%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic-process" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-variadic-process" class="">T.102: ??? How to process arguments to a variadic template ???</a></li></ul></div>
<div class="text">Du kannst es bereits erahnen. Die drei Regeln bestehen nur aus den Überschriften. Ich werde eine Geschichte daraus machen.</div>
<div class="text">Wie versprochen, entwickle ich <i>std::make_unique. </i>Es ist ein Funktions-Template, das ein dynamisch allokiertes Objekt in einem Smart Pointer <i>std::unique_ptr </i>erzeugt und zurückgibt. Hier sind ein paar Anwendungsfälle:</div>
<div class="pre">// makeUnique.cpp<br><br>#include &lt;memory&gt;<br><br>struct MyType{<br>&nbsp;&nbsp;&nbsp; MyType(int, double, bool){};<br>};<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int lvalue{2020};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::unique_ptr&lt;int&gt; uniqZero = std::make_unique&lt;int&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto uniqEleven = std::make_unique&lt;int&gt;(2011);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto uniqTwenty = std::make_unique&lt;int&gt;(lvalue);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto uniqType = std::make_unique&lt;MyType&gt;(lvalue, 3.14, true); // (4)<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Basierend auf diesem Anwendungsfall stellt sich die Frage: Welche Anforderungen muss <i>std::make_unique</i> erfüllen?</div>
<div class="text"><ol><li> Es soll mit einer beliebigen Anzahl von Argumenten umgehen können. Die verwendeten <i>std::make_unique</i>-Aufrufe besitzen 0, 1 und 3 Argumente.</li><li>Es soll mit Rvalues und Lvalues umgehen können. Der <i>std::make_unique</i>-Aufruf in Zeile (2) erhält einen Rvalue und der in Zeile (3) einen Lvalue. Der letzte Aufruf in Zeile (4) bekommt einen Rvalue und einen Lvalue.</li><li>Es soll seine Argumente unverändert an den zugrunde liegenden Konstruktor weiterreichen. Das heißt, der Konstruktor von <i>std::unique_ptr </i>soll einen Lvalue/Rvalue erhalten, wenn <i>std::make_unique</i> einen Lvalue/Rvalue erhält. <br></li></ol></div>
<div class="text">Diese Anforderungen sind typisch für Fabrikfunktionen wie <i>std::make_unique, std::make_shared, std::make_tuple</i>, aber auch für <i>std::thread.</i> Alle nützen zwei mächtige Features von C++11:</div>
<div class="text"><ol><li>Perfect Forwarding<br></li><li>Variadic Templates</li></ol></div>
<div class="text">Jetzt entwickle ich eine Fabrikfunktion <i>createT</i>. Los geht es mit Perfect Forwarding.</div>
<div class="ztitel">Perfect Forwarding<br></div>
<div class="text">Perfect Forwarding erlaubt es, die Wert-Kategorien (Lvalue/Rvalue) und die<i> const/volatile</i>-Qualifier des Arguments beizubehalten. Es tritt typischerweise in einem Pattern auf, das aus einer Universal-Referenz und <i>std::forward</i> besteht: </div>
<div class="pre">template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>void create(T&amp;&amp; t){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::forward&lt;T&gt;(t);&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>}<br></div>
<div class="text">Die drei Komponenten, um Perfect Forwarding zu erhalten, sind: </div>
<div class="text"><ol><li>Verwende einen Template-Parameter T: <i>typename T</i></li><li>Binde T mit einer Universal-Referenz, die auch unter den Namen Perfect-Forwarding-Referenz bekannt ist: <i>T&amp;&amp; t</i></li><li>Rufe std::forward auf dem Argument auf: <i>std::forward&lt;T&gt;(t)</i></li></ol></div>
<div class="text">Die entscheidende Beobachtung ist, dass <i>T&amp;&amp;</i> (Zeile 2) einen Lvalue und einen Rvalue binden kann und dass <i>std::forward </i>in Zeile (3) perfekt weiterleitet.</div>
<div class="text">Nun ist es an der Zeit, einen Prototyp für die Fabrikfunktion <i>createT</i> zu implementieren. Am Ende soll sich <i>createT </i>wie der [i]std::make_unique[/i]-Aufruf in dem Programm in<i> makeUnique.cpp</i> verhalten. Ich habe lediglich <i>std::make_unique </i>in dem Programm mit <i>createT</i> Aufruf ersetzt, die <i>createT-</i>Fabrikfunktion hinzugefügt und die Zeilen (1) und (4) auskommentiert. Zusätzlich ist der Header <i>&lt;memory&gt;(std::make_unique)</i> dem header <i>&lt;utility&gt;(std::forward) </i>gewichen:</div>
<div class="pre">// createT1.cpp<br><br>#include &lt;utility&gt;<br><br>struct MyType{<br>&nbsp;&nbsp;&nbsp; MyType(int, double, bool){};<br>};<br><br>template &lt;typename T, typename Arg&gt;<br>T createT(Arg&amp;&amp; arg){<br>&nbsp;&nbsp;&nbsp; return T(std::forward&lt;Arg&gt;(arg));<br>}<br>&nbsp;&nbsp;&nbsp; <br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int lvalue{2020};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; //std::unique_ptr&lt;int&gt; uniqZero = std::make_unique&lt;int&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto uniqEleven = createT&lt;int&gt;(2011);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto uniqTwenty = createT&lt;int&gt;(lvalue);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; //auto uniqType = std::make_unique&lt;MyType&gt;(lvalue, 3.14, true); // (4)<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Ein Rvalue (Zeile 2) und eine Lvalue (Zeile 3) bestehen meinen Test.</div>
<div class="ztitel">Variadic Templates<br></div>
<div class="text">Manchmal hängt alles an ein paar Punkten. Werden genau neun Punkte an den richtigen Stellen platziert, sind die Zeilen (1) und (4) gültig:<br></div>
<div class="pre">// createT2.cpp<br><br>#include &lt;utility&gt;<br><br>struct MyType{<br>&nbsp;&nbsp;&nbsp; MyType(int, double, bool){};<br>};<br><br>template &lt;typename T, typename ... Args&gt;<br>T createT(Args&amp;&amp; ... args){<br>&nbsp;&nbsp;&nbsp; return T(std::forward&lt;Args&gt;(args) ... );<br>}<br>&nbsp;&nbsp;&nbsp; <br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int lvalue{2020};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; int uniqZero = createT&lt;int&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; auto uniqEleven = createT&lt;int&gt;(2011);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; auto uniqTwenty = createT&lt;int&gt;(lvalue);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto uniqType = createT&lt;MyType&gt;(lvalue, 3.14, true); // (4)<br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Wie funktioniert die ganze Magie? Drei Punkte stehen für eine Ellipse. Durch ihre Verwendung werden <i>Args</i> und <i>args</i> zu einem Parameter-Pack. Um genauer zu sein, <i>Args</i> ist ein Template-Parameter-Pack und <i>args</i> ist ein Funktions-Parameter-Pack. Du kannst nur zwei Operationen auf einem Parameter-Pack anwenden: packen und entpacken. Wenn die Ellipse links von <i>Args</i> steht, wird gepackt, wenn sie rechts von <i>Args</i> steht, entpackt. Im Falle des Ausdrucks [i](std::forward&lt;Args&gt;(args)...)[/i] bedeutet dies, dass der Ausdruck entpackt wird, bis er konsumiert ist und ein Komma zwischen die entpackten Komponenten platziert wird. Das ist alles.<br></div>
<div class="text"><a title="Link auf https://cppinsights.io/" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22CppInsight%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2F%22%2C%22target%22%3A%22_blank%22%7D" class="" href="https://cppinsights.io/">CppInsight</a> erlaubt es, unter die Decke zu blicken: </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164436213_40f9770ae5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164436220_5598d7ef21.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt bin ich fast fertig. Hier ist meine <i>createT-</i>Fabrikfunktion nochmals:<br></div>
<div class="pre">template &lt;typename T, typename ... Args&gt;<br>T createT(Args&amp;&amp; ... args){<br>&nbsp;&nbsp;&nbsp; return T(std::forward&lt;Args&gt;(args) ... );<br>}<br></div>
<div class="text">Zwei Schritte fehlen noch, um <i>std::make_unique</i> zu erhalten:<br></div>
<div class="text"><ol><li>Erzeugen eines <i>std::unique_ptr&lt;T&gt;</i> anstelle eines einfachen T.</li><li>Die Funktion in <i>make_unique</i> umbenennen. <br></li></ol></div>
<div class="ztitel">std::make_unique<br></div>
<div class="pre">template &lt;typename T, typename ... Args&gt;<br>std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp; ... args){<br>&nbsp;&nbsp;&nbsp; return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args) ... ));<br>}<br></div>
<div class="text">Jetzt habe ich doch beinahe den furchteinflößenden Teil meines Artikels vergessen.</div>
<div class="ztitel">printf<br></div>
<div class="text">Klar kennst du die C-Funktion <i>printf.</i> Hier ist die Signatur der Funktion: <span class="mw-geshi cpp source-cpp"><i>int printf( const char* format, ... );</i>. [i]printf[/i] ist eine Funktion, die eine beliebige Anzahl an Argumenten annehmen kann. Ihre Mächtigkeit basiert auf dem Makro <i>va_arg</i>. Damit ist sie nicht typsicher. </span></div>
<div class="text">Dank Variadic Templates kann <i>printf</i> in einer typsicheren Variante implementiert werden:</div>
<div class="pre">// myPrintf.cpp<br><br>#include &lt;iostream&gt;<br>&nbsp;<br>void myPrintf(const char* format){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; format;<br>}<br>&nbsp;<br>template&lt;typename T, typename ... Args&gt;<br>void myPrintf(const char* format, T value, Args ... args){&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; for ( ; *format != '\0'; format++ ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( *format == '%' ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myPrintf(format + 1, args ... );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; *format;<br>&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;<br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; myPrintf("\n");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; myPrintf("% world% %\n", "Hello", '!', 2011);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; myPrintf("\n");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>}<br></div>
<div class="text">Jetzt ist eine Erklärung notwendig. Wenn<i> myPrintf </i>lediglich mit einem Formatstring (Zeile 1) aufgerufen wird, kommt die Funktion in der Zeile (3) zum Einsatz. Im Falle von Zeile (2), kommt das Funktions-Template in Zeile (4) zum Einsatz. Das Funktions-Template (Zeile 5) befindet sich in der Endlosschleife, solange das Formatsymbol nicht<i> '\0'&nbsp;</i> ist. Falls das Formatsymbol nicht <i>'\0' </i>ist, sind zwei Kontrollflüsse möglich. Erstens, falls der Formatstring mit<i> '%' </i>beginnt (Zeile 6), werden das erste Argument <i>value </i>ausgegeben und <i>myPrintf</i> nochmals ausgerufen. Dieses Mal aber mit einem neuen Formatsymbol und einem Argument weniger (Zeile 7). Zweitens, falls der Formatstring nicht mit <i>'%' </i>beginnt, wird das Formatsymbol lediglich ausgegeben (Zeile 8). Die Funktion <i>myPrintf</i> (Zeile 3) stellt die Endbedingungen für die rekursiven Aufrufe dar.</div>
<div class="text">Das Programm produziert die erwartete Ausgabe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_164436226_04157292f3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="ztitel_kleiner">Wie geht' weiter?</div>
<div class="text">Eine Regel zur Variadic Templates gibt es noch. Danach folgt in den Guidelines Template Metaprogrammierung. Ich bin mir noch nicht so sicher, wie tief ich in Template-Metaprogrammierung einsteigen werde.</div>
