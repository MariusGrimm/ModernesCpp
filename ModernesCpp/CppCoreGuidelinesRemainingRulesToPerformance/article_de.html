<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580720_ad47b33178.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Heute geht es um die zehn verbleibenden Regeln zur Performanz. Das hört sich nach einem sehr langen Artikel an, ist er aber nicht, da nur zwei Regeln einen Inhalt besitzen.</div>
<div class="text">Hier sind die restlichen Regeln zur Performanz:</div>
<div class="text"><ul> <li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-Comp" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-Comp%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Per.11%3A%20Move%20computation%20from%20run%20time%20to%20compile%20time%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-Comp%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-Comp">Per.11: Move computation from run time to compile time</a> </li> <li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-alias" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-alias" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-alias%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Per.12%3A%20Eliminate%20redundant%20aliases%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-alias%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D">Per.12: Eliminate redundant aliases</a> </li> <li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-indirect" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Per.13%3A%20Eliminate%20redundant%20indirections%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-indirect%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-indirect%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-indirect">Per.13: Eliminate redundant indirections</a> </li> <li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-alloc" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-alloc%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-alloc%22%2C%22text%22%3A%22Per.14%3A%20Minimize%20the%20number%20of%20allocations%20and%20deallocations%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-alloc">Per.14: Minimize the number of allocations and deallocations</a> </li> <li> <a alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-alloc0%22%2C%22text%22%3A%22Per.15%3A%20Do%20not%20allocate%20on%20a%20critical%20branch%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-alloc0%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-alloc0" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-alloc0">Per.15: Do not allocate on a critical branch</a> </li> <li> <a alt="%7B%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-compact%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-compact%22%2C%22text%22%3A%22Per.16%3A%20Use%20compact%20data%20structures%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-compact" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-compact">Per.16: Use compact data structures</a> </li> <li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-struct" alt="%7B%22text%22%3A%22Per.17%3A%20Declare%20the%20most%20used%20member%20of%20a%20time-critical%20struct%20first%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-struct%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-struct%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-struct">Per.17: Declare the most used member of a time-critical struct first</a> </li> <li> <a alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-space%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-space%22%2C%22text%22%3A%22Per.18%3A%20Space%20is%20time%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-space" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-space">Per.18: Space is time</a> </li> <li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-access" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-access%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Per.19%3A%20Access%20memory%20predictably%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-access%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-access">Per.19: Access memory predictably</a> </li> <li><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-context" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Per.30%3A%20Avoid%20context%20switches%20on%20the%20critical%20path%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-context%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-context%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-context">Per.30: Avoid context switches on the critical path</a></li></ul></div>
<div class="text">Ich werde einen genaueren Blick auf die Regeln Per.11 und Per.19 werfen.&nbsp;</div>
<div class="text"><b><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-Comp" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-Comp" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-Comp%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Per.11%3A%20Move%20computation%20from%20run%20time%20to%20compile%20time%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-Comp%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D">Per.11: Move computation from run time to compile time</a></b></div>
<div class="text">Das Beispiel zeigt den einfachen gcd-Algorithmus, der den größten gemeinsamen Teiler zweier Zahlen zur Laufzeit des Programms ermittelt. gcd verwendet für seine Berechnung den <a title="Link auf https://de.wikipedia.org/wiki/Euklidischer_Algorithmus" class="" alt="%7B%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEuklidischer_Algorithmus%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22euklidischen%20Algorithmus%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FEuklidischer_Algorithmus%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" href="https://de.wikipedia.org/wiki/Euklidischer_Algorithmus">euklidischen Algorithmus</a>:</div>
<div class="pre">int gcd(int a, int b){<br>&nbsp;&nbsp;&nbsp; while (b != 0){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto t= b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b= a % b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a= t;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return a;<br>}</div>
<div class="text">Indem gcd als konstanter Ausdruck deklariert wird, lässt er sich einfach zur Funktion erklären, die auch zur Übersetzungszeit ausgeführt werden kann. Es gibt in C++14 nur noch wenige Einschränkungen für <i>constexpr</i>-Funktionen. gcd darf keine statischen oder thread-lokale Variablen verwenden. Darüber hinaus sind keine Ausnahmebehandlungen und <i>goto</i>-Anweisungen zulässig. Variablen müssen direkt initialisiert werden und einen<a href="http://en.cppreference.com/w/cpp/concept/LiteralType" alt="%7B%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22%20literalen%20Typ%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fconcept%2FLiteralType%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fconcept%2FLiteralType%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%7D" class="" title="Link auf http://en.cppreference.com/w/cpp/concept/LiteralType"> literalen Typ</a> besitzen. </div>
<div class="text">Das muss ich ausprobieren:</div>
<div class="pre">// gcd.cpp<br><br>#include &lt;iostream&gt;<br><br>constexpr int gcd(int a, int b){<br>&nbsp;&nbsp;&nbsp; while (b != 0){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto t= b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b= a % b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a= t;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return a;<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; constexpr auto res = gcd(121, 11);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd(121, 11) = " &lt;&lt; res &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; auto val = 121;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; auto res2 = gcd(val, 11);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "gcd(val, 11) = " &lt;&lt; res2 &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Das <i>gcd </i>zur <i>constexpr</i>-Funktion erklärt wird, heißt nicht, dass sie automatisch zur Übersetzungszeit ausgeführt wird. Das bedeutet nur, dass die Funktion <i>gcd </i>das Potenzial besitzt, zur Übersetzungszeit ausgeführt zu werden. Eine <i>constexpr</i>-Funktion muss zur Übersetzungszeit ausgeführt werden, wenn sie in einem konstanten Ausdruck verwendet wird. (1) ist ein konstanter Ausdruck, da ich das Ergebnis mit der <i>constexpr</i>-Variable<i> res </i>annehme (2). (3) ist kein konstanter Ausdruck, denn <i>res2</i> ist kein konstanter Ausdruck. Wenn ich <i>res2 </i>als c<i>onstexpr auto res2 </i>deklariere, bekomme ich einen Fehler. Der Grund ist, dass <i>val </i>kein konstanter Ausdruck ist. Der Screenshot zeigt die Ausgabe des Programms; </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580740_351dccdf44.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Hier nochmals meine zentrale Aussage: <b>Du kannst eine <i>constexpr</i> Funktion zur Laufzeit und zur Übersetzungszeit ausführen. Um zur Übersetzungszeit ausgeführt werden zu können, benötigt sie Argumente, die konstante Ausdrücke sind.</b></div>
<div class="text">Du glaubst mir nicht, dass die Zeile (1) zur Übersetzungszeit ausgeführt wird? Hier ist der Beweis: Die Abbildung zeigt die der Zeile (1) entsprechenden Assember Anweisungen, die der GCC 7.3 mit maximaler Optimierung erzeugt hat. Die Ausgabe habe ich mithilfe des<a title="Link auf https://godbolt.org/" class="" href="https://godbolt.org/" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22text%22%3A%22%20Compiler%20Explorer%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D"> Compiler Explorer</a> von Matt Godbolt erzeugt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580735_daf8eb2881.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Der Funktionsaufruf <i>gcd(121, 11) </i>reduziert sich direkt auf das Ergebnis: 11. </div>
<div class="text">Templates werden gerne verwendet, um Entscheidungen zur Übersetzungszeit zu treffen. Die C++ Core Guidelines stellen ein schönes Beispiel dazu vor. Eine beliebte Technik ist es, einen Handle für das Speichern von Daten auf dem Stack anzulegen, wenn diese klein genug sind. Wenn nicht, werden die Daten auf dem Heap verwaltet. Hier ist das Beispiel:</div>
<div class="pre">template&lt;typename T&gt;<br>struct Scoped {&nbsp;&nbsp;&nbsp;&nbsp; // store a T in Scoped<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; T obj;<br>};<br><br>template&lt;typename T&gt;<br>struct On_heap {&nbsp;&nbsp;&nbsp; // store a T on the free store<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T* objp;<br>};<br><br>template&lt;typename T&gt;<br>using Handle = typename std::conditional&lt;(sizeof(T) &lt;= on_stack_max),&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Scoped&lt;T&gt;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first alternative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On_heap&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // second alternative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;::type;<br><br>void f()<br>{<br>&nbsp;&nbsp;&nbsp; Handle&lt;double&gt; v1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the double goes on the stack<br>&nbsp;&nbsp;&nbsp; Handle&lt;std::array&lt;double, 200&gt;&gt; v2;&nbsp; // the array goes on the free store<br>&nbsp;&nbsp;&nbsp; // ...<br>}<br></div>
<div class="text">Wie funktioniert das Ganze? <i>std::conditional</i> in Zeile (1) ist ein ternärer Operator aus der Type-Traits Bibliothek. Im Gegensatz zum ternären Operator (<i>a ? b : c</i>) wird er aber zur Übersetzungszeit ausgeführt. Das bedeutet, falls <i>std::condition&lt;sizeof(T) &lt;= on_stack_max)</i> zu <i>true </i>evaluiert wird, wird die erste Alternative ausgewählt. Falls nicht, die zweite.</div>
<div class="text"><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-access" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rper-access" alt="%7B%22text%22%3A%22Per.19%3A%20Access%20memory%20predictably%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-access%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rper-access%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%7D">Per.19: Access memory predictably</a></b></div>
<div class="text">Was soll das heißen? Wenn eine Variable <i>int</i> vom Hauptspeicher gelesen wird, wird tatsächlich deutlich mehr als 4 Bytes vom Speicher gelesen. Ein ganze Cacheline wird gelesen und im Cache gespeichert. Auf modernen Architekturen besitzt eine Cacheline typischerweise 64 Bytes. Wenn nun nochmals eine Variable aus dem Hauptspeicher angefordert wird und sich die Variable bereits im Cache befindet, verwendet die Leseoperation direkt den Cache und ist damit deutlich schneller. </div>
<div class="text">Ein Container wie <i>std::vector,</i> der seine Daten in einem kontinuierlichen Speicherbereich speichert, ist eine Datenstruktur, die Cachelines optimal ausnützt. Ein<i> std::vector</i> besitzt eine Größe und eine Kapazität und wächst nur in eine Richtung. Seine Kapazität ist größer als seine Größe und sie zeigt an, wann Speicher neu allokiert werden muss. Diese Argumentation gilt auch für<i> std::string </i>und <i>std::array</i>. Das <i>std::array</i> besitzt aber keine Kapazität. <br></div>
<div class="text"><b><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580742_30bb4fc3ce.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></b></div>
<div class="text">Meine Argumentation zum <i>std::vector</i> gilt aber nicht für <i>std::list</i> oder <i>std::forward_list</i>. Beide Container bestehen aus Knoten, die doppelt oder einfach verknüpft sind.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580748_898bd25fef.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die <i>std::foward_list </i>kann nur in eine Richtung wachsen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580759_62c4fede71.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><i>std::deque</i> bewegt sich zwischen beiden Extremen , denn sie ist eine Art doppelt verkettete Liste von Speicherbereichen. <br></div>
<div class="text"><b><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580762_522f5be739.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></b></div>
<div class="text">Dies war die Theorie zu den Cachelines. Nun bin ich aber neugierig: Macht es einen Performanzunterschied, alle Elemente einer <i>std::vector</i>, einer <i>std::deque</i>, einer <i>std::list</i> und einer <i>std::forward_list</i> zu lesen und mit <i>std::accumulate</i> ihre Summe zu berechnen? Dieses kleine Programm liefert die Antwort:<br></div>
<div class="pre">// memoryAcess.cpp<br><br>#include &lt;forward_list&gt;<br>#include &lt;chrono&gt;<br>#include &lt;deque&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;numeric&gt;<br>#include &lt;random&gt;<br><br>const int SIZE = 100'000'000; <br><br>template &lt;typename T&gt;<br>void sumUp(T&amp; t, const std::string&amp; cont){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);<br><br>&nbsp; auto begin= std::chrono::steady_clock::now();<br>&nbsp; std::size_t res = std::accumulate(t.begin(), t.end(), 0LL);<br>&nbsp; std::chrono::duration&lt;double&gt; last=&nbsp; std::chrono::steady_clock::now() - begin;<br>&nbsp; std::cout &lt;&lt; cont &lt;&lt;&nbsp; std::endl;<br>&nbsp; std::cout &lt;&lt; "time: " &lt;&lt; last.count() &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::random_device seed;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::mt19937 engine(seed());<br>&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;int&gt; dist(0, 100);<br>&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; randNumbers;<br>&nbsp;&nbsp;&nbsp; randNumbers.reserve(SIZE);<br>&nbsp;&nbsp;&nbsp; for (int i=0; i &lt; SIZE; ++i){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; randNumbers.push_back(dist(engine));<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; myVec(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myVec,"std::vector&lt;int&gt;");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::deque&lt;int&gt;myDec(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myDec,"std::deque&lt;int&gt;");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::list&lt;int&gt;myList(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myList,"std::list&lt;int&gt;");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::forward_list&lt;int&gt;myForwardList(randNumbers.begin(), randNumbers.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumUp(myForwardList,"std::forward_list&lt;int&gt;");&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Das Programm<i> memoryAccess.cpp </i>erzeugt zuerst einmal 100 Millionen Zufallszahlen zwischen 0 and 100 (1). Dann summiert es die Zahlen mit einem <i>std::vector</i> (2), einer<i> std::deque</i> (3), einer <i>std::list </i>(4) und einer <i>std::forward_list </i>(5) zusammen. Die eigentliche Arbeit findet in der Funktion <i>sumUp</i> (6) statt. Ich nehme an, dass Linux und Windows eine ziemlich ähnliche Implementierung des <i>std::accumulate</i>-Algorithmus verwenden.&nbsp; <br></div>
<div class="pre">template&lt;class InputIt, class T&gt;<br>T accumulate(InputIt first, InputIt last, T init)<br>{<br>&nbsp;&nbsp;&nbsp; for (; first != last; ++first) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init = init + *first;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return init;<br>}<br></div>
<div class="text">Daher ist die Zugriffszeit auf die Elemente der Container der dominante Faktor für die Gesamtperformanz.</div>
<div class="text">Ich übersetzte das Programm mit maximaler Optimierung unter Linux und Windows. Mich interessiert in diesem Fall nicht der Performanzunterschied zwischen Linux und Windows, da dies ein Vergleich zwischen einem Desktop-PC und einem Laptop wäre. Mich interessiert die relative Performanz der vier Container. Hier ist sie:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580767_c6f9cb0e0c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:11 type=1>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_151580777_e17eac3d2b.png" title="<ir_inline itemname=bilder_mvp_bild_var2:12 type=3>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Für das Gesamtbild. Dies sind meine Beobachtungen:</div>
<div class="text"><ul><li> <i>std::vector </i>ist auf Linux 10-mal schneller als <i>std::lis</i>t oder <i>std::forward_list</i>; <i>std::vector</i> ist auf Windows 30-mal schneller als <i>std::list</i> oder <i>std::forward_list.</i></li><li><i>std::vector</i> ist auf Linux 1,5-mal schneller als <i>std::deque </i>und auf Windows 5-mal schneller als <i>std::deque</i>. Der Grund ist vermutlich, dass die zusammenhängenden Speicherbereiche auf Linux größer sind als auf Windows. Damit ist die Zugriffszeit auf Linux der eines <i>std::vector </i>sehr ähnlich.</li><li><i>std::deque </i>ist 16-mal schneller als <i>std::list </i>oder <i>std::forward_list</i>. Dies gilt für Linux und Windows.</li><li><i>std::list</i> und <i>std::forward_list</i> sind ähnlich schnell auf Linux und Windows.<br></li></ul></div>
<div class="text">Ich will meine Performanzzahlen nicht überbewerten, aber eine Beobachtung lässt sich auf jeden Fall ableiten. Je optimierter eine Datenstrukur für Cachelines ist, desto schneller ist die Zugriffszeit: <i><b>std::vector &gt; std::deque &gt; (std::list, std::forward_list).</b></i></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Dies waren die Regeln zur Performanz. Mit dem nächsten Artikel werde ich beginnen, zu den Regeln zur Concurrency zu schreiben.</div>
<div class="ztitel">Weitere Informationen</div>
<div class="text">Die neuen PDF-Päckchen stehen zum Download bereit:</div>
<div class="text"><ul><li>Deutsch: <a title="Link auf https://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-charakteristiken-der-funktionalen-programmierung" class="" alt="%7B%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-charakteristiken-der-funktionalen-programmierung%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Charakteristiken%20der%20funktionalen%20Programmierung%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-charakteristiken-der-funktionalen-programmierung%22%7D" href="https://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-charakteristiken-der-funktionalen-programmierung">Charakteristiken der funktionalen Programmierung</a> <br></li><li>Englisch: <a href="http://www.modernescpp.com/index.php/the-new-pdf-bundle-is-ready-functional-features-in-c" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-ready-functional-features-in-c%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-ready-functional-features-in-c%22%2C%22text%22%3A%22Functional%20Features%20in%20C%2B%2B%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" title="Link auf http://www.modernescpp.com/index.php/the-new-pdf-bundle-is-ready-functional-features-in-c" class="">Functional Features in C++</a> <br></li></ul></div>