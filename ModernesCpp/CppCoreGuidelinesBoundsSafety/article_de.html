<div class="vorspann">Der heutige Artikel beschäftigt sich mit dem zweiten Profil der C++ Core Guidelines:<br>Bounds Safety. Dessen Ziel ist es, dass keine Operation über die Grenzen des allokierten Speichers hinausgreift.</div><div class="text">Das Profil nennt zuerst die zwei Feinde der Bounds Safety: Zeigerarithmetik und Indexoperationen. Zusätzlich sollst du nur Zeiger verwenden, die auf ein Objekt verweisen. Dies schließt natürlich Arrays aus. Um die Bounds Safety abzurunden, ist es notwendig, die Regeln zur Type Safety und zur Lifetime Safety einzuhalten. Zur Type Safety habe ich bereits zwei Artikel geschrieben: <a alt="%7B%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22B%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dfbe67855ee4301cafb8c4fbc8226ce91%26rm%3Dopen_article_id%26bid%3D2747284%22%2C%22destination%22%3A2747284%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Type%20Safety%22%7D" href="/exec/mainmenu.pl?sid=fbe67855ee4301cafb8c4fbc8226ce91&amp;rm=open_article_id&amp;bid=2747284" title="Link auf Beitrag 2747284">C++ Core Guidelines: Type Safety</a> und <a alt="%7B%22type%22%3A%22B%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Type%20Safety%20by%20Design%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A2753502%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dfbe67855ee4301cafb8c4fbc8226ce91%26rm%3Dopen_article_id%26bid%3D2753502%22%7D" href="/exec/mainmenu.pl?sid=fbe67855ee4301cafb8c4fbc8226ce91&amp;rm=open_article_id&amp;bid=2753502" title="Link auf Beitrag 2753502">C++ Core Guidelines: Type Safety by Design</a>. Mit der Lifetime Safety werde ich mich im nächsten Artikel befassen. <br></div><div class="ztitel"><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-bounds" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-bounds" alt="%7B%22text%22%3A%22Bounds%20Safety%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-bounds%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23SS-bounds%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">Bounds Safety</a> <br></div><div class="text">Die Bounds Safety besteht aus vier Regeln:</div><div class="text"><ul><li>Bounds.1: Don't use pointer arithmetic</li><li>Bounds.2: Only index into arrays using constant expressions</li><li>Bounds.3: No array-to-pointer decay</li><li>Bounds.4: Don't use standard-library functions and types that are not bounds-checked</li></ul></div><div class="text">Die vier Regen zur Bounds Safety beziehen sich auf drei Regeln der C++ Core Guidelines. Wie in meinen vorherigen Artikeln werde ich daher Hintergrundinformationen hinzufügen, falls dies notwendig ist. </div><div class="ztitel_kleiner">Bounds.1: Don't use pointer arithmetic, Bounds.2: Only index into arrays using constant expressions und Bounds.3: No array-to-pointer decay</div><div class="text">Die Begründung der drei Regeln lässt sich auf drei Do's reduzieren: Übergebe nur Zeiger auf einzelne Elemente, wende nur einfache Zeigerarithmetik an und verwende [code]std::span[/code]. Die erste Regel möchte ich gerne negativ formulieren: Übergib keine Zeiger auf Arrays. Ich vermute, du kennst [code]std::span[/code] nicht? [code]std::span&lt;T&gt;[/code] repräsentiert einen kontinuierlichen Speicherbereich, den er nicht besitzt. Dieser Bereich kann ein Array, ein Zeiger mit einer Länge oder ein [code]std::vector[/code] sein.&nbsp;&nbsp;</div><div class="text">Die Guidelines bringen es deutlich auf den Punkt: "Complicated pointer manipulation is a major source of errors." Warum sollte uns das interessieren? Klar, unser Legacy-Code ist voll mit Altlasten wie im folgendem Beispiel: </div><div class="pre">void f(int* p, int count)<br>{<br>&nbsp;&nbsp;&nbsp; if (count &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int* q = p + 1;&nbsp;&nbsp;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; int n = *p++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; if (count &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; p[4] = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; p[count - 1] = 2;&nbsp; // BAD<br><br>&nbsp;&nbsp;&nbsp; use(&amp;p[0], 3);&nbsp;&nbsp;&nbsp;&nbsp; // BAD<br>}<br><br>int myArray[100];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>f(myArray, 100),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br></div><div class="text">Das dominante Problem dieses Codebeispiels ist es, dass der Aufruf der Funktion die richtige Länge des C-Arrays übergeben muss. Falls nicht, resultiert es in undefiniertes Verhalten.</div><div class="text">Denke über die letzten zwei Zeilen (1) und (2) ein paar Sekunden nach. Diese beginnen mit einem Array, von dem seine Typinformation entfernt wird, indem es als Argument der Funktion [code]f[/code] verwendet wird. Dieser Prozess nennt sich "array to poiner decay" und ist der Grund für viele Fehler. Vielleicht hatte der Autor dieser Zeilen einen schlechten Tag und er zählte die Anzahl der Elemente falsch oder die Größe des C-Arrays ändert sich nachträglich. Egal, das Ergebnis ist immer dasselbe: undefiniertes Verhalten. Dieselbe Argumentation gilt natürlich auch für einen C-String.</div><div class="text">Was sollen wir das tun? Wir sollten den richtigen Datentyp verwenden. Die Guidelines empfehlen den Container [code]std::span[/code]<i>.</i> Hier ist ein kleiner Codeschnipsel:<br></div><div class="pre">void f(span&lt;int&gt; a) // BETTER: use span in the function declaration<br>{<br>&nbsp;&nbsp;&nbsp; if (a.length() &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int n = a[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br><br>&nbsp;&nbsp;&nbsp; span&lt;int&gt; q = a.subspan(1); // OK<br><br>&nbsp;&nbsp;&nbsp; if (a.length() &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; a[4] = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK<br><br>&nbsp;&nbsp;&nbsp; a[count - 1] = 2;&nbsp; // OK<br><br>&nbsp;&nbsp;&nbsp; use(a.data(), 3);&nbsp; // OK<br>}<br></div><div class="text">Gut! [code]std::span[/code] prüft zur Laufzeit seine Grenzen. </div><div class="text">Ich höre bereits Bedenken. Wir setzen noch kein C++20 ein. Die Funktion [code]f[/code] lässt sich direkt mithilfe des Containers [code]std::array[/code] und seiner Method [code]std::array::at[/code] neu formulieren. Hier ist sie:</div><div class="pre">// spanVersusArray.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;array&gt;<br><br>void use(int*, int){}<br><br>void f(std::array&lt;int, 100&gt;&amp; a){<br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int n = a.at(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 99&gt; q;<br>&nbsp;&nbsp;&nbsp; std::copy(a.begin() + 1, a.end(), q.begin());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; a.at(4) = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; a.at(a.size() - 1) = 2;<br><br>&nbsp;&nbsp;&nbsp; use(a.data(), 3); <br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 100&gt; arr{};<br><br>&nbsp;&nbsp;&nbsp; f(arr);<br>&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text">Der [code]std::array::at[/code]-Operator prüft zur Laufzeit seine Grenzen. Falls [code]pos &gt;= size[/code], wirft er eine [code]std::out_of_range[/code]-Ausnahme. Wer das Programm [code]spanVersusArray.cpp[/code] sorgfältig studiert, dem fallen zwei Einschränkungen auf. Zuerst ist der Ausdruck (1) deutlich wortreicher als die entsprechende [code]std::span[/code]-Version. Darüber hinaus ist die Länge des [code]std::array[/code] Bestandteil der Signatur der Funktion. Das ist sehr schlecht. In diesem Fall kann die Funktion nur mit dem Container [code]std::array&lt;int, 100&gt;[/code] verwendet werden. Damit ist auch die Prüfung der Array-Größe im Funktionskörper überflüssig.</div><div class="text">Zu unserer Rettung besitzt C++ Templates. Daher ist es einfach, diese Einschränkungen zu überwinden und trotzdem typsicher zu bleiben:<br></div><div class="pre">// at.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;array&gt;<br>#include &lt;deque&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>template &lt;typename T&gt;<br>void use(T*, int){}<br><br>template &lt;typename T&gt;<br>void f(T&amp; a){<br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 2) return;<br><br>&nbsp;&nbsp;&nbsp; int n = a.at(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; std::array&lt;typename T::value_type , 99&gt; q;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp;&nbsp;&nbsp; std::copy(a.begin() + 1, a.end(), q.begin());&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; if (a.size() &lt; 6) return;<br><br>&nbsp;&nbsp;&nbsp; a.at(4) = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; a.at(a.size() - 1) = 2;<br><br>&nbsp;&nbsp;&nbsp; use(a.data(), 3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>}<br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; std::array&lt;int, 100&gt; arr{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; f(arr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::array&lt;double, 20&gt; arr2{};<br>&nbsp;&nbsp;&nbsp; f(arr2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;double&gt; vec{1, 2, 3, 4, 5, 6, 7, 8, 9};<br>&nbsp;&nbsp;&nbsp; f(vec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string myString= "123456789";<br>&nbsp;&nbsp;&nbsp; f(myString);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // std::deque&lt;int&gt; deq{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>&nbsp;&nbsp;&nbsp; // f(deq);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>}<br></div><div class="text">Jetzt lässt sich die Funktion [code]f[/code] auf [code]std::array[/code]s' beliebiger Länge (1) und beliebigem zugrunde liegenden Datentyp (2) anwenden. Darüber hinaus kann sie mit einem [code]std::vector[/code] (3) oder einem [code]std::string[/code] (4) aufgerufen werden. Diesen Containern ist gemeinsam, dass ihre Daten einem kontinuierlichen Speicherbereich gespeichert werden. Das gilt nicht für [code]std::deque[/code], und somit schlägt der Aufruf [code]a.data()[/code] im Ausdruck (6) fehl. Ein [code]std::deque[/code] ist eine Art doppelt verkettete Liste kleiner Speicherbereiche. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_181029870_df7d397e26.png" title="<ir_inline itemname=bilder_mvp_bild:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Der Ausdruck [code]T::value_type[/code] (5) erlaubt es, den zugrunde liegenden Typ eines Containers zu erhalten. [code]T[/code] ist ein sogenannter Dependent Typ, den [code]T[/code] ist ein Typ-Parameter des Funktions-Templates [code]f[/code]<i>.</i> Das ist der Grund, dass ich dem Compiler unter die Arme greife und ihm einen Hinweis geben muss, dass er in diesem Fall [code]T::value_type[/code] als Typ interpretieren soll: [code]typename T::value_type[/code].</div><div class="ztitel_kleiner">Bounds.4: Don't use standard-library functions and types that are not bounds-checked<br></div><div class="text">Ich habe bereits einen Artikel <a alt="%7B%22destination%22%3A2693463%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dfbe67855ee4301cafb8c4fbc8226ce91%26rm%3Dopen_article_id%26bid%3D2693463%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Greife%20nicht%20%C3%BCber%20den%20Container%20hinaus%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22B%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" title="Link auf Beitrag 2693463" href="/exec/mainmenu.pl?sid=fbe67855ee4301cafb8c4fbc8226ce91&amp;rm=open_article_id&amp;bid=2693463">C++ Core Guidelines: Greife nicht über den Container hinaus</a> geschrieben. Diese Artikel gibt viele Hintergrundinformationen zu der Regel.<br></div><div class="ztitel">Wie geht's weiter? <br></div><div class="text">Der Name des dritten Profils ist Lifetime Safety. Dieses Profil, dem ich mich im nächsten Artikel widme, besteht aus einer Regel: Verwende keinen ungültigen Zeiger.<br></div><div class="simple-translate-result-wrapper"><br> <br></div>