<div class="vorspann">Es gibt mehr zu Anwendung von regulären Ausdrücken zu schreiben, als das was ich in meinem letzten Artikel <a alt="%7B%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fheise.de%2F-4469602%22%2C%22text%22%3A%22%5C%22The%20Regular%20Expression%5C%22-Bibliothek%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fheise.de%2F-4469602%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%7D" title="Link auf https://heise.de/-4469602" href="https://heise.de/-4469602">"The Regular Expression"-Bibliothek</a> schrieb. Heute geht es weiter.</div><div class="ztitel">Der Text bestimmt den regulären Ausdruck, das Ergebnis und die Erfassungsgruppen<br></div><div class="text">Zuerst einmal muss ich mich genauer ausdrücken. Der Datentyp des Textes bestimmt den Typ des regulären Ausdrucks, den Typ des Ergebnisses und den Typ der Erfassungsgruppen. Natürlich gilt meine Argumentation auch, wenn ich sie auf andere Bereiche der Funktionalität regulärer Ausdrücke anwende. Eine Erfassungsgruppe ist ein Teilausdruck in deinem Suchergebnis, der sich mit runden Klammern definieren lässt. In meinen letzten Artikel&nbsp; <a title="Link auf Beitrag 2712883" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A2712883%2C%22ir_link%22%3A1%2C%22text%22%3A%22%5C%22The%20Regular%20Expression%5C%22-Bibliothek%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D0de8ba75492c78173141b4a13271b039%26rm%3Dopen_article_id%26bid%3D2712883%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22%22%2C%22type%22%3A%22B%22%7D" href="/exec/mainmenu.pl?sid=0de8ba75492c78173141b4a13271b039&amp;rm=open_article_id&amp;bid=2712883">"The Regular Expression"-Bibliothek</a> habe ich bereits darüber geschrieben.</div><div class="text">Die Tabelle zeigt alle Datentypen, die vom Typ des Textes abhängen.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_177340141_e35ae889db.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> <br></div><div class="text">Das folgende Beispiel zeigt alle Varianten von <i>std::regex_search</i>, die vom Datentyp des Textes abhängen.<br></div><div class="pre">// search.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;regex&gt;<br>#include &lt;string&gt;<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; // regular expression for time<br>&nbsp; std::regex crgx("([01]?[0-9]|2[0-3]):[0-5][0-9]");<br><br>&nbsp; // const char*<br>&nbsp; std::cout &lt;&lt; "const char*" &lt;&lt; std::endl;<br>&nbsp; std::cmatch cmatch;<br><br>&nbsp; const char* ctime{"Now it is 23:10."};<br><br>&nbsp; if (std::regex_search(ctime, cmatch, crgx)){<br><br>&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ctime &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Time: " &lt;&lt; cmatch[0] &lt;&lt; std::endl;<br><br>&nbsp;&nbsp; }<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; // std::string<br>&nbsp; std::cout &lt;&lt; "std::string" &lt;&lt; std::endl;<br>&nbsp; std::smatch smatch;<br><br>&nbsp; std::string stime{"Now it is 23:25."};<br>&nbsp; if (std::regex_search(stime, smatch, crgx)){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; stime &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Time: " &lt;&lt; smatch[0] &lt;&lt; std::endl;<br><br>&nbsp; }<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; // regular expression holder for time<br>&nbsp; std::wregex wrgx(L"([01]?[0-9]|2[0-3]):[0-5][0-9]");<br><br>&nbsp; // const wchar_t*<br>&nbsp; std::cout &lt;&lt; "const wchar_t* " &lt;&lt; std::endl;<br>&nbsp; std::wcmatch wcmatch;<br><br>&nbsp; const wchar_t* wctime{L"Now it is 23:47."};<br><br>&nbsp; if (std::regex_search(wctime, wcmatch, wrgx)){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::wcout &lt;&lt; wctime &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::wcout &lt;&lt; "Time: " &lt;&lt; wcmatch[0] &lt;&lt; std::endl;<br><br>&nbsp; }<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; // std::wstring<br>&nbsp; std::cout &lt;&lt; "std::wstring" &lt;&lt; std::endl;<br>&nbsp; std::wsmatch wsmatch;<br><br>&nbsp; std::wstring&nbsp; wstime{L"Now it is 00:03."};<br><br>&nbsp; if (std::regex_search(wstime, wsmatch, wrgx)){<br><br>&nbsp;&nbsp;&nbsp; std::wcout &lt;&lt; wstime &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::wcout &lt;&lt; "Time: " &lt;&lt; wsmatch[0] &lt;&lt; std::endl;<br><br>&nbsp; }<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Zuerst kommt ein Text vom Typ <span class="tx_code">const char*</span>, vom Typ <span class="tx_code">std::string</span>, vom Typ <span class="tx_code">const wchar_t*</span> und zum Abschluss vom Typ <span class="tx_code">std::wstring</span> zum Einsatz. Da es fast immer der identische Code in den vier Variationen ist, werde ich mich für den Rest des Artikels nur noch auf <span class="tx_code">std:.string</span> beziehen. </div><div class="text">Der Text enthält einen Teil-String, der für eine Zeitangabe steht. Dank dem regulären Ausdruck <span class="tx_code">"([01]?[0-9]|2[0-3]):[0-5][0-9]" </span>lässt sich nach diesem im Text suchen. Der reguläre Ausdruck definiert ein Zeitformat, das aus einer Stunde und einer Minute besteht, die durch Doppelpunkt separiert sind. Hier sind ein paar Erläuterungen zu dem Stunden- und dem Minutenanteil:</div><div class="text"><ul><li>Stunde: <i>[</i>01]?[0-9]|2[0-3]: <br><ul><li><span class="tx_code">[01]?</span>: 0 oder 1 (optional)</li><li><span class="tx_code">[0-9]</span><i>:</i> eine Zahl von 0 bis 9</li><li><span class="tx_code">|</span>: steht für oder</li><li><span class="tx_code">2[0-3]</span>: 2, gefolgt von einer Zahl von 0 bis 3</li></ul></li><li>Minute: <span class="tx_code">[0-5][0-9]</span><i>:</i> eine Zahl von 0 bis 5, gefolgt von einer Zahl von 0 bis 9 <br></li></ul></div><div class="text">Zum Abschluss die Ausgabe des Programms.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_177340151_4d16b09c56.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="ztitel">Verwende <span class="tx_code">regex_iterator</span> oder <span class="tx_code">regex_token_iterator</span> für wiederholtes Suchen</div><div class="text">Verwende keine wiederholenden <span class="tx_code">std::search</span>-Aufrufe, denn es passiert sehr leicht, dass du Wortgrenzen verlierst oder leere Treffer erhältst. Verwende stattdessen <span class="tx_code">std::regex_iterator</span> oder <span class="tx_code">std::regex_token_iterator</span> für wiederholtes Suchen. <span class="tx_code">std::regex_token_iterator</span> erlaubt es darüber hinuaus, die Komponenten der Erfassungsgruppen oder den Text zwischen den Treffern zu adressieren. </div><div class="text">Das "Hello World" der wiederholten Suche mit regulären Ausdrücken ist es, zu zählen, wie häufig ein Wort in einem Text vorkommt. Hier ist das Programm, das die Aufgabe löst.<br></div><div class="pre">// wordCount.cpp<br><br>#include &lt;algorithm&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;regex&gt;<br>#include &lt;string&gt;<br>#include &lt;map&gt;<br>#include &lt;unordered_map&gt;<br>#include &lt;utility&gt;<br><br>using str2Int = std::unordered_map&lt;std::string, std::size_t&gt;;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>using intAndWords = std::pair&lt;std::size_t, std::vector&lt;std::string&gt;&gt;;<br>using int2Words= std::map&lt;std::size_t,std::vector&lt;std::string&gt;&gt;; <br><br><br>// count the frequency of each word<br>str2Int wordCount(const std::string &amp;text) {<br>&nbsp; std::regex wordReg(R"(\w+)");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp; std::sregex_iterator wordItBegin(text.begin(), text.end(), wordReg); // (3)<br>&nbsp; const std::sregex_iterator wordItEnd;<br>&nbsp; str2Int allWords;<br>&nbsp; for (; wordItBegin != wordItEnd; ++wordItBegin) {<br>&nbsp;&nbsp;&nbsp; ++allWords[wordItBegin-&gt;str()];<br>&nbsp; }<br>&nbsp; return allWords;<br>}<br><br>// get to each frequency the words<br>int2Words frequencyOfWords(str2Int &amp;wordCount) {<br>&nbsp; int2Words freq2Words;<br>&nbsp; for (auto wordIt : wordCount) {<br>&nbsp;&nbsp;&nbsp; auto freqWord = wordIt.second;<br>&nbsp;&nbsp;&nbsp; if (freq2Words.find(freqWord) == freq2Words.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq2Words.insert(intAndWords(freqWord, {wordIt.first}));<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; freq2Words[freqWord].push_back(wordIt.first);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; return freq2Words;<br>}<br><br>int main(int argc, char *argv[]) {<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; // get the filename<br>&nbsp; std::string myFile;<br>&nbsp; if (argc == 2) {<br>&nbsp;&nbsp;&nbsp; myFile = {argv[1]};<br>&nbsp; } else {<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Filename missing !" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp; }<br><br>&nbsp; // open the file<br>&nbsp; std::ifstream file(myFile, std::ios::in);<br>&nbsp; if (!file) {<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Can't open file " + myFile + "!" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp; }<br><br>&nbsp; // read the file<br>&nbsp; std::stringstream buffer;<br>&nbsp; buffer &lt;&lt; file.rdbuf();<br>&nbsp; std::string text(buffer.str());<br><br>&nbsp; // get the frequency of each word<br>&nbsp; auto allWords = wordCount(text);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp; std::cout &lt;&lt; "The first 20 (key, value)-pairs: " &lt;&lt; std::endl;<br>&nbsp; auto end = allWords.begin();<br>&nbsp; std::advance(end, 20);<br>&nbsp; for (auto pair = allWords.begin(); pair != end; ++pair) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "(" &lt;&lt; pair-&gt;first &lt;&lt; ": " &lt;&lt; pair-&gt;second &lt;&lt; ")";<br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp; std::cout &lt;&lt; "allWords[Web]: " &lt;&lt; allWords["Web"] &lt;&lt; std::endl; // (5)<br>&nbsp; std::cout &lt;&lt; "allWords[The]: " &lt;&lt; allWords["The"] &lt;&lt; "\n\n";<br><br>&nbsp; std::cout &lt;&lt; "Number of unique words: ";<br>&nbsp; std::cout &lt;&lt; allWords.size() &lt;&lt; "\n\n";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br><br>&nbsp; size_t sumWords = 0;<br>&nbsp; for (auto wordIt : allWords)<br>&nbsp;&nbsp;&nbsp; sumWords += wordIt.second;<br>&nbsp; std::cout &lt;&lt; "Total number of words: " &lt;&lt; sumWords &lt;&lt; "\n\n";<br><br>&nbsp; auto allFreq = frequencyOfWords(allWords);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp; std::cout &lt;&lt; "Number of different frequencies: " &lt;&lt; allFreq.size() &lt;&lt; "\n\n";<br><br>&nbsp; std::cout &lt;&lt; "All frequencies: ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (8)<br>&nbsp; for (auto freqIt : allFreq)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; freqIt.first &lt;&lt; " ";<br>&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp; std::cout &lt;&lt; "The most frequently used word(s): " &lt;&lt; std::endl; // (9)<br>&nbsp; auto atTheEnd = allFreq.rbegin();<br>&nbsp; std::cout &lt;&lt; atTheEnd-&gt;first &lt;&lt; " :";<br>&nbsp; for (auto word : atTheEnd-&gt;second)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; word &lt;&lt; " ";<br>&nbsp; std::cout &lt;&lt; "\n\n";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (10)<br>&nbsp; std::cout &lt;&lt; "All words which appear more than 1000 times:" &lt;&lt; std::endl;<br>&nbsp; auto biggerIt =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::find_if(allFreq.begin(), allFreq.end(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](intAndWords iAndW) { return iAndW.first &gt; 1000; });<br>&nbsp; if (biggerIt == allFreq.end()) {<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "No word appears more than 1000 times !" &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<br>&nbsp; } else {<br>&nbsp;&nbsp;&nbsp; for (auto allFreqIt = biggerIt; allFreqIt != allFreq.end(); ++allFreqIt) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; allFreqIt-&gt;first &lt;&lt; " :";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto word : allFreqIt-&gt;second)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; word &lt;&lt; " ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; std::endl;<br>}<br></div><div class="text">Um den Progammfluss besser zu verstehen, habe ich ein paar Kommentare in das Programm eingefügt.</div><div class="text">Die <span class="tx_code">using</span>-Deklaration in Zeile 1 hilft mir, meine Schreibarbeit zu minimieren. Die Funktion <span class="tx_code">wordCount</span> bestimmt die Häufigkeit jedes Wortes und die Funktion <span class="tx_code">frequencyOfWords</span> gibt zu jeder Häufigkeit alle Wörter zurück. Was ist ein Wort? Die Zeile 2 definiert dies mit einem regulären Ausdruck und Zeile 3 verwendet diesen in <span class="tx_code">std::regex_iterator</span><i>.</i> Welche Fragen lassen sich mit den zwei Funktionen beantworten?<br></div><div class="text"><ul><li>Line 4: die ersten 20 (Schlüssel, Wert)-Paare<br></li><li>Line 5: Häufigkeit der Wörter "Web" und "The"</li><li>Line 6: Anzahl der eindeutigen Wörter<br></li><li>Line 7: Anzahl der verschiedenen Häufigkeiten<br></li><li>Line 8: alle vorkommenden Häufigkeiten<br></li><li>Line 9: das am häufigsten verwendete Wort<br></li><li>Line 10: Wörter, die mehr als 1000 Mal vorkommen</li></ul> </div><div class="text">Jetzt benötige ich natürlich noch einen&nbsp; längeren Text. Klar, ich verwende Grimms' Märchen vom <a href="https://www.gutenberg.org/" title="Link auf https://www.gutenberg.org/" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.gutenberg.org%2F%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Projekt%20Gutenberg.%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.gutenberg.org%2F%22%7D">Projekt Gutenberg.</a> Hier ist das Ergebnis:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_177340157_00723535cc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Nun bin ich fast fertig mit den regulären Ausdrücken. Eine Regel habe ich aber noch, die das wiederholte Suchen meist einfacher macht: Suche nicht nach dem Textmuster, sondern nach dem Trenner des Textmusters. Ich nenne diese Technik negative Suche. <br></div><div class="simple-translate-result-wrapper"><br> <br></div>
