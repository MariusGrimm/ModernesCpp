<div class="vorspann">Heute vervollständige ich die Regeln der C++ Core Guidelines zu Quelldateien. In ihnen dreht es sich um Header-Dateien und Namensräume.</div><div class="text">Es ist nicht einfach, aus den verbleibenden Regeln zu Quelldateien eine Geschichte zu formen, denn diese besitzen nicht allzu viel Inhalt. Hier sind die Regeln:</div><div class="text"><ul><li> <a alt="%7B%22text%22%3A%22SF.8%3A%20Use%20%23include%20guards%20for%20all%20.h%20files%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-guards%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-guards%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-guards" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-guards">SF.8: Use #include guards for all .h files</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-cycles" alt="%7B%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-cycles%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-cycles%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SF.9%3A%20Avoid%20cyclic%20dependencies%20among%20source%20files%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-cycles">SF.9: Avoid cyclic dependencies among source files</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-implicit" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-implicit%22%2C%22text%22%3A%22SF.10%3A%20Avoid%20dependencies%20on%20implicitly%20%23included%20names%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-implicit%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-implicit">SF.10: Avoid dependencies on implicitly #included names</a> </li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-contained" alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-contained%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22SF.11%3A%20Header%20files%20should%20be%20self-contained%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-contained%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-contained">SF.11: Header files should be self-contained</a></li></ul></div><div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-namespace" alt="%7B%22text%22%3A%22SF.20%3A%20Use%20namespaces%20to%20express%20logical%20structure%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-namespace%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-namespace%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-namespace">SF.20: Use namespaces to express logical structure</a> </li><li> <a alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22SF.21%3A%20Don%C2%92t%20use%20an%20unnamed%20%28anonymous%29%20namespace%20in%20a%20header%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed">SF.21: Don’t use an unnamed (anonymous) namespace in a header</a> </li><li> <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed2%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SF.22%3A%20Use%20an%20unnamed%20%28anonymous%29%20namespace%20for%20all%20internal%2Fnonexported%20entities%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed2%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed2" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed2">SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities</a></li></ul> </div><div class="text">Die erste Regel steht bereits für Best Practice.<br></div><div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-guards" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-guards%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-guards%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22SF.8%3A%20Use%20%23include%20guards%20for%20all%20.h%20files%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-guards">SF.8: Use #include guards for all .h files</a></div><div class="text">Wenn du eine Header-Datei in einen Include-Guard verpackst, wird er nur einmal inkludiert. Dies ist ein kleines Beispiel aus den Guidelines:</div><div class="pre">// file foobar.h:<br>#ifndef LIBRARY_FOOBAR_H<br>#define LIBRARY_FOOBAR_H<br>// ... declarations ...<br>#endif // LIBRARY_FOOBAR_H</div><div class="text">Zu Include-Guards sollten zwei Punkte im Auge behalten werden:</div><div class="text"><ol><li> Gib deinem Include-Guard einen eindeutigen Namen. Wenn du den Namen eines Include-Guards mehr als einmal verwendest, kann es sonst passieren, dass die Header-Datei nicht inkludiert wird.</li><li> <a href="https://en.wikipedia.org/wiki/Pragma_once" alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPragma_once%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22%23pragma%20once%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPragma_once%22%7D" title="Link auf https://en.wikipedia.org/wiki/Pragma_once">#pragma once</a> ist eine nicht standardisierte, aber häufig verwendete Präprozessor-Direktive. Das heißt, dass die folgende Variation der Header-Datei <i>foobar.h</i> nicht portabel ist: <br></li></ol></div><div class="pre">// file foobar.h:<br>#pragma once<br><br>// ... declarations ...</div><div class="text">Zum Beispiel unterstützt der GCC diese Direktive seit 3.4. Die Details zur Unterstützung der <a href="https://en.wikipedia.org/wiki/Pragma_once" alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22%23pragma%20once%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPragma_once%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPragma_once%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://en.wikipedia.org/wiki/Pragma_once">#pragma once</a> Direktive lassen sich schön auf Wikipedia nachlesen.<br></div><div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-cycles" alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22SF.9%3A%20Avoid%20cyclic%20dependencies%20among%20source%20files%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-cycles%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-cycles%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-cycles">SF.9: Avoid cyclic dependencies among source files</a></div><div class="text">Zuerst einmal, was ist eine zirkuläre Abhängigkeit? Die folgenden Quelldateien besitzen eine einfache zirkuläre Abhängigkeit.<br></div><div class="text"><ul><li> <i>a.h</i></li></ul></div><div class="pre">#ifndef LIBRARY_A_H<br>#define LIBRARY_A_H<br>#include "b.h"<br><br>class A {<br>&nbsp; B&nbsp; b;<br>};<br><br>#endif // LIBRARY_A_H<br></div><div class="text"><ul><li><i> b.h</i></li></ul></div><div class="pre">#ifndef LIBRARY_B_H<br>#define LIBRARY_B_H<br>#include "a.h"<br><br>class B {<br>&nbsp; A a;<br>};<br><br>#endif // LIBRARY_B_H<br></div><div class="text"><ul><li><i>main.cpp</i></li></ul></div><div class="pre">#include "a.h" <br><br>int main() {<br>&nbsp; A a;<br>}</div><div class="text">Wenn ich versuche, das Programm zu übersetzen, schlägt dies fehl.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173164475_803c9fa03e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Das Problem ist, dass es eine zirkuläre Abhängigkeit zwischen den Header-Dateien <i>a.h </i>und <i>b.h </i>gibt. Das Problem tritt dann auf, wenn <i>a</i> im Hauptprogramm erzeugt wird. Um ein <i>A </i>zu erzeugen, muss der Compiler die Größe von <i>B </i>kennen. Um die Größe von <i>B </i>zu kennen, muss er die Größe von <i>A</i> kennen. Dies ist aber nicht möglichen, wenn <i>a </i>oder <i>b </i>Objekte sind. Dies ist nur möglich, wenn <i>a </i>oder <i>b</i> Zeiger oder Referenzen sind. <br></div><div class="text">Die einfache Lösung ist es, <i>A</i> in <i>b.h </i>oder <i>B </i>in <i>a.h</i> vorwärts zu deklarieren. Abhängig von deiner Plattform ist ihre Größe nun 32 oder 64 Bit. Dies ist die veränderte Header-Datei <i>a.h.</i></div><div class="pre">#ifndef LIBRARY_A_H<br>#define LIBRARY_A_H<br><br>class B;<br><br>class A {<br>&nbsp; B* b;<br>&nbsp; B&amp; b2 = *b;<br>};<br><br>#endif // LIBRARY_A_H</div><div class="text">Eine kleine Information. Der Standard-Header <i>&lt;iosfwd&gt;</i> besitzt Vorwärtsdeklarationen der Ein- und Ausgabebibliotheken.</div><div class="text">In die nächste Falle bin ich schon ein paar Mal gefallen.<br></div><div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-implicit" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-implicit" alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-implicit%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22SF.10%3A%20Avoid%20dependencies%20on%20implicitly%20%23included%20names%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-implicit%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D">SF.10: Avoid dependencies on implicitly #included names</a></div><div class="text">Zum Beispiel lässt sich das folgende Programm mit dem GCC 5.4 übersetzen, hingegen schlägt es mit dem Microsoft-Compiler 19.00.23506 fehl:</div><div class="pre">#include &lt;iostream&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string s = "Hello World";<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; s;<br><br>}</div><div class="text">Ich habe in dem Programm die notwendige Header-Datei &lt;string&gt; vergessen. Der GCC 5.5 inkludiert automatisch die Header-Datei <i>&lt;string&gt;</i> mit der Header-Datei <i>&lt;iostream&gt;</i>. Die gilt aber nicht für den Microsoft-Compiler. Seine Fehlermeldung ist sehr wortreich:</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_173164484_82fd2b9b66.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Die nächste Regel ist kurz und prägnant.<br></div><div class="ztitel"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-contained" alt="%7B%22text%22%3A%22SF.11%3A%20Header%20files%20should%20be%20self-contained%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-contained%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-contained%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-contained">SF.11: Header files should be self-contained</a></div><div class="text">Eine in sich abgeschlossene (<i>self-contained</i>) Header-Datei kann an erster Stelle in einer Übersetzungseinheit verwendet werden. Das heißt, dass sie nicht von Header-Dateien abhängt, die zuerst inkludiert werden müssen. Wenn du dieser Regel nicht folgst, kann dies einen Nutzer deiner Header-Datei sehr überraschen, da er seltsame Fehlermeldungen erhält. Zeitweise verhält sich die Header-Datei anständig; zeitweise nicht. Dies hängt davon ab, welche Header-Dateien davor verwendet wurden.</div><div class="text">In den letzten drei Regeln geht es um Namensräume. Es geht mit einer allgemeinen Regel los.<br></div><div class="ztitel"><a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-namespace%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SF.20%3A%20Use%20namespaces%20to%20express%20logical%20structure%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-namespace%22%2C%22target%22%3A%22_blank%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-namespace" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-namespace">SF.20: Use namespaces to express logical structure</a></div><div class="text">Klar, wir besitzen wir Namensräume im C++-Standard, die logische Strukturen vorgeben. Beispiel? Hier sind ein paar: <br></div><div class="pre">std<br>std::chrono<br>std::literals<br>std::literals::chrono_literals<br>std::filesystem<br>std::placeholders<br><br>std::view&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // C++20</div><div class="text">Die nächste zwei Reglen handeln von unbenannten (anonymen) Namensräumen.<br> </div><div class="ztitel"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed" alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22SF.21%3A%20Don%C2%92t%20use%20an%20unnamed%20%28anonymous%29%20namespace%20in%20a%20header%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed">SF.21: Don’t use an unnamed (anonymous) namespace in a header</a> und<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed2" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed2%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed2%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22%20SF.22%3A%20Use%20an%20unnamed%20%28anonymous%29%20namespace%20for%20all%20internal%2Fnonexported%20entities%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed2"> SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities</a></div><div class="text">Ein unbenannter Namensraum besitzt interne Bindung (internal linkage). Das heißt, dass Namen in dem unbenannten Namensraum nur innerhalb der aktuellen Übersetzungseinheit angesprochen werden können und nicht exportiert werden (<a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed2" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed2" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed2%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22SF22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed2%22%7D">SF22</a>). Was heißt dass?</div><div class="pre">namespace {<br>&nbsp;&nbsp;&nbsp; int i;&nbsp; // defines ::(unique_name)::i<br>}<br>void inc() {<br>&nbsp;&nbsp;&nbsp; i++;&nbsp; // increments ::(unique_name)::i<br>}<br></div><div class="text">Wenn du dich innerhalb der Übersetzungseinheit auf <i>i</i> beziehst, wird ein <i>unique_name</i> angewandt, ohne dass es zu einer Namenskollision kommt. Zum Beispiel kannst du daher eine freie Funktion <i>ad</i>d in dem unbenannten Namensraum definieren, ohne dass sich der Linker darüber beschwert, dass du die One-Definition-Rule verletzt hast. </div><div class="text">Jetzt beziehe ich mich auf das Problem, das entsteht, wenn ein unbenannter Namensraum in der Header-Datei verwendet wird (<a alt="%7B%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22text%22%3A%22SF21%29%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rs-unnamed%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rs-unnamed">SF21)</a>. In diesem Fall definiert jede Übersetzungseinheit ihre eindeutige Instanz des unbenannten Namensraums. Unbenannten Namensräume in Header-Dateien besitzen die folgenden Auswirkungen.</div><div class="text"><ul><li> Das erzeugte ausführbare Datei wird größer.</li><li>Jede Deklaration in einem unbenannten Namensraum bezieht sich auf ein andere Entität in jeder Übersetzungseinheit. Das entspricht nicht dem erwarteten Verhalten.</li></ul></div><div class="text">Die Verwendung eines unbenannten Namensraum ist dem <i>static</i> Schlüsselwort in C sehr ähnlich.</div><div class="pre">namespace { int i1; }<br>static int i2;<br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Die C++ Core Guidelines haben Module in den Regeln zu Quelldateien erwähnt. Sie haben sie erwähnt, aber nicht über das neue C++20 Feature geschrieben. Dieses Lücke will ich in meinem nächsten Artikel füllen. <br></div><div class="ztitel">C++-Schulungen im Großraum Stuttgart</div><div class="text">Ich freue mich darauf, weitere C++-Schulungen halten zu dürfen.</div><div class="text"><ul><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Embedded%20Programmierung%20mit%20modernem%20C%2B%2B%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F19-embedded-programmierung-mit-modernem-c20190102153438%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/19-embedded-programmierung-mit-modernem-c20190102153438">Embedded Programmierung mit modernem C++</a>: 21.05.19 - 23.05.19 </li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C%2B%2B11%20und%20C%2B%2B14%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F20-c-11-und-c-1420190311073407%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F20-c-11-und-c-1420190311073407%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" href="https://www.modernescpp.de/index.php/c/2-c/20-c-11-und-c-1420190311073407" title="Link auf https://www.modernescpp.de/index.php/c/2-c/20-c-11-und-c-1420190311073407">C++11 und C++14</a>: 25.06.19 - 27.06.19 <br></li><li> <a title="Link auf https://www.modernescpp.de/index.php/c/2-c/21-generische-programmierung-templates-mit-c20190311073743" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F21-generische-programmierung-templates-mit-c20190311073743%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Generische%20Programmierung%20%28Templates%29%20mit%20C%2B%2B%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%2F2-c%2F21-generische-programmierung-templates-mit-c20190311073743%22%2C%22target%22%3A%22_blank%22%7D" href="https://www.modernescpp.de/index.php/c/2-c/21-generische-programmierung-templates-mit-c20190311073743">Generische Programmierung (Templates) mit C++</a>: 13.08.19 - 15.08.19 </li></ul></div><div class="text">Die Details zu meinen C++- und Python-Schulungen gibt es auf <a alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22text%22%3A%22www.ModernesCpp.de%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2F%22%2C%22subject%22%3A%22%22%7D" href="https://www.modernescpp.de/" title="Link auf https://www.modernescpp.de/">www.ModernesCpp.de</a>. <br></div>
