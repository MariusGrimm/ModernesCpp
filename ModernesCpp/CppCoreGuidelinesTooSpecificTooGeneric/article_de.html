<div class="vorspann">Concepts werden die Art und Weise verändern, wie wir über generische Programmierung denken und sie anwenden. Sie haben es nicht in C++11 oder C++17 geschafft, werden aber mit hoher Wahrscheinlichkeit Bestandteil von C++20 sein.</div>
<div class="text">Bevor ich über die Verwendung von Concepts schreibe, möchte ich gerne noch eine allgemeinere Bemerkung machen.<br></div>
<div class="ztitel">Zu spezifisch oder zu generisch</div>
<div class="text">Bis C++20 kennen wir in C++ zwei diametrale Wege, Funktionen oder benutzerdefinierte Typen (Klassen) zu implementieren. Funktionen oder Klassen können für spezifische oder generische Datentypen implementiert werden. Im zweiten Fall nennen wir diese Funktions- oder Klassen-Templates. Was sind die Nachteile der beiden Varianten?</div>
<div class="ztitel_kleiner">Zu spezifisch</div>
<div class="text">Es ist ein ganz schön aufwendiger Job, für jeden Datentyp eine Funktion oder eine Klasse zu definieren. Um diesen Job deutlich zu vereinfachen, besteht die Rettung aber auch ein großer Teil des Problems aus Typkonvertierungen.<br></div>
<div class="text"><b>Narrowing Conversion</b></div>
<div class="text">Angenommen, du hast eine Funktion <i>getInt(int a)</i> definiert, die du mit einem <i>double</i>-Wert aufrufst. Nun tritt Narrowing Conversion in Aktion.<br></div>
<div class="pre">// narrowingConversion.cpp<br><br>#include &lt;iostream&gt;<br><br>void needInt(int i){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "int: " &lt;&lt; i &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;double d{1.234};<br>&nbsp;&nbsp; &nbsp;std::cout &lt;&lt; "double: " &lt;&lt; d &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;needInt(d);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp; &nbsp;<br>}</div>
<div class="text">Ich denke nicht, dass das deine Absicht war. Mit einem <i>double</i>-Wert Wert hast du begonnen, mit einem [i]int[/i]-Wert endest du.</div>
<div class="text">Konvertierungen gibt es natürlich auch in die andere Richtung.</div>
<div class="text"><b>Integral Promotion</b></div>
<div class="text">Angenommen, du hast eine Klasse [i]MyHouse[/i] entworfen. Instanzen von [i]MyHouse[/i] sollen in zwei Arten erzeugt werden können. Wenn der Konstruktor ohne Argument aufgerufen wird (1), wird das Attribut [i]family[/i] auf einen leeren String gesetzt. Das bedeute, dass das Haus noch nicht bewohnt ist. Um einfach zu testen, ob das Haus bewohnt ist, soll der Konvertierungsoperator nach [i]bool[/i] (2) zum Einsatz kommen. Gut! Oder? <br></div>
<div class="pre">// conversionOperator.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>struct MyHouse{<br>&nbsp;&nbsp;&nbsp; MyHouse() = default;<br>&nbsp;&nbsp;&nbsp; MyHouse(const std::string&amp; fam): family(fam){}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; operator bool(){ return !family.empty(); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::string family = "";<br>};<br><br>void needInt(int i){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "int: " &lt;&lt; i &lt;&lt; std::endl;<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyHouse firstHouse;<br>&nbsp;&nbsp;&nbsp; if (!firstHouse){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "The firstHouse is still empty." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; MyHouse secondHouse("grimm");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; if (secondHouse){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Family grimm lives in secondHouse." &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; needInt(firstHouse);<br>&nbsp;&nbsp;&nbsp; needInt(secondHouse);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Nun lassen sich Instanzen von [i]MyHouse[/i] verwenden, wenn ein [i]int[/i]-Wert erforderlich ist. Seltsam!</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159263578_1e6a7917e1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Dank des überladenen Operators [i]bool[/i] (2), können Instanzen von [i]MyHouse[/i] als natürliche Zahlen verwendet werden. Damit sind sie in beliebigen arithmetischen Ausdrücken einsetzbar: <i>auto res = MyHouse() + 5</i><span class="tx_code">.</span> Das war wohl nicht deine Absicht. Nur der Vollständigkeit halber: Seit C++11 kann der Konvertierungsoperator als [i]explicit[/i] deklariert werden. Damit werden implizite Konvertierungen unterbunden.</div>
<div class="text">Mein fester Glaube ist es, dass wir aus Gemütlichkeitsgründen die Magie der Konvertierung in C/C++ benötigen, da Funktionen nur spezifische Datentypen annehmen können.<br></div>
<div class="text">Sind Templates die Rettung? Nein!<br></div>
<div class="ztitel_kleiner">Zu generisch</div>
<div class="text">Generische Funktionen oder Klassen können mit beliebigen Werten aufgerufen werden. Falls die Werte die Anforderungen der Funktion oder Klasse nicht erfüllen, kein Problem. In diesem Fall erhältst du einen Fehlermeldung beim Kompilieren. Alles ist daher gut!<br></div>
<div class="pre">// gcd.cpp<br><br>#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>T gcd(T a, T b){<br>&nbsp; if( b == 0 ){ return a; }<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; return gcd(b, a % b);<br>&nbsp; }<br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; gcd(100, 10)&nbsp; &lt;&lt; std::endl;<br>&nbsp;<br>&nbsp; std::cout &lt;&lt; gcd(3.5, 4.0)&lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; gcd("100", "10") &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Was ist das Problem dieser Fehlermeldung?</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159263584_1ea7280040.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Klar, die Fehlermeldung ist sehr wortreich und schwer verständlich. Das ist aber nicht mein zentraler Punkt. Die Kompilierung des Programms schlägt fehl, da weder [i]double[/i]s noch C-Strings den %-Operator unterstützen. Das heißt, der Fehler tritt durch eine fehlerhafte Instanziierung des Funktions-Templates für [i]double[/i]-Werte und C-Strings auf. Dies ist deutlich zu spät. Es sollte keine Template-Instanziierung für die Werte [i]double[/i] oder C-Strings möglich sein! Die Anforderungen für die Argumente sollten Bestandteil der Funktionsdeklaration sein und nicht zu einer fehlerhaften Instanziierung führen.&nbsp; <br></div>
<div class="text">Jetzt kommen Concepts als Retter ins Spiel.</div>
<div class="ztitel_kleiner">Der dritte Weg</div>
<div class="text">Mit Concepts betreten wir den Mittelweg. Mit ihnen lassen sich Funktionen oder Klassen definieren, die auf semantischen Kategorien agieren. Das heißt, dass die Argumente weder zu spezifisch noch zu generisch sind, sondern für Anforderungen mit Namen wie [i]Integral[/i] stehen.&nbsp; <br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Sorry, der Artikel ist ein wenig kurz geraten, aber eine Woche vor meinem Mulithreading-Workshop auf der CppCon hatte ich weder die Zeit noch die Ressourcen dazu, (keine Verbindung in den Nationalparks des States Washington) einen vollständigen Artikel zu schreiben. Mein nächster Artikel wird besonders sein, denn ich werde über die CppCon schreiben. Danach geht es aber wieder um die generische Programmierung im Allgemeinen und Concepts im Besonderen.<br></div>