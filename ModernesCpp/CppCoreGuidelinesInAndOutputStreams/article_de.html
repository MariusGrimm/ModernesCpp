<div class="vorspann">Im heutigen Blogbeitrag geht es um notwendiges Wissen zu Ein- und Ausgabestreams. Insbesondere beschäftigt er sich mit formatierter und unformatierter Ein- und Ausgabe.</div><div class="ztitel">Funktionen zur Ein- und Ausgabe</div><div class="text">C++ besitzt vier vordefinierte Streamobjekte, die mit der Tastatur oder dem Monitor verbunden sind.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203037_70aa24054d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text">Mit diesen lässt sich ein interaktives Programm schreiben, das Zahlen von der Kommandozeile einliest und die Summe ausgibt.<br></div><div class="pre">// Iostreams.cpp<br><br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Type in your numbers(Quit with an arbitrary character): " &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; int sum{0};<br>&nbsp; int val;<br><br>&nbsp; while ( std::cin &gt;&gt; val ) sum += val;<br><br>&nbsp; std::cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203047_081b8117db.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Das Programm zeigt die Streamoperatoren &lt;&lt; und <i>&gt;&gt; </i>sowie den Streammanipulator <i>std::endl</i> in der Anwendung.</div><div class="text"><ul><li>Der Insert-Operator <i>&lt;&lt;&nbsp;</i> schiebt Zeichen auf den Ausgabestream <i>std::cout.</i></li><li>Der Extract-Operator <i>&gt;&gt; </i>zieht Zeichen vom Eingabestream <i>std::cin</i>. <br></li><li>Beide Operatoren können verkettet werden, da sie Referenzen auf sich selbst zurückgeben.<br></li></ul></div><div class="text"><i>std::endl </i>ist ein Streammanipulator, da er ein (<i>\n</i>)-Zeichen auf den Ausgabestream <i>std::cout </i>schiebt und insbesondere den Ausgabepuffer leert. </div><div class="text">Die Tabelle stellt die am häufigsten verwendeten Manipulatoren vor.<br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203052_776f867bd4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="ztitel_kleiner">Eingabe<br></div><div class="text">Eingabestreams lassen sich in C++ formatiert mit dem Extraktor (<i>&lt;&lt;)</i> und unformatiert mit expliziten Methoden lesen.</div><div class="text"><b>Formatierte Eingabe</b></div><div class="text">Der Extraktion-Operator (<i>&lt;&lt;)</i></div><div class="text"><ul><li>ist für alle built-in-Datentypen und Strings vordefiniert,</li><li>lässt sich für eigene Datentypen definieren,</li><li>lässt sich durch Formatangaben konfigurieren<br></li></ul></div><div class="text">Das nächste Codeschnipsel zeigt, wie einfach sich zwei<i> int'</i>s einlesen lassen.<br></div><div class="pre">#include &lt;iostream&gt;<br>...<br>int a, b;<br>std::cout &lt;&lt; "Two natural numbers: " &lt;&lt; std::endl;<br>std::cin &gt;&gt; a &gt;&gt; b; // &lt; 2000 11&gt;<br>std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; " b: " &lt;&lt; b;<br></div><div class="text"><i>std::cin</i> ignoriert per Default führende Leerzeichen.<br></div><div class="text"><b>Unformatierte Eingabe</b></div><div class="text">Für die unformatierte Eingabe auf einem Eingabestream gibt es mehrere Methoden.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203057_b47b91d4aa.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="text"><b><i>std::string</i> besitzt eine <i>getline-</i>Funktion</b><br></div><div class="text">Die <i>getline</i>-Funktion für den String besitzt einen großen Vorteil gegenüber der <i>getline</i>-Funktion des <i>istream</i>. Die Funktionen verwalten ihren Speicher automatisch. Dieses Argument trifft auch auf die <i>get</i>-Funktion des <i>istream</i> zu: <i>is.get(buf, num)</i> . Auch bei dieser Funktion muss der Speicher für den Puffer <i>buf </i>explizit bereitgestellt werden.<br></div><div class="pre">// inputUnformatted.cpp<br><br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::string line;<br>&nbsp; std::cout &lt;&lt; "Write a line: " &lt;&lt; std::endl;<br>&nbsp; std::getline(std::cin, line);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::ifstream inputFile("test.txt"); <br>&nbsp; while ( std::getline(inputFile, line, ';') ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br>&nbsp; }<br><br>}<br></div><div class="text">Das Programm liest in Zeile (1) von <i>std::cin</i>; im Gegensatz dazu, liest es in Zeile (2) von der Datei <i>text.txt.</i><br></div><div class="text">Der Einfachheit halber besitzt das Programm keine Fehlerbehandlung. Die Details zur Fehlerbehandlung lassen sich in meinem letzten Artikel <a href="/exec/mainmenu.pl?sid=b717573dcb19efb26037eba5486f0a02&amp;rm=open_article_id&amp;bid=2701256" title="Link auf Beitrag 2701256" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Iostreams%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A2701256%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Db717573dcb19efb26037eba5486f0a02%26rm%3Dopen_article_id%26bid%3D2701256%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%7D">C++ Core Guidelines: Iostreams</a> nachlesen. Die Datei <i>test.txt</i> enthält Zahlen, die durch ein "<i>;</i>"-Zeichen getrennt sind. <br></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203064_06e67c233e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="ztitel_kleiner">Ausgabe<br></div><div class="text">Wie ich bereits in meinem letzten Artikel <a href="/exec/mainmenu.pl?sid=b717573dcb19efb26037eba5486f0a02&amp;rm=open_article_id&amp;bid=2701256" title="Link auf Beitrag 2701256" alt="%7B%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A2701256%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Db717573dcb19efb26037eba5486f0a02%26rm%3Dopen_article_id%26bid%3D2701256%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22text%22%3A%22C%2B%2B%20Core%20Guidelines%3A%20Iostreams%22%2C%22target%22%3A%22_blank%22%7D">C++ Core Guidelines: Iostreams</a> versprochen habe, geht es jetzt um die Format-Spezifier, die du kennen solltest oder zumindest wissen musst, wo du sie finden solltest.</div><div class="text"><b>Wichtige Format-Spezifier</b><br></div><div class="text">Oft höre ich selbst von erfahrenen C++-Entwicklern Klagen in meinen Schulungen, dass die Arithmetik in C++ nicht präzise genug ist. Der Grund ist aber fast immer nicht C++, sondern der Default-Format-Spezifier, der bei dem Iostream zum Einsatz kommt. </div><div class="text">Zuerst einmal, kann das Format mittels Manipulatoren und Flags spezifiziert werden. </div><div class="text"><b>Manipulatoren und Flags</b></div><div class="pre">// formatSpecifier.cpp<br><br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; int num{2011};<br><br>&nbsp; std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n\n";<br><br>&nbsp; std::cout.setf(std::ios::hex, std::ios::basefield);&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::cout &lt;&lt; "hex: " &lt;&lt; num &lt;&lt; std::endl;<br>&nbsp; std::cout.setf(std::ios::dec, std::ios::basefield);&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; std::cout &lt;&lt; "dec: " &lt;&lt; num &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::hex &lt;&lt; "hex: " &lt;&lt; num &lt;&lt; std::endl;&nbsp;&nbsp; // (2)<br>&nbsp; std::cout &lt;&lt; std::dec &lt;&lt; "dec: " &lt;&lt; num &lt;&lt; std::endl;&nbsp;&nbsp; // (2)<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">In den Zeilen (1) kommen Flags und in den Zeilen (2) Manipulatoren zum Einsatz.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203067_d6de465f2d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Aus dem Blickwinkel der Lesbarkeit und Wartbarkeit des Codes, ziehe ich Manipulatoren deutlich vor.</div><div class="text"><b>Manipulatoren für die Iostreams</b></div><div class="text">Jetzt geht es aber los mit den wichtigen Manipulatoren. Die folgenden Tabellen stellen die wichtigsten Formatangaben vor. Die Formatangaben eines Manipulators bleiben bestehen. Das gilt mit Ausnahme der Feldbreite (field with), die nach ihrer Anwendung wieder zurückgesetzt wird.</div><div class="text">Die Manipulatoren ohne Argument benötigen die Headerdatei <i>&lt;iostream&gt;</i>, die mit Argumenten die Headerdatei <i>&lt;iomanip&gt;</i>.<br></div><div class="text"><ul><li>Boolsche Werte</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203075_2a408521f4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:8 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Feldbreite und Füllzeichen</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203083_44150054b7.png" title="<ir_inline itemname=bilder_mvp_bild_var2:9 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Textausrichtung</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203085_8b9dcc1507.png" title="<ir_inline itemname=bilder_mvp_bild_var2:10 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Positive Vorzeichen und Großbuchstaben</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203091_c8c8655502.png" title="<ir_inline itemname=bilder_mvp_bild_var2:11 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Numerische Basis</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203101_b40d8d4606.png" title="<ir_inline itemname=bilder_mvp_bild_var2:12 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text"><ul><li>Fließkommazahlen</li></ul></div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_176203103_1b5c47e6a4.png" title="<ir_inline itemname=bilder_mvp_bild_var2:13 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Für Fließkommazahlen gibt es besondere Regeln:</div><div class="text"><ul><li>Die Anzahl der signifikanten Stellen (Nachkommastellen) ist per Default 6.</li><li>Wenn die Anzahl der signifikanten Stellen nicht ausreicht, erfolgt die Ausgabe im wissenschaftlichen Format.</li><li>Führende oder folgende Nullen werden nicht ausgegeben.</li><li>Der Dezimalpunkt wird, wenn möglich, nicht ausgegeben.<br></li></ul></div><div class="text">Nach so viel Theorie, sind jetzt die Format-Spezifier in Aktion zu bewundern.<br></div><div class="pre">// formatSpecifierOutput.cpp<br><br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "std::setw, std::setfill and std::left, right and internal: " &lt;&lt; std::endl;<br><br>&nbsp; std::cout.fill('#');<br>&nbsp; std::cout &lt;&lt; -12345 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setw(10) &lt;&lt; -12345 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; -12345 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setw(10) &lt;&lt; std::right &lt;&lt; -12345 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setw(10) &lt;&lt; std::internal &lt;&lt; -12345 &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "std::showpos:" &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; 2011 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::showpos &lt;&lt; 2011 &lt;&lt; std::endl;<br><br><br>&nbsp; std::cout &lt;&lt; std::noshowpos &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "std::uppercase: "&nbsp; &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; 12345678.9 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::uppercase &lt;&lt; 12345678.9 &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::nouppercase &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "std::showbase and std::oct, dec and hex: " &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; 2011 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::oct &lt;&lt; 2011 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::hex &lt;&lt; 2011 &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::showbase;<br>&nbsp; std::cout &lt;&lt; std::dec &lt;&lt; 2011 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::oct &lt;&lt; 2011 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::hex &lt;&lt; 2011 &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::dec &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; "std::setprecision, std::fixed and std::scientific: " &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::fixed &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(8) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(9) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::scientific &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(8) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; std::setprecision(9) &lt;&lt; 123.456789 &lt;&lt; std::endl;<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Die Ausgabe des Programm sollte als Erklärung für das Programm <i>formatSpecifierOutput.cpp</i> ausreichen.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Wenn du zu stark synchronisierst, verlierst du. Im Falle des Iostreams bedeutet dies, dass du Performanz verlierst. In meinem nächsten Artikel präsentiere ich konkrete Zahlen zu dieser Aussage.<br></div><div class="simple-translate-result-wrapper"><br> <br></div>
