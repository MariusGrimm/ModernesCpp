<div class="text">Der Lebenszyklus jedes Objekts beginnt mit seiner Erzeugung. Somit beschäftigt sich dieser Artikel mit den zwölf fundamentalsten Regeln für Objekte: Regeln für Konstruktoren. </div>
<div class="text">Dreizehn Regeln sind eindeutig zu viel für einen Artikel. In diesem Artikel geht es nur um die ersten elf Regeln. Warum nicht nur zehn Regeln? Die elfte Regel ist einfach zu interessant. Die verbleibenden zwei Regeln spare ich mir für den nächsten Artikel auf. Hier sind die zwölf Regeln kurz und bündig.</div>
<div class="ztitel">Regeln für Konstruktoren:<img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_140593335_18b27423cc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text"><ul><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor" alt="%7B%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-ctor%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-ctor%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.40%3A%20Define%20a%20constructor%20if%20a%20class%20has%20an%20invariant%22%7D" class="">C.40: Define a constructor if a class has an invariant</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-complete" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-complete" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-complete%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-complete%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.41%3A%20A%20constructor%20should%20create%20a%20fully%20initialized%20object%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D" class="">C.41: A constructor should create a fully initialized object</a> <br></li><li> <a alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.42%3A%20If%20a%20constructor%20cannot%20construct%20a%20valid%20object%2C%20throw%20an%20exception%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-throw%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-throw%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-throw" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-throw">C.42: If a constructor cannot construct a valid object, throw an exception</a> <br></li><li> <a alt="%7B%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default0%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default0%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.43%3A%20Ensure%20that%20a%20value%20type%20class%20has%20a%20default%20constructor%22%2C%22target%22%3A%22_blank%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default0" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default0">C.43: Ensure that a value type class has a default constructor</a> <br></li><li> <a class="" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.44%3A%20Prefer%20default%20constructors%20to%20be%20simple%20and%20non-throwing%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default00%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default00%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default00" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default00">C.44: Prefer default constructors to be simple and non-throwing</a> <br></li><li> <a class="" alt="%7B%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.45%3A%20Don%C2%92t%20define%20a%20default%20constructor%20that%20only%20initializes%20data%20members%3B%20use%20member%20initializers%20instead%22%2C%22ir_link%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default">C.45: Don’t define a default constructor that only initializes data members; use member initializers instead</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-explicit" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-explicit" alt="%7B%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.46%3A%20By%20default%2C%20declare%20single-argument%20constructors%20explicit%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-explicit%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-explicit%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%7D" class="">C.46: By default, declare single-argument constructors explicit</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-order" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-order" class="" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22C.47%3A%20Define%20and%20initialize%20member%20variables%20in%20the%20order%20of%20member%20declaration%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-order%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-order%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%7D">C.47: Define and initialize member variables in the order of member declaration</a> <br></li><li> <a alt="%7B%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-in-class-initializer%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-in-class-initializer%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.48%3A%20Prefer%20in-class%20initializers%20to%20member%20initializers%20in%20constructors%20for%20constant%20initializers%22%2C%22ir_link%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-in-class-initializer" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-in-class-initializer">C.48: Prefer in-class initializers to member initializers in constructors for constant initializers</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-initialize" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-initialize" class="" alt="%7B%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.49%3A%20Prefer%20initialization%20to%20assignment%20in%20constructors%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-initialize%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-initialize%22%7D">C.49: Prefer initialization to assignment in constructors</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-factory" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-factory" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-factory%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-factory%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.50%3A%20Use%20a%20factory%20function%20if%20you%20need%20%C2%93virtual%20behavior%C2%94%20during%20initialization%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%7D" class="">C.50: Use a factory function if you need “virtual behavior” during initialization</a> <br></li><li>C.51: Use delegating constructors to represent common actions for all constructors of a class<br></li><li>C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization</li></ul></div>
<div class="text">Auf die Suche in Breite folgt in bekannter Manier die Suche in die Tiefe. Weitere Details lassen sich einfach mit den Links auf die Regeln nachlesen. </div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-ctor" class="" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.40%3A%20Define%20a%20constructor%20if%20a%20class%20has%20an%20invariant%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-ctor%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-ctor%22%7D">C.40: Define a constructor if a class has an invariant</a></div>
<div class="text">Eine Invariante eines Objekts ist eine Charakteristik des Objekts, die für seinen ganzen Lebenszyklus gelten soll. Der Platz, um eine Invariante zu etablieren, ist der Konstruktor. Eine Invariante kann ein gültiges Datum sein.</div>
<div class="pre">class Date {&nbsp; // a Date represents a valid date<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in the January 1, 1900 to December 31, 2100 range<br>&nbsp;&nbsp;&nbsp; Date(int dd, int mm, int yy)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :d{dd}, m{mm}, y{yy}<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_valid(d, m, y)) throw Bad_date{};&nbsp; // enforce invariant<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // ...<br>private:<br>&nbsp;&nbsp;&nbsp; int d, m, y;<br>};</div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-complete" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-complete" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-complete%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-complete%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.41%3A%20A%20constructor%20should%20create%20a%20fully%20initialized%20object%22%2C%22user_params%22%3A%22%22%7D" class="">C.41: A constructor should create a fully initialized object</a></div>
<div class="text">Diese Regel schlägt eine ähnlichen Ton an wie ihr Vorgänger. Es gilt, dass es die Aufgabe eines Konstruktors ist, ein fertig initialisiertes Objekt zu erzeugen. Besitzt eine Klasse eine <i>init </i>Methode, gehen die Probleme typischerweise bereits los.<br></div>
<div class="pre">class X1 {<br>&nbsp;&nbsp;&nbsp; FILE* f;&nbsp;&nbsp; // call init() before any other function<br>&nbsp;&nbsp;&nbsp; // ...<br>public:<br>&nbsp;&nbsp;&nbsp; X1() {}<br>&nbsp;&nbsp;&nbsp; void init();&nbsp;&nbsp; // initialize f<br>&nbsp;&nbsp;&nbsp; void read();&nbsp;&nbsp; // read from f<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>void f()<br>{<br>&nbsp;&nbsp;&nbsp; X1 file;<br>&nbsp;&nbsp;&nbsp; file.read();&nbsp;&nbsp; // crash or bad read!<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; file.init();&nbsp;&nbsp; // too late<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Der Anwender kann irrtümlicherweise <i>read</i> befor <i>init</i> aufrufen oder schlicht den Aufruf von <i>init</i> vergessen. </div>
<div class="ztitel_kleiner"><a alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.42%3A%20If%20a%20constructor%20cannot%20construct%20a%20valid%20object%2C%20throw%20an%20exception%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-throw%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-throw%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-throw" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-throw">C.42: If a constructor cannot construct a valid object, throw an exception</a></div>
<div class="text">Entsprechend zur vorherigen Regel gilt: Wirf eine Ausnahme, falls du kein gültiges Objekt erzeugen kannst. Da gibt es nicht viel hinzuzufügen. Falls ein nicht gültiges Objekt verwendet wird, muss vor jeder Verwendung des Objekts seinen Zustand geprüft werden. Wenn das nicht fehleranfällig ist? Hier ist ein Beispiel aus den Guidelines.<br></div>
<div class="pre">class X3 {&nbsp;&nbsp;&nbsp;&nbsp; // bad: the constructor leaves a non-valid object behind<br>&nbsp;&nbsp;&nbsp; FILE* f; &nbsp;<br>&nbsp;&nbsp;&nbsp; bool valid;<br>&nbsp;&nbsp;&nbsp; // ...<br>public:<br>&nbsp;&nbsp;&nbsp; X3(const string&amp; name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :f{fopen(name.c_str(), "r")}, valid{false}<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (f) valid = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; bool is_valid() { return valid; }<br>&nbsp;&nbsp;&nbsp; void read();&nbsp;&nbsp; // read from f<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>void f()<br>{<br>&nbsp;&nbsp;&nbsp; X3 file {"Heraclides"};<br>&nbsp;&nbsp;&nbsp; file.read();&nbsp;&nbsp; // crash or bad read!<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; if (file.is_valid()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file.read();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ... handle error ...<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="ztitel_kleiner"><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default0%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default0%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.43%3A%20Ensure%20that%20a%20value%20type%20class%20has%20a%20default%20constructor%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default0" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default0">C.43: Ensure that a value type class has a default constructor</a></div>
<div class="text">Ein Value Type ist ein Datentyp, der sich wie ein int verhält. Ein Value Type ist einem Regular Typ sehr ähnlich. Ich habe in dem Artikel zu <a class="" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3807875%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3807875%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Concrete%20Types%20%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22%22%7D" href="https://www.heise.de/-3807875" title="Link auf https://www.heise.de/-3807875">Concrete Types </a>über Value Types und Regular Types geschrieben. Falls ein Datentyp einen Default-Konstruktor besitzt, lässt es sich deutlich einfacher mit ihm arbeiten. Viele Konstruktoren der STL-Container verlassen sich darauf, dass ein Datentyp einen Default-Konstruktor besitzt. Zum Beispiel der Wert eines geordneten assoziativen Containers wie <i>std::map</i>. Falls alle Mitglieder einer Klasse einen Default-Konstruktor besitzen, erzeugt der Compiler automatisch einen Default-Konstruktor für diese Klasse.<br></div>
<div class="ztitel_kleiner"><a alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.44%3A%20Prefer%20default%20constructors%20to%20be%20simple%20and%20non-throwing%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default00%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default00%22%7D" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default00" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default00">C.44: Prefer default constructors to be simple and non-throwing</a></div>
<div class="text">Fehlerbehandlung ist einfacher mit Default-Konstruktoren, die keine Ausnahme werfen können. Die Guidelines bieten ein einfaches Beispiel an.<br></div>
<div class="pre">template&lt;typename T&gt;<br>// elem is nullptr or elem points to space-elem element allocated using new<br>class Vector1 {<br>public:<br>&nbsp;&nbsp;&nbsp; // sets the representation to {nullptr, nullptr, nullptr}; doesn't throw<br>&nbsp;&nbsp;&nbsp; Vector1() noexcept {}<br>&nbsp;&nbsp;&nbsp; Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}<br>&nbsp;&nbsp;&nbsp; // ...<br>private:<br>&nbsp;&nbsp;&nbsp; own&lt;T*&gt; elem = nullptr;<br>&nbsp;&nbsp;&nbsp; T* space = nullptr;<br>&nbsp;&nbsp;&nbsp; T* last = nullptr;<br>};</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default" class="" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-default%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.45%3A%20Don%C2%92t%20define%20a%20default%20constructor%20that%20only%20initializes%20data%20members%3B%20use%20member%20initializers%20instead%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D">C.45: Don’t define a default constructor that only initializes data members; use member initializers instead</a></div>
<div class="text">Dies ist eines meiner Lieblingsfeatures aus C++11. Wenn du Klassenmitglieder direkt im Klassenkörper initialisierst, wird das Schreiben von Konstruktoren deutlich einfacher und manchmal sogar überflüssig. Die Klasse <i>X1</i> definiert seine Mitglieder in der klassischen Weise (bevor C++11) und die Klasse <i>X2</i> in der vorzuziehenden Weise. Ein schöner Seiteneffekt der Klasse X2 ist es, dass der Compiler automatisch den Konstruktor für die Klasse X2 erzeugt.<br></div>
<div class="pre">class X1 { // BAD: doesn't use member initializers<br>&nbsp;&nbsp;&nbsp; string s;<br>&nbsp;&nbsp;&nbsp; int i;<br>public:<br>&nbsp;&nbsp;&nbsp; X1() :s{"default"}, i{1} { }<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>class X2 {<br>&nbsp;&nbsp;&nbsp; string s = "default";<br>&nbsp;&nbsp;&nbsp; int i = 1;<br>public:<br>&nbsp;&nbsp;&nbsp; // use compiler-generated default constructor<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-explicit" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-explicit" class="" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.46%3A%20By%20default%2C%20declare%20single-argument%20constructors%20explicit%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-explicit%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-explicit%22%7D">C.46: By default, declare single-argument constructors explicit</a></div>
<div class="text">Diese Anwendung dieser Regel ist sehr wichtig und schützt vor bösen Überraschungen. Konstruktoren, die nur ein Argument annehmen, werden gerne auch Konvertierungs-Konstruktor genannt, da sie das Argument in eine Instanz der Klasse konvertieren. Falls solch einen Konvertierungs-Konstruktor nicht als explizit deklariert ist, lauert immer der Gefahr der impliziten Typkonvertierung. Das Codeschnipsel macht es richtig.<br></div>
<div class="pre">class String {<br>public:<br>&nbsp;&nbsp;&nbsp; explicit String(int);&nbsp; // explicit<br>&nbsp;&nbsp;&nbsp; // String(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // implicit<br>};<br><br>String s = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error because of explicit</div>
<div class="text">Die implizite Konvertierung von <i>int</i> nach <i>String</i> ist in diesem Beipiel nicht möglich, da der Konstruktor als explizit deklariert wurde. Falls statt des expliziten Konstruktor der auskommentierte, implizite Konstruktor zum Einsatz käme, würde die letzte Zeile einen String der Länge 10 erzeugen. </div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-order" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-order" class="" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-order%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-order%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22C.47%3A%20Define%20and%20initialize%20member%20variables%20in%20the%20order%20of%20member%20declaration%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D">C.47: Define and initialize member variables in the order of member declaration</a></div>
<div class="text">Klassenmitglieder werden in der Reihenfolge ihre Deklaration initialisiert. Falls sie in einer anderen Reihenfolge in dem Konstruktor-Initialisierer initialisiert werden, mag das Verhalten den einen oder anderen überraschen. <br></div>
<div class="pre">class Foo {<br>&nbsp;&nbsp;&nbsp; int m1;<br>&nbsp;&nbsp;&nbsp; int m2;<br>public:<br>&nbsp;&nbsp;&nbsp; Foo(int x) :m2{x}, m1{++x} { }&nbsp;&nbsp; // BAD: misleading initializer order<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>Foo x(1); // surprise: x.m1 == x.m2 == 2</div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-in-class-initializer" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-in-class-initializer" alt="%7B%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.48%3A%20Prefer%20in-class%20initializers%20to%20member%20initializers%20in%20constructors%20for%20constant%20initializers%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-in-class-initializer%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-in-class-initializer%22%7D" class="">C.48: Prefer in-class initializers to member initializers in constructors for constant initializers</a></div>
<div class="text">Wenn Klassenmitglieder direkt im Klassenkörper initialisiert werden, wird das Schreiben von Konstruktoren deutlich einfacher. Zusätzlich kannst du nicht vergessen, ein Klassenmitglied zu initialisieren.<br></div>
<div class="pre">class X {&nbsp;&nbsp; // BAD<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; string s;<br>&nbsp;&nbsp;&nbsp; int j;<br>public:<br>&nbsp;&nbsp;&nbsp; X() :i{666}, s{"qqq"} { }&nbsp;&nbsp; // j is uninitialized<br>&nbsp;&nbsp;&nbsp; X(int ii) :i{ii} {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // s is "" and j is uninitialized<br>&nbsp;&nbsp;&nbsp; // ...<br>};<br><br>class X2 {<br>&nbsp;&nbsp;&nbsp; int i {666};<br>&nbsp;&nbsp;&nbsp; string s {"qqq"};<br>&nbsp;&nbsp;&nbsp; int j {0};<br>public:<br>&nbsp;&nbsp;&nbsp; X2() = default;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all members are initialized to their defaults<br>&nbsp;&nbsp;&nbsp; X2(int ii) :i{ii} {}&nbsp;&nbsp; // s and j initialized to their defaults&nbsp; (1)<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="text">Während die Initialisierung von Klassenmitglieder im Klassenkörper das Default-Verhalten für die Objekt einer Klasse etabliert, erlaubt der Konstruktor (1) diese Default-Verhalten zu variieren. </div>
<div class="ztitel_kleiner"><a class="" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22C.49%3A%20Prefer%20initialization%20to%20assignment%20in%20constructors%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-initialize%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-initialize%22%2C%22anchor%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-initialize" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-initialize">C.49: Prefer initialization to assignment in constructors</a></div>
<div class="text">Diese Regel ist schon lang in der Anwendung. Die offensichtlichsten Gründe für Initialisierung gegenüber Zuweisung sind: Du kannst nicht vergessen einen Wert zu initialisieren und ihn daher uninitialisiert zu verwenden und die Initialisierung ist meistens schneller aber nicht langsamer als die Zuweisung.<br></div>
<div class="pre">class B {&nbsp;&nbsp; // BAD<br>&nbsp;&nbsp;&nbsp; string s1;<br>public:<br>&nbsp;&nbsp;&nbsp; B() { s1 = "Hello, "; }&nbsp;&nbsp; // BAD: default constructor followed by assignment<br>&nbsp;&nbsp;&nbsp; // ...<br>};</div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-factory" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-factory" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22C.50%3A%20Use%20a%20factory%20function%20if%20you%20need%20%C2%93virtual%20behavior%C2%94%20during%20initialization%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-factory%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-factory%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="">C.50: Use a factory function if you need “virtual behavior” during initialization</a></div>
<div class="text">Der Aufruf einer virtuellen Funktion aus dem Konstruktor verhält sich besonders. Um den Anwender zu schützen, wird der virtuelle Aufruf im Konstruktor unterbunden, da die abgeleiteten Klassen zu diesem Zeitpunkt noch nicht erzeugt sind. </div>
<div class="text">Daher wird in diesem Beispiel die <i>Base</i> Variante der virtuellen Funktion<i> f </i>aufgerufen.<br></div>
<div class="pre">// virtualConstructor.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Base{<br>&nbsp; Base(){<br>&nbsp;&nbsp;&nbsp; f();<br>&nbsp; }<br>&nbsp; virtual void f(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base called" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>struct Derived: Base{<br>&nbsp; virtual void f(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived called" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; Derived d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>};</div>
<div class="text">Hier ist die Ausgabe des Programms.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_140593344_90414ac7a2.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt werde ich eine <a href="https://de.wikipedia.org/wiki/Fabrikmethode" title="Link auf https://de.wikipedia.org/wiki/Fabrikmethode" class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FFabrikmethode%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FFabrikmethode%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Fabrikmethode%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D">Fabrikmethode</a> implementieren, um virtuelles Verhalten während der Objektinitialisierung zu erhalten. Um mit den Besitzverhältnissen richtig umzugehen, sollte die Fabrikmethode einen Smart Pointer wie <i>std::unique_ptr </i>oder <i>std::shared_ptr</i> zurückgeben. Als Startpunkt meiner Implementierung kommt das vorherige Beispiel zum Einsatz. Damit nur Objekte vom Typ <i>Derived</i> erzeugt werden können, setze ich den Konstruktor von <i>Base</i> auf <i>protected.</i><br></div>
<div class="pre">// virtualInitialisation.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;memory&gt;<br><br>class Base{<br>protected:<br>&nbsp; Base() = default;<br>public:<br>&nbsp; virtual void f(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Base called" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; }<br>&nbsp; template&lt;class T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp; static std::unique_ptr&lt;T&gt; CreateMe(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>&nbsp;&nbsp;&nbsp; auto uniq = std::make_unique&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp; uniq-&gt;f();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; return uniq;<br>&nbsp; }<br>&nbsp; virtual ~Base() = default;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>};<br><br>struct Derived: Base{<br>&nbsp; virtual void f(){<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Derived called" &lt;&lt; std::endl;<br>&nbsp; }<br>};<br><br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::unique_ptr&lt;Base&gt; base = Derived::CreateMe&lt;Derived&gt;();&nbsp;&nbsp; // (5)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>};</div>
<div class="text">Als letzter Schritt der Initialisierung soll die virtuelle Funktion f (1) aufgerufen werden. (2) ist die Fabrikmethode. Die Fabrikmethode ruft <i>f </i>auf, nachdem sie einen <i>std::unqiue_ptr </i>erzeugt hat und gibt diesen zurück. Wenn <i>Derived</i> von <i>Base </i>abgeleitet ist, dann ist <i>std::unique_ptr&lt;Derived&gt; </i>implizit nach <i>std::unique_ptr&lt;Base&gt; </i>konvertierbar. So erhalten wir virtuelles Verhalten während der Initialiserung.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_140593346_ca1ca292de.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Es gibt eine Gefahr beim Einsatz dieser Technik. Falls <i>base</i> seine Gültigkeit verliert, muss sichergestellt sein, dass der Destruktor von <i>Derived</i> aufgerufen wird. Das ist der Grund für den virtuellen Destruktor von <i>Base</i> (4). Falls der Destruktor nicht virtuell wäre, würde undefiniertes Verhalten resultieren. Seltsam: Wenn ich einen <i>std::shared_ptr </i>anstelle eines s<i>td::unique_ptr</i> in der Fabrikmethode verwendet hätte, wäre der virtuelle Destruktor von <i>Base</i> nicht notwendig gewesen.<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Sorry, aber der Artikel wurde ein wenig länglich. Aber ich fand gerade die letzte Regel (C.50) sehr interessant. Daher habe ich mehr dazu geschrieben als üblich. Im nächsten Artikel werde ich die Regeln für Konstruktoren abschließen und dann gibt es schon die Regeln für das Kopieren und Verschieben von Objekten. </div>
<div class="ztitel">Weitere Informationen</div>
<div class="text"><ul><li> <b>Sourcecode</b>: Den Sourcecode zu den ausführbaren Dateien gibt es auf meinem GibHub Account: <a class="" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22ModernesCppSource%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2FRainerGrimm%2FModernesCppSource%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2FRainerGrimm%2FModernesCppSource%22%7D" href="https://github.com/RainerGrimm/ModernesCppSource" title="Link auf https://github.com/RainerGrimm/ModernesCppSource">ModernesCppSource</a></li><li><b>Aktuelles pdf-Päckchen</b>: Alle 4-6 Wochen veröffentliche ich nach einer Abstimmung ein Päckchen zu meinen bisherigen Artikel. Diese Päckchen enthält alle Artikel, den Sourcecode und eine minimale cmake Datei zu dem gewünschten Thema. Wie der Download funktioniert, habe ich auf dem Artikel <a title="Link auf http://www.grimm-jaud.de/index.php/blog/das-pdf-paeckchen-ist-fertig-embedded-hohe-sicherheitsanforderungen" href="http://www.grimm-jaud.de/index.php/blog/das-pdf-paeckchen-ist-fertig-embedded-hohe-sicherheitsanforderungen" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22Das%20neue%20pdf-P%C3%A4ckchen%20ist%20fertig%3A%20Embedded%3A%20Hohe%20Sicherheitsanforderungen%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-pdf-paeckchen-ist-fertig-embedded-hohe-sicherheitsanforderungen%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-pdf-paeckchen-ist-fertig-embedded-hohe-sicherheitsanforderungen%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%7D" class="">Das neue pdf-Päckchen ist fertig: Embedded: Hohe Sicherheitsanforderungen</a> beschrieben.</li></ul></div>
