<div class="vorspann">Die Regel "T.5: Combine generic and OO techniques to amplify their strengths, not their costs" zur generischen Programmierung verwendet Type Erasure als Beispiel. Um Type Erasure zu erklären, muss ich ein wenig ausholen.</div>
<div class="text">Zuerst was ist Type Erasure?</div>
<div class="text"><ul><li><b>Type Erasure:</b> Es erlaubt, verschiedene Datentypen mit einem generischen Interface zu verwenden.</li></ul></div>
<div class="text">Du hast vermutlich relativ häufig Type Erasure in deinem C- oder C++-Code verwendet. Der C-Weg zu Type Erasure führt über void-Zeiger; der bei C++ hingegen über Objektorientierung. <br></div>
<div class="ztitel">Void-Zeiger</div>
<div class="text">Ein genauerer Blick auf <i>std::qsort</i> ist sehr interessant:</div>
<div class="pre">void qsort(void *ptr, std::size_t count, std::size_t size, cmp);</div>
<div class="text">Für die Vergleichsfunktion [i]cmp[/i] gilt:</div>
<div class="pre">int cmp(const void *a, const void *b);</div>
<div class="text">Die Vergleichsfunktion [i]cmp[/i] sollte dabei die folgenden Werte zurückgeben:</div>
<div class="text"><ul><li>kleiner Null, wenn das erste Argument kleiner ist als das zweite</li><li>Null, wenn beide Argumente identisch sind</li><li>größer Null, wenn das erste Argument größer ist als das zweite <br></li></ul></div>
<div class="text">Dank des [i]void[/i]-Zeigers lässt sich <i>std::qsort</i> sehr generisch verwenden, ist aber auch sehr fehlerbehaftet.</div>
<div class="text">Es kann relativ leicht passieren, dass du einen [i]std::vector&lt;int&gt;[/i] verwenden willst, deine Vergleichsfunktion aber C-Strings vergleicht. Der Compiler kann diesen Fehler nicht detektieren, da die Typinformation entfernt wurden. Daher endest du mit "undefined behaviour". </div>
<div class="text">Das geht aber besser in C++.</div>
<div class="ztitel">Objektorientierung</div>
<div class="text">Los geht es mit einem einfachen Beispiel, das als Startpunkt für weitere Variationen dienen wird: </div>
<div class="pre">// typeErasureOO.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>struct BaseClass{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; virtual std::string getName() const = 0;<br>};<br><br>struct Bar: BaseClass{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::string getName() const override {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return "Bar";<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>struct Foo: BaseClass{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; std::string getName() const override{<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return "Foo";<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>void printName(std::vector&lt;const BaseClass*&gt; vec){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp; for (auto v: vec) std::cout &lt;&lt; v-&gt;getName() &lt;&lt; std::endl;<br>}<br><br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Foo foo;<br>&nbsp;&nbsp;&nbsp; Bar bar; <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::vector&lt;const BaseClass*&gt; vec{&amp;foo, &amp;bar};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; printName(vec);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">[i]std::vector&lt;const Base*&gt;[/i] (1) besitzt als Parameter einen Zeiger auf ein konstantes [i]BaseClass[/i]. Das ist eine abstrakte Basisklasse, die in (3) verwendet wird. [i]foo[/i] und [i]bar[/i] sind konkrete Klassen (4).</div>
<div class="text">Die Ausgabe ist nicht so aufregend:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_158523402_e2dd8dbecc.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um es formaler auszudrücken: [i]foo[/i] und [i]bar[/i] setzen das Interface der Klasse [i]BaseClass[/i] um und können daher anstelle von [i]BaseClass[/i] verwendet werden. Dieses Prinzip wird <a title="Link auf https://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip" href="https://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FLiskovsches_Substitutionsprinzip%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22Liskovsches%20Substitutionsprinzip%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FLiskovsches_Substitutionsprinzip%22%7D" class="">Liskovsches Substitutionsprinzip</a> genannt und stellt Type Erasure mit OO dar.</div>
<div class="text">In objektorientierten Sprache implementierst du ein Interface. In dynamisch typisierten Sprachen wie Python interessieren dich Interfaces nicht. In diesen Sprachen interessiert dich Verhalten.</div>
<div class="ztitel">Templates</div>
<div class="text">Hier möchte ich einen kleinen Ausflug machen. In Python programmierst du gegen Verhalten und nicht gegen formale Interfaces. Für diese Idee steht der bekannte Ausdruck <a title="Link auf https://de.wikipedia.org/wiki/Duck-Typing" class="" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FDuck-Typing%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Duck-Typing%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FDuck-Typing%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%7D" href="https://de.wikipedia.org/wiki/Duck-Typing">Duck-Typing</a>. Um mich kurz zu halten: Der Begriff geht auf ein Gedicht von <a class="" alt="%7B%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FJames_Whitcomb_Riley%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22James%20Whitcomb%20Rileys%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FJames_Whitcomb_Riley%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%7D" href="https://de.wikipedia.org/wiki/James_Whitcomb_Riley" title="Link auf https://de.wikipedia.org/wiki/James_Whitcomb_Riley">James Whitcomb Rileys</a> zurück:<br></div>
<div class="einrueckung">“When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</div>
<div class="text">Was soll das heißen? Stelle dir eine Funktion [i]void acceptsOnlyDucks(Duck&amp; duck)[/i] vor, die nur [i]Duck[/i]s als Argument annimmt. In statisch typisierten Sprachen wie C++ kann diese Funktion von Datentypen verwendet werden, die öffentlich von Duck abgeleitet sind. In Python können hingegen alle Datentypen verwendet werden, die sich wie eine Duck verhalten. Um es deutlich auf den Punkt zu bringen: Wenn ein Vogel sich wie eine Ente verhält, dann ist es eine Ente. Ein Sprichwort in Python bringt das verschärft auf den Punkt: "Don't ask for permission, ask for forgiveness."</div>
<div class="text">In unserem Fall bedeutet dies, dass du einfach die Funktion [i]acceptsOnlyDucks[/i] mit einem Vogel aufrufst und auf das Beste hoffst. Falls dies nicht gut geht, fängst du die Ausnahme in einem Except Handler. Diese Strategie funktioniert ziemlich gut und schnell in Python. </div>
<div class="text">Das ist aber nur das Ende meines Ausflugs. Vermutlich wunderst du dich, warum ich über Duck-Typing in einem C++-Artikel geschrieben habe. Meine Antwort ist ganz einfach. Dank Templates besitzen wir Duck-Typing in C++. Wenn du dazu noch Duck-Ttyping mit der Objektorientierung verknüpfst, wird es sogar noch typsicher. </div>
<div class="text">[i]std::function[/i] als polymorpher Funktions-Wrapper ist ein nettes und prominentes Beispiel für Type Erasure in C++. </div>
<div class="ztitel_kleiner">std::function</div>
<div class="text">[i]std::function[/i] kann alles annehmen, was sich wie eine Funktion verhält. Genauer gesagt heißt dies, dass [i]std::function[/i] zum Beispiel eine Funktion, ein Funktionsobjekt, ein von [i]std::bind[/i] erzeugtes Funktionsobjekt oder einfach nur eine Lambda-Funktion annehmen kann: </div>
<div class="pre">// callable.cpp<br><br>#include &lt;cmath&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br><br>double add(double a, double b){<br>&nbsp;&nbsp; &nbsp;return a + b;<br>}<br><br>struct Sub{<br>&nbsp;&nbsp; &nbsp;double operator()(double a, double b){<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return a * b;<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>double multThree(double a, double b, double c){<br>&nbsp;&nbsp; &nbsp;return a * b * c;<br>}<br><br>int main(){<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; using namespace std::placeholders;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::map&lt;const char , std::function&lt;double(double, double)&gt;&gt; dispTable{&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {'+', add },&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {'-', Sub() },&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {'*', std::bind(multThree, 1, _1, _2) },&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {'/',[](double a, double b){ return a / b; }}};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3.5 + 4.5 = " &lt;&lt; dispTable['+'](3.5, 4.5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3.5 - 4.5 = " &lt;&lt; dispTable['-'](3.5, 4.5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3.5 * 4.5 = " &lt;&lt; dispTable['*'](3.5, 4.5) &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "3.5 / 4.5 = " &lt;&lt; dispTable['/'](3.5, 4.5) &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Ich verwendete in diesem Beispiel ein Dispatch Table (1), das in diesem Fall Buchstaben auf aufrufbare Einheiten (Callables) abbildet. Eine aufrufbare Einheit kann eine Funktion (2), ein Funktionsobjekt (3), ein durch [i]std::bind[/i] erzeugtes Funktionsobjekt (4) oder eine Lambda-Funktion (5) sein. Die Ausdrücke _1, und _2 in (4) stehen für Platzhalter (6).</div>
<div class="text">Der entscheidende Punkt von [i]std::function[/i] ist es, dass diese verschiedenen Funktionstypen annimmt und ihre Typinformation reduziert (Type Erasure). [i]std::function[/i] fordert von ihren aufrufbaren Einheiten, dass sie zwei [/i]double[/i]s annimmt und eine [i]double[/i] zurückgibt: [i]std::function&lt;double(double, double)&gt;[/i]<span class="tx_code">.</span> Der Vollständigkeit halber ist hier die Ausgabe:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_158523408_1a90487736.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Bevor ich in meinem nächsten Artikel tiefer auf Type Erasure eingehe, möchte ich die drei Techniken kurz vergleichen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_158523414_ea032cf85c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Du kannst Type Erasure mit void-Zeigern, Objektorientierung oder Templates umsetzen. Lediglich die Implementierung mit Templates ist typsicher und setzt keine Ableitungshierarchie voraus. <br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wie Type Erasure mit Templates implementiert werden kann, darauf gehe ich in meinen nächsten Artikel ein. </div>
