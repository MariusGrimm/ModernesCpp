<div class="vorspann">Wir sprechen oft von klassischem und modernem C++. Was bedeutet das? Aber vor allem. Was ist modernes C++? Es gibt eine einfache und eine nicht so einfache Antwort. Die einfache Antwort ist. Modernes C++ ist C++, das auf C++11, C++14 und C++17 zugrunde liegt. Ich denke, du weißt es schon. Dieser Artikel und eine Serie von weiteren Artikel dreht sich um die nicht so einfache Antwort.</div><div class="text">Mit C++11 hatten wir eine Revolution. Diese Revolution wandelte sich mit C++14 zur Evolution und wird mit C++17 eine Evolution bleiben. Der Überblick zum Zeitstrahl of C++ Features macht meinen Punkt offensichtlich.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_135999191_3416c2375e.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Wenn du auf die Menge auf Features blickst, die wir seit C++11 erhalten haben und dir deren Auswirkung überlegt, musst du zu der Schlussfolgerung kommen: C++11 vor 2011 und seit 2011 sind verschiedene Sprachen. Die erste wird klassisches C++, die zweite modernes C++ genannt. Daher ist die idiomatische Art und Weise in C++ vor 2011 und seit 2011 zu programmieren vollkommen unterschiedlich.<br></div><div class="utitel">Zwei Ressouren</div><div class="text">Ich bin nicht alleine auf meine Suche. Es gibt bereits großartige Ressourcen. Hier sind zwei.</div><div class="ztitel">C++ Best Practices</div><div class="text"><a alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Flefticus%2Fcppbestpractices%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Flefticus%2Fcppbestpractices%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22C%2B%2B%20Best%20Practices%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%7D" href="https://github.com/lefticus/cppbestpractices" title="Link auf https://github.com/lefticus/cppbestpractices">C++ Best Practices</a> von Jason Turner ist eine "Collaborative Collection of C++ Best Practices". Sie ist eine sehr wertvolle Ressource für moderne Softwareentwicklung mit C++ und für allgemeine Betrachtungen zu gutem C++ Code. Die allgemeinen Betrachtungen schließen Sicherheit, die Wartung, Portierbarkeit, Gleichzeitigkeit und Performanz von Code ein.&nbsp;</div><div class="text">Heute will ich mich nicht auf die allgemeinen Betrachtungen konzentrieren, sondern auf die Sammlung von Werkzeugen, die Jason in C++ Best Practices anbietet. </div><div class="text">Seine C++ Best Practices enthält eine Sammlung viele Werkzeuge zur </div><div class="text"><ul><li>Versions Kontrolle <br> </li><li>Bauen von Software<br> </li><li>Continuous Integration</li><li>Compilers wie gcc, clang und msvc</li><li>Statische Code Analyse Werkzeuge<br> </li><li>Laufzeit Checker<br> </li><li>Testing</li><li>Debugging</li></ul></div><div class="text">Falls du ein professioneller Softwareentwickler bist - ich nehme es stark an, den du liest diesen Artikel - und du musst die Entscheidung fällen, welche Werkzeuge du in deiner professionellen Softwareentwicklung einsetzen sollst, dann gibt diese Quelle einen großartigen Überblick, welche Werkzeuge zur Verfügung stehen.</div><div class="text">Mit diesem Artikel möche ich dir einen Überblick geben, worüber ich insbesonder meine nächsten Artikel schreibe. Das dominate Thema werden die<a href="https://github.com/isocpp/CppCoreGuidelines" title="Link auf https://github.com/isocpp/CppCoreGuidelines" alt="%7B%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fisocpp%2FCppCoreGuidelines%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22%20C%2B%2B%20Core%20Guidelines%22%7D"> C++ Core Guidelines</a> sein. <br></div><div class="utitel">C++ Core Guidelines&nbsp; </div><div class="text">Dies sind die Ziele der Guidlelines: "This document is a set of guidelines for using C++ well. The aim of this document is to help people to use modern C++ effectively. By "modern C++" we mean C++11 and C++14 (and soon C++17)."</div><div class="text">Die Herausgeber sind Bjarne Stroustrup und Herb Sutter. </div><div class="text">Die C++ Core Guidelines sind eine Menge von mehr als 100 Regeln. Diese Regeln werden in Hauptabschnitte (<i>main section</i>) und unterstützende Abschnitte (supporting section) aufgeteilt. Hier sind die Hauptabschnitte. <br></div><div class="text"><ul><li>In: Introduction<br></li><li>P: Philosophy<br></li><li>I: Interfaces<br></li><li>F: Functions<br></li><li>C: Classes and class hierarchies<br></li><li>Enum: Enumerations<br></li><li>R: Resource management<br></li><li>ES: Expressions and statements<br></li><li>E: Error handling <br></li><li>Con: Constants and immutability<br></li><li>T: Templates and generic programming<br></li><li>CP: Concurrency<br></li><li>SL: The Standard library<br></li><li>SF: Source files<br></li><li>CPL: C-style programming<br></li><li>Pro: Profiles<br></li><li>GSL: Guideline support library<br></li><li>FAQ: Answers to frequently asked questions</li></ul></div><div class="text">Ich will gerne mal einen näheren Blick auf den Einführungsabschnitt werfen. Diese beschäftigt sich mit den folgenden Meta-Regeln.</div><div class="text"><ul><li>In.target: Target readership<br></li><li>In.aims: Aims<br></li><li>In.not: Non-aims<br></li><li>In.force: Enforcement<br></li><li>In.struct: The structure of this document<br></li><li>In.sec: Major section</li></ul></div><div class="text">Lasse mich die Meta-Regeln paraphrasieren. Der adressierte Leser (<b>target reader</b>) ist selbst ein C Programmierer. Das Ziel (<b>aim</b>) der Regeln ist es, Entwicklern zu helfen modernes C++ (C++11, C++14 und bald C++17) einzusetzen. Die Regeln betonen statische Typsicherheit und sicheres Ressourcenmanagement. Du solltest diese Regeln verstehen, den sie sind präskriptiv. Neben den Zielen, die sie verfolgen, gibt es Ziele, die sie nicht verfolgen (<b>non-aims</b>). Das Ziel der Regeln ist es weder minimal noch orthogonal zu sein, noch sollen sie sich einfach nacheinander lesen lassen oder ein Tutorial ersetzen. Die Regeln sind auch weder eine Anleitung, alten C++ Code in modernes C++ zu portieren, noch sollen sie sehr exakt sein oder eine vereinfachte Teilmenge von C++ beschreiben. Weder sind sie wertfrei noch perfekt. Jede Regel hat einen Abschnitt, der sich mit ihrer Durchführung (<b>enforcement</b>) beschäftigt, den die Regeln sollen den Entwicklern helfen ihren Code zu vereinheitlichen und zu modernisieren. Die Regel folgen einer einheitlichen Sturktur (<b>structure</b>). Die Struktur besteht aus den Punkten </div><div class="text"><ul><li>Rule&nbsp;</li><li>Rule Reference Number</li><li>Reason&nbsp;</li><li>Examples</li><li>Alternatives</li><li>Exceptions</li><li>Enforcement wie die Regel automatisch geprüft werden kann </li><li>See also</li><li>Notes&nbsp;</li><li>Discussion&nbsp;</li></ul></div><div class="text">Um ehrlich zu sein, diese Struktur erinnert mich sehr an die (Design) Pattern Literatur.</div><div class="text">Um die Absicht der Struktur klar auf den Punkt zu bringen, folgt als einfaches Beispiel die Regel R.22. Das R steht für Ressourcemanagement. </div><div class="ztitel">R.22: Verwene <i>make_shared()</i> um <i> shared_ptrs</i> zu erzeugen</div><div class="ztitel_kleiner">Reason: <br></div><div class="text">Falls du ein Objekt erzeugst und an den Konstruktor des <i>shared_ptr </i>übergibts, wendest du mit hoher Wahrschinelichkeit mehr als eine Speicherallokation und später eine Speicherdeallokation an, den das Objekt und der Referenz Zähler müssen seperat allokiert werden. Das ist nicht der Fall, falls du make_shared() verwendest.&nbsp; </div><div class="ztitel_kleiner">Example</div><div class="ztitel_kleiner">Consider:</div><div class="pre">shared_ptr&lt;X&gt; p1 { new X{2} }; // bad<br>auto p = make_shared&lt;X&gt;(2);&nbsp;&nbsp;&nbsp; // good<br></div><div class="text">Die<i> make_shared() </i> Version verwendet<i> X </i>nur einmal. Daher ist diese Variante im allgemeinen kürzer und schneller als die Variante mit dem expliziten<i> new</i> Aufruf.</div><div class="ztitel_kleiner">Enforcement (Simple)<br></div><div class="text">Gib eine Warnung aus, falls ein<i> shared_ptr </i> durch einen new Aufruf und nicht durch einen <i>make_shared</i> Aufruf erzeugt wird.<br> </div><div class="utitel">Wie geht's weiter?</div><div class="text">Bevor ich diesen Artikel beende, will ich ein paar Worte zu meiner Motivation sagen,&nbsp; über modernes C++&nbsp; und insebsondere über die C++ Core Guidlines zu schreiben. Wähend ich diese Zeilen schreibe, fällt mir aber auf, dass ich meine Motivation nicht auf ein paar Sätze reduzieren will. Daher weißt du bereits, wovon mein nächster Artikel handelt.&nbsp; .</div>