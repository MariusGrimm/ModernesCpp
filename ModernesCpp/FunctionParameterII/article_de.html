<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_139011935_df6caec91a.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="vorspann">Heute schließe ich meinen Artikel über Funktionen in den C++ Core Guidelines ab. <a alt="%7B%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D212698ded5dfcee2f8ed438a9db05251%26rm%3Dopen_article_id%26bid%3D2253605%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A2253605%2C%22type%22%3A%22B%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22target%22%3A%22%22%2C%22text%22%3A%22Der%20letzte%20Artikel%22%7D" title="Link auf Beitrag 2253605" class="" href="/exec/mainmenu.pl?sid=212698ded5dfcee2f8ed438a9db05251&amp;rm=open_article_id&amp;bid=2253605">Der letzte Artikel</a> hat die Syntax der Funktionsparameter und Rückgabewerte behandelt. In diesem geht es um deren Semantik.</div>
<div class="text">Bevor ich in die Details dieses Artikels abtauche, hier ist in bekannter Manier erst einmal ein Überblick zu den semantischen Regeln für Parameter, Rückgabewerte und ein paar weitere Regeln rund um Funktionen.</div>
<div class="text"><b>Parameter passing semantic rules:</b></div>
<div class="text"><ul><li>F.22: Use T* or owner&lt;T*&gt; to designate a single object<br></li><li>F.23: Use a not_null&lt;T&gt; to indicate "null" is not a valid value<br></li><li>F.24: Use a span&lt;T&gt; or a span_p&lt;T&gt; to designate a half-open sequence<br></li><li>F.25: Use a zstring or a not_null&lt;zstring&gt; to designate a C-style string<br></li><li>F.26: Use a unique_ptr&lt;T&gt; to transfer ownership where a pointer is needed<br></li><li>F.27: Use a shared_ptr&lt;T&gt; to share ownership</li></ul></div>
<div class="text"><b>Value return semantic rules:</b></div>
<div class="text"><ul><li>F.42: Return a T* to indicate a position (only)<br></li><li>F.43: Never (directly or indirectly) return a pointer or a reference to a local object<br></li><li>F.44: Return a T&amp; when copy is undesirable and "returning no object" isn't an option<br></li><li>F.45: Don't return a T&amp;&amp;<br></li><li>F.46: int is the return type for main()<br></li><li>F.47: Return T&amp; from assignment operators.</li></ul></div>
<div class="text"><b>Other function rules:</b></div>
<div class="text"><ul><li>F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)<br></li><li>F.51: Where there is a choice, prefer default arguments over overloading<br></li><li>F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms<br></li><li>F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread<br></li><li>F.54: If you capture this, capture all variables explicitly (no default capture)<br></li><li>F.55: Don't use va_arg arguments</li></ul></div>
<div class="ztitel">Parameter passing semantic <br></div>
<div class="text">Die Regeln dieses Abschnitts kann ich sehr kompakt abhandeln. Die meisten habe ich bereits im Artikel zu der <a alt="%7B%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D212698ded5dfcee2f8ed438a9db05251%26rm%3Dopen_article_id%26bid%3D2245170%22%2C%22type%22%3A%22B%22%2C%22destination%22%3A2245170%2C%22text%22%3A%22Guidelines%20Support%20Library%22%2C%22version%22%3A1%2C%22target%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%7D" title="Link auf Beitrag 2245170" href="/exec/mainmenu.pl?sid=212698ded5dfcee2f8ed438a9db05251&amp;rm=open_article_id&amp;bid=2245170" class="">Guidelines Support Library</a> beschrieben. Wer daher neugierig bist, lese den zitierten Artikel. Ich werde nur kurz auf die erste Regel F.22 eingehen.<br></div>
<div class="ztitel_kleiner">F.22: Use T* or owner&lt;T*&gt; to designate a single object<br></div>
<div class="text">Was heißt, dass T* ein einzelnes Objekt bezeichnen soll? Die Regel beantwortet direkt die Frage. Zeiger können für viele Zwecken verwendet werden. Zeiger können die folgenden Rollen annehmen:<br></div>
<div class="text"><ol><li>Objekte, die von der Funktion nicht gelöscht werden dürfen</li><li>Objekte, die auf dem Heap angelegt wurden und von der Funktion gelöscht werden müssen</li><li>Nullzeiger (<i>nullptr</i>)<br></li><li>C-Strings</li><li>C-Arrays</li><li>Positionen in C-Arrays</li></ol></div>
<div class="text">Angesichts dieser verschiedenen Rollen, die Zeiger annehmen können, sollte man sie nur für Objekte (1) verwenden, die nicht gelöscht werden dürfen.</div>
<div class="text">Wie bereits angekündigt, werde ich die verbleibenden Regeln F.23 bis F.27 zu Funktionsparametern überspringen.</div>
<div class="ztitel">Value return semantic rules</div>
<div class="text"><b>F.42: Return a T* to indicate a position (only)</b></div>
<div class="text">Das lässt sich noch besser auf den Punkt bringen. Man soll keine Zeiger verwenden, um Besitzverhältnisse auszudrücken. Das ist ein Missbrauch von Zeigern. Hier ist ein Beispiel:&nbsp; </div>
<div class="pre">Node* find(Node* t, const string&amp; s)&nbsp; // find s in a binary tree of Nodes<br>{<br>&nbsp;&nbsp;&nbsp; if (t == nullptr || t-&gt;name == s) return t;<br>&nbsp;&nbsp;&nbsp; if ((auto p = find(t-&gt;left, s))) return p;<br>&nbsp;&nbsp;&nbsp; if ((auto p = find(t-&gt;right, s))) return p;<br>&nbsp;&nbsp;&nbsp; return nullptr;<br>}</div>
<div class="text">Die Guidelines sind in diesem Punkt sehr eindeutig. Man darf nicht ein Objekt aus einer Funktion zurückgeben, das sich nicht bereits im Bereich der aufrufenden Funktion befindet. Die nächste Regel adressiert genau diesen typischen Programmierfehler. <br></div>
<div class="text"><b>F.43: Never (directly or indirectly) return a pointer or a reference to a local object</b></div>
<div class="text">Diese Regel ist sehr einleuchtend, lässt sich aber mit ein paar verschachtelten Funktionsaufrufen allzu leicht aushebeln. Das Unheil nimmt in dem folgenden Beispiel mit der Funktion<i> f</i> seinen Lauf.<i> f</i> gibt einen Zeiger auf ein lokales Objekt zurück.</div>
<div class="pre">int* f()<br>{<br>&nbsp;&nbsp;&nbsp; int fx = 9;<br>&nbsp;&nbsp;&nbsp; return &amp;fx;&nbsp; // BAD<br>}<br><br>void g(int* p)&nbsp;&nbsp; // looks innocent enough<br>{<br>&nbsp;&nbsp;&nbsp; int gx;<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "*p == " &lt;&lt; *p &lt;&lt; '\n';<br>&nbsp;&nbsp;&nbsp; *p = 999;<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; "gx == " &lt;&lt; gx &lt;&lt; '\n';<br>}<br><br>void h()<br>{<br>&nbsp;&nbsp;&nbsp; int* p = f();<br>&nbsp;&nbsp;&nbsp; int z = *p;&nbsp; // read from abandoned stack frame (bad)<br>&nbsp;&nbsp;&nbsp; g(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pass pointer to abandoned stack frame to function (bad)<br>}</div>
<div class="text"><b>F.44: Return a T&amp; when copy is undesirable and "returning no object" isn't an option</b></div>
<div class="text">Die C++-Sprache sichert zu, dass ein Referenz <i>T&amp;</i> immer auf ein Objekt verweist. Daher muss der Aufrufer nicht auf einen Nullzeiger <i>nullptr</i> prüfen, da dies keine Option sein kann. Die Regel stellt kein Widerspruch zu vorherigen Regeln F.43 dar. F.43 besagt, dass man keine Referenz auf ein lokales Objekt zurückgeben soll.<br></div>
<div class="text"><b>F.45: Don't return a T&amp;&amp;</b></div>
<div class="text">Mit T&amp;&amp; können Entwickler eine Referenz auf ein bereits zerstörtes Objekt zurückgeben. Das ist sehr bösartig, und sie sind sehr leicht mitten im undefinierten Verhalten (F.43). </div>
<div class="text">Falls der Aufruf <i>f() </i>eine Kopie zurückgibt, erhält man eine Kopie auf ein temporäres Objekt.</div>
<div class="pre">template&lt;class F&gt;<br>auto&amp;&amp; wrapper(F f)<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; return f();<br>}</div>
<div class="text">Die einzigen Ausnahmen zu dieser Regel sind die Funktionen <i>std::move</i> für <a title="Link auf http://www.grimm-jaud.de/index.php/blog/move-semantik-zwei-nette-feature" class="" href="http://www.grimm-jaud.de/index.php/blog/move-semantik-zwei-nette-feature" alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22text%22%3A%22Move-Semantik%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fmove-semantik-zwei-nette-feature%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fmove-semantik-zwei-nette-feature%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%7D">Move-Semantik</a> und <i>std::forward</i> für<a class="" href="http://www.grimm-jaud.de/index.php/blog/perfect-forwarding" title="Link auf http://www.grimm-jaud.de/index.php/blog/perfect-forwarding" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22%20Perfect%20Forwarding%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%7D"> Perfect Forwarding</a>.<br></div>
<div class="text"><b>F.46: int is the return type for main()</b></div>
<div class="text">Standard C++ kennt zwei Arten, die <i>main</i>-Funktion zu deklarieren. <i>void</i> ist keine Option in C++ und schränkt daher die Portabilität des Codes ein.</div>
<div class="pre">int main();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // C++<br>int main(int argc, char* argv[]); // C++<br>void main();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad, not C++</div>
<div class="text">Die zweite Form ist äquivalent zu <i>int main(int argc, char** argv)</i>.</div>
<div class="text">Die <i>main</i>-Funktion gibt automatisch<i> return 0</i> zurück, falls eine <i>main-</i>Funktion keine <i>return-</i>Anweisung besitzt. <br> </div>
<div class="text"><b>F.47: Return T&amp; from assignment operators</b></div>
<div class="text">Der <a href="http://en.cppreference.com/w/cpp/language/copy_assignment" class="" title="Link auf http://en.cppreference.com/w/cpp/language/copy_assignment" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fcopy_assignment%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Copy-Zuweisungsoperator%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fcopy_assignment%22%2C%22user_params%22%3A%22%22%7D">Copy-Zuweisungsoperator</a> sollte T&amp; zurückgeben. In diesem Fall ist er konsistent mit den Containern der Standard Template Library und folgt dem bewährten Prinzip: "do as the ints do". </div>
<div class="text">Es besteht ein feiner Unterschied, ob ein Copy-Zuweisungsoperator sein Ergebnis mittels Referenz oder Copy zurückgibt. </div>
<div class="text"><ol><li><i><span class="pln">A</span><span class="pun">&amp;</span> <span class="kwd">operator</span><span class="pun">=(</span><span class="pln">constA</span><span class="pun">&amp;</span><span class="pln"> rhs</span><span class="pun">){</span> <span class="pun">...</span> <span class="pun">};<br></span></i></li><li><i><span class="pln">A</span><span class="pun">&nbsp;</span> <span class="kwd">operator</span><span class="pun">=(</span><span class="pln">constA</span><span class="pun">&amp;</span><span class="pln"> rhs</span><span class="pun">){</span> <span class="pun">...</span> <span class="pun">};</span></i></li></ol><br></div>
<div class="text">Im zweiten Fall führt die Kette von Zuweisungen zu zwei zusätzlichen Copy-Konstruktor und Destruktor Aufrufen.<br></div>
<div class="ztitel"><b>Other function rules:</b></div>
<div class="text"><b>F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)</b></div>
<div class="text">In C++11 gibt es aufrufbare Einheiten wie Funktionen, Funktionsobjekte und Lambda-Funktionen. Häufig taucht die Frage auf: Wann soll ich eine Funktion oder eine Lambda-Funktion verwenden? Hier sind zwei einfache Faustregeln.</div>
<div class="text"><ol><li> Falls eine aufrufbare Einheit lokale Variablen verwendet oder in einem lokalen Bereich verwendet wird, sollte man eine Lambda-Funktion einsetzen.</li><li>Falls man eine aufrufbare Einheit überladen will, setzt man eine Funktion ein.</li></ol></div>
<div class="pre">void print(const string&amp; s, format f = {});</div>
<div class="text">versus</div>
<div class="pre">void print(const string&amp; s);&nbsp; // use default format<br>void print(const string&amp; s, format f);<br></div>
<div class="text"><b>F.51: Where there is a choice, prefer default arguments over overloading</b></div>
<div class="text">Falls man eine Funktion mit einer variablen Anzahl an Argumenten aufrufen muss, zieht man Default-Argumente dem Überladen der Funktion vor. Damit setzt man automatisch das <a alt="%7B%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22DRY-Prinzip%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%7D" class="" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" title="Link auf https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY-Prinzip</a> um (don't repeat yourself).<br></div>
<div class="text"><b>F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</b></div>
<div class="text">Aus Performanz- und Korrektheitsgründen werden Entwickler meist ihre Variablen in Lambda-Funktionen per Referenz verwenden. Aus Effizienzgründen heißt dies entsprechend der Regel F.16, falls für ihre Variable p gilt: <i>sizeof(p) &gt; 4*sizeof(int).</i></div>
<div class="text">Da man eine Lambda-Funktion lokal verwendest, bekommt man auch keine Lebenszeitproblem mit einer verwendeten Variable<i> message. </i></div>
<div class="pre">std::for_each(begin(sockets), end(sockets), [&amp;message](auto&amp; socket)<br>{<br>&nbsp;&nbsp;&nbsp; socket.send(message);<br>});<br></div>
<div class="text"><b>F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</b></div>
<div class="text">Man muss sehr vorsichtig sein, wenn man einen Thread im Hintergrund laufen lässt (detach). Der kleine Codeschnipsel besitzt bereits zwei <a title="Link auf https://www.heise.de/developer/artikel/Race-Conditions-versus-Data-Races-3717884.html" href="https://www.heise.de/developer/artikel/Race-Conditions-versus-Data-Races-3717884.html" class="" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FRace-Conditions-versus-Data-Races-3717884.html%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22%22%2C%22text%22%3A%22Race%20Condition%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2Fdeveloper%2Fartikel%2FRace-Conditions-versus-Data-Races-3717884.html%22%7D">Race Condition</a>.</div>
<div class="pre">std::string s{"undefined behaviour"};<br>std::thread t([&amp;]{std::cout &lt;&lt; s &lt;&lt; std::endl;});<br>t.detach();</div>
<div class="text"><ol><li>Der erzeugte Thread t kann länger leben als sein Erzeuger. Daher existiert<i> std::string</i> eventuell nicht mehr. <br></li><li>Der erzeugte Thread t möchte länger leben als sein Erzeuger. Daher existiert <i>std::cout</i> eventuell nicht mehr. <br></li></ol> </div>
<div class="text"><b>F.54: If you capture this, capture all variables explicitly (no default capture)</b></div>
<div class="text">Es scheint, als ob man mit [=] alle Argumente per Copy bindest. Tatsächlich bindet man aber in einem Objekt damit alle Mitglieder per Referenz. Das kann, muss aber nicht die Intention sein.<br></div>
<div class="pre">class My_class {<br>&nbsp;&nbsp;&nbsp; int x = 0;<br><br>&nbsp;&nbsp;&nbsp; void f() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto lambda = [=]{ std::cout &lt;&lt; x; };&nbsp; // bad&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 42;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lambda();&nbsp;&nbsp; // 42<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 43;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lambda();&nbsp;&nbsp; // 43<br>&nbsp;&nbsp;&nbsp; }<br>};</div>
<div class="text">Die Lambda-Funktion bindet x per Referenz. <br></div>
<div class="text"><b>F.55: Don’t use va_arg arguments</b></div>
<div class="text">Falls eine Funktion eine beliebige Anzahl an Argumenten annehmen soll, setzt&nbsp; man Variadic Templates ein. Im Gegensatz zu<i> va_args</i> kann der Compiler bei diesen automatischen den richtigen Typ bestimmen. Mit C++17 lässt sich auf diese beliebige Anzahl an Argumente direkt ein Operator anwenden. </div>
<div class="pre">template&lt;class ...Args&gt;<br>auto sum(Args... args) { // GOOD, and much more flexible<br>&nbsp;&nbsp;&nbsp; return (... + args); // note: C++17 "fold expression"<br>}<br><br>sum(3, 2); // ok: 5<br>sum(3.14159, 2.71828); // ok: ~5.85987</div>
<div class="text">Falls der Codeschnipsel für ungewohnt ausschaut, hier geht es zu meinem Artikel zu <a href="http://www.modernescpp.com/index.php/fold-expressions" class="" title="Link auf http://www.modernescpp.com/index.php/fold-expressions" alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Ffold-expressions%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Fold%20Expressions%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Ffold-expressions%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%7D">Fold Expressions</a>.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Klassen sind benutzerdefinierte Typen. Sie erlauben es, Zustand und Verhalten zu kapseln. Dank Klassenhierarchien kannst man Typen organisieren. Daher geht es in dem nächsten Artikel um Regeln für Klassen und Klassenhierarchien. </div>