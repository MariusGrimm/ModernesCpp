<div class="vorspann">Interfaces sind ein Vertrag zwischen dem Serviceanbieter und dem Servicenutzer. Die C++ Core Guidelines stellt 20 Regeln für diesen Vertrag auf, denn "interfaces is probably the most importang single aspect of code organization".</div>
<div class="text">Bevor ich die Regeln vorstelle, gibt es hier einen kompakten Überblick.<img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_137207287_6aeee90513.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text"><ul><li>I.1: Make interfaces explicit<br></li><li>I.2: Avoid global variables<br></li><li>I.3: Avoid singletons<br></li><li>I.4: Make interfaces precisely and strongly typed<br></li><li>I.5: State preconditions (if any)<br></li><li>I.6: Prefer Expects() for expressing preconditions<br></li><li>I.7: State postconditions<br></li><li>I.8: Prefer Ensures() for expressing postconditions<br></li><li>I.9: If an interface is a template, document its parameters using concepts<br></li><li>I.10: Use exceptions to signal a failure to perform a required task<br></li><li>I.11: Never transfer ownership by a raw pointer (T*)<br></li><li>I.12: Declare a pointer that must not be null as not_null<br></li><li>I.13: Do not pass an array as a single pointer<br></li><li>I.22: Avoid complex initialization of global objects<br></li><li>I.23: Keep the number of function arguments low<br></li><li>I.24: Avoid adjacent unrelated parameters of the same type<br></li><li>I.25: Prefer abstract classes as interfaces to class hierarchies<br></li><li>I.26: If you want a cross-compiler ABI, use a C-style subset<br></li><li>I.27: For stable library ABI, consider the Pimpl idiom<br></li><li>I.30: Encapsulate rule violations</li></ul></div>
<div class="text">Ich kann die Regeln nicht im Details vorstellen. Dazu sind es zu viele. Daher werde ich in diesem Artikel über die ersten zehn schreiben und im nächsten Artikel mich den verbleibenden zehn widmen. Los geht's.</div>
<div class="ztitel">I.1: Make interfaces explicit</div>
<div class="text">In dieser Regel geht es um Korrektheit. Das bedeutet, das Annahmen über die Funktionalität einer Funktion im Interface ausgedrückt werden sollen. Falls das nicht geschieht, können diese Annahmen leicht übersehen werden und der Code ist schwierig zu testen.</div>
<div class="pre">int round(double d)<br>{<br>&nbsp;&nbsp;&nbsp; return (round_up) ? ceil(d) : d;&nbsp;&nbsp;&nbsp; // don't: "invisible" dependency<br>}</div>
<div class="text">Zum Beispiel drückt die Funktion <i>round </i>nicht aus, dass ihr Ergebnis von der globalen Variable <i>round_up</i> abhängt.<br></div>
<div class="ztitel">I.2: Avoid global variables</div>
<div class="text">Die Regel ist natürlich offensichtlich, aber sie spricht explizit von veränderlichen globalen Variablen. Globale Konstanten sind unproblematisch, da sie keine Abhängigkeiten in eine Funktion induzieren und keine race conditions verursachen können.<br></div>
<div class="ztitel">I.3: Avoid singletons</div>
<div class="text">Singletons sind verkleidete, globale Objekte. Daher solltest du sie vermeiden.<br></div>
<div class="ztitel">I.4: Make interfaces precisely and strongly typed</div>
<div class="text">Die Begründung der Regel ist sehr überzeugend: Datentypen sind die einfachste und expliziteste Dokumentation, besitzen eine wohl-definierte Semantik und werden durch den Compiler automatisch geprüft.</div>
<div class="text">Hier ist ein Beispiel:</div>
<div class="pre">void draw_rect(int, int, int, int);&nbsp;&nbsp; // great opportunities for mistakes<br>draw_rect(p.x, p.y, 10, 20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // what does 10, 20 mean?<br><br>void draw_rectangle(Point top_left, Point bottom_right);<br>void draw_rectangle(Point top_left, Size height_width);<br><br>draw_rectangle(p, Point{10, 20});&nbsp; // two corners<br>draw_rectangle(p, Size{10, 20});&nbsp;&nbsp; // one corner and a (height, width) pair</div>
<div class="text">Wie leicht kann es passieren, die Funktion <i>draw_rect</i> falsch zu verwenden? Vergleiche die Funktion mit der Funktion <i>draw_rectangle.</i> Der Compiler sichert zu, dass diese nur mit <i>Point </i>oder <i>Size</i> Objekten verwendet werden kann. </div>
<div class="text">Du solltest daher in deinem Prozess der Codesäuberung nach Funktionen Ausschau halten, die viele built-in Datentypen als Argument verwenden; oder noch schlimmer, die den Datentype <i>void* </i>als Argument verwenden. <br></div>
<div class="ztitel">I.5: State preconditions (if any)</div>
<div class="text">Wenn möglich, solltest du Vorbedingungen an deine Funktion, wie <i>x</i> darf in double <i>sqrt(double x) </i>nicht negativ sein, als Zusicherungen formulieren. </div>
<div class="text">Dank der Funktion <i>Expects()</i> der <a alt="%7B%22text%22%3A%22Guideline%20support%20library%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23S-gsl%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" title="Link auf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl" class="">Guideline support library</a> (GSL) kannst du deine Vorbedingungen direkt ausdrücken. </div>
<div class="pre">double sqrt(double x) { Expects(x &gt;= 0); /* ... */ }</div>
<div class="text">Contracts, bestehend aus Vorbedingungen, Nachbedingungen und Zusicherungen und sind eines der Feature, auf das wir in C++20 hoffen können. Hier ist das offizielle Proposal <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf" class="" alt="%7B%22text%22%3A%22p03801.pdf%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0380r1.pdf%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0380r1.pdf%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%7D">p03801.pdf</a>.<br></div>
<div class="ztitel">I.6: Prefer Expects() for expressing preconditions</div>
<div class="text">Diese Regel ist der vorherigen relativ ähnlich, legt aber ihren Fokus auf einen anderen Aspekt. Du sollst Expects() und nicht zum Beispiel if Anweisungen, Kommentare oder assert() Anweisungen verwenden, um die Vorbedingungen an deinen Code zu stellen.<br></div>
<div class="pre">int area(int height, int width)<br>{<br>&nbsp;&nbsp;&nbsp; Expects(height &gt; 0 &amp;&amp; width &gt; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // good<br>&nbsp;&nbsp;&nbsp; if (height &lt;= 0 || width &lt;= 0) my_error();&nbsp;&nbsp; // obscure<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Der<i> Expects() </i>Ausdruck ist einfach zu identifizieren und wird sich aller Voraussicht nach mit C++20 prüfen lassen. </div>
<div class="ztitel">I.7: State postconditions, I.8: Prefer Ensures() for expressing postconditions</div>
<div class="text">Entsprechend der Argumente einer Funktion solltes du dir zum Rückgabewert einer Funktion Gedanken machen. Daher sind die Regeln zu den Nachbedingungen ähnlich wie die zu den gerade beschriebenen Vorbedingungen. <br></div>
<div class="ztitel">I.9: If an interface is a template, document its parameters using concepts</div>
<div class="text">Mit hoher Wahrscheinlichkeit werden wir mit C++20 Concepts bekommen. Concepts sind Prädikate für Template-Parameter, die sich zur Compilezeit auswerten lassen. So kann ein Concept die Menge der Argumente reduzieren, die sich für ein Template-Parameter verwenden lassen. Ich schrieb bereits vier Artikeln zu <a alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconcepts%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Concepts%22%7D" class="" href="http://www.grimm-jaud.de/index.php/blog/tag/concepts" title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/concepts">Concepts</a>, denn diese haben noch deutlich mehr zu bieten.</div>
<div class="text">Die Regel zu Concepts ist sehr einleuchtend. Du sollst einfach Concepts verwenden.</div>
<div class="pre">template&lt;typename Iter, typename Val&gt;<br>requires InputIterator&lt;Iter&gt; &amp;&amp; EqualityComparable&lt;ValueType&lt;Iter&gt;&gt;, Val&gt;<br>Iter find(Iter first, Iter last, Val v)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Der generische <i>find </i>Algorithmus fordert, das sein Template-Parameter <i>Iter </i>ein <i>InputIterator </i>und das sein zugrundeliegende Wert<i> EqualityComparable </i>ist.&nbsp; Falls du find mit einem Template-Argument aufrufst, dass diese Bedingungen nicht erfüllt, erhälst du eine <b>lesbare und einfach verständliche Fehlermeldun</b>g. <br></div>
<div class="ztitel">I.10: Use exceptions to signal a failure to perform a required task</div>
<div class="text">Hier kommt die Begründung: "It should not be possible to ignore an error because that could leave the system or a computation in an undefined (or unexpected) state."</div>
<div class="text">Die Regel bietet ein böses und ein gutes Beispiel für den zitierten "undefined (or unexpecead) state" an.<br></div>
<div class="pre">int printf(const char* ...);&nbsp;&nbsp;&nbsp; // bad: return negative number if output fails<br><br>template &lt;class F, class ...Args&gt;<br>// good: throw system_error if unable to start the new thread<br>explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);</div>
<div class="text">Im bösen Anwendungsfall kannst du die Ausnahme ignorieren und somit besitzt dein Programm undefiniertes Verhalten.</div>
<div class="text">Falls du keine Ausnahmen anwenden kannst, solltest du Wertpaare zurückgeben. Dank dem C++17 Feature <a alt="%7B%22text%22%3A%22structured%20binding%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-kern%23h2-1-4-structured-binding-deklaration%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-kern%23h2-1-4-structured-binding-deklaration%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/c-17-kern#h2-1-4-structured-binding-deklaration" href="http://www.grimm-jaud.de/index.php/blog/c-17-kern#h2-1-4-structured-binding-deklaration" class="">structured binding</a> kannst du diese Regel elegant umsetzen. <br></div>
<div class="pre">auto [val, error_code] = do_something();<br>if (error_code == 0) {<br>&nbsp;&nbsp;&nbsp; // ... handle the error or exit ...<br>}<br>// ... use val ...</div>
<div class="utitel">Wie geht's weiter?</div>
<div class="text">In dem nächsten Artikel schaue ich mir die verbleibenden Regeln zu Zeigern, der Initialisierung von globalen Variablen, Funktionsparameter und ABI (application binary interface) genauer an. In modernem C++ gibt zum guten Interfacdesign viel zu lernen.<br></div>
