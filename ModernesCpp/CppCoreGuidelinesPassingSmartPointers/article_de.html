<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_146428242_e981757886.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div><div class="vorspann">Die Übergabe von Smart-Pointern an Funktionen ist ein wichtiges Thema, das selten adressiert wird. Das gilt aber nicht mehr mit den C++ Core Guidelines, denn diese bieten sechs Regeln für std::unique_ptr und std::shared_ptr an.</div><div class="text">Die sechs Regeln verletzen das wichtige DRY-Prinzip (<a alt="%7B%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDon%27t_repeat_yourself%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Don%27t%20Repeat%20Yourself%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D" title="Link auf https://en.wikipedia.org/wiki/Don't_repeat_yourself" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">Don't Repeat Yourself</a>) der Softwareentwicklung. Am Ende sind es nur vier Regeln, die unser Leben als Softwareentwickler deutlich einfacher machen. Hier sind sie.</div><div class="text"><ul><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam" alt="%7B%22text%22%3A%22R.32%3A%20Take%20a%20unique_ptr%26lt%3Bwidget%26gt%3B%20parameter%20to%20express%20that%20a%20function%20assumes%20ownership%20of%20a%20widget%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-uniqueptrparam%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-uniqueptrparam%22%2C%22custom%22%3A%7B%7D%7D">R.32: Take a unique_ptr&lt;widget&gt; parameter to express that a function assumes ownership of a widget</a> <br></li><li> <a alt="%7B%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22R.33%3A%20Take%20a%20unique_ptr%26lt%3Bwidget%26gt%3B%26amp%3B%20parameter%20to%20express%20that%20a%20function%20reseats%20the%20widget%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-reseat%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-reseat%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-reseat" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-reseat">R.33: Take a unique_ptr&lt;widget&gt;&amp; parameter to express that a function reseats the widget</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-owner" alt="%7B%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22R.34%3A%20Take%20a%20shared_ptr%26lt%3Bwidget%26gt%3B%20parameter%20to%20express%20that%20a%20function%20is%20part%20owner%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam-owner%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam-owner%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-owner">R.34: Take a shared_ptr&lt;widget&gt; parameter to express that a function is part owner</a> <br></li><li> <a alt="%7B%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22R.35%3A%20Take%20a%20shared_ptr%26lt%3Bwidget%26gt%3B%26amp%3B%20parameter%20to%20express%20that%20a%20function%20might%20reseat%20the%20shared%20pointer%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam">R.35: Take a shared_ptr&lt;widget&gt;&amp; parameter to express that a function might reseat the shared pointer</a> <br></li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-const" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-const" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam-const%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam-const%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22R.36%3A%20Take%20a%20const%20shared_ptr%26lt%3Bwidget%26gt%3B%26amp%3B%20parameter%20to%20express%20that%20it%20might%20retain%20a%20reference%20count%20to%20the%20object%20%3F%3F%3F%22%7D">R.36: Take a const shared_ptr&lt;widget&gt;&amp; parameter to express that it might retain a reference count to the object ???</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrget" alt="%7B%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22R.37%3A%20Do%20not%20pass%20a%20pointer%20or%20reference%20obtained%20from%20an%20aliased%20smart%20pointer%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrget%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrget%22%2C%22user_params%22%3A%22%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrget">R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</a></li></ul></div><div class="text">Los geht es mit den ersten zwei Regeln für <i>std::unique_ptr</i>.</div><div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-uniqueptrparam%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-uniqueptrparam%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22R.32%3A%20Take%20a%20unique_ptr%26lt%3Bwidget%26gt%3B%20parameter%20to%20express%20that%20a%20function%20assumes%20ownership%20of%20a%20widget%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam">R.32: Take a unique_ptr&lt;widget&gt; parameter to express that a function assumes ownership of a widget</a></b></div><div class="text">Falls eine Funktion Besitzer eines <i>Widgets</i> werden soll, soll die Funktion ihren <i>std::unique_ptr&lt;Widget&gt; </i>per Copy annehmen. Die Konsequenz ist, dass der Aufrufer der Funktion den <i>std::unique_ptr&lt;Widget&gt;</i> verschieben muss, damit der Code übersetzt werden kann.<br></div><div class="pre">#include &lt;memory&gt;<br>#include &lt;utility&gt;<br><br>struct Widget{<br>&nbsp;&nbsp;&nbsp; Widget(int){}<br>};<br><br>void sink(std::unique_ptr&lt;Widget&gt; uniqPtr){<br>&nbsp;&nbsp;&nbsp; // do something with uniqPtr<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; auto uniqPtr = std::make_unique&lt;Widget&gt;(1998);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; sink(std::move(uniqPtr));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp; sink(uniqPtr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) ERROR<br>}</div><div class="text">Der Aufruf (1) ist syntaktisch richtig, aber der Aufruf (2) schlägt fehl, da ein <i>std::unique_ptr</i> nicht kopiert werden kann. Falls deine Funktion das Widget nur verwenden will, solltest du das Widget per Zeiger oder Referenz annehmen. Der Unterschied zwischen einem Zeiger einer Referenz ist es, dass der Zeiger ein Nullzeiger sein kann.</div><div class="pre">void useWidget(Widget* wid);<br>void useWidget(Widget&amp; wid);</div><div class="text"><b><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-reseat" alt="%7B%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-reseat%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-reseat%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22R.33%3A%20Take%20a%20unique_ptr%26lt%3Bwidget%26gt%3B%26amp%3B%20parameter%20to%20express%20that%20a%20function%20reseats%20the%20widget%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-reseat">R.33: Take a unique_ptr&lt;widget&gt;&amp; parameter to express that a function reseats the widget</a></b></div><div class="text">Manchmal möchte eine Funktion ein Widget neu setzen. In diesem Anwendungsfall solltest du den <i>std::unique_ptr&lt;Widget&gt;</i> als nichtkonstante Referenz annehmen.<br></div><div class="pre">#include &lt;memory&gt;<br>#include &lt;utility&gt;<br><br>struct Widget{<br>&nbsp;&nbsp;&nbsp; Widget(int){}<br>};<br><br>void reseat(std::unique_ptr&lt;Widget&gt;&amp; uniqPtr){<br>&nbsp;&nbsp;&nbsp; uniqPtr.reset(new Widget(2003));&nbsp;&nbsp; // (0)<br>&nbsp;&nbsp;&nbsp; // do something with uniqPtr<br>}<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; auto uniqPtr = std::make_unique&lt;Widget&gt;(1998);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; reseat(std::move(uniqPtr));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1) ERROR<br>&nbsp;&nbsp;&nbsp; reseat(uniqPtr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2) <br>}</div><div class="text">Nun schlägt der Aufruf (1) schief, da ein Rvalue nicht an eine nichtkonstante Lvalue-Referenz gebunden werden kann. Das gilt aber nicht für das Kopieren in (2). Ein Lvalue kann an eine nichtkonstante Lvalue Referenz gebunden werden. Ich möchte noch einen wichtigen Punkt hinzufügen. Der Aufruf (0) erzeugt nicht nur ein neues <i>Widget(2003)</i>, auch das alte <i>Widget(1998)</i> wird automatisch destruiert.</div><div class="text">Die Erklärungen zu den nächsten drei Regeln zu <i>std::shared_ptr</i> sind buchstäblich Wiederholungen. Daher werde ich eine Regel daraus machen. <br></div><div><ul><li><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam" alt="%7B%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22text%22%3A%22R.34%3A%20Take%20a%20shared_ptr%26lt%3Bwidget%26gt%3B%20parameter%20to%20express%20that%20a%20function%20is%20part%20owner%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam%22%2C%22type%22%3A%22E%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam">R.34: Take a shared_ptr&lt;widget&gt; parameter to express that a function is part owner</a> </b></li><li><b> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam" alt="%7B%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam%22%2C%22text%22%3A%22R.35%3A%20Take%20a%20shared_ptr%3Cwidget%3E%26%20parameter%20to%20express%20that%20a%20function%20might%20reseat%20the%20shared%20pointer%20%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" target="_blank">R.35: Take a shared_ptr&lt;widget&gt;&amp; parameter to express that a function might reseat the shared pointer </a> </b></li><li><b><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-const" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22R.36%3A%20Take%20a%20const%20shared_ptr%26lt%3Bwidget%26gt%3B%26amp%3B%20parameter%20to%20express%20that%20it%20might%20retain%20a%20reference%20count%20to%20the%20object%20%3F%3F%3F%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam-const%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-sharedptrparam-const%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-const">R.36: Take a const shared_ptr&lt;widget&gt;&amp; parameter to express that it might retain a reference count to the object ???</a></b></li></ul></div><div class="text">Hier sind die drei entscheidenden Funktionssignaturen.<br></div><div class="pre">void share(std::shared_ptr&lt;Widget&gt; shaWid);<br>void reseat(std::shard_ptr&lt;Widget&gt;&amp; shadWid);<br>void mayShare(const std::shared_ptr&lt;Widget&gt;&amp; shaWid);</div><div class="text">Die Funktionssignaturen sollten wir in Isolation betrachten. Was bedeutet die Signatur aus der Sicht der Funktion?</div><div class="text"><ul><li><b><i>void share(std::shared_ptr&lt;Widget&gt; shaWid);: </i></b>Ich bin für die Lebenszeit des Funktionskörpers ein Miteigentümer der <i>Widget.</i> Am Anfang des Funktionskörpers inkrementiere ich den Referenzzähler und am Ende dekrementiere ich den Referenzzähler. Daher bleibt das <i>Widget</i> so lange am Leben, wie ich es benötige.</li><li><b><i>void reseat(std::shard_ptr&lt;Widget&gt;&amp; shadWid);:</i></b> Ich bin nicht der Miteigentümer des <i>Widget,</i> da ich seinen Referenzzähler nicht erhöhe. Ich besitze keine Garantie, dass das <i>Widget</i> gültig ist, während ich es verwende. Ich kann das <i>Widget</i> aber neu setzen. Ein nichtkonstante Referenz ist eine Art ausleihen, das es erlaubt, die Ressource neu zu setzen.&nbsp;</li><li><b><i>void mayShare(const std::shared_ptr&lt;Widget&gt;&amp; shaWid);: </i></b>Ich leihe mir nur das <i>Widget</i> aus. Weder kann ich seine Lebenszeit verlängern noch es zurücksetzen. Um ehrlich zu sein, in diesem Fall solltest du einen Zeiger (<i>Widget*)</i> oder eine Referenz (<i>Widget&amp;</i>) als Parameter verwenden, denn ein <i>std::shared_ptr</i> fügt keinen Mehrwert hinzu. <b><i><br></i></b></li></ul></div><div class="text"><b><a alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22R.37%3A%20Do%20not%20pass%20a%20pointer%20or%20reference%20obtained%20from%20an%20aliased%20smart%20pointer%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrget%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rr-smartptrget%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrget" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-smartptrget">R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</a></b></div><div class="text">Um die Regel verständlich zu machen, kommt hier ein kleines Codeschnipsel.<br></div><div class="pre">void oldFunc(Widget* wid){<br>&nbsp; // do something with wid<br>}<br><br>void shared(std::shared_ptr&lt;Widget&gt;&amp; shaPtr){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; oldFunc(*shaPtr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; &nbsp;<br>&nbsp;&nbsp; // do something with shaPtr<br>&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;}<br><br>auto globShared = std::make_shared&lt;Widget&gt;(2011);&nbsp;&nbsp; // (1)<br><br><br>...<br><br>shared(globShared);</div><div class="text"><i>globShared </i>(1) ist ein globaler, geteilter <i>std::shared_ptr</i>. Die Funktion <i>shared</i> nimmt ihr Argument als Referenz (2) an. Daher wird der Referenzzähler von <i>shaPtr</i> nicht erhöht, und die Funktion verlängert konsequenterweise auch nicht die Lebenszeit von <i>Widget(2011)</i>. Das Problem beginnt mit (3). <i>oldFunc </i>erwartet einen Zeiger auf ein <i>Widget</i>. Damit besitzt <i>oldFunc </i>keine Garantie, dass <i>Widget</i> während ihrer Ausführung gültig bleibt. <i>oldFunc</i> leiht sich nur das Widget aus. </div><div class="text">Das Heilmittel ist einfach. Du musst sicherstellen, dass der Referenzzähler von <i>globShared </i>vor dem Aufruf von <i>oldFunc</i> erhöht wird. Das heißt, du solltest <i>std::shared_ptr</i> kopieren. <br></div><div class="text"><ul><li><b>Übergebe den [i]std::shared_ptr[/i] per Copy:</b></li></ul></div><div class="pre">void shared(std::shared_ptr&lt;Widget&gt; shaPtr){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; oldFunc(*shaPtr);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; // do something with shaPtr<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;} <br></div><div class="text"><ul><li><b>Lege ein Kopie von [i]shaPtr[/i] in der Funktion [i]shared[/i] an:&nbsp;</b> &nbsp;<br></li></ul></div><div class="pre">void shared(std::shared_ptr&lt;Widget&gt;&amp; shaPtr){<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; auto keepAlive = shaPtr;&nbsp;&nbsp; <br>&nbsp;&nbsp; oldFunc(*shaPtr);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; // do something with keepAlive or shaPtr<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;} <br></div><div class="text">Dieselbe Argumentation lässt sich natürlich auch auf einen <i>std::unique_ptr</i> anwenden. Aber für <i>std::unique_ptr</i> gibt es kein einfaches Heilmittel, da dieser nicht kopiert werden kann. Daher schlage ich vor, dass du den <i>std::unique_ptr </i>gegebenenfalls klonst und damit einen neuen <i>std::unique_ptr</i> erzeugst.</div><div class="ztitel">Wie geht's weiter?</div><div class="text">Das war der letzte von vier Artikel zum Ressourcen-Management in den C++ Core Guidelines. Die C++ Core Guidelines bietet mehr als 50 Regeln für Ausdrücke und Anweisungen an. Ich werde in meinem nächsten Artikel einen genaueren Blick auf diese Regeln werfen.</div><div class="ztitel">Weitere Informationen:</div><div class="text"><ul><li> Die neuen PDF-Päckchen <b>stehen zum Download bereit:</b><br></li><ul><li>Deutsch: <a href="http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle" alt="%7B%22ir_link%22%3A1%2C%22text%22%3A%22Multithreading%3A%20The%20High-Level%20Schnittstelle%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-multithreading-die-high-level-schnittstelle">Multithreading: The High-Level Schnittstelle</a> <br></li><li>Englisch: <a href="http://www.modernescpp.com/index.php/the-new-pdf-bundle-is-available-embedded-performance-matters" alt="%7B%22text%22%3A%22Embedded%3A%20Performance%20Matters%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-available-embedded-performance-matters%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fthe-new-pdf-bundle-is-available-embedded-performance-matters%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://www.modernescpp.com/index.php/the-new-pdf-bundle-is-available-embedded-performance-matters">Embedded: Performance Matters</a></li></ul></ul> </div>
