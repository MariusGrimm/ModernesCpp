<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143708378_3e5be873c8.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;">
</div>
<div class="text">Es gibt neun Regeln in den C++ Core Guidelines um auf
Objekte in Klassenhierarchien zuzugreifen. Diese sind einen genaueren
Blick wert.</div>
<div class="text">Hier sind die neun Regeln.</div>
<div class="ztitel">Accessing objects in a hierarchy rule summary:</div>
<div class="text"><ul><li> <a alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-poly%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.145%3A%20Access%20polymorphic%20objects%20through%20pointers%20and%20references%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-poly%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-poly" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-poly">C.145: Access polymorphic objects through pointers and references</a>
</li><li> <a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dynamic_cast%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dynamic_cast%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.146%3A%20Use%20dynamic_cast%20where%20class%20hierarchy%20navigation%20is%20unavoidable%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast">C.146: Use dynamic_cast where class hierarchy navigation is unavoidable</a>
</li><li> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast" class="" alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ref-cast%22%2C%22text%22%3A%22C.147%3A%20Use%20dynamic_cast%20to%20a%20reference%20type%20when%20failure%20to%20find%20the%20required%20class%20is%20considered%20an%20error%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ref-cast%22%7D">C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error</a>
</li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.148%3A%20Use%20dynamic_cast%20to%20a%20pointer%20type%20when%20failure%20to%20find%20the%20required%20class%20is%20considered%20a%20valid%20alternative%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ptr-cast%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ptr-cast%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D">C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative</a>
</li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-smart" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-smart" alt="%7B%22subject%22%3A%22%22%2C%22text%22%3A%22C.149%3A%20Use%20unique_ptr%20or%20shared_ptr%20to%20avoid%20forgetting%20to%20delete%20objects%20created%20using%20new%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-smart%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-smart%22%7D">C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new</a>
</li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_unique" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_unique" alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_unique%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22text%22%3A%22C.150%3A%20Use%20make_unique%28%29%20to%20construct%20objects%20owned%20by%20unique_ptrs%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_unique%22%2C%22subject%22%3A%22%22%7D">C.150: Use make_unique() to construct objects owned by unique_ptrs</a>
</li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_shared" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_shared" alt="%7B%22text%22%3A%22C.151%3A%20Use%20make_shared%28%29%20to%20construct%20objects%20owned%20by%20shared_ptrs%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_shared%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_shared%22%7D">C.151: Use make_shared() to construct objects owned by shared_ptrs</a>
</li><li> <a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-array" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-array" alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22C.152%3A%20Never%20assign%20a%20pointer%20to%20an%20array%20of%20derived%20class%20objects%20to%20a%20pointer%20to%20its%20base%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-array%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-array%22%7D">C.152: Never assign a pointer to an array of derived class objects to a pointer to its base</a>
</li><li><a alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-use-virtual%22%2C%22text%22%3A%22C.153%3A%20Prefer%20virtual%20function%20to%20casting%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-use-virtual%22%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-use-virtual" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-use-virtual">C.153: Prefer virtual function to casting</a></li></ul></div>
<div class="text">Slicing ist immer noch ein Problem in vielen Code-Basen.</div>
<div class="ztitel_kleiner"><a alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-poly%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.145%3A%20Access%20polymorphic%20objects%20through%20pointers%20and%20references%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-poly%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-poly" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-poly" class="">C.145: Access polymorphic objects through pointers and references</a></div>
<div class="text">Falls du eine virtuelle Funktion verwendest, weißt du
nicht, welche Klasse die Funktionalität zur Verfügung stellt. Aus diesem
Grund solltest du Zeiger oder Referenzen verwenden. Das bedeutet in dem
konkreten Fall, dass bei d "gesliced" werden.
</div>
<div class="pre">struct B{
&nbsp; int a;
&nbsp; virtual int f();
};

struct D : B{
&nbsp; int b;
&nbsp; int f() override;
};

void use(B b)
{
&nbsp;&nbsp;&nbsp; D d;
&nbsp;&nbsp;&nbsp; B b2 = d;&nbsp;&nbsp; // slice
&nbsp;&nbsp;&nbsp; B b3 = b;
}

void use2()
{
&nbsp;&nbsp;&nbsp; D d;
&nbsp;&nbsp;&nbsp; use(d);&nbsp;&nbsp; // slice
}</div>
<div class="text">Der erste und der zweite "slice" verursacht, dass nur der B-Anteil von D kopiert wird. </div>
<div class="text">Willst du mehr über "Slicing" wissen? Die Regel <a class="" title="Link auf https://www.heise.de/-3834288" href="https://www.heise.de/-3834288" alt="%7B%22version%22%3A1%2C%22target%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3834288%22%2C%22text%22%3A%22%20C.67%3A%20A%20base%20class%20should%20suppress%20copying%2C%20and%20provide%20a%20virtual%20clone%20instead%20if%20%C2%93copying%C2%94%20is%20desired%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3834288%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D"> C.67: A base class should suppress copying, and provide a virtual clone instead if “copying” is desired</a> beschäftigt sich mit "Slicing".</div>
<div class="text">Die nächsten drei Regeln gehen tiefer auf den <i>dynamic_cas</i>t ein. Bevor ich aber loslege und über dynamic_cast schreibe, möchte ich einen Punkt betonen: Konvertierungen wie ein <i>dynamic_cast</i> werden viel zu häufig verwendet. Die Aufgabe des <i>dynamic_cast </i>ist
es, Typ-sicher zwischen Zeiger und Referenzen auf Klassen hoch, runter
und seitwärts in der Klassenhierarchie zu konvertieren. (<a alt="%7B%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdynamic_cast%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22cppreference.con%20%C3%BCber%20dynamic_cast%20%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Flanguage%2Fdynamic_cast%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="http://en.cppreference.com/w/cpp/language/dynamic_cast" title="Link auf http://en.cppreference.com/w/cpp/language/dynamic_cast" class="">cppreference.con über dynamic_cast </a>). </div>
<div class="ztitel_kleiner"><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-dynamic_cast" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dynamic_cast%22%2C%22text%22%3A%22C.146%3A%20Use%20dynamic_cast%20where%20class%20hierarchy%20navigation%20is%20unavoidable%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-dynamic_cast%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D">C.146: Use dynamic_cast where class hierarchy navigation is unavoidable</a></div>
<div class="text">Los geht es mit einem Anwendungsfall von den C++ Core
Guidelines. Der Anwendungsfall besteht darin, durch eine
Klassenhierarchie zu navigieren.
</div>
<div class="pre">struct B {&nbsp;&nbsp; // an interface
&nbsp;&nbsp;&nbsp; virtual void f();
&nbsp;&nbsp;&nbsp; virtual void g();
};

struct D : B {&nbsp;&nbsp; // a wider interface
&nbsp;&nbsp;&nbsp; void f() override;
&nbsp;&nbsp;&nbsp; virtual void h();
};

void user(B* pb)
{
&nbsp;&nbsp;&nbsp; if (D* pd = dynamic_cast<d*>(pb)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ... use D's interface ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ... make do with B's interface ...
&nbsp;&nbsp;&nbsp; }
}</d*></div>
<div class="text">Um den richtigen Datentyp für <i>pb</i> <b>(1)</b> herauszufinden, ist ein <i>dynamic_cast</i> zur Laufzeit notwendig. Falls die Konvertierung fehlschlägt, gibt sie einen Nullzeiger zurück.</div>
<div class="pre">void user2(B* pb)&nbsp;&nbsp; // bad
{
&nbsp;&nbsp;&nbsp; D* pd = static_cast<d*>(pb);&nbsp;&nbsp;&nbsp; // I know that pb really points to a D; trust me
&nbsp;&nbsp;&nbsp; // ... use D's interface ...
}

void user3(B* pb)&nbsp;&nbsp;&nbsp; // unsafe
{
&nbsp;&nbsp;&nbsp; if (some_condition) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D* pd = static_cast<d*>(pb);&nbsp;&nbsp; // I know that pb really points to a D; trust me
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ... use D's interface ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ... make do with B's interface ...
&nbsp;&nbsp;&nbsp; }
}

void f()
{
&nbsp;&nbsp;&nbsp; B b;
&nbsp;&nbsp;&nbsp; user(&amp;b);&nbsp;&nbsp; // OK
&nbsp;&nbsp;&nbsp; user2(&amp;b);&nbsp; // bad error&nbsp;&nbsp; (1)
&nbsp;&nbsp;&nbsp; user3(&amp;b);&nbsp; // OK *if* the programmer got the some_condition check right // (2)
}</d*></d*></div>
<div class="text">Ein Zeiger auf <i>B</i> zu einem Zeiger auf<i> D </i><b>(1)</b> zu konvertieren, ist ein Fehler. Das kann unter gegebenenfalls auch für die Zeile <b>(2)</b> gelten.</div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ref-cast" alt="%7B%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C.147%3A%20Use%20dynamic_cast%20to%20a%20reference%20type%20when%20failure%20to%20find%20the%20required%20class%20is%20considered%20an%20error%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ref-cast%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ref-cast%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D">C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error</a></div>
<div class="text">Falls du einen <i>dynamic_cast</i> auf einen Zeiger
anwendest, bekommst du im Fehlerfall einen Nullzeiger zurück. Falls du
hingegen einen dynamic_cast auf eine Referenz anwendest, wird im
Fehlerfall eine Ausnahme von Typ std::bad_cast geworfen.
</div>
<div class="pre">// badCast.cpp

struct A{
&nbsp;&nbsp;&nbsp; virtual void f() {}
};
struct B : A {};

int main(){
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp; A a;
&nbsp;&nbsp;&nbsp; B b;
&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp; B* b1 = dynamic_cast<b*>(&amp;a);&nbsp; // nullptr, because 'a' is not a 'B'
&nbsp;&nbsp;&nbsp; B&amp; b2 = dynamic_cast<b&>(a);&nbsp;&nbsp; // std::bad_cast, because 'a' is not a 'B'
&nbsp; &nbsp;
}</b&></b*></div>
<div class="text">Der g++-6 Compiler beschwert sich in beiden Fällen über den falsch angewandeten <i>dynamic_cast</i>. Nur im Falle der Referenz führt dies dazu, dass die Programmausführung mit der Ausnahme <i>std::bad_cast</i> abgebrochen wird. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_143708385_0ed258c1e5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=0>" style="max-height: 25px; max-width: 25px;">
</div>
<div class="ztitel_kleiner"><a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-ptr-cast" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ptr-cast%22%2C%22text%22%3A%22C.148%3A%20Use%20dynamic_cast%20to%20a%20pointer%20type%20when%20failure%20to%20find%20the%20required%20class%20is%20considered%20a%20valid%20alternative%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-ptr-cast%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D">C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative</a></div>
<div class="text">Machmal ist es notwendig, einen alternativen Code auszuführen, wenn die Konvertierung eines Zeigers mit einem <i>dynamic_cast</i> fehlschlägt und damt einen Nullzeiger zurückgibt. </div>
<div class="ztitel_kleiner"><a alt="%7B%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-smart%22%2C%22text%22%3A%22C.149%3A%20Use%20unique_ptr%20or%20shared_ptr%20to%20avoid%20forgetting%20to%20delete%20objects%20created%20using%20new%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-smart%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-smart" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-smart">C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new</a> </div>
<div class="text"><i>std::unique_ptr</i> oder <i>std::shared_ptr</i>
anzuwenden ist eine wohl die wichtigste Regel aus den C++ Core
Guidelines. Dank ihr gehören Speicherlecks der C++-Vergangenheit an.
Falls du eine Anwendung programmierst und kein Infrastruktur wie ein
Bibliothek zur Verfügung stellst, möchte ich die Regel gerne
umformulieren: <b>Verwende niemals <i>new</i> (und <i>delete).</i></b>
</div>
<div class="text">Das Anwenden der Regel bedeutet, dass du <i>std::make_unique</i> und <i>std::make_shared</i> anwenden sollst um Zeiger zu erzeugen.
</div>
<div class="ztitel_kleiner"><a class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_unique" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_unique" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C.150%3A%20Use%20make_unique%28%29%20to%20construct%20objects%20owned%20by%20unique_ptrs%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_unique%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_unique%22%7D">C.150: Use make_unique() to construct objects owned by unique_ptrs</a>, <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_shared" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-make_shared" alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_shared%22%2C%22text%22%3A%22C.151%3A%20Use%20make_shared%28%29%20to%20construct%20objects%20owned%20by%20shared_ptrs%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-make_shared%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%7D">C.151: Use make_shared() to construct objects owned by shared_ptrs</a></div>
<div class="text">Da beide Regeln ziemlich ähnlich sind, werde ich sie
zusammen behandeln. std::make_unique und std::make_shared geben die
Garantie, dass ihre Operationen nicht unterbrochen werden. Das bedeutet
für das folgende Beispiel, dass kein Speicher verloren geht.
</div>
<div class="pre">f(std::make_unique<foo>(), bar());</foo></div>
<div class="text">Diese Garantie, dass kein Speicherleck entstehen kann, gibt der folgende Ausdruck aber nicht.</div>
<div class="pre">f(std::unique_ptr<foo>(new Foo()), bar());</foo></div>
<div class="text">Es ist möglich, dass zuerst <i>Foo</i> auf dem Heap angelegt und dann <i>bar</i> aufgerufen wird. Falls nun <i>bar</i> eine Ausnahme wirft, wird <i>Foo</i> nicht aufgeräumt und wird erhalten ein Speicherleck.</div>
<div class="text">Die gleiche Beobachtung gilt auch für <i>std::make_shared </i>um einen <i>std::shared_ptr </i>zu erzeugen. <i>std::make_shared </i>besitzt einen zusätzlichen Performanzvorteil gegenüber einem direkt <i>std::shared_ptr</i> Aufruf. Um einen <i>std::shared_ptr </i>zu
erzeugen, sind zwei Speicherallokationen notwendig: eine Allokation für
die zugrundeliegende Ressource und eine Allokation für den Zähler. Dank
<i>std::make_shared</i> lassen sich die beiden teuren Allokationen in
einem Schritt durchführen. Der Performanzunterschied ist dramatisch.
Genauere Zahlen gibt es auf meinem Artikel: <a alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22Speicher%20und%20Performanz%20Overhead%20von%20Smart%20Pointern%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%7D" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern" href="http://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern">Speicher und Performanz Overhead von Smart Pointern</a>. </div>
<div class="ztitel_kleiner"><a alt="%7B%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-array%22%2C%22text%22%3A%22C.152%3A%20Never%20assign%20a%20pointer%20to%20an%20array%20of%20derived%20class%20objects%20to%20a%20pointer%20to%20its%20base%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-array%22%7D" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-array" class="" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-array">C.152: Never assign a pointer to an array of derived class objects to a pointer to its base</a></div>
<div class="text">Es passiert nicht so häufig, aber wenn es passiert,
sind die Konsequenzen sehr dramatisch. Der Ergebnis kann ein ungültige
Zugriff auf ein Objekt sein oder Speicherkorruption. Genau diesen
ungültigen Zugriff auf ein Objekt stellt das folgende Beispiel vor.
</div>
<div class="pre">struct B { int x; };
struct D : B { int y; };&nbsp; &nbsp;

D a[] = {{1, 2}, {3, 4}, {5, 6}};
B* p = a;&nbsp;&nbsp;&nbsp;&nbsp; // bad: a decays to &amp;a[0] which is converted to a B*
p[1].x = 7;&nbsp;&nbsp; // overwrite D[0].y</div>
<div class="text">Die letzte Zuweisung des Codesbeispiels sollte das <i>x</i> Attribute der Instanz von <i>B</i> updaten. Tatsächlich überschreibt die Zuweisung das <i>y </i>Attribut eines <i>D </i>Objekts. Der Grund ist, dass der Zeiger<i> B*</i> einem Zeiger von abgeleiteten Objekten <i>D</i> zugewiesen wird.
</div>
<div class="text">"Decay" ist der Name einer impliziten Konvertierung,
die bei lvalues zu rvules, Arrays zu Zeigern und Funktionen zu
Funktionszeigern angewandt wird und die <i>const</i> und <i>volatile</i> Qualifizierer entfernt. Das bedeutet in dem folgenden Beispiel, dass du eine ein Funktion, die einen Zeiger auf <i>D*</i> erwartet, mit einem Array von <i>D</i>'s
aufrufen kannst. Das Argument d wird dadurch zu einem Zeiger auf das
erste Element des Arrays. Wichtige Information wie die Länge des Arrays
geht von <i>D</i> geht damit verloren. </div>
<div class="pre">void use(D* d);
D d[] = {{1, 2}, {3, 4}, {5, 6}};

use(d);</div>
<div class="ztitel_kleiner"><a alt="%7B%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-use-virtual%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C.153%3A%20Prefer%20virtual%20function%20to%20casting%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rh-use-virtual%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-use-virtual" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-use-virtual">C.153: Prefer virtual function to casting</a></div>
<div class="text">Dank <i>dynamic_cas</i>t kann Virtualität, gerne auf späte Bindung genannt, simuliert werden. Dieser Missbrauch des <i>dynamic_cast</i> ist aber hässlich und fehleranfällig. Du erhälst unter Umständen einen Nullzeiger oder eine <i>std::bad_cast </i>Ausnahme (siehe C.147). Die Regel <a href="https://www.heise.de/-3834288" class="" title="Link auf https://www.heise.de/-3834288" alt="%7B%22text%22%3A%22C.67%3A%20A%20base%20class%20should%20suppress%20copying%2C%20and%20provide%20a%20virtual%20clone%20instead%20if%20%C2%93copying%C2%94%20is%20desired%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3834288%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.heise.de%2F-3834288%22%7D">C.67: A base class should suppress copying, and provide a virtual clone instead if “copying” is desired</a> geht tiefer auf virtuelle Funktionen ein. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">C++ erlaubt das Überladen von Funktion,
Funktions-Templates und sogar Operatoren. Insbesondere das Überladen von
Operatoren wird sehr häufig kontrovers diskutiert. Zum Beispiel
verbietet <a alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22MISRA%20C%2B%2B%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffakten%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffakten%22%7D" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/fakten" href="http://www.grimm-jaud.de/index.php/blog/fakten">MISRA C++</a>,
eine Richtinie für eine sichere Teilmenge von C++, das Überladen von
Operatoren. Um ehrlich zu sein. Ich weiß nicht warum? Die C++ Core
Guidelines bieten zehn Regeln zum Überladen an. Diese werde ich mir im
nächsten Artikel genauer anschauen.
</div>
<div class="ztitel">Weitere Informationen</div>
<div class="text"><ul><li>Das PDF-Päckchen mit Artikel zu C++17 steht auf <a alt="%7B%22alias%22%3A%22%22%2C%22text%22%3A%22www.grimm-jaud.de%20%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-embedded-c-17%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fdas-neue-pdf-paeckchen-ist-fertig-embedded-c-17%22%7D" href="http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-embedded-c-17" title="Link auf http://www.grimm-jaud.de/index.php/blog/das-neue-pdf-paeckchen-ist-fertig-embedded-c-17" class="">www.grimm-jaud.de </a>bereit. Es enthält neben dem gut 30-seitigen PDF alle Codebeispiele und eine einfache cmake-Datei. </li></ul></div>
