<div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_139856356_61a0e4437f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="vorspann">In diesem Artikel geht es um die Nuller-, Fünfer- oder Sechserregel, die Unterschiede zwischen Referenz- und Copy-Semantik und ein weiteres, sehr verwandtes Thema: Tiefes versus Flaches kopieren.</div>
<div class="text">Um ganz genau zu sein. C++ besitzt circa 50 Regeln für den Lebenszyklus eines Objekts. Heute werde ich mir die drei sehr wichtigen Regeln zu den Default-Operatoren anschauen. Zu jeder Regel gibt es dazu den Link, sodass die Leser die Details gegebenenfalls genauer nachlesen können.&nbsp; </div>
<div class="text">C++ bietet sechs Default-Operatoren, manchmal werden sie auch spezielle Funktionen genannt, die den Lebenszyklus eines Objekts regeln. Konsequenterweise beginnt dieser Artikel mit den sechs Operatoren. </div>
<div class="text"><ul><li>ein Default Konstruktor: <b><i>X() </i></b></li><li>ein Copy-Konstruktor: <b><i>X(const X&amp;)</i></b></li><li>ein Copy-Zuweisungsoperator: <b><i>operator=(const X&amp;)</i></b></li><li>ein Move-Konstruktor: <b><i>X(X&amp;&amp;)</i></b></li><li>ein Move-Zuweisungsoperator: <b><i>operator=(X&amp;&amp;)</i></b></li><li>ein Destruktor: <b><i>~X()</i></b></li></ul></div>
<div class="text">Die Default-Operatoren sind stark verwandt. Das heißt, falls man einen implementiert oder ihn mit <i>=delete</i> unterbindest, sollte man sich zu den anderen fünf Operatoren Gedanken machen. Das Wort "implementiert" mag ein wenig verwirren. Es bedeutet für den Default-Konstruktor, das man ihn definieren oder vom Compiler anfordern kann.</div>
<div class="pre">X(){};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // explicitly defined<br>X() = default;&nbsp; // requested from the compiler<br></div>
<div class="text">Diese Aussage trifft natürlich auch für die weiteren fünf Default-Operatoren zu.</div>
<div class="text">Ich habe noch eine allgemeine Bemerkung, bevor ich über die sechs Default-Operatoren schreibe. C++ bietet Value- und nicht Referenz-Semantik für seine Datentypen an. Die beste Erläuterung zu beiden Begriffen konnte ich <a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fvalue-vs-ref-semantics%22%2C%22version%22%3A1%2C%22text%22%3A%22hier%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fisocpp.org%2Fwiki%2Ffaq%2Fvalue-vs-ref-semantics%22%7D" title="Link auf https://isocpp.org/wiki/faq/value-vs-ref-semantics">hier</a> finden. </div>
<div class="text"><ul><li><b>Value-Semantik</b>: Value (oder “Copy”)-Semantik bedeutet, dass eine Zuweisung den Wert zuweist und nicht nur den Zeiger auf diesen.<br></li><li><b>Referenz-Semantik</b>: Bei der Referenz-Semantik besteht Zuweisung aus einem kopieren der Zeiger (und Referenzen). </li></ul></div>
<div class="text">Hier sind die ersten drei Regeln.</div>
<div class="ztitel">Die Default-Operatoren Regeln</div>
<div class="text"><ul><li> <a class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero" alt="%7B%22text%22%3A%22C.20%3A%20If%20you%20can%20avoid%20defining%20any%20default%20operations%2C%20do%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-zero%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-zero%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D">C.20: If you can avoid defining any default operations, do</a> <br></li><li> <a title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero" alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-zero%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22C.21%3A%20If%20you%20define%20or%20%3Ddelete%20any%20default%20operation%2C%20define%20or%20%3Ddelete%20them%20all%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-zero%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%7D" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">C.21: If you define or =delete any default operation, define or =delete them all</a> <br></li><li><a alt="%7B%22href%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-matched%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C.22%3A%20Make%20default%20operations%20consistent%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fisocpp.github.io%2FCppCoreGuidelines%2FCppCoreGuidelines%23Rc-matched%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-matched" class="" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-matched">C.22: Make default operations consistent</a> <br></li></ul></div>
<div class="text"><b>C.20: If you can avoid defining any default operations, do</b></div>
<div class="text">Diese Regel ist auch unter dem Namen Nullerregel "the rule of zero" bekannt. Das bedeutet, falls eine Klasse keine Default-Operatoren benötigt, da bereits alle Mitglieder diese besitzen, muss man auch keine definieren. </div>
<div class="pre">struct Named_map {<br>public:<br>&nbsp;&nbsp;&nbsp; // ... no default operations declared ...<br>private:<br>&nbsp;&nbsp;&nbsp; string name;<br>&nbsp;&nbsp;&nbsp; map&lt;int, int&gt; rep;<br>};<br><br>Named_map nm;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // default construct<br>Named_map nm2 {nm};&nbsp; // copy construct</div>
<div class="text">Der Aufruf des Default- und des Copy-Konstruktors ist in diesem Fall möglich, da beide bereits für <i>std::string</i> und <i>std::map</i> vorhanden sind. <br></div>
<div class="text"><b>C.21: If you define or =delete any default operation, define or =delete them all</b></div>
<div class="text">Da wir alle sechs zu implementieren oder mit<i> =delete</i> zu unterbinden haben, ist diese Regel unter dem Name "<b>the rule of five</b>" bekannt. Die Zahl fünf ist in diesem Zusammenhang schräg, aber die Regel ist es nicht. Die sechs Operatoren sollten als logische Einheit betrachtet werden. Daher ist die Wahrscheinlichkeit sehr hoch, dass man nichtintuitive Datentypen erhältt, wenn man dieser Regel nicht folgt. Hier ist ein Beispiel aus den Guidelines.</div>
<div class="pre">struct M2 {&nbsp;&nbsp; // bad: incomplete set of default operations<br>public:<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; // ... no copy or move operations ...<br>&nbsp;&nbsp;&nbsp; ~M2() { delete[] rep; }<br>private:<br>&nbsp;&nbsp;&nbsp; pair&lt;int, int&gt;* rep;&nbsp; // zero-terminated set of pairs<br>};<br><br>void use()<br>{<br>&nbsp;&nbsp;&nbsp; M2 x;<br>&nbsp;&nbsp;&nbsp; M2 y;<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; x = y;&nbsp;&nbsp; // the default assignment<br>&nbsp;&nbsp;&nbsp; // ...<br>}</div>
<div class="text">Wann bricht die Klasse M2 die Erwartungshaltung? Zuerst einmal wird im Destruktor <i>rep</i> gelöscht, obwohl er nicht initialisiert wurde. Zum zweiten und das ist ein viel ernsteres Problem, kopiert der Copy-Zuweisungsoperator&nbsp;<i> (x = y) </i>in der letzten Zeile alle Mitglieder von M2. Das bedeutet insbesondere, das der Zeiger <i>rep</i> kopiert wird. Daher wird der Destruktor für <i>x </i>und <i>y </i>aufgerufen und wir erhalten undefiniertes Verhalten, da das Objekt zweimal gelöscht wurde.<br></div>
<div class="text"><b>C.22: Make default operations consistent</b></div>
<div class="text">Diese Regel schließt direkt an die vorherige Regel an. Falls man die Default-Operatoren mit unterschiedlicher Semantik implementiert, werden die Anwender mit maximaler Verwirrung reagieren. Zur Verdeutlichung habe ich die Klasse <i>Strange</i> implementiert. Um das Veriwrrungspotenzial auf den Punkt zu bringen, enthält sie einen Zeiger auf <i>int</i>. </div>
<div class="pre">// strange.cpp (https://github.com/RainerGrimm/ModernesCppSource)<br><br>#include &lt;iostream&gt;<br><br>struct Strange{ <br>&nbsp; <br>&nbsp; Strange(): p(new int(2011)){}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; // deep copy <br>&nbsp; Strange(const Strange&amp; a) : p(new int(*(a.p))){}&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp; <br>&nbsp; // shallow copy<br>&nbsp; Strange&amp; operator=(const Strange&amp; a){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; p = a.p;<br>&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp; }&nbsp; <br>&nbsp;&nbsp; <br>&nbsp; int* p;<br>&nbsp;&nbsp;&nbsp; <br>};<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Deep copy" &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; Strange s1;<br>&nbsp; Strange s2(s1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "s1.p: " &lt;&lt; s1.p &lt;&lt; "; *(s1.p): " &lt;&lt; *(s1.p) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "s2.p: " &lt;&lt; s2.p &lt;&lt; "; *(s2.p): " &lt;&lt; *(s2.p) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt;&nbsp; "*(s2.p) = 2017" &lt;&lt; std::endl;<br>&nbsp; *(s2.p) = 2017;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "s1.p: " &lt;&lt; s1.p &lt;&lt; "; *(s1.p): " &lt;&lt; *(s1.p) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "s2.p: " &lt;&lt; s2.p &lt;&lt; "; *(s2.p): " &lt;&lt; *(s2.p) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Shallow copy" &lt;&lt; std::endl;<br><br>&nbsp; Strange s3;<br>&nbsp; s3 = s1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (5)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "s1.p: " &lt;&lt; s1.p &lt;&lt; "; *(s1.p): " &lt;&lt; *(s1.p) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "s3.p: " &lt;&lt; s3.p &lt;&lt; "; *(s3.p): " &lt;&lt; *(s3.p) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; <br>&nbsp; std::cout &lt;&lt;&nbsp; "*(s3.p) = 2017" &lt;&lt; std::endl;<br>&nbsp; *(s3.p) = 2017;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (6)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "s1.p: " &lt;&lt; s1.p &lt;&lt; "; *(s1.p): " &lt;&lt; *(s1.p) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "s3.p: " &lt;&lt; s3.p &lt;&lt; "; *(s3.p): " &lt;&lt; *(s3.p) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "delete s1.p" &lt;&lt; std::endl; <br>&nbsp; delete s1.p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (7)<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "s2.p: " &lt;&lt; s2.p &lt;&lt; "; *(s2.p): " &lt;&lt; *(s2.p) &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "s3.p: " &lt;&lt; s3.p &lt;&lt; "; *(s3.p): " &lt;&lt; *(s3.p) &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div>
<div class="text">Die Klasse Strange besitzt einen Copy-Konstruktor (1) und einen Copy-Zuweisungsoperator (2). Der Copy-Konstruktor wendet tiefes Kopieren ("deep copy") und der Copy-Zuweisungsoperator flaches Kopieren ("shallow copy") an. Fast immer will man tiefes Kopieren (Value-Semantik) für die Datentypen; vermutlich will man nie, dass die Datentypen unterschiedliche Semantik für diese beiden Operationen besitzen.</div>
<div class="text">Der Unterschied ist, das tiefes Kopieren zwei neue, getrennte Objekte erzeugt <i>(p(new int(*(a.p)</i>), während flaches Kopieren (<i>p = a.p)</i> nur die Zeiger kopiert. Lass uns mit dem <i>Strange</i> Datentypen spielen. Hier ist die Ausgabe des Programms.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_139856365_3da949c371.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ich verwende in Ausdruck (3) den Copy-Konstruktor, um <i>s2</i> zu erzeugen. Die Ausgabe der Adresse des Zeigers und das Verändern des Werts von <i>s2</i> zeigt (4), <i>s1</i> und <i>s2 </i>sind vollkommen unabhängige Objekte. Das gilt aber nicht für <i>s1</i> und <i>s3.</i> Die Copy-Zuweisung in dem Ausdruck (5) erzeugt eine flache Kopie. Das Ergebnis ist, dass das Verändern des Zeiger <i>s3.p</i> (6) auch den Zeiger <i>s1.p</i> betrifft. Das gilt natürlich auch für den Wert, auf den sie verweisen. </div>
<div class="text">Der Spaß beginnt, wenn ich den Zeiger<i> s1.p</i> lösche (7). Aufgrund der tiefen Kopie besitzt dies Löschen keine Auswirkung auf <i>s2.p</i>, aber der Wert von <i>s3.p</i> wird zum Nullzeiger. Um noch genauer zu sein: Anschließendes Dereferenzieren eines Nullzeigers wie in dem abschließenden Ausdruck (<i>*s3.p</i>) stellt undefiniertes Verhalten dar-<br></div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Die Geschichte der C++ Core Guidelines zum Lebenszyklus von Objekten geht weiter. Im nächsten Artikel dreht sich alles um Destruktoren. </div>
<div class="ztitel">Hintergrundwissen</div>
<div class="text"><ul><li> <i>default </i>und <i>delete: </i><a alt="%7B%22text%22%3A%22Automatik%20mit%20Methode%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2014%2F08%2FC-11%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2014%2F08%2FC-11%22%7D" title="Link auf http://www.linux-magazin.de/Ausgaben/2014/08/C-11" class="" href="http://www.linux-magazin.de/Ausgaben/2014/08/C-11">Automatik mit Methode</a> (freier Artikel für das Linux-Magazin<i>)<br></i></li><li>Copy- und Move-Semantik: <a alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2012%2F12%2FC-11%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Rasch%20verschoben%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.linux-magazin.de%2FAusgaben%2F2012%2F12%2FC-11%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf http://www.linux-magazin.de/Ausgaben/2012/12/C-11" href="http://www.linux-magazin.de/Ausgaben/2012/12/C-11" class="">Rasch verschoben</a> (freier Artikel für das Linux-Magazin) <br></li></ul></div>