<div class="vorspann">Funktionen sind die "fundamental building block of programs" und "the most critical part in most interfaces". Diese Aussagen leiten die Regeln zu Funktionen in den "C++ Core Guidelines" ein und sind hundertprozentig richtig. Grund, tiefer in die mehr als 30 Regeln für Definition, Parameterübergabe und Rückgabewerte von Funktionen einzutauchen. <br></div>
<div class="text">Natürlich kann ich nicht zu jeder Regel alle Details liefern; dafür gibt es einfach zu viele. Ich werde versuchen, eine Geschichte zu erzählen, damit wir sie uns merken können. Los geht es mit den Regeln zu Definition von Funktionen. Hier ist der erste Überblick.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_138299999_bf688a9c3d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>F.1: “Package” meaningful operations as carefully named functions<br></li><li>F.2: A function should perform a single logical operation<br></li><li>F.3: Keep functions short and simple<br></li><li>F.4: If a function may have to be evaluated at compile time, declare it constexpr<br></li><li>F.5: If a function is very small and time-critical, declare it inline<br></li><li>F.6: If your function may not throw, declare it noexcept<br></li><li>F.7: For general use, take T* or T&amp; arguments rather than smart pointers<br></li><li>F.8: Prefer pure functions<br></li><li>F.9: Unused parameters should be unnamed</li></ul></div>
<div class="ztitel">Definition von Funktionen</div>
<div class="text"><b>F.1: “Package” meaningful operations as carefully named functions<br></b></div>
<div class="text"><b>F.2: A function should perform a single logical operation<br></b></div>
<div class="text"><b>F.3: Keep functions short and simple</b></div>
<div class="text">Die ersten drei Regeln sollten selbstverständlich sein und teilen eine gemeinsame Idee. Ich beginne mit der Regel F2. Wenn man eine Funktion schreibt, die<b> eine einzige logische Operation ausführt (F2)</b>, wird diese Funktion mit hoher Wahrscheinlichkeit <b>kurz und einfach (F3)</b> sein. Die Regeln sprechen von Funktionen, die auf einen Bildschirm passen. Nun hat man diese kurze und einfache Funktion, die genau eine Aufgabe ausführt. Dieser Funktion sollte man einen <b>sorgfältig ausgewählten Namen geben (F1)</b>. Dieser sorgfältig ausgewählte Name ist der elementare Baustein, den Entwickler mit weiteren Bausteinen zusammenfügen und höherer Abstraktionen bilden können. Nun besitzen sie Funktionen mit intuitiven Namen und daher einen intuitiven Einstieg in das Programm.<br></div>
<div class="text"><b>F.4: If a function may have to be evaluated at compile time, declare it constexpr</b></div>
<div class="text">Eine <i>constexpr</i>-Funktion ist eine Funktion, die zur Übersetzungszeit oder Laufzeit ausgeführt werden kann. Wer <i>constexpr</i>-Funktion mit konstanten Ausdrücken aufruft und das Ergebnis dieser Funktion zur Übersetzungszeit anfordert, wird es bereits zur Übersetzungszeit erhalten. Wer ein eine solche Funktion mit Argument aufruft, die sich nicht zur Übersetzungszeit auswerten lässt, kann diese Funktion wie eine gewöhnliche Funktion verwenden. </div>
<div class="pre">constexpr int min(int x, int y) { return x &lt; y ? x : y; }<br><br>constexpr auto res= min(3, 4);<br><br>int first = 3;<br>auto res2 = min(first, 4);</div>
<div class="text">Die Funktion <i>min</i> kann zur Übersetzungszeit ausgeführt werden. Falls ich <i>min </i>mit einem konstanten Ausdruck aufrufe und das Ergebnis zur Übersetzungszeit anfordere, erhalte ich das Ergebnis zur Übersetzungszeit: <i>constexpr auto res= min(3, 4)</i>. Ich kann <i>min</i> nur als gewöhnliche Funktion verwenden, falls <i>first</i> kein konstanter Ausdruck ist: <i>auto res2 = min(first, 4).</i></div>
<div class="text">Es gibt viel mehr über <i>constexpr-</i>Funktionen zu erzählen. Ihre Syntax war mit C++11 sehr eingeschränkt, unterscheidet sich aber mit C++14 kaum noch von einer gewöhnlichen Funktion. <i>constexpr</i>-Funktionen sind eine Art reine Funktionen in C++. Details dazu gibt es in meinen Artikeln zu <i><a title="Link auf http://www.grimm-jaud.de/index.php/blog/tag/constexpr" alt="%7B%22version%22%3A1%2C%22text%22%3A%22constexpr%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconstexpr%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Fconstexpr%22%7D" href="http://www.grimm-jaud.de/index.php/blog/tag/constexpr" class="">constexpr</a></i>. <br></div>
<div class="text"><b>F.5: If a function is very small and time-critical, declare it inline</b></div>
<div class="text">Ich war ziemlich überrascht, diese Regel zu lesen. Optimierer wenden <i>inline</i> an, wenn die Funktion nicht als <i>inline</i> deklariert ist. Das Gleiche gilt genau andersrum. Sie wenden <i>inline </i>nicht an, wenn die Funktion als <i>inline</i> deklariert ist. Letztlich ist <i>inline</i> nur ein Hinweis für den Optimierer, den Funktionsaufruf durch seinen Funktionskörper zu ersetzen. </div>
<div class="text"><i>constexpr</i>-Funktionen sind implizit <i>inline</i>. Das Gleiche gilt per Default für Klassenmethoden, die im Klassenkörper definiert werden, oder auch für Funktions-Templates.</div>
<div class="text">Mit modernen Compilern ist der wichtigste Grund für den Einsatz von <i>inline</i> ein anderer. Es erlaubt es, die One Defintion Rule (ODR) zu brechen. Man darf <i>inline</i>-Funktionen in mehr als einer Übersetzungseinheit definieren. Hier geht es zu meinem Artikel zu<i> <a title="Link auf http://www.grimm-jaud.de/index.php/blog/inline" alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22text%22%3A%22inline%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Finline%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Finline%22%2C%22custom%22%3A%7B%7D%7D" href="http://www.grimm-jaud.de/index.php/blog/inline" class="">inline</a></i>. <br></div>
<div class="text"><b>F.6: If your function may not throw, declare it noexcept</b></div>
<div class="text">Indem Entwickler eine Funktion als <i>noexcept </i>erklären, reduzieren sie die Anzahl der alternativen Kontrollpfade; daher ist <i>noexcept</i> ein Hinweis für den Optimierer.</div>
<div class="text">Sogar wenn eine Funktion eine Ausnahme werfen kann, ist der Einsatz von <i>noexcept </i>oft sinnvoll. <i>noexcept </i>bedeutet in dem Fall: Ich kümmere mich nicht um Ausnahmen. Der Grund mag sein, dass Entwickler keine explizite Möglichkeit besitzen, um auf die Ausnahme zu reagieren. Daher besteht als einzige Möglichkeit, dass automatisch <i>terminate() </i>aufgerufen wird. </div>
<div class="text">Hier ist ein Beispiel für eine Funktion, die als [i]noexcept[/i] deklariert wurde. Es kann eine Ausnahme werfen, falls dem Programm der Speicher ausgeht.</div>
<div class="pre">vector&lt;string&gt; collect(istream&amp; is) noexcept<br>{<br>&nbsp;&nbsp;&nbsp; vector&lt;string&gt; res;<br>&nbsp;&nbsp;&nbsp; for (string s; is &gt;&gt; s;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.push_back(s);<br>&nbsp;&nbsp;&nbsp; return res;<br>}<br></div>
<div class="text"><b>F.7: For general use, take T* or T&amp; arguments rather than smart pointers</b></div>
<div class="text">Wenn man Smart Pointer einsetzt, schränkt man den Anwendungsbereich einer Funktion ein. Das folgende Beispiel bringt die Aussage auf den Punkt.</div>
<div class="pre">// accepts any int*<br>void f(int*);<br><br>// can only accept ints for which you want to transfer ownership<br>void u(unique_ptr&lt;int&gt;);<br><br>// can only accept ints for which you are willing to share ownership<br>void s(shared_ptr&lt;int&gt;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>// accepts any int<br>void h(int&amp;);</div>
<div class="text">Die Funktionen <i>u </i>und <i>s</i> besitzen eine besondere Besitzsemantik. <i>u </i>will exklusiv sein Argument besitzen, <i>s </i>will sein Argument teilen. Die Funktion <i>s</i> hat einen kleinen Performanz-Overhead. Der Referenzzähler für <i>std::shared_ptr</i> muss erhöht und erniedrigt werden. Diese atomare Operation benötigt ein wenig Zeit.<br></div>
<div class="text"><b>F.8: Prefer pure functions</b></div>
<div class="text">Reine Funktionen sind Funktionen, die immer das gleiche Ergebnis zurückgeben, wenn sie die gleichen Argumente erhalten. Diese Eigenschaft wird auch <a alt="%7B%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FReferenzielle_Transparenz%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FReferenzielle_Transparenz%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22referenzielle%20Transparenz%22%2C%22version%22%3A1%7D" href="https://de.wikipedia.org/wiki/Referenzielle_Transparenz" title="Link auf https://de.wikipedia.org/wiki/Referenzielle_Transparenz" class="">referenzielle Transparenz</a> genannt. </div>
<div class="text">Reine Funktionen besitzen ein paar sehr interessante Charakteristiken.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_138300008_1fe3f5e5d6.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Diese Charakteristiken haben sehr weitreichende Konsequenzen, denn durch sie kann man die Funktion in Isolation betrachten:</div>
<div class="text"><ul><li> Die Korrektheit der Funktion ist einfacher zu verifizieren.</li><li>Die Refaktorierung und das Testen der Funktion sind einfacher.</li><li>Man kann das Ergebnis des Funktionsaufrufs zwischenspeichern.</li><li>Man kann reine Funktionen umsortieren oder in anderen Threads ausführen.</li></ul></div>
<div class="text">Reine Funktionen werden auch gerne mathematische Funktionen genannt. Per Default besitzt C++ keine reine Funktionen wie zum Beispiel die rein funktionale Sprache Haskell. <i>constexpr</i> Funktionen sind nur fast reinen Funktionen, daher basiert Reinheit in C++ vor allem auf der Disziplin des Entwicklers.</div>
<div class="text">Nur der Vollständigkeit halber. Template Metaprogrammierung ist eine rein funktionale Subsprache, eingebettet in die imperative Sprache C++. Falls du neugierig ist, hier geht es weiter mit <a alt="%7B%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffunktional-in-c98%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ffunktional-in-c98%22%2C%22text%22%3A%22Template%20Metaprogrammierung%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%7D" href="http://www.grimm-jaud.de/index.php/blog/funktional-in-c98" title="Link auf http://www.grimm-jaud.de/index.php/blog/funktional-in-c98" class="">Template Metaprogrammierung</a>. <br></div>
<div class="ztitel_kleiner">F.9: Unused parameters should be unnamed</div>
<div class="text">Falls du keine Namen für die nicht verwendeten Funktionsparameter&nbsp; verwendest, wird deine Funktion einfacher zu lesen sein und du wirst kein Warnung für nicht verwendete Parameter erhalten.<br></div>
<div class="ztitel">Wie geht's weiter? </div>
<div class="text">Dies waren die Regeln zur Definition von Funktionen. Im nächsten Artikel geht es darum, welche Regeln für Funktionsparameter gelten.<br></div>
