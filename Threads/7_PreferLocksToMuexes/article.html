<p>If the last post showed one point, then, that you should use mutexes with great care. That's the reason, why you should wrap them in a lock.</p>
<hr id="system-readmore" />
<h2>Locks<span id="transmark"></span></h2>
<p>Locks take care of there resource following the <a href="http://en.cppreference.com/w/cpp/language/raii">RAII&nbsp;</a>idiom. That means. A lock automatically binds its mutex in the constructor and release it in the destructor. That reduces considerably the risks of a deadlock, because the runtime has to take care of the mutex.</p>
<p>Locks are available in two flavours in C++11. <span style="font-family: courier new,courier;">std::lock_guard</span> for the simple, <span style="font-family: courier new,courier;">std::unique-lock</span> for the advanced use case.</p>
<h3><span style="font-family: courier new,courier;"><a id="lock_guard">std::lock_guard</a></span></h3>
<p>At first to the simple use case.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<pre style="margin: 0px; line-height: 125%;">mutex m;
m.lock();
sharedVariable= getVar();
m.unlock();
</pre>
</div>
<p>&nbsp;</p>
<p>The mutex <span style="font-family: courier new,courier;">m</span> ensures in the small piece of code, that the access of the critical region <span style="font-family: courier new,courier;">sharedVariable= getVar()</span> is serialized. Serialized means in this special case, that each thread after the other gets access to the critical region. The code is simple, but prone to deadlocks. A deadlock can appear, if the critical regions throws an exception or if the programmer simply forgets to unlock the mutex. With <span style="font-family: courier new,courier;">std::lock_guard</span> we can do the whole with more elegance.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<pre style="margin: 0px; line-height: 125%;">{
  std::mutex m,
  std::lock_guard&lt;std::mutex&gt; lockGuard(m);
  sharedVariable= getVar();
}
</pre>
</div>
<p>&nbsp;</p>
<p>That was easy. But what's about the opening and closing brackets? By the brackets, the lifetime of <span style="font-family: courier new,courier;">std::lock_guard</span> is limited. That means, its lifetime ends exactly at that point, when it leaves the critical section. Exactly at that time point, the destructor of<span style="font-family: courier new,courier;"> std::lock_guard i</span>s called and - I guess, you know it - the mutex is released. That happen automatically, that happens in addition, if the call of <span style="font-family: courier new,courier;">sharedVariable= getVar()</span> throws an exception. Of course, an artificial scope to limited the lifetime of an object can be a function body or an if loop.</p>
<h3><span style="font-family: courier new,courier;"><a id="unique_lock">std::unique_lock</a></span></h3>
<p>std::unique_lock is mightier but more expansive than his small brother&nbsp;<span style="font-family: courier new,courier;">std::lock_guard</span>.</p>
<p>A <span style="font-family: courier new,courier;">std::unique_lock </span>enables you<span style="font-family: courier new,courier;"></span>in addition to <span style="font-family: courier new,courier;">std::lock_guard </span></p>
<ul>
	<li>create it without an associated mutex</li>
	<li>create it without a locked associated mutex</li>
	<li>explicitly and repeatedly set or release the lock of the associated mutex</li>
	<li>move the mutex</li>
	<li>trywise or delayed lock the associated mutex</li>
</ul>
<p>But why is it necessary? Do you remember the deadlock from the post <a href="index.php?option=com_content&amp;view=article&amp;id=71:gefahren-von-mutexen&amp;catid=35:c&amp;Itemid=101#DeadlockVerschiedeneReihenfolge">Risks of mutexes</a>? The reason for the deadlock was, that the mutexes were locked in different sequence.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0px; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre>
				</td>
				<td>
					<pre style="margin: 0px; line-height: 125%;"><span style="color: #008000;">// deadlock.cpp</span>

<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;chrono&gt;</span>
<span style="color: #0000ff;">#include &lt;mutex&gt;</span>
<span style="color: #0000ff;">#include &lt;thread&gt;</span>

<span style="color: #0000ff;">struct</span> CriticalData{
  std::mutex mut;
};

<span style="color: #2b91af;">void</span> deadLock(CriticalData&amp; a, CriticalData&amp; b){

  a.mut.lock();
  std::cout &lt;&lt; <span style="color: #a31515;">"get the first mutex"</span> &lt;&lt; std::endl;
  std::this_thread::sleep_for(std::chrono::milliseconds(1));
  b.mut.lock();
  std::cout &lt;&lt; <span style="color: #a31515;">"get the second mutex"</span> &lt;&lt; std::endl;
  <span style="color: #008000;">// do something with a and b</span>
  a.mut.unlock();
  b.mut.unlock();
  
}

<span style="color: #2b91af;">int</span> main(){

  CriticalData c1;
  CriticalData c2;

  std::<span style="color: #0000ff;">thread</span> t1([&amp;]{deadLock(c1,c2);});
  std::<span style="color: #0000ff;">thread</span> t2([&amp;]{deadLock(c2,c1);});

  t1.join();
  t2.join();

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>Now, the solution becomes easy. The function deadlock has to lock their mutex in an atomic fashion. That exactly is happening in the following example.</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0px; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre>
				</td>
				<td>
					<pre style="margin: 0px; line-height: 125%;"><span style="color: #008000;">// deadlockResolved.cpp</span>

<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;chrono&gt;</span>
<span style="color: #0000ff;">#include &lt;mutex&gt;</span>
<span style="color: #0000ff;">#include &lt;thread&gt;</span>

<span style="color: #0000ff;">struct</span> CriticalData{
  std::mutex mut;
};

<span style="color: #2b91af;">void</span> deadLock(CriticalData&amp; a, CriticalData&amp; b){

  std::unique_lock&lt;std::mutex&gt;guard1(a.mut,std::defer_lock);
  std::cout &lt;&lt; <span style="color: #a31515;">"Thread: "</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span style="color: #a31515;">" first mutex"</span> &lt;&lt;  std::endl;

  std::this_thread::sleep_for(std::chrono::milliseconds(1));

  std::unique_lock&lt;std::mutex&gt;guard2(b.mut,std::defer_lock);
  std::cout &lt;&lt; <span style="color: #a31515;">"    Thread: "</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span style="color: #a31515;">" second mutex"</span> &lt;&lt;  std::endl;

  std::cout &lt;&lt; <span style="color: #a31515;">"        Thread: "</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span style="color: #a31515;">" get both mutex"</span> &lt;&lt; std::endl;
  std::lock(guard1,guard2);
  <span style="color: #008000;">// do something with a and b</span>
}

<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  CriticalData c1;
  CriticalData c2;

  std::<span style="color: #0000ff;">thread</span> t1([&amp;]{deadLock(c1,c2);});
  std::<span style="color: #0000ff;">thread</span> t2([&amp;]{deadLock(c2,c1);});

  t1.join();
  t2.join();

  std::cout &lt;&lt; std::endl;

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>In case you call the constructor of <span style="font-family: courier new,courier;">std::unique_lock</span> with the argument <span style="font-family: courier new,courier;">std::defer_lock<span style="font-family: arial,helvetica,sans-serif;">, the lock will not automatically be locked. That happens in line 14 and 19. The lock operation is atomically performed in line 23 by using the variadic template <span style="font-family: courier new,courier;">std::lock</span>. A variadic template is a template, which can accept an arbitrary number of arguments. Here, the arguments are locks. <span style="font-family: courier new,courier;">std::lock</span>&nbsp;tries to get the all lock in an atomic step. So, he fails or get all of them. <span style="font-family: courier new,courier;"></span><span style="font-family: courier new,courier;"></span></span>
	</span>
</p>
<p>In this example, <span style="font-family: courier new,courier;">std::unique_lock</span> take care of the lifetime of the resources, <span style="font-family: courier new,courier;">std::lock</span> locks the associated mutex. But, you can do it also the other way around. In the first step you lock the mutexes, in the second <span style="font-family: courier new,courier;">std::unique_lock</span> take care of the lifetime of resources. Here is a sketch of the second approach.</p>
<p>&nbsp;</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<pre style="margin: 0px; line-height: 125%;">std::lock(a.mut, b.mut);
std::lock_guard&lt;std::mutex&gt; guard1(a.mut, std::adopt_lock);
std::lock_guard&lt;std::mutex&gt; guard2(b.mut, std::adopt_lock);
</pre>
</div>
<p>&nbsp;</p>
<p>Now, all is fine. The program runs without deadlock.</p>
<p><img src="images/blog/Threads/LocksStattMutexen/deadlockResolved.png" alt="deadlockResolved" /><span style="color: #000000;"></span><br /><span style="color: #000000;"></span></p>
<h3><span style="color: #000000;">A side note: Special deadlocks<br /></span></h3>
<p>It is a illusion, that only a mutex is capable of producing a deadlock.<strong> Each time a thread has to wait for a resource, while it is holding a&nbsp;resource, a deadlock lurks.</strong></p>
<p><span style="color: #000000;">Even a thread is a resource.<br /></span></p>
<p><span style="color: #000000;"><!-- HTML generated using hilite.me --></span></p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
				</td>
				<td>
					<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// blockJoin.cpp</span>

<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;mutex&gt;</span>
<span style="color: #0000ff;">#include &lt;thread&gt;</span>

std::mutex coutMutex;

<span style="color: #2b91af;">int</span> main(){

  std::<span style="color: #0000ff;">thread</span> t([]{
    std::cout &lt;&lt; <span style="color: #a31515;">"Still waiting ..."</span> &lt;&lt; std::endl;
    std::lock_guard&lt;std::mutex&gt; lockGuard(coutMutex);
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    }
  );

  {
    std::lock_guard&lt;std::mutex&gt; lockGuard(coutMutex);
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    t.join();
  }

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p><span style="color: #000000;"></span></p>
<p><span style="color: #000000;">The program immediately stand still.<br /></span></p>
<p><span style="color: #000000;"><img src="images/blog/Threads/LocksStattMutexen/blockJoin.png" alt="blockJoin" /></span></p>
<p>What's happening? The lock of output stream <span style="font-family: courier new,courier;">std::cout</span> and the waiting of the main thread for its child t are the cause for the deadlock. By observing the output, you can easily see, in which order the statements will be performed.</p>
<p>In the first step, the main thread executes the lines 19 - 21. He waits in line 21 by using the call <span style="font-family: courier new,courier;">t.join()</span>, until his child t is done with his work package. The main thread is waiting, while he is locking the output stream. But that is exactly the resource, the child is&nbsp;waiting for. Two ways to solve this deadlock come to mind.</p>
<p style="color: #000000;">&nbsp;</p>
<ul>
	<li><span style="color: #000000;">The <span style="font-family: courier new,courier;">main t</span>hread locks the output stream <span style="font-family: courier new,courier;">std::cout</span> after the call <span style="font-family: courier new,courier;">t.join()</span>.</span>
	</li>
</ul>
<p><span style="color: #000000;"><!-- HTML generated using hilite.me --></span></p>
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<pre style="margin: 0px; line-height: 125%; padding-left: 60px;"><span style="color: #000000;">{
  t.join();
  std::lock_guard&lt;std::mutex&gt; lockGuard(coutMutex);
  std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
}
</span></pre>
</div>
<ul>
	<li><span style="color: #000000;">The main thread releases his lock by an additional scope. This is done before the <span style="font-family: courier new,courier;">t.join()</span> call.<span style="font-family: courier new,courier;"></span><br /></span>
	</li>
</ul>
<p><span style="color: #000000;"><!-- HTML generated using hilite.me --></span></p>
<div style="background: #ffffff none repeat scroll 0% 0%; overflow: auto; width: auto; border-width: 0.1em 0.1em 0.1em 0.8em;">
	<pre style="margin: 0px; line-height: 125%; padding-left: 60px;"><span style="color: #000000;">{
  {
    std::lock_guard&lt;std::mutex&gt; lockGuard(coutMutex);
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;<br />  }
  t.join();
}
</span></pre>
</div>
<p><span style="color: #3366ff;"><span style="color: #000000;"></span></span>
</p>
<h2>What' next?</h2>
<p>In the next post I talk about reader writer locks. Reader writer locks empowers you since C++14, to distinguish between reading and writing threads. So, the contention on the shared variable will be mitigated, because an arbitrary number of reading threads can access the shared variable at the same time.</p>
<p>&nbsp;</p>
<p>Would you like to have all articles for the weekend?</p>
<p><span style="color: #3366ff;">{loadmodule mod_acymailing,Neue Artikel zum Wochenende}&nbsp;</span></p>
<p>&nbsp;</p>