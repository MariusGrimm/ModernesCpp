<p>In case you use promise and future to synchronize threads, they have a lot in common with <a href="index.php/condition-variables">condition variables</a>. But most of the times, tasks are the better choice.</p>
<hr id="system-readmore" />
<h2>Synchronization of threads</h2>
<p>To get the big picture, at first the facts. The table compares condition variables with tasks (promise and future).</p>
<p><img src="images/blog/Threads/BedingungsvariablenVersusTasks/ConditionVariableVersusTask.png" alt="ConditionVariableVersusTask" width="600" height="208" style="margin: 15px;" /></p>
<p>The benefit of a condition variable to a promise and future is, that you can use condition variables to synchronize threads multiple times. In opposite to that, a promise can send its notification only once. So you have to use more promise and future pairs to get the functionality of a condition variable. But in case you use the condition variable only for one synchronization, the condition variable is a lot more difficult to use in right way. So a promise and future pair needs no shared variable and therefore no lock, they are not prone to <a href="index.php/condition-variables">spurious wakeups</a> or <a href="index.php/condition-variables">lost wakeups</a>. In addition to that, they can handle exceptions. <strong>So there are lot of reasons to prefer tasks to condition variables.</strong></p>
<p>How can I use tasks to synchronize threads?</p>
<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre>
				</td>
				<td>
					<pre style="margin: 0; line-height: 125%;"><span style="color: #008000;">// promiseFutureSynchronize.cpp</span>

<span style="color: #0000ff;">#include &lt;future&gt;</span>
<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;utility&gt;</span>


<span style="color: #2b91af;">void</span> doTheWork(){
  std::cout &lt;&lt; <span style="color: #a31515;">"Processing shared data."</span> &lt;&lt; std::endl;
}

<span style="color: #2b91af;">void</span> waitingForWork(std::future&lt;<span style="color: #2b91af;">void</span>&gt;&amp;&amp; fut){

    std::cout &lt;&lt; <span style="color: #a31515;">"Worker: Waiting for work."</span> &lt;&lt; std::endl;
    fut.wait();
    doTheWork();
    std::cout &lt;&lt; <span style="color: #a31515;">"Work done."</span> &lt;&lt; std::endl;

}

<span style="color: #2b91af;">void</span> setDataReady(std::promise&lt;<span style="color: #2b91af;">void</span>&gt;&amp;&amp; prom){

    std::cout &lt;&lt; <span style="color: #a31515;">"Sender: Data is ready."</span>  &lt;&lt; std::endl;
    prom.set_value();

}

<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  std::promise&lt;<span style="color: #2b91af;">void</span>&gt; sendReady;
  <span style="color: #0000ff;">auto</span> fut= sendReady.get_future();

  std::<span style="color: #0000ff;">thread</span> t1(waitingForWork,std::move(fut));
  std::<span style="color: #0000ff;">thread</span> t2(setDataReady,std::move(sendReady));

  t1.join();
  t2.join();

  std::cout &lt;&lt; std::endl;
  
}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>Relatively easy.</p>
<p>With the help of the promise <span style="font-family: courier new,courier;">sendReady</span> (line32) I get the future <span style="font-family: courier new,courier;">fut</span> (line34). The promise signalises in this case by his return value<span style="font-family: courier new,courier;"> void (std::promise&lt;void&gt; sendReady)</span>, that it is only capable of sending notifications. Both communications endpoints are moved into the thread <span style="font-family: courier new,courier;">t1</span> respectively <span style="font-family: courier new,courier;">t2</span> (line 35 and 36). The future is waiting with its call <span style="font-family: courier new,courier;">fut.wait()</span> (line 15) for the notification of the promise: <span style="font-family: courier new,courier;">prom.set_value()</span> (line 24).</p>
<p>As well the structure as the output of the program matches the program in den post about the condition variable.</p>
<p><img src="images/blog/Threads/PromiseFuture/promiseFutureSynchronize.png" alt="promiseFutureSynchronize" /><span id="transmark"></span></p>
<h2>What's next?</h2>
<p>So that was the overview of the mulitithreading interface. Now it's time to have a deeper look into mulithreading in C++.&nbsp;Although the most programmers will and should never use the features of C++ memory&nbsp; model, the C++ memory model gives you a deeper insight into the challenges of mulitthrading programming. The next post starts with an overview of the C++ memory model.</p>
<p>&nbsp;</p>
<dl>
	<dt>
		<p>&nbsp;</p>
	</dt>
</dl>
<p>Do you want to get the source code? <a href="index.php/source-code-repository">Source code repository</a></p>
<p>Would you like to have all posts for the weekend?&nbsp;
	<a href="index.php/source-code-repository"></a>
</p>
<p>{loadmodule mod_acymailing,Neue Artikel zum Wochenende}&nbsp;</p>