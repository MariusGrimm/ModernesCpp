<p>A thread gets its data (arguments) by value (copying value) or by reference. By default, you should pass by value. Why? In case your thread gets its data by reference, you have to be extremely careful about the lifetime of the arguments.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<h2>Thread arguments</h2>
<p>A thread is a <a href="https://en.wikipedia.org/wiki/Variadic_template">variadic template</a>. So it can get an arbitrary number of arguments.</p>
<p>Let's see the difference between getting the arguments by value or by reference.</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;">std::string s{<span style="color: #a31515;">"C++11"</span>}

std::<span style="color: #0000ff;">thread</span> t([=]{ std::cout &lt;&lt; s &lt;&lt; std::endl;});
t.join();

std::<span style="color: #0000ff;">thread</span> t2([&amp;]{ std::cout &lt;&lt; s &lt;&lt; std::endl;});
t2.detach()
</pre>
</div>
<p>&nbsp;</p>
<p>Being precise, it is not the thread that gets the arguments in this example, but the lambda function. But that makes no difference here. The first thread t1 gets its data by value (<span style="font-family: courier new,courier;">[=]</span>), and the second thread t2 gets its data by reference (<span style="font-family: courier new,courier;">[&amp;]</span>).</p>
<p>What dangers are hidden in these lines? Thread t2 gets its string s by reference and is afterwards detached from the lifetime of its creator. On the one hand the lifetime of the string is bound to the lifetime of the calling context, and on the other hand the lifetime of the global object<span style="font-family: courier new,courier;"> std::cout</span> is bound the lifetime of<span style="font-family: courier new,courier;"> the main </span>thread. So it may happen that the lifetime of the string s or the lifetime of <span style="font-family: courier new,courier;">std::cout</span> is shorter than the lifetime of the thread t2. Now we are deep in the area of undefined behaviour.</p>
<p>Not convinced? Let's have a closer look, how undefined behaviour may look like.</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<table>
<tbody>
<tr>
<td>
<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%;"><span style="color: #0000ff;">#include &lt;chrono&gt;</span>
<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;thread&gt;</span>

<span style="color: #0000ff;">class</span> <span style="color: #2b91af;">Sleeper</span>{
  public:
    Sleeper(<span style="color: #2b91af;">int</span>&amp; i_):i{i_}{};
    <span style="color: #2b91af;">void</span> operator() (<span style="color: #2b91af;">int</span> k){
      <span style="color: #0000ff;">for</span> (<span style="color: #2b91af;">unsigned</span> <span style="color: #2b91af;">int</span> j= 0; j &lt;= 5; ++j){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        i += k;
      }
      std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    }
  private:
    <span style="color: #2b91af;">int</span>&amp; i;
};


<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #2b91af;">int</span> valSleeper= 1000;
  std::<span style="color: #0000ff;">thread</span> t(Sleeper(valSleeper),5);
  t.detach();
  std::cout &lt;&lt; <span style="color: #a31515;">"valSleeper = "</span> &lt;&lt; valSleeper &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>The question is, which value does <span style="font-family: courier new,courier;">valSleeper</span> have in line 27? <span style="font-family: courier new,courier;">valSleeper</span> is a global variable. The thread t gets as a payload a function object of type <span style="font-family: courier new,courier;">Sleeper</span> together with the variable <span style="font-family: courier new,courier;">valSleeper</span> and the number 5 (line 25). The crucial observation is, that the thread gets <span style="font-family: courier new,courier;">valSleeper</span> by reference (line 7) and will be detached from the lifetime of the main thread (line 26). Then it will execute the call operator of the function object (line 8 - 14). In this method, it counts from 0 to 5, sleeps in each iteration 1/10 of a second and increments i by k. At the end, it displays its ID on the screen. As an old German proverb says, <em>according to <a href="http://www.math-in-europe.eu/pl/76-enjoy-maths/strick/670-adam-ries-ca-1492-march-30-1559-by-heinz-klaus-strick-germany">Adam Ries</a></em>, the result must be 1000 +&nbsp; 6 * 5 = 1030.</p>
<p>But, what happened? Something is going totally wrong.&nbsp;</p>
<p><img src="images/blog/Threads/DatenuebergabeAnThreads/Sleeper.png" alt="Sleeper" style="margin: 15px;" /></p>
<p>There are two issues. On the one hand, <span style="font-family: courier new,courier;">valSleeper</span> is 1000, on the other hand, the ID is missing on the console. So, that is undefined behaviour. The reason is the lifetime of the main thread ends before the child thread has performed its calculation or written its ID to <span style="font-family: courier new,courier;">std::cout</span>.</p>
<p>In this case, the main thread waits using<span style="font-family: courier new,courier;">&nbsp;t.join()</span> until its child thread is done with its work, and we get the expected result:</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #2b91af;">int</span> valSleeper= 1000;
  std::<span style="color: #0000ff;">thread</span> t(Sleeper(valSleeper),5);
  t.join();
  std::cout &lt;&lt; <span style="color: #a31515;">"valSleeper = "</span> &lt;&lt; valSleeper &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
</div>
<p>&nbsp;</p>
<p><img src="images/blog/Threads/DatenuebergabeAnThreads/Sleeper2.png" alt="Sleeper2" style="margin: 15px;" /></p>
<h2>What's next?</h2>
<p>Thinking about the lifetime of the threads is by far not the only issue with threads. Both threads, the main thread and the child thread share two objects. That is <span style="font-family: courier new,courier;">std::cout</span> and the variable <span style="font-family: courier new,courier;">valSleeper.</span> Now, I described the classical recipe for a data race or - to say it differently - for undefined behaviour. In the next post I will deal with sharing variables between threads.</p>
<p>&nbsp;</p>
<p>Would you like to have all articles for the weekend? Source included.</p>
<p>{loadmodule mod_acymailing,Neue Artikel zum Wochenende}</p>