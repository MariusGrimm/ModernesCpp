<p>A thread gets his data per copy or per reference. Per default, you should use per copy. Why? In case your thread gets his data per reference, you have to be extremely careful about the lifetime of the arguments.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<h2>Thread arguments</h2>
<p>A thread is a <a href="https://en.wikipedia.org/wiki/Variadic_template">variadic template</a>. So he can get an arbitrary number of arguments.&nbsp;</p>
<p>But now to the difference between getting the argument per copy or per reference.</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<pre style="margin: 0; line-height: 125%;">std::string s{<span style="color: #a31515;">"C++11"</span>}

std::<span style="color: #0000ff;">thread</span> t([=]{ std::cout &lt;&lt; s &lt;&lt; std::endl;});
t.join();

std::<span style="color: #0000ff;">thread</span> t2([&amp;]{ std::cout &lt;&lt; s &lt;&lt; std::endl;});
t2.detach()
</pre>
</div>
<p>&nbsp;</p>
<p>Precisely said, not the thread gets his arguments in this example, but the lambda function. But that makes no difference for my argumentation. So the first Thread t1 gets his data per copy (<span style="font-family: courier new,courier;">[=]</span>), so the second Thread t2 his data per reference (<span style="font-family: courier new,courier;">[&amp;]</span>).</p>
<p>What dangers are hidden in are this lines? Thread t2 gets his string s per reference and is afterwards detached from the lifetime of his creator. At first, the lifetime of the string is bound to the lifetime of the invocation context, and at second, the lifetime of the global object<span style="font-family: courier new,courier;"> std::cout</span> is bound the lifetime of<span style="font-family: courier new,courier;"> the main </span>thread. So it may happen, that the lifetime of the string s or the lifetime of <span style="font-family: courier new,courier;">std::cout</span> is shorter than the lifetime of the thread t2. Now we are deep in the area of undefined behaviour.</p>
<p>Not convinced? Let's have a closer look, how undefined behaviour may look like.</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<table>
		<tbody>
			<tr>
				<td>
					<pre style="margin: 0; line-height: 125%;"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre>
				</td>
				<td>
					<pre style="margin: 0; line-height: 125%;"><span style="color: #0000ff;">#include &lt;chrono&gt;</span>
<span style="color: #0000ff;">#include &lt;iostream&gt;</span>
<span style="color: #0000ff;">#include &lt;thread&gt;</span>

<span style="color: #0000ff;">class</span> <span style="color: #2b91af;">Sleeper</span>{
  public:
    Sleeper(<span style="color: #2b91af;">int</span>&amp; i_):i{i_}{};
    <span style="color: #2b91af;">void</span> operator() (<span style="color: #2b91af;">int</span> k){
      <span style="color: #0000ff;">for</span> (<span style="color: #2b91af;">unsigned</span> <span style="color: #2b91af;">int</span> j= 0; j &lt;= 5; ++j){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        i += k;
      }
      std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    }
  private:
    <span style="color: #2b91af;">int</span>&amp; i;
};


<span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #2b91af;">int</span> valSleeper= 1000;
  std::<span style="color: #0000ff;">thread</span> t(Sleeper(valSleeper),5);
  t.detach();
  std::cout &lt;&lt; <span style="color: #a31515;">"valSleeper = "</span> &lt;&lt; valSleeper &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p>&nbsp;</p>
<p>The question is. Which value has <span style="font-family: courier new,courier;">valSleeper</span> in line 27? <span style="font-family: courier new,courier;">valSleeper</span> is a global variable. The thread t gets as work package a function objekt of type <span style="font-family: courier new,courier;">Sleeper</span> together with the variable <span style="font-family: courier new,courier;">valSleeper</span> and the number 5 (line 25). The crucial observation is, that the thread gets <span style="font-family: courier new,courier;">valSleeper</span> by reference (line 7) and will be detached from the lifetime of the main thread (line 26). Then he will execute the call operator of the function object (line 8 - 14). In this method, he counts from 0 to 5, sleeps in each iteration 1/10 of a second and increments i by k. At the end, he displays his ID on the screen. After Adam Riese (a German proverb), the result must be 1000 +&nbsp; 6 * 5 = 1030.</p>
<p>But, what happened. Something is going totally wrong.&nbsp;</p>
<p><img src="images/blog/Threads/DatenuebergabeAnThreads/Sleeper.png" alt="Sleeper" style="margin: 15px;" /></p>
<p>There are two issues. At the one hand, <span style="font-family: courier new,courier;">valSleeper</span> is 1000, at the other hand, the ID is missing on the console. So, that is undefined behaviour. The reason is, that the lifetime of the main thread ends, before the child thread has performed his calculation or written his ID to <span style="font-family: courier new,courier;">std::cout</span>.</p>
<p>In case, the main thread waits via<span style="font-family: courier new,courier;"> t.join()</span> until this child thread is done with his work, we get the expected result.</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; gray;border-width: .1em .1em .1em .8em;">
	<pre style="margin: 0; line-height: 125%;"><span style="color: #2b91af;">int</span> main(){

  std::cout &lt;&lt; std::endl;

  <span style="color: #2b91af;">int</span> valSleeper= 1000;
  std::<span style="color: #0000ff;">thread</span> t(Sleeper(valSleeper),5);
  t.join();
  std::cout &lt;&lt; <span style="color: #a31515;">"valSleeper = "</span> &lt;&lt; valSleeper &lt;&lt; std::endl;

  std::cout &lt;&lt; std::endl;

}
</pre>
</div>
<p>&nbsp;</p>
<p><img src="images/blog/Threads/DatenuebergabeAnThreads/Sleeper2.png" alt="Sleeper2" style="margin: 15px;" /></p>
<h2>What's next?</h2>
<p>Thinking about the lifetime of the threads is by far not the only issue with threads. Both threads, the main thread and the child thread share two objects. That is <span style="font-family: courier new,courier;">std::cout</span> and the variable <span style="font-family: courier new,courier;">valSleeper.</span> Now, I described the classical recipe for a data race or - to say it differently -for undefined beha<span id="transmark"></span>viour. In the next post I deal with shared variables between threads.</p>
<p>&nbsp;</p>
<p>Would you like to have all articles for the weekend? Source included.</p>
<p>{loadmodule mod_acymailing,Neue Artikel zum Wochenende}</p>
