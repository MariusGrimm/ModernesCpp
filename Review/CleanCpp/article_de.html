<div class="vorspann">Heute möchte ich einen kleinen Umweg von meiner langen Artikelserie zu den C++ Core Guidelines machen. Ich habe in den letzten Tagen das hervorragende Buch "Clean C++" gelesen und kann es mir nicht verkneifen, eine Rezension darüber zu schreiben.</div><div class="vorspann"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_146840714_2e785bb3ae.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=3>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Oft werde ich am Ende meiner Schulungen gefragt: Mit welchen Büchern soll ich mich beschäftigen, um bessere Software zu schreiben? Meine Antwort bestand bisher aus den bekannten Verdächtigen: "<a title="Link auf https://en.wikipedia.org/wiki/Design_Patterns" href="https://en.wikipedia.org/wiki/Design_Patterns" class="" alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDesign_Patterns%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Design%20Pattern%3A%20Elements%20of%20reusable%20object-oriented%20software%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDesign_Patterns%22%7D">Design Pattern: Elements of reusable object-oriented software</a>", "<a alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.cs.wustl.edu%2F~schmidt%2FPOSA%2F%22%2C%22text%22%3A%22Pattern-Oriented%20Software%20Architecture%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.cs.wustl.edu%2F~schmidt%2FPOSA%2F%22%7D" href="http://www.cs.wustl.edu/~schmidt/POSA/" class="" title="Link auf http://www.cs.wustl.edu/~schmidt/POSA/">Pattern-Oriented Software Architecture</a>", "<a alt="%7B%22href%22%3A%22https%3A%2F%2Fsites.google.com%2Fsite%2Funclebobconsultingllc%2Fbooks%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Clean%20Code%22%2C%22destination%22%3A%22https%3A%2F%2Fsites.google.com%2Fsite%2Funclebobconsultingllc%2Fbooks%22%7D" title="Link auf https://sites.google.com/site/unclebobconsultingllc/books" href="https://sites.google.com/site/unclebobconsultingllc/books" class="">Clean Code</a>", "<a class="" href="http://wiki.c2.com/?WorkingEffectivelyWithLegacyCode" title="Link auf http://wiki.c2.com/?WorkingEffectivelyWithLegacyCode" alt="%7B%22text%22%3A%22Working%20effectively%20with%20legacy%20code%22%2C%22destination%22%3A%22http%3A%2F%2Fwiki.c2.com%2F%3FWorkingEffectivelyWithLegacyCode%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwiki.c2.com%2F%3FWorkingEffectivelyWithLegacyCode%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%7D">Working effectively with legacy code</a>" und "<a class="" href="https://martinfowler.com/books/uml.html" title="Link auf https://martinfowler.com/books/uml.html" alt="%7B%22text%22%3A%22UML%20Distilled%22%2C%22destination%22%3A%22https%3A%2F%2Fmartinfowler.com%2Fbooks%2Fuml.html%22%2C%22href%22%3A%22https%3A%2F%2Fmartinfowler.com%2Fbooks%2Fuml.html%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D">UML Distilled</a>". Das war aber erst die halbe Antwort: Aus C++-Perspektive sind natürlich die Bücher von Scott Meyers, Herb Sutter und auch die C++ Core Guidelines ein Muss. Summa Summarum macht das mindesten 3000 Seiten an geballtem Wissen.</div><div class="text">Bestand, denn in Zukunft wird meine Antwort ganz einfach sein. Lesen sie das Buch "Clean C++" von Stephan Roth. Das Buch ist ideal für die erste Suche in die Breite, für die Suche in die Tiefe werde ich die Klassiker zitieren. Warum?</div><div class="text">Der Autor schafft es in seinem englischsprachigen Werk, einen sehr guten, aber nicht zu oberflächlichen Überblick zu den Themen zu liefern, die für gute Software insbesondere in C++ stehen. Dabei setzt er den C++11-Standard voraus, geht aber in vielen Anschauungsbeispielen auf den aktuellen&nbsp; C++17-Standard ein. Was ich besonders an dem Werk schätzte, ist, dass es nicht nur auf die Don't, sondern auch auf die Do's eingeht.</div><div class="text">Nun aber der Reihe nach im Schnelldurchlauf. Clean C++ besteht aus neun Kapiteln und einer kurzen Einleitung zu UML. Die ersten beiden Kapitel sind vollkommen programmiersprachenagnostisch. In den Kapiteln zu Unit Testing und den wichtigsten Prinzipen der Softwareentwicklung, wie (Keep It Simple and Stupid (KISS), You Aren't Gonna Need It (YAGNI), Don't Repeat Yourself (DRY) und Principle Of Least Asthonishment (PLA), beschäftigt sich der Autor mit Evergreens, die gute Softwareentwicklung auszeichnen.</div><div class="text">Die verbleibenden Kapitel beschreiben zwar weiterhin die Punkte, die für gute Software stehen. Nun aber aus der Perspektive von modernem C++. Diesen neuen Blickwinkel nimmt er in den Basics von Clean C++ ein und beschreibt darin die Schlüsselfaktoren, die es bei der Auswahl von guten Namen, Kommentaren und Funktionen zu beachten gilt. Was hat modernes C++ zu bieten? Genau diese Frage beantwortet Roth in seinem Kapitel "Advanced Concepts of Modern C++". Die Wurzeln von C++ liegen in der Objektorientierung, seine funktionale Ader wird aber mit modernem C++ zunehmend dominanter. Welche Vor- und Nachteile bieten beide Paradigmen? Weitere Fragen, zu den das Buch auf 60 Seiten die Antworten liefert.</div><div class="text">Unit-Testing sollte als Grundlage für Test-Driven Development verwendet werden. Genau diesen Fokus nimmt Roth in seinem gleichnamigen Kapitel ein und zeigt in einem ausführlichen Beispiel, wie sich arabische Zahlen in römische Zahlen mithilfe von TDD konvertieren lassen. Abgerundet wird das Buch durch seine pragmatische Sicht auf die wichtigsten Design Pattern und Idiome. Dabei liegt dem Autor ein Design Pattern sehr am Herzen: Dependency Injection. Es ist die Heilung, wenn es darum geht, dass oft sehr kontrovers diskutierte Singleton Pattern als Anti-Pattern aus unseren Codebasen zu entfernen. Zugegeben, er hat Recht.</div><div class="text">Was zeichnet nun Clean C++ aus, sodass es für mich die Empfehlung ist, wenn ich nach weiterführender Literatur am Ende meiner Schulungen gefragt werde? Enthalten die zitierten Klassiker und C++-Bücher nicht schon alle wichtige Informationen? Auf jeden Fall! Das Buch "Clean C++" ist aber aus meiner Sicht der erste und einzige pragmatische Einstieg in die Themen rundum gute Softwareentwicklung in modernem C++, das sich in einer Woche gut konsumieren lässt. Ist dieser Einstieg geschafft, bieten sich natürlich Vertiefungen zu allen Aspekten des Buchs an. Diese Vertiefungen können allgemeiner Natur, aber auch C++-spezifisch sein, und werden wohl jeden professionellen Softwareentwickler sein ganzes Leben beschäftigen.</div>