<p>The atomics are the base of the C++ memory model. Per default sequential consistency is applied.</p>
<hr id="system-readmore" />
<h2>The strong C++ memory model<span id="transmark"></span></h2>
<p>In 2004 Java 5.0 gets its current <a href="https://en.wikipedia.org/wiki/Java_memory_model">memory model</a>, in 2011 C++.&nbsp; Before that, Java had an erroneous, C++ no memory model. Who thinks, that this is the endpoint of a long process, is totally wrong. The foundations of multithreading programming are 40 to 50 years old. So <a href="https://en.wikipedia.org/wiki/Leslie_Lamport">Leslie Lamport </a>defined 1979 the concept of sequential consistency.</p>
<p><strong>Sequential consistency</strong> guarantees two characteristics.</p>
<ol>
	<li>The instructions of a program are executed in source code order.</li>
	<li>There is a global order of all operations on all threads.</li>
</ol>
<p>Before I look deeper in these two characteristics, I explicitly emphasis. The statements only holds for atomics but influences non atomics.</p>
<p>The simple graphic displays two threads. Each thread is storing its variable <span style="font-family: courier new,courier;">x</span> or <span style="font-family: courier new,courier;">y</span>, loads the other variable <span style="font-family: courier new,courier;">y</span> and <span style="font-family: courier new,courier;">x</span> and stores them in the variable <span style="font-family: courier new,courier;">res1</span> or <span style="font-family: courier new,courier;">res2.</span></p>
<p>&nbsp;</p>
<p><img src="images/blog/Speichermodell/SequenzielleKonsistenz/twoAtomics.png" alt="twoAtomics" /></p>
<p>&nbsp;</p>
<p>The operations take place on atomics and so, they are atomic. Per default&nbsp;sequential consistency applies. But the question is. In which order can the statements take place?</p>
<p>Characteristic 1 of the sequential consistency guarantees, that the instruction will be execute in the order of the source code. That is easy. No store-operation can overtake a load-operation.</p>
<p>Characteristic 2 of the sequential consistency guarantees, that all instructions of all threads have to follow a global order. That means in that concrete case, that thread 2 sees the operations of thread 1 in the same order, in which thread 1 executes them. This is the key observation. <strong>Thread 2 sees all operations of thread 1 in the source code order of thread 1.</strong> The same holds from the perspective of thread 1. So you can think about characteristic 2 as a global counter, which all threads have to obey. The global counter is the global order.</p>
<p>No we are already done with our riddle. What is still missing, is to look at the different interleaving executions of the two threads. So the following six interleaving of the two threads are possible.</p>
<p><img src="images/blog/Speichermodell/SequenzielleKonsistenz/atomicInterleavingEng.png" alt="atomicInterleavingEng" width="700" height="525" style="margin: 15px;" /></p>
<p>That was easy. Or?</p>
<h2>From the strong to the weak memory model</h2>
<p>I want once more refer to the <a href="index.php/c-memory-model">picture</a> of the contract between the programmer and the system.</p>
<p>The programmer is using in this concrete example atomics. So he obeys his part of the contract by using them in the right way. The system guarantees him a well defined program behaviour without data races. In addition to that, the system can execute the four operations in each combination. In case the programmer uses the relaxed semantic, the pillars of the contract dramatically changes. On one hand it is a lot more difficult for the programmer to apply the contract in the right way. On the other hand the system has a lot more optimization possibilities. With the relaxed semantic - also called weak memory model - there are a lot more combinations of the four operations possible. The counter-intuitive behaviour is, that the thread 1 can see the operations of thread 2 in a different order. So there is no picture of a global counter. From the perspective of thread 1 it is possible, that the operation <span style="font-family: courier new,courier;">res= y.load()</span> overtake <span style="font-family: courier new,courier;">x.store().</span></p>
<p>Between the sequential consistency and the relaxed-semantic there a few more models. The most important one is the acquire-release semantic. I think you already guess it. With acquire-release semantic the programmer has to obey stronger rules than with sequential consistency. But the system has more optimization possibilities. The acquire-release semantic is the key to a deeper understanding of the multithreading programming, because the threads will be synchronized at a specific synchronization points in the code. Without these synchronization points there is no well defined behaviour of threads, tasks or condition variables possible. More about that in following post. &nbsp; <span style="font-family: courier new,courier;"><span style="font-family: courier new,courier;"></span></span>
</p>
<h2>What's next?</h2>
<p>The next post will provide a deeper look into the atomics. But we stick with the strong C++ memory model.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Do you want to get the source code? <a href="index.php/source-code-repository">Source code repository</a></p>
<p>Would you like to have all posts for the weekend?&nbsp;
	<a href="index.php/source-code-repository"></a>
</p>
<p>{loadmodule mod_acymailing,Neue Artikel zum Wochenende}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: arial,helvetica,sans-serif;"></span></p>
<p><span style="font-family: arial,helvetica,sans-serif;"></span></p>
<p>&nbsp;</p>