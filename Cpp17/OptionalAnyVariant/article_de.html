<div class="vorspann">Was haben die neuen C++17 Datentypen <i>std::optional</i>, <i>std::any </i>und <i>std::variant </i>gemein? Sie können in-place erzeugt werden. Aber das ist natürlich nicht alles. <i>std::variant </i>unterstützt einen Visitor.</div>
<div class="text">Aber bevor es mit dem Artikel losgeht, muss ich erst eine Frage klären. Was ist der Job der drei neuen Datentypen?</div>
<div class="text"><ul><li> <i>std::optional </i>ist ein Wrapper, der einen oder keinen Wert besitzen kann.</li><li><i>std::variant</i> ist eine typ-sichere Union.</li><li><i>std::any</i> ist ein Datentyp, der einen Wert eines beliebigen Typs halten kann.</li></ul></div>
<div class="text">Natürlich will ich mich nicht selber wiederholen. In dem Artikel <a class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/c-17-was-gibts-neues-in-der-bibliothek" alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-was-gibts-neues-in-der-bibliothek%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-was-gibts-neues-in-der-bibliothek%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22C%2B%2B17%3A%20Was%20gibts%20Neues%20in%20der%20Bibliothek%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" href="http://www.grimm-jaud.de/index.php/blog/c-17-was-gibts-neues-in-der-bibliothek">C++17: Was gibts Neues in der Bibliothek</a> stelle ich die drei Datentypen genauer vor. Für die einfache Orientierung zu C++17, gibt's hier die Übersicht.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_133328379_641171b53c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">In-place erzeugen<br></div>
<div class="text">Was heißt das überhaupt? In-place erzeugen. Der Einfachheit werde ich mich nur auf <i>std::optional </i>beziehen. Ein <i>std::optional&lt;std::string&gt; opt</i> kann einen Wert vom Typ <i>std::string</i> besitzen. In-place bedeutet, dass <i>opt</i> direkt durch die Argumente für <i>std::string</i> erzeugt werden kann. </div>
<div class="text">Ein kleines Beispiel sollte meinen Punkt klar machen.</div>
<div class="pre">// inPlace.cpp<br><br>#include &lt;optional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; // C string literal<br>&nbsp; std::optional&lt;std::string&gt; opt1(std::in_place, "C++17");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(1)</span><br><br>&nbsp; // 5 characters 'C'<br>&nbsp; std::optional&lt;std::string&gt; opt2(std::in_place,5, 'C');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(2)</span><br><br>&nbsp; // initializer list<br>&nbsp; std::optional&lt;std::string&gt; opt3(std::in_place, {'C', '+', '+', '1', '7'}); <span class="tx_blue">(3)</span><br><br>&nbsp; // Copy constructor<br><span class="tx_blue">&nbsp; </span>std::optional&lt;std::string&gt; opt4(opt3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(4)</span><br><br>&nbsp; std::cout &lt;&lt; *opt1 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; *opt2 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; *opt3 &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; *opt4 &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}&nbsp; </div>
<div class="text">opt1 (1), opt2 (2) und opt3 (3) werden mit dem Tag <i>std::in_place </i>erzeugt. Das bedeutet, das der Konstruktor von <i>std::string </i>direkt mit seinen Argumenten aufgerufen wird. Daher wird der String in-place von einem C-String (1), fünf Buchstaben 'C' (2) und einer Initialisierer-Liste (3) erzeugt. Das gilt aber nicht für <i>opt4 </i>(4). opt4 wird von op3 copy-konstruiert. </div>
<div class="text">Hier kommt die Ausgabe des Programms.</div>
<div class="pre"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_133328384_97e11d2bec.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Ist <i>in-place </i>Erzeugung neu für dich? Warum? C++ besitzt das Feature schon seit C++11. Die Container der Standard Template Library unterstützen einen ganzen Satz an neuen Methoden um Elemente hinzuzufügen. Diese Methoden beginnen mit dem Name <i>emplace</i> wie zum Beispiel <i>emplace_back.</i> Daher kannst du einfach ein neues Elemet zu einem Container<i> std::vector vec</i> hinzufügen, indem du <i>vec.emplace_back(5)</i> schreibst. Das ist äquivalent zu <i>vec.push_back(int(5)).</i></div>
<div class="text">Was für ein Zufall. Diese Woche halte ich ein Seminar zu Design Pattern in Python und dann entdecke ich die Funktion <i>std::visit</i> in dem Funktion zu <i>std::variant.</i> Was sich wie das klassische <a class="" title="Link auf https://de.wikipedia.org/wiki/Besucher_(Entwurfsmuster)" alt="%7B%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FBesucher_%28Entwurfsmuster%29%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Visitor%20Pattern%22%2C%22href%22%3A%22https%3A%2F%2Fde.wikipedia.org%2Fwiki%2FBesucher_%28Entwurfsmuster%29%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%7D" href="https://de.wikipedia.org/wiki/Besucher_(Entwurfsmuster)">Visitor Pattern</a> anhört, ist tatsächlich eine Visitor für eine Liste von Varianten. </div>
<div class="ztitel">Ein Visitor für eine Liste von Varianten</div>
<div class="text"><i>std::visit</i> ermöglicht es, einen Visitor auf eine Liste von Varianten anzuwenden. Der Visitor muss eine aufrufbare Einheit sein. Eine aufrufbare Einheit ist alles, was sich wie eine Funktion anfühlt. Das kann eine Funktion, ein Funktionsobjekte oder auf eine Lambda-Funktion sein. Um mir das Schreiben einfach zu machen, verwende ich eine Lambda-Funktion.</div>
<div class="pre">// visit.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;type_traits&gt;<br><br>#include &lt;variant&gt;<br><br>&nbsp; <br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::vector&lt;std::variant&lt;char, long, float, int, double, long long&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(1)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vecVariant = {5, '2', 5.4, 100ll, 2011l, 3.5f, 2017};<br>&nbsp; <br>&nbsp; // display each value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; for (auto&amp; v: vecVariant){<br>&nbsp;&nbsp;&nbsp; std::visit([](auto&amp;&amp; arg){std::cout &lt;&lt; arg &lt;&lt; " ";}, v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(2)</span><br>&nbsp; }<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; // display each type<br>&nbsp; for (auto&amp; v: vecVariant){<br>&nbsp;&nbsp;&nbsp; std::visit([](auto&amp;&amp; arg){std::cout &lt;&lt; typeid(arg).name() &lt;&lt; " ";}, v); <span class="tx_blue">(3)</span><br>&nbsp; }<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; // get the sum<br>&nbsp; std::common_type&lt;char, long, float, int, double, long long&gt;::type res{};&nbsp; <span class="tx_blue">(4)</span><br>&nbsp;<br>&nbsp; std::cout &lt;&lt; "typeid(res).name(): "&nbsp; &lt;&lt; typeid(res).name() &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; for (auto&amp; v: vecVariant){<br>&nbsp;&nbsp;&nbsp; std::visit([&amp;res](auto&amp;&amp; arg){res+= arg;}, v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(5)</span><br>&nbsp; }<br>&nbsp; std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; // double each value<br>&nbsp; for (auto&amp; v: vecVariant){<br>&nbsp;&nbsp;&nbsp; std::visit([&amp;res](auto&amp;&amp; arg){arg *= 2;}, v);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="tx_blue">(6)</span><br>&nbsp;&nbsp;&nbsp; std::visit([](auto&amp;&amp; arg){std::cout &lt;&lt; arg &lt;&lt; " ";}, v);<br>&nbsp; }<br>&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div>
<div class="text">In (1) erzeuge ich einen <i>std::vector</i> von Varianten. Jede Variante kann einen <i>char, long, float, int, double </i>oder <i>long long </i>besitzen. Damit geht es schnell von der Hand, den Vektor von Varianten zu traversieren und die Lambda-Funktion auf jedes Element anzuwenden (2). Danke der Funktion<i> typeid</i> gibt jeder Wert seinen Typ zurück. Ich denke, du hast das Visitor Pattern entdeckt: Der Vektor von Varianten ist die besuchte Datenstruktur, auf die ich die visit-Funktion (Visitor) anwende.</div>
<div class="text">Nun gilt es, die Elemente der Varianten zusammenzurechnen. Zuerst benötige ich den richtigen Ergebnistyp zur Übersetzungszeit. <i>std::common_type</i> (4) aus der<a class="" title="Link auf http://en.cppreference.com/w/cpp/header/type_traits" href="http://en.cppreference.com/w/cpp/header/type_traits" alt="%7B%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22%20type-traits%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fheader%2Ftype_traits%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D"> type-traits</a> Bibliothek leistet mir wertvolle Dienste. <i>std::common_type</i> gibt mit den Typ zurück, zu denen die Typen <i>char, long, float, int, double </i>und <i>long long </i>automatisch konvertiert werden können. Die abschließenden geschweiften Klammern in<i> res{}</i> bewirken, dass das Ergebnis mit <i>0.0 </i>initialisiert wird. <i>res</i> ist vom Typ <i>double</i>. (5) berechnet die Summe. Der Visitor kann selbst im vorbeigehen die Element der Varianten modfizieren. Genau das geschieht in (6). </div>
<div class="text">Hier kommt die Ausgabe des Programms. Mit Visual C++ gibt mir <a href="https://en.wikipedia.org/wiki/Run-time_type_information" alt="%7B%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRun-time_type_information%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22run-time%20type%20information%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRun-time_type_information%22%2C%22ir_link%22%3A1%7D" title="Link auf https://en.wikipedia.org/wiki/Run-time_type_information" class="">run-time type information</a> mit <i> <a href="http://en.cppreference.com/w/cpp/types/type_info" alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Ftype_info%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22std%3A%3Ainfo_type%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Ftypes%2Ftype_info%22%7D" class="" title="Link auf http://en.cppreference.com/w/cpp/types/type_info">std::info_type</a> </i>lesbare Namen.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_133328391_f07de1306f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Es war nicht einfach, diese Ausgabe zu erzeugen. Um das Programm zu übersetzen, ist ein aktueller GCC snapshot notwendig. Weder habe ich diesen, noch ist dieser Online verfügbar. Daher verwendete ich im ersten Schritt den Compiler Explorer auf <a class="" title="Link auf https://godbolt.org/" alt="%7B%22subject%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22godbolt%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fgodbolt.org%2F%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%7D" href="https://godbolt.org/">godbolt</a>, um die Syntax des Programms zu prüfen. Im zweiten Schritt verwendet ich den aktuellen Visual C++ Compiler auf <a alt="%7B%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22http%3A%2F%2Fwebcompiler.cloudapp.net%2F%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwebcompiler.cloudapp.net%2F%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwebcompiler.cloudapp.net%2F%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" href="http://webcompiler.cloudapp.net/" class="" title="Link auf http://webcompiler.cloudapp.net/">http://webcompiler.cloudapp.net/</a>, um das Ergebnis zu erhalten. In diesem Fall ist der Flag <i>std::c++latest </i>notwendig. Zwei von drei Versuchen resultierten in der Fehlermeldung: Maximum execution time exceeded!. Aber letztendlich hat es dann funktioniert.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Mit C++17 gibt es <a alt="%7B%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fparallele-algorithmen-der-stl%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22Parallele%20Algorithmen%20der%20Standard%20Template%20Library%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fparallele-algorithmen-der-stl%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%7D" href="http://www.grimm-jaud.de/index.php/blog/parallele-algorithmen-der-stl" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/parallele-algorithmen-der-stl">Parallele Algorithmen der Standard Template Library</a>. Selbst ein paar neue Algorithmen bringt C++17 mit. Welche? Das stelle ich im nächsten Artikel vor.<br></div>
