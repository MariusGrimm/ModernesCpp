<div class="vorspann">Race conditions und data races sind ähnliche, aber doch verschiedene Konzepte. Da sie ähnlich sind, werden sie häufig verwechselt. Verschärfend kommt hinzu, dass beide Begriff ins Deutsche mit kritischem Wettlauf übersetzt werden. Um ehrlich zu sein, verwirrender kann es nicht sein. Gerade aber, wenn es um Gleichzeitigkeit geht, ist eine eindeutige Ausdrucksweise unentbehrlich. Daher geht es heute in dem Artikel um race conditions und data races.</div>
<div class="text">Zuerst gilt es, die beiden Begriffe in der Softwaredomäne zu definieren.</div>
<div class="text"><ul><li> <b>Race condition</b>: Eine race condition ist eine Konstellation, in dem das Ergebnis einer Operation von der zeitlich verschränkten Ausführung von bestimmten anderen Operationen abhängt.</li><li><b>Data race</b>: Ein data race ist eine Konstellation, in der zumindestestens zwei Thread zu selben Zeit auf eine gemeinsame Variable zugreifen. Zumindestens ein Thread versucht diese zu verändern.</li></ul></div>
<div class="text">Eine race condition ist per se nicht bösartig. Ein race condition kann die Ursache eines data races sein. Im Gegensatz dazu stellt ein data race undefiniertes Verhalten dar. Daher erübrigt sich jede weitere Analyse des Programms. </div>
<div class="text">Bevor ich die verschiedenen Formen von race conditions vorstelle, die alle nicht gutartig sind, will ich ein Programm mit einer race condition und einem data race vorstellen.</div>
<div class="utitel">Eine race condition und ein data race</div>
<div class="text">Los geht es mit dem Klassiker. Ein Programm, dass es erlaubt, Geld zwischen zwei Konten zu verschieben. Diese Programm besitzt sowohl ein data race als auch eine race condition.</div>
<div class="pre"><span class="tx_code">// account.cpp<br><br>#include &lt;iostream&gt;<br><br>struct Account{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="tx_blue"> // 1</span><span class="tx_code"><br>&nbsp; int balance{100};<br>};<br><br>void transferMoney(int amount, Account&amp; from, Account&amp; to){<br>&nbsp; if (from.balance &gt;= amount){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="tx_blue"> // 2</span><span class="tx_code"><br>&nbsp;&nbsp;&nbsp; from.balance -= amount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; to.balance += amount;<br>&nbsp; }<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Account account1;<br>&nbsp; Account account2;<br><br>&nbsp; transferMoney(50, account1, account2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="tx_blue">// 3</span><span class="tx_code"><br>&nbsp; transferMoney(130, account2, account1);<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "account1.balance: " &lt;&lt; account1.balance &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "account2.balance: " &lt;&lt; account2.balance &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</span></div>
<div class="text">Ich habe den Workflow bewusst einfach gehalten, um meinen Punkt klar zu machen. Jeder Account starten mit einer Summe von 100 $ (1). Um Geld abzuheben, muss das Konto natürlich ausreichend gedeckt sein (2). Falls ausreichend Guthaben vorhanden ist, wird der Betrag zuerst vom alten Konto entfernt und dann zum neuen Konto hinzugefügt. Zwei Überweisungen finden statt (3). Eine von <i>account1</i> auf <i>account2</i> und eine mit vertauschten Rollen. Jede Überweisung finden nach der anderen statt. Die Überweisungen sind eine Art Transaktion und etablieren eine totale Ordnung. Das ist gut so.</div>
<div class="text">Beide Accounts enthalten den richtigen Kontostand.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_134454644_1ea7cf1290.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;">Im wahren Leben wird die Funktion <i>transferMoney</i> natürlich gleichzeitig ausgeführt.</div>
<div class="ztitel">Multithreading </div>
<div class="text">Nun haben wir ein data race und eine race condition.</div>
<div class="pre"><span class="tx_code">// accountThread.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>struct Account{<br>&nbsp; int balance{100};<br>};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="tx_blue">// 2</span><span class="tx_code"><br>void transferMoney(int amount, Account&amp; from, Account&amp; to){<br>&nbsp; using namespace std::chrono_literals;<br>&nbsp; if (from.balance &gt;= amount){<br>&nbsp;&nbsp;&nbsp; from.balance -= amount;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1ns);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="tx_blue">// 3</span><span class="tx_code"><br>&nbsp;&nbsp;&nbsp; to.balance += amount;<br>&nbsp; }<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Account account1;<br>&nbsp; Account account2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="tx_blue">// 1</span><span class="tx_code"><br>&nbsp; std::thread thr1(transferMoney, 50, std::ref(account1), std::ref(account2));<br>&nbsp; std::thread thr2(transferMoney, 130, std::ref(account2), std::ref(account1));<br>&nbsp; <br>&nbsp; thr1.join();<br>&nbsp; thr2.join();<br><br>&nbsp; std::cout &lt;&lt; "account1.balance: " &lt;&lt; account1.balance &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "account2.balance: " &lt;&lt; account2.balance &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</span></div>
<div class="text">Die Aufrufe von <i>transferMoney</i> (1) werden gleichzeitig ausgeführt. Die Argumente an eine Funktion, die in einem Thread verwendet werden, müssen verschoben oder kopiert werden. Falls eine Referenz wie <i>account1</i> oder <i>account2 </i>an die Thread Funktion übergeben wird, muss diese in einen Referenz-Wrapper mit Hilfe von <i><a class="" href="http://en.cppreference.com/w/cpp/utility/functional/ref" alt="%7B%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Ffunctional%2Fref%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22std%3A%3Aref%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Futility%2Ffunctional%2Fref%22%7D" title="Link auf http://en.cppreference.com/w/cpp/utility/functional/ref">std::ref</a></i> verpackt werden.</div>
<div class="text">Nun haben wir ein data race und eine race condition. Die Aufrufe von <i>transferMoney</i> (1) werden gleichzeitig ausgeführt. Daher gibt es ein data race auf dem Kontostand <i>balance</i> in der Funktion <i>transferMoney</i> (2). Aber wo ist die race condition? Um die race condition sichtbar zu machen, lege ich die Threads einen kleinen Zeitraum schlafen (3). Das built-in Literal<i> 1ns</i> in dem Ausdruck<i> std::this_thread::sleep_for(1ns)</i> steht für eine Nanosekunde. In dem Artikel <a alt="%7B%22text%22%3A%22Raw%20und%20Cooked%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fraw-und-cooked%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fraw-und-cooked%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf http://www.grimm-jaud.de/index.php/blog/raw-und-cooked" href="http://www.grimm-jaud.de/index.php/blog/raw-und-cooked" class="">Raw und Cooked</a> stelle ich die Details zu den neuen built-in Literalen vor. Seit dem C++14 Standard besitzen wir sie in C++ für Zeitdauern.</div>
<div class="text">Nebenbei gesagt. Oft hilft das kurze Schlafen legen eines Threads, um eine race condition sichtbar zu machen.<br></div>
<div class="text">Hier kommt die Ausgabe des Programms.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_134454649_67a1e62337.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> Hier ist das Problem. Nur der erste Aufruf von <i>transferMoney</i> wurde ausgeführt. Der zweite Aufruf wurde nicht ausgeführt, da der Kontostand zu niedrig war. Der Grund ist, dass die zweite Überweisung ausgeführt werden sollte, bevor die erste vollständig abgeschlossen war. Hier ist unsere race condition.</div>
<div class="text">Das data race aufzulösen, ist recht einfach. Die Operationen auf dem Kontostand müssen geschützt werden. Ich setze dazu atomare Variablen ein.<br></div>
<div class="pre">// accountThreadAtomic.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>struct Account{<br>&nbsp; std::atomic&lt;int&gt; balance{100};<br>};<br><br>void transferMoney(int amount, Account&amp; from, Account&amp; to){<br>&nbsp; using namespace std::chrono_literals;<br>&nbsp; if (from.balance &gt;= amount){<br>&nbsp;&nbsp;&nbsp; from.balance -= amount;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1ns);<br>&nbsp;&nbsp;&nbsp; to.balance += amount;<br>&nbsp; }<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Account account1;<br>&nbsp; Account account2;<br>&nbsp; <br>&nbsp; std::thread thr1(transferMoney, 50, std::ref(account1), std::ref(account2));<br>&nbsp; std::thread thr2(transferMoney, 130, std::ref(account2), std::ref(account1));<br>&nbsp; <br>&nbsp; thr1.join();<br>&nbsp; thr2.join();<br><br>&nbsp; std::cout &lt;&lt; "account1.balance: " &lt;&lt; account1.balance &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "account2.balance: " &lt;&lt; account2.balance &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}</div>
<div class="text">Klar, die atomare Variable wird die race condition nicht in Wohlgefallen auflösen. Nur das data race existiert nicht mehr.</div>
<div class="utitel">Wie geht's weiter?</div>
<div class="text">Ich habe ein kleines Programm vorgestellt, dass sowohl ein data race als auch eine race condition besitzt. Aber es gibt viel mehr Varianten von bösartigen race conditions. Den Bruch von Invarianten des Programms, Locking Probleme wie Dead- oder Livelocks oder auch Lebenszeitprobleme von Hintergrundthreads sind wohl die prominentesten Vertreter. Es gibt auch data races ohne race conditions. Im nächsten Artikel schreibe ich über bösartige race conditions. <br></div>
