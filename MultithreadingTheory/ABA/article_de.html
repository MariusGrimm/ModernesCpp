<div class="vorspann">Ein bekanntes Problem in nebenläufigen Programmen ist das so genannte ABA Problem. Das bedeutet, dass ein Wert zweimal gelesen wird und jedes Mal den gleichen Wert A zurückgibt. Die Schlussfolgerung, dass sich der Wert nicht geländert hat, ist falsch. Es hat sich ein B dazwischen eingenistet. <br></div>
<div class="text">Lass mich zuerst das subtile Problem vorstellen</div>
<div class="utitel">Eine Analogie</div>
<div class="text">Das Szenario ist ganz einfach. Du sitzt im Auto und wartest darauf, dass die Ampel grün wird. Grün steht in dem Fall für B und rot für A. Was passiert? </div>
<div class="text"><ol><li> Du schaust auf die Ampel und diese ist rot (A).</li><li>Nun bist du gelangweilt und kontrolliert die Neuigkeiten auf deinem Smartphone. Dabei vergisst du die Zeit.</li><li>Du schaust nochmals auf die Ampel. Diese ist immer noch rot (A).</li></ol></div>
<div class="text">Klar, die Ampel ist zwischen deinen zwei Kontrollblicken grün (B) gewesen. Du denkst aber, dass die zwei Rotphasen eine lange Rotphase sind.</div>
<div class="text">Was bedeutet das für Threads oder auch Prozesse? Nun nochmal ein wenig formaler.</div>
<div class="text"><ol><li>Thread 1 liest eine Variable var mit dem Wert A.</li><li>Thread 1 bekommt die CPU entzogen und Thead 2 läuft.</li><li>Thread 2 ändert den Wert der Variable var von A nach B nach A.</li><li>Thread 1 bekommt wieder die CPU und kontrolliert die Variable A. Da die Variable var denselben Wert besitzt, fährt Thread 1 mit seiner Arbeit fort.</li></ol></div>
<div class="text">Oft ist dies kein Problem. Du kannst es einfach ignorieren.</div>
<div class="utitel">Kein Problem </div>
<div class="text">Betrache das Beispiel. Die Funktion <i>fetch_mult </i>(1) multipliziert ein <i>std::atomic&lt;T&gt;&amp; shared</i> mit <i>mult.</i></div>
<div class="pre">// fetch_mult.cpp<br><br>#include &lt;atomic&gt;<br>#include &lt;iostream&gt;<br><br>template &lt;typename T&gt;<br>T fetch_mult(std::atomic&lt;T&gt;&amp; shared, T mult){<br>&nbsp; T oldValue = shared.load();<br>&nbsp; while (!shared.compare_exchange_strong(oldValue, oldValue * mult));<br>&nbsp; return oldValue;<br>}<br><br>int main(){<br>&nbsp; std::atomic&lt;int&gt; myInt{5};<br>&nbsp; std::cout &lt;&lt; myInt &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; fetch_mult(myInt,5);<br>&nbsp; std::cout &lt;&lt; myInt &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Die zentrale Beobachtung ist es, zu sehen, dass es ein kleines Zeitfenster zwischen dem Lesen des alten Wertes <i>T oldValue = shared.load </i>(2) und dem Vergleich mit dem neuen Wert (3) gibt. Daher kann ein anderer Thread zum Zuge kommen und den alten Wert von <i>oldValue</i> auf <i>anotherValue</i> wieder zurück auf <i>oldValue </i>setzen. Der <i>anotherValue</i> repräsentiert das B.</div>
<div class="text">Oft macht es keinen Unterschied, ob der erste gelesene Wert in der zweiten Leseoperation der ursprüngliche Wert ist. Aber in lock-freien, nebenläufigen Datenstrukturen kann ABA schwerwiegende Folgen haben.</div>
<div class="utitel">Eine lock-freie Datenstruktur</div>
<div class="text">Ich werde in diesem Artikel keine lock-freie Datenstruktur im Detail vorstellen. Ich werde einen lock-freien Stack verwenden, der als einfach verkettete Liste implementiert ist. Der Stack unterstützt zwei Operationen.</div>
<div class="text"><ol><li> "Pop" (auskellern) das erste Element und gibt einen Zeiger darauf zurück.</li><li>"Push" (einkellern) das spezifizierte Objekt auf den Stack.</li></ol></div>
<div class="text">Um das ABA Problem zu identifizieren, möchte ich die "pop" Operation beschreiben. Die "pop" Operation führt im Wesentlichen die folgenden Schritte in einer Schleife aus, bis die Operation erfolgreich war.</div>
<div class="text"><ol><li>Referenziere den Kopfknoten: <b>head</b></li><li>Referenziere den Nachfolger des Kopfknotens: <b>headNext</b></li><li>Mache <b>headNex</b>t zum neuen Kopfknoten, falls <b>head</b> noch der Kopfknoten ist.</li></ol><br></div>
<div class="text">Hier sind die ersten zwei Knoten des Stacks:</div>
<div class="pre"><b>Stack: TOP -&gt; head -&gt; headNext -&gt; ...</b></div>
<div class="text">Nun konstruiere ich das ABA Problem.</div>
<div class="utitel">ABA in Aktion</div>
<div class="text">Der Stack besitzt die folgende Struktur.</div>
<div class="pre">Stack: TOP -&gt; A -&gt; B -&gt; C</div>
<div class="text">Thread 1 ist aktiv und will den Kopf des Stack entfernen. (pop)<br></div>
<div class="text"><ul><li> Thread 1 speichert</li><ul><li>head = A</li><li>headNext = B</li></ul></ul></div>
<div class="text">Bevor Thread 1 sein Entfernen des Kopfes vollenden konnte, kommt Thread 2 zum Zuge.</div>
<div class="text"><ul><li>Thread 2 entfernt A. (pop) </li></ul></div>
<div class="pre">&nbsp;&nbsp;&nbsp; Stack: TOP -&gt; B -&gt; C</div>
<div class="text"><ul><li> Thread 2 entfernt B und löscht B. (pop)<br></li></ul></div>
<div class="pre">&nbsp;&nbsp;&nbsp; Stack: TOP -&gt; C</div>
<div class="text"><ul><li>Thread 2 fügt A wieder hinzu. (push)</li></ul></div>
<div class="pre">&nbsp;&nbsp;&nbsp; Stack: TOP -&gt; A -&gt; C</div>
<div class="text">Thread 1 bekommt wieder die CPU und kontrolliert, ob <i>A == head</i> gilt. Da <i>A == head</i> gilt, wird B zum neuen Kopf des Stacks. Aber B wurde bereits gelöscht. Daher besitzt das Programm undefiniertes Verhalten. </div>
<div class="text">Es gibt ein paar Heilmittel gegen das ABA Problem.</div>
<div class="utitel">Heilmittel gegen ABA</div>
<div class="text">Das konzeptionelle Problem für ABA ist recht offensichtlich. Ein Knoten B == headNext wurde gelöscht, obwohl ein anderer Knoten <i>A == head</i> noch diesen referenzierte. Die Lösung des Problems ist es, das vorzeitige Löschen des Knotens zu verhindern. Hier sind ein paar Heilmittel.</div>
<div class="ztitel">Taged state reference</div>
<div class="text">Eine einfach Lösung besteht darin, zu jedem Knoten hinzuzufügen, wie oft er erfolgreich modifizierte wurde. Das Ergebnis ist, das eine "compare and swap" Operation eventuell fehlschlagen wird, obwohl der Test true ergab.</div>
<div class="text">Die drei nächsten Techniken basieren auf der Idee der deferred reclamation (verzögerte Wiederverwertung).</div>
<div class="ztitel">Garbage collection</div>
<div class="text">Garbage collection sichert zu, dass eine Variable erst gelöscht wird, wenn diese nicht mehr benötigt wird. Das hört sich vielversprechend an, hat aber einen großen Nachteil. Die meisten Garbage collectoren sind nicht lock-frei. Daher besitzt du eine lock-freie Datenstruktur, die in ein nicht lock-freies System eingebunden ist.</div>
<div class="ztitel">Hazard pointers</div>
<div class="text">Von <a title="Link auf https://en.wikipedia.org/wiki/Hazard_pointer" href="https://en.wikipedia.org/wiki/Hazard_pointer" alt="%7B%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHazard_pointer%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHazard_pointer%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Wikipedia%3A%20Hazard%20pointers%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%7D" class="">Wikipedia: Hazard pointers</a>:</div>
<div class="text">In a hazard-pointer system, each thread keeps a list&nbsp; of hazard pointers indicating which nodes the thread is currently accessing. (In many systems this "list" may be provably limited to only one <sup>&nbsp;</sup>or two elements.) Nodes on the hazard pointer list must not be modified or deallocated by any other thread. ...&nbsp;When a thread wishes to remove a node, it places it on a list of nodes "to be freed later", but does not actually deallocate the node's memory until no other thread's hazard list contains the pointer.&nbsp;This manual garbage collection can be done by a dedicated garbage-collection thread (if the list "to be freed later" is shared by all the threads); alternatively, cleaning up the "to be freed" list can be done by each worker thread as part of an operation such as "pop".</div>
<div class="text">Hier kommt das Zitat in einfachen Worten. Jeder Thread hält eine Liste von hazard pointern, die er gerade verwendet. Die Elemente der Liste werden nicht sofort gelöscht, sondern erst auf Liste geschoben, die für das Löschen vorgesehen sind.&nbsp; Das Löschen findet manuell oder automatisch erst später statt.</div>
<div class="ztitel">RCU</div>
<div class="text">RCU steht für <b>R</b>ead <b>C</b>opy <b>U</b>pdate uns ist eine Synchronisations Technik, die für Datenstrukturen verwendet wird, die fast nur gelesen werden. RCU wurde von Paul McKenney entwickelt und wird im Linux Kernel seit 2002 eingesetzt.</div>
<div class="text">Die Idee ist relativ einfach und folgt dem Akronym. Um ein Datum zu ändern, muss eine Kopie davon erzeugt werden, auf der die Modifikation stattfindet. Im Gegensatz finden alle lesenden Operationen auf den ursprünglichen Daten statt. Falls kein lesender Zugriff mehr erfolgt, kann die Datenstruktur einfach mit seiner modifizierten Kopie ersetzt werden. </div>
<div class="text">Mehr Details zu RCU gibt es im Artikel von Paul McKenney: <a href="https://lwn.net/Articles/262464/" alt="%7B%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Flwn.net%2FArticles%2F262464%2F%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Flwn.net%2FArticles%2F262464%2F%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22What%20is%20RCU%2C%20Fundamentally%22%2C%22alias%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://lwn.net/Articles/262464/" class="">What is RCU, Fundamentally</a>?</div>
<div class="text">Als Teil des "concurrency toolkit" gibt es zwei Proposals für die nächsten C++ Standards. Der Proposal <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0233r0.pdf" title="Link auf http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0233r0.pdf" alt="%7B%22destination%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2016%2Fp0233r0.pdf%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22P0233r0%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2016%2Fp0233r0.pdf%22%7D" class="">P0233r0</a> für hazard pointers und der Proposal <a class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0461r0.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0461r0.pdf" alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0461r0.pdf%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2016%2Fp0461r0.pdf%22%2C%22text%22%3A%22P0461R0%20%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22ir_link%22%3A1%7D">P0461R0 </a>für RCU.</div>
<div class="utitel">Wie geht's weiter?</div>
<div class="text">Ich bin mir noch nicht sicher. Ich überlege mir gerade das nächste große Thema, das Potential für mindestens 20 aufregenden Artikel besitzt. Lasse dich überraschen.<br></div>
