<div class="vorspann">In diesem Artikel geht es um bösartige&nbsp; Race Conditions und Data Races. Bösartige Race Conditions sind Race Conditions, die den Bruch von Invarianten eines Programms verursachen, blockierende Threads oder auch Lebenszeitprobleme von Variablen. </div><div class="text">Aber zuerst will ich kurz wiederholen, was eine Race Condition ist.</div><div class="text"><ul><li><b>Race Condition</b>: eine Konstellation, in dem das Ergebnis einer Operation von der zeitlich verschränkten Ausführung von bestimmten anderen Operationen abhängt. </li></ul></div><div class="text">Mit dieser Definition kann der Artikel schon losgehen. Eine Race Condition kann die Invariante eines Programms brechen. </div><div class="ztitel">Bruch von Invarianten </div><div class="text">Im letzten Artikel "<a href="/exec/mainmenu.pl?sid=8e08885d76e6961c9a9dbc70999a3881&amp;rm=open_article_id&amp;bid=2204485" title="Link auf Beitrag 2204485" alt="%7B%22user_params%22%3A%22%22%2C%22text%22%3A%22Race%20Conditions%20und%20Data%20Races%22%2C%22target%22%3A%22%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3D8e08885d76e6961c9a9dbc70999a3881%26rm%3Dopen_article_id%26bid%3D2204485%22%2C%22version%22%3A1%2C%22type%22%3A%22B%22%2C%22custom%22%3A%7B%7D%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A2204485%2C%22alias%22%3A%22%22%7D">Race Conditions und Data Races</a>" stellte ich anhand einer Geldüberweisung ein Data Race vor. Es gab in dem Programm eine unkritische Race Condition. Um ehrlich zu sein, es gab auch eine bösartige Race Condition, auf die ich jetzt eingehe.</div><div class="text">Die bösartige Race Condition bricht eine wichtige Invariante des Programms. Die Invariante ist, dass die Summe aller Konten immer den gleichen Betrag besitzen soll. Das ist in unserem Fall 200 Euro, da jedes Konto einen initialen Betrag von 100 Euro (1) besitzt. Der Einfachheit nehme ich die Einheit Euro an. Weder will ich durch eine Transaktion zusätzliches Geld erzeugen noch Geld vernichten. </div><div class="pre">// breakingInvariant.cpp<br> <br>#include &lt;atomic&gt; <br>#include &lt;functional&gt; <br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>struct Account{ <br>&nbsp; std::atomic&lt;int&gt; balance{100};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>void transferMoney(int amount, Account&amp; from, Account&amp; to){<br>&nbsp; using namespace std::chrono_literals; <br>&nbsp; if (from.balance &gt;= amount){ <br>&nbsp;&nbsp;&nbsp; from.balance -= amount;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1ns);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>&nbsp;&nbsp;&nbsp; to.balance += amount;<br>&nbsp; }<br>}<br><br>&nbsp;void printSum(Account&amp; a1, Account&amp; a2){<br>&nbsp; std::cout &lt;&lt; (a1.balance + a2.balance) &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>}<br><br>int main(){ <br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Account acc1;<br>&nbsp; Account acc2;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Initial sum: ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; printSum(acc1, acc2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4<br>&nbsp; <br>&nbsp; std::thread thr1(transferMoney, 5, std::ref(acc1), std::ref(acc2));<br>&nbsp; std::thread thr2(transferMoney, 13, std::ref(acc2), std::ref(acc1));<br>&nbsp; std::cout &lt;&lt; "Intermediate sum: ";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; std::thread thr3(printSum, std::ref(acc1), std::ref(acc2));&nbsp; // 5<br>&nbsp; <br>&nbsp; thr1.join();<br>&nbsp; thr2.join();<br>&nbsp; thr3.join();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 6<br>&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp; acc1.balance: " &lt;&lt; acc1.balance &lt;&lt; std::endl;<br>&nbsp; std::cout &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp; acc2.balance: " &lt;&lt; acc2.balance &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "Final sum: ";<br>&nbsp; printSum(acc1, acc2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 8<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>}<br></div><div class="text">Am Anfang beträgt die Summe der Konten 200 Euro. Die&nbsp; Funktion <i>printSum</i> (3) stellt die Summe in dem Aufruf (4) dar. Die Zeile (5) bringt die Invariante zum Vorschein. Dank des kurzen Schlafens von <i>1ns</i> in Zeile (2) beträgt die Zwischensumme nur 182 Euro. Am Ende passt die Arithmetik wieder. Jedes Konto besitzt den richtigen Betrag (6), und die Gesamtsumme ist 200 Euro (8). </div><div class="text">Hier ist die Ausgabe des Programms. </div><div class="text"><img title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_134903249_ba8f585c29.png" style="max-height: 25px; max-width: 25px;"></div><div class="text">Die bösartige Geschichte geht weiter. Jetzt erzeuge ich ein Deadlock mithilfe einer Bedingungsvariablen ohne Prädikat.</div><div class="ztitel">Blockieren mit Race Conditions </div><div class="text">Zuerst muss ich klarstellen: Eine Bedingungsvariable sollte zusammen mit einem Prädikat verwendet werden. Die Details dazu finden sich in meinem Artikel "<a href="http://www.grimm-jaud.de/index.php/blog/bedingungsvariablen" title="Link auf http://www.grimm-jaud.de/index.php/blog/bedingungsvariablen" alt="%7B%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fbedingungsvariablen%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fbedingungsvariablen%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Bedingungsvariablen%22%7D">Bedingungsvariablen</a>". Falls kein Prädikat verwendet wird, kann das Programm Opfer eines "spurious wakeup" oder auch "lost wakeup" werden.&nbsp; </div><div class="text">Falls man eine Bedingungsvariable ohne ein Prädikat verwendet, kann es passieren, das der benachrichtigende Thread seine Benachrichtigung schickt, bevor der wartende Thread im Wartezustand ist. Daher wartet der wartende Thread für immer, und das Programm verabschiedet sich in den Dornröschenschlaf. Dies Phänomen wird als "lost wakeup" bezeichnet. Hier ist das Programm.</div><div class="pre">// conditionVariableBlock.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;mutex&gt;<br>#include &lt;thread&gt;<br><br>std::mutex mutex_;<br>std::condition_variable condVar;<br><br>bool dataReady;<br><br><br>void waitingForWork(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Worker: Waiting for work." &lt;&lt; std::endl;<br><br>&nbsp;&nbsp;&nbsp; std::unique_lock&lt;std::mutex&gt; lck(mutex_);<br>&nbsp;&nbsp;&nbsp; condVar.wait(lck);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp;&nbsp;&nbsp; // do the work<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Work done." &lt;&lt; std::endl;<br><br>}<br><br>void setDataReady(){<br><br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Sender: Data is ready."&nbsp; &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; condVar.notify_one();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br><br>}<br><br>int main(){<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; std::thread t1(setDataReady);<br>&nbsp; std::thread t2(waitingForWork);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br><br>&nbsp; t1.join();<br>&nbsp; t2.join();<br><br>&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp; <br>}</div><div class="text">Der erste Aufruf des Programms geht gut. Der zweite Aufruf blockiert, da die Benachrichtigung (1) stattfindet, bevor der Thread<i> t2</i> (2) im Wartezustand (3) ist.&nbsp;</div><div class="text"><img title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_134903258_eae13ea4ac.png" style="max-height: 25px; max-width: 25px;"></div><div class="text">Selbstverständlich sind Deadlocks und Livelocks weitere Effekte von Race Conditions. Ein Deadlock hängt im&nbsp;Allgemeinen von dem zeitlichen Zusammenspiel von Threads ab und tritt daher gelegentlich auf. Ein Livelock ist einem Deadlock sehr ähnlich. Während aber ein Deadlock blockiert, scheint ein Livelock Fortschritte zu machen. Meine Betonung liegt auf "scheint". Es sei hier an eine Transaktion in einem Transactional Memory System erinnert. Jedes Mal, wenn die Transaktion veröffentlicht werden soll, tritt ein Konflikt zum Anfangszustand ein. Daher wird die Transaktion ordnungsgemäß zurückgesetzt. Hier ist mein Artikel zu "<a alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftransactional-memory%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Transactional%20Memory%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftransactional-memory%22%2C%22version%22%3A1%7D" href="http://www.grimm-jaud.de/index.php/blog/transactional-memory" title="Link auf http://www.grimm-jaud.de/index.php/blog/transactional-memory">Transactional Memory</a>". </div><div class="text">Lebenszeitprobleme von Variablen zu zeigen, ist nicht so anspruchsvoll.</div><div class="ztitel">Lebenszeitprobleme von Variablen<br></div><div class="text">Das Rezept für ein Lebenszeitproblem ist ziemlich einfach. Lass den erzeugten Thread im Hintergrund laufen, und du bist schon halb fertig. Damit meine ich, dass der Erzeuger nicht darauf wartet, bis sein Kind seine Arbeit vollbracht hat. In diesem Fall ist äußerste Vorsicht geboten, damit das Kind nicht etwas verwendet, was dem Erzeuger gehört.</div><div class="pre">// lifetimeIssues.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;thread&gt; <br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp; std::cout &lt;&lt; "Begin:" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2&nbsp;&nbsp;&nbsp; <br><br>&nbsp; std::string mess{"Child thread"};<br><br>&nbsp; std::thread t([&amp;mess]{ std::cout &lt;&lt; mess &lt;&lt; std::endl;});<br>&nbsp; t.detach();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; "End:" &lt;&lt; std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br><br>}</div><div class="text">Das war zu einfach. Der Thread<i> t</i> verwendet <i>std::cout </i>und die Variable <i>mess</i>. Beide gehören dem [i]main[/i]-Thread. Das Ergebnis ist, dass wir die Ausgabe des Kinder-Threads nicht in der zweiten Ausführung des Programms sehen. Nur "<i>Begin</i> :" (2) und <i>"End</i>:" (3) werden dargestellt. </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_134903270_ad46c8ada5.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"> &nbsp;</div><div class="text">Ich will es nochmals ganz explizit sagen: Alle Programme des Artikels enthalten bis hierher kein Data Race. Meine Idee war es aber, über Race Conditions und Data Races zu schreiben. Sie sind ähnliche, aber doch unterschiedliche Konzepte. </div><div class="text">Es lässt sich auch ein Data Race ohne eine Race Condition erzeugen. </div><div class="ztitel">Ein Data Race ohne eine Race Condition</div><div class="text">Zuerst will ich wieder kurz die Definiton eines Data Race wiederholen. <br></div><div class="text"><ul><li><b>Data Race</b>: ist eine Konstellation, in der mindestens zwei Threads zu selben Zeit auf eine gemeinsame Variable zugreifen. Zumindest ein Thread versucht, diese zu verändern.</li></ul></div><div class="pre">// addMoney.cpp<br><br>#include &lt;functional&gt;<br>#include &lt;iostream&gt; <br>#include &lt;thread&gt;<br>#include &lt;vector&gt;<br><br>struct Account{<br>&nbsp; int balance{100};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>};<br><br>void addMoney(Account&amp; to, int amount){<br>&nbsp; to.balance += amount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>}<br><br>int main(){<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br><br>&nbsp; Account account;<br>&nbsp; <br>&nbsp; std::vector&lt;std::thread&gt; vecThreads(100);<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br>&nbsp; for (auto&amp; thr: vecThreads) thr = std::thread( addMoney,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ref(account), 50);<br>&nbsp; <br>&nbsp; for (auto&amp; thr: vecThreads) thr.join();<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4<br>&nbsp; std::cout &lt;&lt; "account.balance: " &lt;&lt; account.balance &lt;&lt; std::endl;<br>&nbsp; <br>&nbsp; std::cout &lt;&lt; std::endl;<br> <br>}</div><div class="text">100 Threads fügen 50 Euro (3) zu demselben Konto (1) hinzu. Sie verwenden die Funktion <i>addMone</i>. Die entscheidende Beobachtung ist es, dass das Schreiben des Kontos ohne Synchronisation stattfindet. Daher ist dies ein Data Race, und wir erhalten kein eindeutiges Ergebnis. Das Programm besitzt undefiniertes Verhalten und der finale Kontostand (4) schwankt zwischen 5000 und 5100 Euro.&nbsp; </div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_134903271_1e26c217a3.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> &nbsp;<br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Ich verfolge häufig in Konferenzen, die sich mit Gleichzeitigkeit und Parallelität beschäftigen, intensive Diskussionen zu den Begriffen nichtblockierend, lock-frei und wait-frei. Daher werde ich mir im nächsten Artikel die drei Begriffe genauer anschauen.&nbsp; <br></div>