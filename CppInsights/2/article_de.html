<div class="vorspann">Andreas Fertigs Serie über C++ Insights geht weiter. Dieser Artikel beschäftigt sich mit der automatischen Typableitung mithilfe von <i>auto</i> und <i>decltyp</i>e oder wie ich es gerne umschreibe: "Nutze die Intelligenz des Compilers." <br></div><div class="ztitel">Automatische Typableitung<br></div><div class="text">Mit C++ 11 bekamen wir <i>auto</i> und <i>decltype</i>, eine neue Form der Typermittlung.</div><div class="ztitel_kleiner"><i>auto</i><br></div><div class="text">Wir sind Typermittlung von Templates gewohnt, jedoch können diese beiden neuen Varianten manchmal schwierig sein. Betrachtet sei dieses Beispiel:</div><div class="pre">int main()<br>{<br>&nbsp; int* ip;<br>&nbsp; const int* cip;<br>&nbsp; const int* const cicp = ip;<br>&nbsp; <br>&nbsp; auto aip = ip;<br>&nbsp; auto acip = cip;<br>&nbsp; auto acicp = cicp;<br>}<br></div><div class="text">Wir haben drei verschiedene Zeiger, alle vom Typ <i>int</i>. Sie werden immer mehr <i>const</i>. Die Frage ist, welche Art von <i>auto</i> abgeleitet wird. Alle sind Zeiger, das ist sicher. Aber was passiert mit dem <i>const</i>? Alle Qualifikationsmerkmale der obersten Ebene werden automatisch entfernt. Daher verschwindet auch das <i>const</i>. Stimmt das? Hier ist die Ausgabe, die C++ Insights liefert:</div><div class="pre">int main()<br>{<br>&nbsp; int * ip;<br>&nbsp; const int * cip;<br>&nbsp; const int *const cicp = ip;<br>&nbsp; int * aip = ip;<br>&nbsp; const int * acip = cip;<br>&nbsp; const int * acicp = cicp;<br>}</div><div class="text">Ja, das <i>const</i> der obersten Ebene wird entfernt. Ein konstanter Zeiger spielt keine Rolle, also wird dieses <i>const</i> verworfen, aber die Konstanz des dahinterliegenden Speichers bleibt bestehen. Daher bleibt dieses <i>const</i> erhalten. Deshalb sieht <i>acip</i> genau wie <i>acicp</i> aus. Macht Sinn, richtig?</div><div class="ztitel_kleiner"><i>decltype(auto)</i><br></div><div class="text">Von Zeit zu Zeit möchten wir alle Qualifikanten beibehalten. Dies ist der Zeitpunkt, an dem <i>decltype</i> erscheint. Im Gegensatz zu <i>auto</i> behält <i>decltype</i> alle Top-Level-Qualifikationsmerkmale bei. Mit C++14 ist die Kombination von <i>decltype</i> und <i>auto</i> möglich, wir können <i>decltype(auto)</i> schreiben, was die Sache einfacher macht. Hier ist ein weiteres Beispiel aus C++ Insights, das C++14 nutzt:<br></div><div class="pre">int main()<br>{<br>&nbsp; int* ip;<br>&nbsp; const int* cip;<br>&nbsp; const int* const cicp = ip;<br><br>&nbsp; decltype(auto) aip = ip;<br>&nbsp; decltype(auto) acip = cip;<br>&nbsp; decltype(auto) acicp = cicp;<br>}<br></div><div class="text">Daraus erhalten wir folgende Ausgabe:</div><div class="pre">int main()<br>{<br>&nbsp; int * ip;<br>&nbsp; const int * cip;<br>&nbsp; const int *const cicp = ip;<br>&nbsp; int * aip = ip;<br>&nbsp; const int * acip = cip;<br>&nbsp; const int *const acicp = cicp;<br>}</div><div class="text">Wir können sehen, dass <i>acicp</i> das zweite <i>const</i> trägt, das verloren geht, wenn wir nur <i>auto</i> verwenden.</div><div class="ztitel_kleiner"><i>decltype</i><br></div><div class="text">Wann brauchen wir <i>decltype</i> oder genauer gesagt, wann möchten wir alle Qualifikanten behalten? Ein beliebter Grund sind Templates. Stellen wir uns ein Klassen-Template mit der Funktion <i>Get</i> vor. Wenn wir nur <i>auto</i> als Rückgabetyp verwenden, können wir niemals einen Verweis auf etwas zurückgeben. Im Template-Code kennen wir oft nicht die genauen Typen, weshalb es wünschenswert ist, Code bereitzustellen, der gerade funktioniert. Hier kann <i>decltype</i> helfen. Wir sollten es jedoch als Funktionalität für Bibliotheksautoren betrachten. In den meisten Fällen geht es uns mit <i>auto</i> gut. Es ist nur einfach gut, die gesamte Toolbox genau zu kennen.</div><div class="ztitel_kleiner"><i>auto&amp;</i> und <i>auto*</i> versus <i>auto</i><br></div><div class="text">Was wir bisher gesehen haben, ist, dass wir explizit sein müssen, wenn es um <i>auto</i> und Referenzen geht. Wir müssen immer <i>auto&amp;</i> schreiben, um eine Referenz zu erhalten. Wie ist es mit Zeigern? Gibt uns <i>auto</i> den richtigen Typ und können wir uns den Stern sparen? Dies ist in der Tat eine Frage, die ich häufig von meinen Schülern bekomme. Die Antwort ist: Es kommt darauf an. Ich empfehle es, schon aus Gründen der Konsistenz zu schreiben. Es gibt jedoch Szenarien, in denen wir <i>auto*</i> benötigen, selbst wenn automatisch der korrekte Typ abgeleitet wurde. Betrachten wir dieses <a title="Link auf https://cppinsights.io/lnk?code=c3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogIGF1dG8gZnAgPSBHZXRGb28oKTsKfQ==&amp;rev=1.0" alt="%7B%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3Dc3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogIGF1dG8gZnAgPSBHZXRGb28oKTsKfQ%3D%3D%26amp%3Brev%3D1.0%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Beispiel%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3Dc3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogIGF1dG8gZnAgPSBHZXRGb28oKTsKfQ%3D%3D%26amp%3Brev%3D1.0%22%7D" href="https://cppinsights.io/lnk?code=c3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogIGF1dG8gZnAgPSBHZXRGb28oKTsKfQ==&amp;rev=1.0">Beispiel</a>:</div><div class="pre">struct Foo{};<br><br>Foo* GetFoo()<br>{<br>&nbsp; static Foo foo;<br>&nbsp; <br>&nbsp; return &amp;foo;<br>}<br><br>int main()<br>{<br>&nbsp; auto fp = GetFoo();<br>}</div><div class="text">Wir haben eine Funktion, die ein <i>Foo*</i> zurückgibt, und eine <i>auto</i>-Variable <i>auto f = GetFoo()</i>, die den Typ ableitet. Natürlich der richtige Typ. Was ist, wenn wir gerne <i>f</i> <i>const</i> machen? Dass wir die Daten von <i>f</i> nicht ändern können? Sicher schreiben wir es so: <i>const auto f = ..</i>. Zumindest würden wir das tun, wenn wir es ohne <i>auto</i> schreiben würden. Hier sind einige Möglichkeiten, die wir ausprobieren können:<br></div><div class="pre">struct Foo{};<br><br>Foo* GetFoo()<br>{<br>&nbsp; static Foo foo;<br>&nbsp; <br>&nbsp; return &amp;foo;<br>}<br><br>int main()<br>{<br>&nbsp; auto fp0 = GetFoo();<br>&nbsp; const auto fp1 = GetFoo();<br>&nbsp; auto const fp2 = GetFoo();<br>&nbsp; //const auto const fp3 = GetFoo(); does not compile<br>&nbsp; const auto* fp4 = GetFoo();<br>&nbsp; auto* const fp5 = GetFoo();<br>&nbsp; const auto* const fp6 = GetFoo();<br>}</div><div class="text">Zunächst erzeugt <i>fp1</i> einen <i>const</i>-Zeiger auf veränderliche Daten. Nicht genau das, was wir beabsichtigten. <i>fp2</i> scheint wahrscheinlich sinnlos. Am sinnvollsten ist <i>fp3</i>, aber das wird nicht kompiliert. Die Kontrolle ändert sich, wenn wir die Form <i>auto*</i> verwenden. Jetzt können wir die Qualifier hinzufügen, wie wir es mit einem regulären Typ tun können. Aber <a alt="%7B%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3Dc3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogICAgICAgIGF1dG8gICAgICAgIGZwMCA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8gICAgICAgIGZwMSA9IEdldEZvbygpOwogICAgICAgIGF1dG8gIGNvbnN0IGZwMiA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8qICAgICAgIGZwMyA9IEdldEZvbygpOwogICAgICAgYXV0byogIGNvbnN0IGZwNCA9IEdldEZvbygpOwp9%26amp%3Brev%3D1.0%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22sehen%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3Dc3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogICAgICAgIGF1dG8gICAgICAgIGZwMCA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8gICAgICAgIGZwMSA9IEdldEZvbygpOwogICAgICAgIGF1dG8gIGNvbnN0IGZwMiA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8qICAgICAgIGZwMyA9IEdldEZvbygpOwogICAgICAgYXV0byogIGNvbnN0IGZwNCA9IEdldEZvbygpOwp9%26amp%3Brev%3D1.0%22%2C%22ir_link%22%3A1%7D" href="https://cppinsights.io/lnk?code=c3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogICAgICAgIGF1dG8gICAgICAgIGZwMCA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8gICAgICAgIGZwMSA9IEdldEZvbygpOwogICAgICAgIGF1dG8gIGNvbnN0IGZwMiA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8qICAgICAgIGZwMyA9IEdldEZvbygpOwogICAgICAgYXV0byogIGNvbnN0IGZwNCA9IEdldEZvbygpOwp9&amp;rev=1.0" title="Link auf https://cppinsights.io/lnk?code=c3RydWN0IEZvb3t9OwoKRm9vKiBHZXRGb28oKQp7CiAgc3RhdGljIEZvbyBmb287CiAgCiAgcmV0dXJuICZmb287Cn0KCmludCBtYWluKCkKewogICAgICAgIGF1dG8gICAgICAgIGZwMCA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8gICAgICAgIGZwMSA9IEdldEZvbygpOwogICAgICAgIGF1dG8gIGNvbnN0IGZwMiA9IEdldEZvbygpOwogIGNvbnN0IGF1dG8qICAgICAgIGZwMyA9IEdldEZvbygpOwogICAgICAgYXV0byogIGNvbnN0IGZwNCA9IEdldEZvbygpOwp9&amp;rev=1.0">sehen</a> wir selbst in C++ Insights, was das Ergebnis ist:</div><div class="pre">struct Foo{/* public: inline constexpr Foo() noexcept; */<br>/* public: inline constexpr Foo(const Foo &amp;); */<br>/* public: inline constexpr Foo(Foo &amp;&amp;); */<br>};<br><br>Foo * GetFoo()<br>{<br>&nbsp; static Foo foo = Foo();<br>&nbsp; return &amp;foo;<br>}<br><br><br>int main()<br>{<br>&nbsp; Foo * fp0 = GetFoo();<br>&nbsp; Foo *const fp1 = GetFoo();<br>&nbsp; Foo *const fp2 = GetFoo();<br>&nbsp; const Foo * fp4 = GetFoo();<br>&nbsp; Foo *const fp5 = GetFoo();<br>&nbsp; const Foo *const fp6 = GetFoo();<br>}</div><div class="text">Der einfache Rat ist, immer explizit zu bleiben und das Formular <i>auto&amp;</i> sowie <i>auto*</i> zu verwenden, auch wenn <i>auto</i> einen Zeigertyp ableiten kann.</div><div class="text">Nehmen wir an, wir sind explizit und verwenden <i>auto</i>&amp;. Schauen wir uns dieses <a title="Link auf https://cppinsights.io/lnk?code=c3RydWN0IFNpbmdsZXRvbnt9OwoKYXV0byBHZXQoKQp7CiAgc3RhdGljIFNpbmdsZXRvbiBze307CiAgCiAgcmV0dXJuIHM7Cn0KCmludCBtYWluKCkKewogIGF1dG8mIHggPSBHZXQoKTsKfQ==&amp;std=cpp17&amp;rev=1.0" alt="%7B%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3Dc3RydWN0IFNpbmdsZXRvbnt9OwoKYXV0byBHZXQoKQp7CiAgc3RhdGljIFNpbmdsZXRvbiBze307CiAgCiAgcmV0dXJuIHM7Cn0KCmludCBtYWluKCkKewogIGF1dG8mIHggPSBHZXQoKTsKfQ%3D%3D%26amp%3Bstd%3Dcpp17%26amp%3Brev%3D1.0%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Beispiel%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3Dc3RydWN0IFNpbmdsZXRvbnt9OwoKYXV0byBHZXQoKQp7CiAgc3RhdGljIFNpbmdsZXRvbiBze307CiAgCiAgcmV0dXJuIHM7Cn0KCmludCBtYWluKCkKewogIGF1dG8mIHggPSBHZXQoKTsKfQ%3D%3D%26amp%3Bstd%3Dcpp17%26amp%3Brev%3D1.0%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%7D" href="https://cppinsights.io/lnk?code=c3RydWN0IFNpbmdsZXRvbnt9OwoKYXV0byBHZXQoKQp7CiAgc3RhdGljIFNpbmdsZXRvbiBze307CiAgCiAgcmV0dXJuIHM7Cn0KCmludCBtYWluKCkKewogIGF1dG8mIHggPSBHZXQoKTsKfQ==&amp;std=cpp17&amp;rev=1.0">Beispiel</a> an:</div><div class="pre">struct Singleton{};<br><br>auto Get()<br>{<br>&nbsp; static Singleton s{};<br>&nbsp; <br>&nbsp; return s;<br>}<br><br>int main()<br>{<br>&nbsp; auto&amp; x = Get();<br>}<br></div><div class="text">Wir haben ein klassisches Singleton, das die Funktion <i>Get</i> zurückgeben soll. Natürlich möchten wir eine Referenz darauf, ansonsten haben wir mehrere Singletons. Trotz <i>auto</i> und <i>&amp;</i> kompiliert dieser Code nicht:</div><div class="text"><i>error: non-const lvalue reference to type 'Singleton' cannot bind to a temporary of type 'Singleton'</i><br></div><div class="text">Der Grund ist, dass <i>Get</i> tatsächlich <i>Singleton</i> zurückgibt und nicht <i>Singleton&amp;</i>. Warum? Weil wir das <i>&amp;</i> nicht auf den automatischen Rückgabetyp von <i>Get</i> angewendet haben. Eine kleine Änderung und der Code kompiliert:</div><div class="pre">struct Singleton{};<br><br>auto&amp; Get()<br>{<br>&nbsp; static Singleton s{};<br>&nbsp; <br>&nbsp; return s;<br>}<br><br>int main()<br>{<br>&nbsp; auto&amp; x = Get();<br>}</div><div class="text">Viel Spaß mit C++ Insights. Wer möchte, kann das Projekt unterstützen, entweder als <a title="Link auf https://www.patreon.com/cppinsights" href="https://www.patreon.com/cppinsights" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.patreon.com%2Fcppinsights%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.patreon.com%2Fcppinsights%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Patreon%22%2C%22subject%22%3A%22%22%7D">Patreon</a> oder natürlich auch mit <a title="Link auf https://github.com/andreasfertig/cppinsights" href="https://github.com/andreasfertig/cppinsights" alt="%7B%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fandreasfertig%2Fcppinsights%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Code-Beitr%C3%A4gen%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fandreasfertig%2Fcppinsights%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%7D">Code-Beiträgen</a>.<br></div><div class="text">Demnächst mehr zu C++ Insights und Template Instanziierungen ...</div><div class="ztitel">Wahl des nächsten PDF-Päckchens:</div><div class="text">Auf meinem deutschen und meinem englischen Blog findet gerade die Wahl zum nächsten PDF-Päckchen statt. Hier sind die Links zur Wahl:</div><div class="text"><ul><li>Deutscher Blog: <a href="http://bit.ly/2Jrtdnl" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22Welches%20PDF-P%C3%A4ckchen%20soll%20ich%20zusammenstellen%3F%20Mache%20dein%20Kreuz%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fbit.ly%2F2Jrtdnl%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22http%3A%2F%2Fbit.ly%2F2Jrtdnl%22%7D" title="Link auf http://bit.ly/2Jrtdnl">Welches PDF-Päckchen soll ich zusammenstellen? Mache dein Kreuz</a>! </li><li>Englischer Blog: <a alt="%7B%22text%22%3A%22Which%20PDF%20bundle%20should%20I%20provide%3F%20Make%20your%20choice%21%20%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fbit.ly%2F2Cs2Ibt%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fbit.ly%2F2Cs2Ibt%22%7D" href="http://bit.ly/2Cs2Ibt" title="Link auf http://bit.ly/2Cs2Ibt">Which PDF bundle should I provide? Make your choice! </a> </li></ul> </div>
