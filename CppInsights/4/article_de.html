<div class="vorspann">Variadic Templates sind ein C++-Feature, das beim ersten Blick magisch wirkt. Dank C++ Insights verschwindet die Magie aber schnell.<br></div><div class="text">Variadic Templates sind eines der mächtigsten neuen Konstrukte, die wir seit C++11 haben.</div><div class="ztitel">Variadic Templates<br></div><div class="text">Sie sind großartig, weil wir eine Funktion haben können, die mehrere Argumente gleichzeitig akzeptiert und trotzdem stark typisiert ist. Wir benötigen keinen Formatbezeichner, um etwas Speicher vom Stapel in einen Typ umzuwandeln. Variadische Templates oder in diesem Fall genauer variadische Funktions-Templates erweitern sich in Funktionen, wie wir sie schreiben würden. Das sogenannte Parameterpaket wird erweitert. Während dieses Vorgangs wird jeder Parameter einfach durch ein Komma getrennt, so wie wir die Funktion schreiben würden. Hier ist ein grundlegendes Beispiel:</div><div class="pre">template&lt;typename T&gt;<br>T add(const T&amp; arg)<br>{<br>&nbsp; return arg;<br>}<br><br>template&lt;typename T, typename... ARGS&gt;<br>T add(const T&amp; arg, const ARGS&amp;... args)<br>{<br>&nbsp; return arg + add(args...);<br>}<br><br>int main()<br>{<br>&nbsp; return add(1, 2u, 3u);<br>}<br></div><div class="text">Die Überladung des einzelnen Arguments ist erforderlich, um die hier verwendete Rekursion zu beenden. Verwenden wir C++ Insights, um zu sehen, was unter der Haube <a href="https://cppinsights.io/lnk?code=dGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ==&amp;rev=1.0" alt="%7B%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3DdGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ%3D%3D%26amp%3Brev%3D1.0%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3DdGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ%3D%3D%26amp%3Brev%3D1.0%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22passiert%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://cppinsights.io/lnk?code=dGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ==&amp;rev=1.0">passiert</a>:<br></div><div class="pre">template&lt;typename T&gt;<br>T add(const T&amp; arg)<br>{<br>&nbsp; return arg;<br>}<br><br>/* First instantiated from: insights.cpp:10 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>unsigned int add&lt;unsigned int&gt;(const unsigned int &amp; arg)<br>{<br>&nbsp; return arg;<br>}<br>#endif<br><br><br>template&lt;typename T, typename... ARGS&gt;<br>T add(const T&amp; arg, const ARGS&amp;... args)<br>{<br>&nbsp; return arg + add(args...);<br>}<br><br>/* First instantiated from: insights.cpp:15 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>int add&lt;int, unsigned int, unsigned int&gt;(const int &amp; arg, const unsigned int &amp; __args1, const unsigned int &amp; __args2)<br>{<br>&nbsp; return static_cast&lt;int&gt;(static_cast&lt;unsigned int&gt;(arg) + add(__args1, __args2));<br>}<br>#endif<br><br><br>/* First instantiated from: insights.cpp:10 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>unsigned int add&lt;unsigned int, unsigned int&gt;(const unsigned int &amp; arg, const unsigned int &amp; __args1)<br>{<br>&nbsp; return arg + add(__args1);<br>}<br>#endif<br><br><br>int main()<br>{<br>&nbsp; return add(1, 2u, 3u);<br>}<br></div><div class="text">Achten Sie auf die Typen. Ich habe <i>2u</i> und <i>3u</i> verwendet, was zu zwei <i>unsigned int</i>-Argumenten und einem <i>signed int</i> führt. Aufgrund der Anordnung der Parameter ist der Rückgabewert von <i>add int</i>. C++ Insights zeigt, dass dies zu einer impliziten Umwandlung in <i>add</i> führt. Ein weiterer Einblick, den C++ Insights uns zeigt.</div><div class="ztitel_kleiner">Fold-Ausdrücke<br></div><div class="text">Mit C++17 und Fold-Ausdrücken können wir unseren Code darauf reduzieren:<br></div><div class="pre">template&lt;typename... ARGS&gt;<br>auto add(const ARGS&amp;... args)<br>{<br>&nbsp; return (args + ...);<br>}<br><br>int main()<br>{<br>&nbsp; return add(1, 2u, 3u);<br>}<br></div><div class="text">Ich mag es wirklich, wie die neuen Standards dazu führen, dass wir weniger Code schreiben müssen. Das Ergebnis von <a title="Link auf https://cppinsights.io/lnk?code=dGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ==&amp;rev=1.0" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22C%2B%2B%20Insights%22%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3DdGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ%3D%3D%26amp%3Brev%3D1.0%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3DdGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ%3D%3D%26amp%3Brev%3D1.0%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" href="https://cppinsights.io/lnk?code=dGVtcGxhdGU8dHlwZW5hbWUuLi4gQVJHUz4KYXV0byBhZGQoY29uc3QgQVJHUyYuLi4gYXJncykKewogIHJldHVybiAoYXJncyArIC4uLik7Cn0KCmludCBtYWluKCkKewogIHJldHVybiBhZGQoMSwgMnUsIDN1KTsKfQ==&amp;rev=1.0">C++ Insights</a> ändert sich ebenfalls:<br></div><div class="pre">template&lt;typename... ARGS&gt;<br>auto add(const ARGS&amp;... args)<br>{<br>&nbsp; return (args + ...);<br>}<br><br>/* First instantiated from: insights.cpp:9 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>unsigned int add&lt;int, unsigned int, unsigned int&gt;(const int &amp; __args0, const unsigned int &amp; __args1, const unsigned int &amp; __args2)<br>{<br>&nbsp; return static_cast&lt;unsigned int&gt;(__args0) + __args1 + __args2;<br>}<br>#endif<br><br><br>int main()<br>{<br>&nbsp; return static_cast&lt;int&gt;(add(1, 2u, 3u));<br>}<br></div><div class="text">Natürlich können wir auch verschiedene Klassen-Templates schreiben. Schauen wir uns dieses Codebeispiel an:<br></div><div class="pre">template&lt;int...&gt;<br>struct add;<br><br>template&lt;&gt;<br>struct add&lt;&gt;<br>{<br>&nbsp; static constexpr int value = 0;<br>};<br><br>template&lt;int i, int... tail&gt;<br>struct add&lt;i, tail...&gt;<br>{<br>&nbsp; static constexpr int value = i + add&lt;tail...&gt;::value;<br>};<br><br>static_assert(6 == add&lt;1, 2, 3&gt;::value, "Expect 6");<br></div><div class="text">Wir haben ein variadisches Klassen-Template, das die Summe einer beliebigen Anzahl von Zahlen berechnet. In C++ Insights werden alle im Hintergrund stattfindenden Instanziierungen angezeigt, um das Ergebnis zu berechnen. Hier können wir sehen, wie jedes Mal eine Zahl erscheint, bis es keine mehr gibt:<br></div><div class="pre">template&lt;int...&gt;<br>struct add;<br><br>/* First instantiated from: insights.cpp:16 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>struct add&lt;1, 2, 3&gt;<br>{<br>&nbsp; inline static constexpr const int value = 1 + add&lt;2, 3&gt;::value;<br>&nbsp; <br>};<br>#endif<br><br><br>/* First instantiated from: insights.cpp:13 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>struct add&lt;2, 3&gt;<br>{<br>&nbsp; inline static constexpr const int value = 2 + add&lt;3&gt;::value;<br>&nbsp; <br>};<br>#endif<br><br><br>/* First instantiated from: insights.cpp:13 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>struct add&lt;3&gt;<br>{<br>&nbsp; inline static constexpr const int value = 3 + add&lt;&gt;::value;<br>&nbsp; <br>};<br>#endif<br><br><br>template&lt;&gt;<br>struct add&lt;&gt;<br>{<br>&nbsp; static constexpr int value = 0;<br>};<br><br>template&lt;int i, int... tail&gt;<br>struct add&lt;i, tail...&gt;<br>{<br>&nbsp; static constexpr int value = i + add&lt;tail...&gt;::value;<br>};<br><br>/* PASSED: static_assert(6 == add&lt;1, 2, 3&gt;::value, "Expect 6"); */<br></div><div class="ztitel">Referenz auf ein Array<br></div><div class="text">Eine weitere Sache von Templates ist, dass sie eine Referenz auf ein Array aufnehmen können. Das verhindert, dass ein Array zu einem Zeiger zerfällt:<br></div><div class="pre">template&lt;typename T, int N&gt;<br>void Rx(T (&amp;data)[N])<br>{<br>&nbsp; // assuming char here<br>&nbsp; static_assert(sizeof(data) == 5);<br>}<br><br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; char buffer[5]{};<br><br>&nbsp;&nbsp;&nbsp; Rx(buffer);<br>}<br></div><div class="text">In C ++ Insights können wir sehen, dass die Instantiierung den Typ sowie die Größe des Arrays <a href="https://cppinsights.io/lnk?code=dGVtcGxhdGU8dHlwZW5hbWUgVCwgaW50IE4+CnZvaWQgUngoVCAoJmRhdGEpW05dKQp7CiAgLy8gYXNzdW1pbmcgY2hhciBoZXJlCiAgc3RhdGljX2Fzc2VydChzaXplb2YoZGF0YSkgPT0gNSk7Cn0KCmludCBtYWluKCkKewogICAgY2hhciBidWZmZXJbNV17fTsKCiAgICBSeChidWZmZXIpOwp9&amp;std=cpp17&amp;rev=1.0" title="Link auf https://cppinsights.io/lnk?code=dGVtcGxhdGU8dHlwZW5hbWUgVCwgaW50IE4+CnZvaWQgUngoVCAoJmRhdGEpW05dKQp7CiAgLy8gYXNzdW1pbmcgY2hhciBoZXJlCiAgc3RhdGljX2Fzc2VydChzaXplb2YoZGF0YSkgPT0gNSk7Cn0KCmludCBtYWluKCkKewogICAgY2hhciBidWZmZXJbNV17fTsKCiAgICBSeChidWZmZXIpOwp9&amp;std=cpp17&amp;rev=1.0" alt="%7B%22text%22%3A%22enth%C3%A4lt%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3DdGVtcGxhdGU8dHlwZW5hbWUgVCwgaW50IE4%2BCnZvaWQgUngoVCAoJmRhdGEpW05dKQp7CiAgLy8gYXNzdW1pbmcgY2hhciBoZXJlCiAgc3RhdGljX2Fzc2VydChzaXplb2YoZGF0YSkgPT0gNSk7Cn0KCmludCBtYWluKCkKewogICAgY2hhciBidWZmZXJbNV17fTsKCiAgICBSeChidWZmZXIpOwp9%26amp%3Bstd%3Dcpp17%26amp%3Brev%3D1.0%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fcppinsights.io%2Flnk%3Fcode%3DdGVtcGxhdGU8dHlwZW5hbWUgVCwgaW50IE4%2BCnZvaWQgUngoVCAoJmRhdGEpW05dKQp7CiAgLy8gYXNzdW1pbmcgY2hhciBoZXJlCiAgc3RhdGljX2Fzc2VydChzaXplb2YoZGF0YSkgPT0gNSk7Cn0KCmludCBtYWluKCkKewogICAgY2hhciBidWZmZXJbNV17fTsKCiAgICBSeChidWZmZXIpOwp9%26amp%3Bstd%3Dcpp17%26amp%3Brev%3D1.0%22%7D">enthält</a>:<br></div><div class="pre">template&lt;typename T, int N&gt;<br>void Rx(T (&amp;data)[N])<br>{<br>&nbsp; // assuming char here<br>&nbsp; static_assert(sizeof(data) == 5);<br>}<br><br>/* First instantiated from: insights.cpp:12 */<br>#ifdef INSIGHTS_USE_TEMPLATE<br>template&lt;&gt;<br>void Rx&lt;char, 5&gt;(char (&amp;data)[5])<br>{<br>&nbsp; /* PASSED: static_assert(sizeof(data) == 5); */<br>}<br>#endif<br><br><br>int main()<br>{<br>&nbsp; char buffer[5] = {'\0', '\0', '\0', '\0', '\0'};<br>&nbsp; Rx(buffer);<br>}<br></div><div class="text">Abgesehen von Templates, die wir in diesem Beispiel sehen können, sehen wir auch den Effekt der braced-Initialisierung von <i>buffer</i>. Der Compiler füllt alle Elemente des Arrays für uns mit dem Standardwert. Auf diese Weise können wir uns vom guten, alten <i>memset</i> verabschieden und unsere Programme schneller und sicherer machen.<br></div><div class="text">Ich hoffe, ich konnte zeigen, wie C++ Insights hilfreich sein kann, wenn es um Templates geht. Für mich ist es ein wichtiges Instrument, wenn es um das Lehren und Erklären von Templates geht, insbesondere von variadischen Vorlagen.<br></div><div class="text">Viel Spaß mit C++ Insights. Wer möchte, kann das Projekt unterstützen, entweder als <a href="https://www.patreon.com/cppinsights" alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Patreon%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.patreon.com%2Fcppinsights%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.patreon.com%2Fcppinsights%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%7D" title="Link auf https://www.patreon.com/cppinsights">Patreon</a> oder natürlich auch mit <a alt="%7B%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fgithub.com%2Fandreasfertig%2Fcppinsights%22%2C%22ir_link%22%3A1%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fgithub.com%2Fandreasfertig%2Fcppinsights%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Code-Beitr%C3%A4gen%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" title="Link auf https://github.com/andreasfertig/cppinsights" href="https://github.com/andreasfertig/cppinsights">Code-Beiträgen</a>.</div><div class="text">Demnächst mehr zu C++ Insights ...&nbsp; Der nächste Artikel beschäftigt sich mit Lambdas.<br></div>
