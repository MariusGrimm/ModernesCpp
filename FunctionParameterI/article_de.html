<div class="text">Es gibt viele Möglichkeiten, Funktionsparameter zu übergeben. Du kannst sie kopieren oder als Referenz übergeben. Diese Referenz kann konstant oder nicht-konstant sein. Du kannst deine Parameter sogar verschieben oder forward darauf anwenden. Deine Entscheidung sollte davon abhängig sein, ob der Parameter ein <b>in, out, in-out, consume</b> oder <b>forward </b>Funktionsparameter ist. Neugierig? Los gehts!</div>
<div class="ztitel">Hier sind alle Regeln für die Übergabe von Ausdrücken:</div>
<div class="text"><ul><li>F.15: Prefer simple and conventional ways of passing information<br></li><li>F.16: For “in” parameters, pass cheaply-copied types by value and others by reference to const<br></li><li>F.17: For “in-out” parameters, pass by reference to non-const<br></li><li>F.18: For “consume” parameters, pass by X&amp;&amp; and std::move the parameter<br></li><li>F.19: For “forward” parameters, pass by TP&amp;&amp; and only std::forward the parameter<br></li><li>F.20: For “out” output values, prefer return values to output parameters<br></li><li>F.21: To return multiple “out” values, prefer returning a tuple or struct<br></li><li>F.60: Prefer T* over T&amp; when “no argument” is a valid option</li></ul></div>
<div class="text">Das schaut nach viel Regelwerk aus. Es ist aber bei weitem nicht so schlimm. Die erste Regel F.15 fasst die Regeln F.16 - F.21 zusammen.</div>
<div class="ztitel_kleiner">F.15: Prefer simple and conventional ways of passing information</div>
<div class="text">Hier kommt das große Bild von den C++ Core Guidelines. Dies sind die Standard Regeln für die Übergabe von Parametern.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_138683676_459be7143c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Basierend auf diesen Standard Regeln gibt es ein paar Ergänzungen in grün. Diese werden "advanced parameter passing rules" genannt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_138683676_459be7143c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Die Begründung für diese Regeln and deren Variationen folgt in den nächsten Regeln.<br></div>
<div class="ztitel_kleiner">F.16: For “in” parameters, pass cheaply-copied types by value and others byreference to const</div>
<div class="text">Die Regeln für <b>in </b>Parameter sind leicht eingänglich. </div>
<div class="pre">void f1(const string&amp; s);&nbsp; // OK: pass by reference to const; always cheap<br><br>void f2(string s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bad: potentially expensive<br><br>void f3(int x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK: Unbeatable<br><br>void f4(const int&amp; x);&nbsp;&nbsp;&nbsp;&nbsp; // bad: overhead on access in f4()</div>
<div class="text">In meinen Schulungen taucht immer wieder die Frage auf: Was bedeutet billig zu kopieren? In diesem Punkt sind die Guidelines sehr konkret:</div>
<div class="text"><ul><li>Du sollst deinen Parameter p nicht kopieren, falls <b><i>sizeof(p) &gt; 4 * sizeof(int) </i></b>gilt.<br></li><li>Du sollst eine konstante Referenz auf p verwenden, falls <b><i>sizeof(p) &lt; 3 * sizeof(int)</i></b> gilt.</li></ul></div>
<div class="text">Ich nehme an, dass diese Zahlen auf Erfahrung basieren.<br></div>
<div class="ztitel_kleiner">F.17: For “in-out” parameters, pass by reference to non-const</div>
<div class="text"><b>In-out </b>Parameter werden in der Funktion verändert. Daher sollten sie als nicht-konstante Referenz übergeben werden.</div>
<div class="pre">void appendElements(std::vector&lt;int&gt;&amp; vec){<br>&nbsp; // append elements to vec<br>&nbsp; ...<br>}</div>
<div class="ztitel_kleiner">F.18: For “consume” parameters, pass by X&amp;&amp; and std::move the parameter</div>
<div class="text">Dies ist die erst fortgeschrittene (advanced) Regel um Parameter zu konsumieren (<b>consume</b>). Verwende eine Rvalue Referenz, falls du den Parameter konsumiert und im Funktionskörper verschiebst (move). Hier kommst schon das Beispiel:<br></div>
<div class="pre">// sink takes ownership of whatever the argument owned<br>void sink(vector&lt;int&gt;&amp;&amp; v) { <br>&nbsp;&nbsp;&nbsp; // usually there might be const accesses of v here<br>&nbsp;&nbsp;&nbsp; store_somewhere(std::move(v));<br>&nbsp;&nbsp;&nbsp; // usually no more use of v here; it is moved-from<br>}<br><br></div>
<div class="text">Es gibt aber eine Ausnahme dieser Regel. <i>std::unique_ptr </i>ist ein Datentyp, der sich nur verschieben, aber nicht kopieren lässt. Du kannst ihn verschieben, da diese Operation sehr billig ist. </div>
<div class="pre">void sink(std::unique_ptr&lt;int&gt; p) { <br>&nbsp; ...&nbsp;&nbsp;&nbsp; <br>}<br>...<br>sink(std::move(uniqPtr));<br></div>
<div class="ztitel_kleiner">F.19: For “forward” parameters, pass by TP&amp;&amp; and only std::forward the parameter</div>
<div class="text">Dies ist ein bekanntes Idiom in C++, dass Fabrikfunktionen zum Erzeugen von Smart Pointern wie <i>std::make_unique</i> oder <i>std::make_shared </i>anwenden. Beide Funktionen nehmen einen Datentyp <i>T </i>und Argumente <i>args </i>an und reichen diese identisch weiter (<b>forward</b>). Das Beispiel zeigt eine mögliche Implementierung von <i>std::make_unique.</i></div>
<div class="pre">template&lt;typename T, typename... Args&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1<br>std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2<br>{<br>&nbsp;&nbsp;&nbsp; return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...)); // 3<br>}</div>
<div class="text">Dies Muster wird Perfect Forwarding genannt: Ein Funktions-Template wendet Perfect Forwarding an, falls es seine Parameter unverändert weiterreicht.<br></div>
<div class="text">Hier geht es direkt zu meinem Artikel über <a alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fperfect-forwarding%22%2C%22text%22%3A%22Perfect%20Forwarding.%22%2C%22type%22%3A%22E%22%7D" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/perfect-forwarding" href="http://www.grimm-jaud.de/index.php/blog/perfect-forwarding">Perfect Forwarding.</a></div>
<div class="text">Um Perfect Forwarding für ein Funktions-Template einzusetzen, gilt es ein dreiteiliges Rezept anzuwenden. Dazu werden, wie bei <i>std::make_unique</i>. keine Variadic Templates (<i> ... </i>) benötigt. Aus diesem Grund verzichte ich darauf. </div>
<div class="text"><ol><li> Du benötigst einen Template-Parameter: <i>typename Args</i></li><li>Nimm dein Funktions-Argument als perfect forwarding Referenz an: <i>Args&amp;&amp; args</i></li><li>Reiche das Funktions-Argument unverändert durch: <i>std::forward&lt;Args&gt;(args)</i><br></li></ol></div>
<div class="ztitel_kleiner">F.20: For “out” output values, prefer return values to output parameters</div>
<div class="text">Ein expliziter Returnwert dokumentiert die Absicht einer Funktion. Dagegen ist ein Parameter mit einer Referenz, der als Rückgabewert (<b>out</b>) verwendet wird, leicht zu missbrauchen. Dieser Rückgabewert kann auch als in-out Wert verstanden werden. Eine Funktion soll ihr Ergebnis per Copy zurückgeben. Diese Regel gilt selbst für die Container der Standard Template Library, die unter der Decke Move Semantik einsetzen. </div>
<div class="pre">// OK: return pointers to elements with the value x<br>vector&lt;const int*&gt; find_all(const vector&lt;int&gt;&amp;, int x);<br><br>// Bad: place pointers to elements with value x in-out<br>void find_all(const vector&lt;int&gt;&amp;, vector&lt;const int*&gt;&amp; out, int x);</div>
<div class="text">Keine Regel ohne Ausnahme. Falls du ein Objekt zurückgeben willst, das teuer zu verschieben ist, kannst du eine Referenz als Rückgabewert (out) verwenden.</div>
<div class="pre">struct Package {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exceptional case: expensive-to-move object<br>&nbsp;&nbsp;&nbsp; char header[16];<br>&nbsp;&nbsp;&nbsp; char load[2024 - 16];<br>};<br><br>Package fill();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bad: large return value<br>void fill(Package&amp;);&nbsp; // OK<br></div>
<div class="ztitel_kleiner">F.21: To return multiple “out” values, prefer returning a tuple or struct</div>
<div class="text">Ab und zu gibt eine Funktion mehr als einen Wert (out) zurück. In diesem Fall solltest du ein <i>std::tuple</i> oder ein <i>struct </i>verwenden, aber keinen Parameter mit einer Referenz. Das ist sehr fehleranfällig.</div>
<div class="pre">// BAD: output-only parameter documented in a comment<br>int f(const string&amp; input, /*output only*/ string&amp; output_data)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; output_data = something();<br>&nbsp;&nbsp;&nbsp; return status;<br>}<br><br>// GOOD: self-documenting<br>tuple&lt;int, string&gt; f(const string&amp; input)<br>{<br>&nbsp;&nbsp;&nbsp; // ...<br>&nbsp;&nbsp;&nbsp; return make_tuple(status, something());<br>}</div>
<div class="text">Dank <a href="http://www.grimm-jaud.de/index.php/blog/c-17-kern" class="" title="Link auf http://www.grimm-jaud.de/index.php/blog/c-17-kern" alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-kern%22%2C%22text%22%3A%22structured%20binding%22%2C%22type%22%3A%22E%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fc-17-kern%22%7D">structured binding</a> kann in C++17 eine Funktion sehr elegant mehrere Werte zurückgeben.</div>
<div class="pre">auto [value, success] = getValue(key);<br><br>if (success){<br>&nbsp; // do something with the value;<br></div>
<div class="text">Die Funktion <i>getValue </i>gibt ein Paar zurück. <i>success </i>zeigt an, dass die Abfrage erfolgreich war.</div>
<div class="text">Die nächste Regel ist speziell. Für mich ist es eher eine semantische Regel. <br></div>
<div class="ztitel_kleiner">F.60: Prefer T* over T&amp; when “no argument” is a valid option</div>
<div class="text">Falls dein Parameter niemals ein Nicht-Argument&nbsp; wie <i>nullptr</i> annehmen kann, solltest du eine Referenz <i>T&amp;</i> verwenden. <i>T&amp;</i> kann keinen nullptr annehmen. Falls ein <i>nullptr</i> zulässig ist, verwende<i> T*</i>. </div>
<div class="pre">std::string upperString(std::string* str){<br>&nbsp; if (str == nullptr) return std::string{};&nbsp; // check for nullptr<br>&nbsp; else{<br>&nbsp;&nbsp;&nbsp; ...<br>}</div>
<div class="text">Falls eine Nicht-Argument eine Option ist, musst du dies natürlich prüfen.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In diesem Artikel ging es um in, out, in-out, consume und forward Parameter. Das sind aber nicht alle Fragen, die es zu beantworten gilt. Wie sollst du mit Sequenzen oder Besitzverältnissen umgehen. Genau darauf werde ich im nächsten Artikel eingehen.<br></div>
