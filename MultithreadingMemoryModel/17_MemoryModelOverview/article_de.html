<p>Seit dem C++11-Standard besitzt C++ ein Speichermodell. Dieses Speichermodell ist die elementare Grundlage dafür, das C++ Programme in Multithreading Umgebungen ein definiertes Verhalten haben.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<p>Das C++-Speichermodell kennt zwei Aspekte für den Programmierer. Auf der einen Seite steht die Pflicht, sich mit der hohen Komplexität des Speichermodells, das oft der Intuition widerspricht, auseinanderzusetzen, auf der anderen Seite steht die Kür, einen viel tieferen Einblick in die Komplexität von Multithreading Programmen zu erreichen.</p>
<h2>Der Vertrag</h2>
<p>In der ersten Annäherung beschreibt das C++-Speichermodell&nbsp;einen Vertrag. Dieser Vertrag besteht&nbsp;zwischem dem Programmierer und dem <a href="index.php?option=com_content&amp;view=article&amp;id=82:das-c-speichermodell&amp;catid=35:c&amp;Itemid=101#System">System</a>.&nbsp;Zum einen fordert der Vertrag von dem Programmierer, bestimmte Regeln genau einzuhalten, zum anderen bietet es dem System alle Freiheiten,&nbsp;solange das System die Regeln einhält. Als Ergebnis resultiert im Idealfall ein definiertes ausführbares Programm, das im Rahmen der Regeln maximal optimiert ist. Genau genommen ist es kein einziger Vertrag, sondern eine sehr feingranular anpassbare Abstufung von Verträgen. Das heißt, je lockerer die Regeln sind, die der Programmierer einzuhalten hat, desto mehr Möglichkeiten besitzt das System, optimierte ausführbare Programme zu erzeugen.&nbsp;</p>
<p>Der Faustregel ist ganz einfach. Je strenger der Vertrag ist, desto weniger Freiheiten hat das System, optimierte ausführbare Dateien zu erzeugen. Der Umkehrschluß geht leider nach hinten los. Eine sehr lockere Abstufung des Vertrages oder des C++-Speichermodells zu wählen, besitzt zwar hohes Optimierungspotential.&nbsp;Leider sind solche Programme nur noch von wenigen ausgewiesenen Experten zu zügeln.</p>
<p>Die Graphik stellt die Abstufungen des Vertrages dar.&nbsp;Auch wenn diese starke Vereinfachung hinkt, schärft sie&nbsp;den Blick fürs Wesentliche.</p>
<dl><dt><img src="images/blog/Speichermodell/Speichermodell/SpeichermodellStrongToWeak.png" alt="SpeichermodellStrongToWeak" /></dt></dl>
<p>Es gibt drei Abstufungen des Vertrags in C++11.</p>
<p>Bis zum C++11-Standard gab es nur einen Vertrag. C++ war sich der Existenz von Multithreading Progammen oder atomaren Variablen nicht bewußt. Das System kannte nur einen Kontrollfluß und besaß damit auch relativ wenig Freiheiten, das ausführbare Programm zu optimieren. Im Wesentlichen musste das System für den Programmierer die Illusion aufrechterhalten, dass das beobachte Programmverhalten der Reihenfolge der Sourcecodebefehle entsprach. Natürlich gab es zu diesem Zeitpunkt noch kein Speichermodell. C++ kannte <a href="index.php?option=com_content&amp;view=article&amp;id=82:das-c-speichermodell&amp;catid=35:c&amp;Itemid=101#SequencePoint">Sequence Points</a>. Sequence Points sind Positionen im Programm, an denen alle Aktion davor sichtbar sein müssen. Der Beginn der Ausführung einer Funktion oder deren Verlassen sind klassische Sequence Points. Wird hingegen eine Funktion mit zwei Argumenten<span style="font-family: courier new,courier;"> add(a++,a)</span> aufgerufen, ist es nicht im C++ Standard spezifiziert, welches Argument als erstes ausgewertet wird. Daher ist das Verhalten undefiniert. Der Grund ist ganz einfach, das Kommazeichen ist kein Sequence Point. Das ändert sich auch nicht mit C++11.</p>
<p>Mit C++11 ändert sich alles. C++11 ist sich zum ersten Mal der Existenz mehrerer Threads bewußt. Die Grundlage des definierten Verhaltens mehrerer Threads ist das C++-Speichermodell. Dies ist an das Java-Speichermodell angelehnt, geht aber in typischer C++-Manier noch ein paar Schritte weiter. Dazu mehr in den nächsten Artikeln. Nun gilt es für den Programmierer einige Regeln im Umgang mit geteilten Variablen zu beachten, damit das Programmverhalten definiert ist. Undefiniert ist das Programmverhalten, wenn es zumindestens einen<a href="index.php?option=com_content&amp;view=article&amp;id=70:threads-teilen-daten&amp;catid=35:c&amp;Itemid=101#KritischerWettlauf"> kritischen Wettlauf</a> besitzt. Kritische Wettlauf laueren gerne dann, wenn <a href="index.php?option=com_content&amp;view=article&amp;id=70:threads-teilen-daten&amp;catid=35:c&amp;Itemid=101">Threads Daten teilen</a>. Daher sind<a href="index.php?option=com_content&amp;view=article&amp;id=78:tasks&amp;catid=35:c&amp;Itemid=101"> Tasks </a>deutlich leichter richtig zu verwenden als <a href="index.php?option=com_content&amp;view=article&amp;id=67:threads&amp;catid=35:c&amp;Itemid=101">Threads</a> oder gar <a href="index.php?option=com_content&amp;view=article&amp;id=76:bedingungsvariablen&amp;catid=35:c&amp;Itemid=101">Bedingungsvariablen</a>.&nbsp;</p>
<p>Mit den atomaren Variablen betreten wir einen Bereich, der nur von Experten zu meistern ist. Das gilt umso mehr, je weiter das C++-Speichermodell abgeschwächt wird.&nbsp;Gerne wird der Umgang mit atomaren Variablen als auch <a href="index.php?option=com_content&amp;view=article&amp;id=82:das-c-speichermodell&amp;catid=35:c&amp;Itemid=101#LockfreieProgrammierung">lockfreie Programmierung</a> bezeichnet. Ich habe im Laufe des Artikels habe ich gerne von lockeren und strengen Regeln gesprochen.&nbsp;Tatsächlich wird die Sequenzielle Konsistenz als Strong Memory Model, die Relaxed Semanik als&nbsp; Weak Memory Model bezeichnet.&nbsp;</p>
<h2>Der Vertragsinhalt</h2>
<p>Der Vertrag zwischen dem Programmierer und dem System setzt sich aus drei Komponenten zusammen.</p>
<ul>
<li>Atomare Operationen: Operationen, die eine Anwendung ohne Unterbrechung ausgeführt muss</li>
<li>Partielle Ordnung von Operationen: Reihenfolge von Operationen, die nicht umsortiert werden können</li>
<li>Speichersichtbarkeit: Zusicherung, ab oder bis wann Operationen auf gemeinsam genutzen Variablen für einen anderen Thread sichtbar sind</li>
</ul>
<p>Grundlage des Vertrages oder auch der C++-Speichermodells sind atomare Datentypen. Diese zeichnen sich durch zwei Eigenschafen aus. Zum einen sind sie - wie unschwer zu erraten - atomar, zum anderen setzen sie Synchronisations- und Ordnungsbedingungen an die Programmausführung. Dies Synchronisations- und Ordungsbedingungen geltern&nbsp;auch für nichtatomare Datentypen. Während ein atomarer Datentyp immer atomar bleibt, erlaubt das C++-Speichermodell, die Synchronisations- und Ordnungsbedingungen feingranular anzupassen.</p>
<h2>Wie geht's weiter?</h2>
<p>In den nächsten Artikeln werde ich deutlich weiter in die Untiefen des C++-Speichermodells abtauchen. Das heißt insbesondere, dass die nächsten Artikel die lockfreien Programmierung zum Thema haben. Auf meiner Tour werde ich atomare Datentypen und Operationen auf ihnen vorstellen. Sind diese Grundlagen gelegt geht, gehe ich weiter auf die verschiedenen Abstufungen des C++-Speichermodells ein. Starten werde ich mit der relativ intuitiven sequenziellen Konsistenz, fortfahren mit der schon deutlich anspruchsvolleren Acquire-Release Semantik und enden mit der sehr unintuitiven Relaxed-Semanik. Los geht es im nächsten Artikel mit der <a href="index.php/blog/sequenzielle-konsistenz">Sequenzielle Konsistenz.</a> Die sequenzielle Konsistenz stellt das Standardverhalten für atomare Datentypen dar.</p>
<h2>Hintergrundinformation</h2>
<dl><dt><a id="System">System</a></dt><dd>&nbsp;&nbsp;&nbsp; Vereinfachend gesprochen, verstehe ich unter dem System die drei Komponenten Compiler, Prozessor und die diversen Speicherhierachien. Der Compiler übersetzt das Programm in Assembleranweisungen, der Prozessor führt die aus und die diversen Speicherhierachien repräsentieren den Zustand des ausgeführten Progamms.</dd><dt><a id="SequencePoint">sequence point</a></dt><dd>&nbsp;&nbsp;&nbsp; Die Details zu sequence points lassen sich auf&nbsp;<a href="https://en.wikipedia.org/wiki/Sequence_point">Wikipedia </a>nachlesen.</dd><dt><a id="LockfreieProgrammierung">Lockfreie Programmierung</a></dt><dd>&nbsp;&nbsp;&nbsp; Umgangssprachlich wird lockfreies Programmierung als Programmieren ohne Mutexe bezeichnet. Diese Definition ist aber zu eng gefasst. Ein Codeabschnitt ist lockfrei, wenn sich keine Prozesse bzw. Threads gegenseitig blockieren können.</dd><dt>C++-Speichermodell</dt><dd>&nbsp;&nbsp;&nbsp; Ein<em> relativ einfachen</em> Einstieg in das Speichermodell bietet der Artikel<a href="index.php/modernes-c-in-der-praxis-linux-magazin-a"> Der Vertrag</a> 06/2014.</dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd></dd><dd>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>{tooltip} <img src="images/books/title_page_small.png" alt="title page small" width="166" height="212" />{end-texte}<img src="images/books/title_page_small.png" alt="title page small" style="margin: 3px;" /> Go to <a href="https://leanpub.com/cpplibrary"> </a><a href="https://leanpub.com/cpplibrary">Leanpub/cpplibrary</a> <a href="https://leanpub.com/cpplibrary"> </a><strong>"What every professional C++ programmer should know about the C++ standard library".</strong> <a href="https://leanpub.com/cpplibrary"></a>{end-tooltip} &nbsp; <strong><span class="h3">Hole dir dein E-Book. Unterstütze meinen Blog.</span></strong></p>
</dd></dl>
