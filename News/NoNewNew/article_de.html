<div class="vorspann">Vor zwei Wochen fand das ISO-C++-Standardisierungsmeeting in Jacksonville statt. Daher will ich heute einen kleinen Ausflug machen und über eine revolutionäre Entscheidung schreiben, die dort getroffen wurde. Zusätzlich beziehe ich mich auf den englischsprachigen Artikel "<a title="Link auf https://www.fluentcpp.com/2018/04/01/cpp-will-no-longer-have-pointers/" href="https://www.fluentcpp.com/2018/04/01/cpp-will-no-longer-have-pointers/" class="" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.fluentcpp.com%2F2018%2F04%2F01%2Fcpp-will-no-longer-have-pointers%2F%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22C%2B%2B%20will%20no%20Longer%20have%20Pointers%22%2C%22href%22%3A%22https%3A%2F%2Fwww.fluentcpp.com%2F2018%2F04%2F01%2Fcpp-will-no-longer-have-pointers%2F%22%7D">C++ will no Longer have Pointers</a>" (Fluent C++). Das Standardisierungskomitee entschied, dass Zeiger mit C++20 deprecated und mit C++23 mit hoher Wahrscheinlichkeit entfernt werden. </div>
<div class="text">Das, was sich wie ein Revolution anfühlt, ist tatsächlich nur der letzte Schritt in einer langen Evolution. Daher beschreibe ich erst einmal das große Bild:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150943545_9325408a6d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">Die Evolution von Zeigern in C++</div>
<div class="text">Zeiger gibt es von Anfang an in C++. Das ist ein Erbe von C. Von Anfang an gab es auch den Versuch in C++, den Umgang von Zeigern ohne zusätzliche Kosten typsicherer zu machen.</div>
<div class="text">Mit C++98 erhielten wir mit <i>std::auto_ptr </i>den ersten Smart Pointer. Mit diesem ließen sich exklusive Besitzverhältnisse ausdrücken. Aber <i>std::auto_ptr</i> besaß einen großen Nachteil. Wurde ein <i>std::auto_ptr </i>kopiert, wurde seine Ressource heimlich verschoben. Was sich wie eine Copy-Operation anfühlte, war unter der Decke eine Move-Operation. Die Grafik zeigt das überraschende Verhalten des <i>std::auto_ptr.</i></div>
<div class="text"><i><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150943548_d8112a6dfb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></i></div>
<div class="text">Dieses Verhalten war sehr bösartig und der Grund für viele ernsthafte Bugs. Daher wurde C++11 um <i>std::unique_ptr </i>erweitert und <i>std::auto_ptr</i> in C++11 auf deprecated gesetzt und in C++17 entfernt. Zusätzlich erhielt C++11 mit dem <i>std::shared_ptr </i>und dem <i>std::weak_ptr </i>zwei Smart Pointer für geteilte Besitzverhältnisse. Ein <i>std::unique_ptr</i> kann nicht kopiert, aber verschoben werden. Falls du hingegen einen <i>std::shared_ptr</i> kopierst oder zuweist, wird der interne Referenzzähler erhöht. Die Grafiken bringen das Verhalten beider Smart Pointer auf den Punkt. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150943557_8298c9e392.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150943559_31f3ab0a56.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Seit C++11 besitzt C++ eine Multithreading-Bibliothek. Das macht den Umgang mit <i>std::shared_ptr</i> sehr anspruchsvoll, denn der <i>std:.shared_ptr</i> ist per Definition geteilt und nicht thread-sicher. Lediglich der Zugriff auf den Kontrollblock ist thread-sicher, aber nicht der Umgang mit seiner zugrunde liegenden Ressource. Das bedeutet, er bietet die Garantie, dass das Verändern des Referenzzählers eine atomare Operation ist und dass die Ressource genau einmal gelöscht wird. Dies ist der Grund, warum wir mit C++20 atomare Smart Pointer erhalten: <i>std::atomic_shared_ptr </i>und <i>std::atomic_weak_ptr.</i> Die Details dazu gibt es im Proposal: <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf" alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4162.pdf%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2014%2Fn4162.pdf%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Atomic%20Smart%20Pointers%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf" class="">Atomic Smart Pointers</a>.</div>
<div class="text">Nun aber zum deutlich interessanteren Punkt der neuen C++20- und C++23-Standards. Zeiger werden in C++20 als deprecated erklärt und in C++23 entfernt. Um es in drei Worten zu sagen: <b>N</b>o <b>N</b>ew <b>N</b>ew (NNN).</div>
<div class="ztitel_kleiner">Die Rettung ist std::unique_ptr<br></div>
<div class="text">Aber halt. Wir haben einen Glaubenssatz in C++: Zahle nicht für etwas, das du nicht benutzt. Wie können wir daher auf Zeiger verzichten? Verwende einfach einen <i>std::unique_ptr</i>. Er ist per Design so schnell und so leichtgewichtig wie ein nackter Zeiger und besitzt einen großen Vorteil: Er passt automatisch auf seine Ressource auf.</div>
<div class="text">Nur als Erinnerungsstütze. Hier ist ein kleiner Performanztest.</div>
<div class="pre">#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>static const long long numInt= 100000000;<br><br>int main(){<br><br>&nbsp; auto start = std::chrono::system_clock::now();<br><br>&nbsp; for ( long long i=0 ; i &lt; numInt; ++i){<br>&nbsp;&nbsp;&nbsp; int* tmp(new int(i));<br>&nbsp;&nbsp;&nbsp; delete tmp;<br>&nbsp;&nbsp;&nbsp; // std::shared_ptr&lt;int&gt; tmp(new int(i));<br>&nbsp;&nbsp;&nbsp; // std::shared_ptr&lt;int&gt; tmp(std::make_shared&lt;int&gt;(i));<br>&nbsp;&nbsp;&nbsp; // std::unique_ptr&lt;int&gt; tmp(new int(i)); <br>&nbsp;&nbsp;&nbsp; // std::unique_ptr&lt;int&gt; tmp(std::make_unique&lt;int&gt;(i)); <br>&nbsp; }<br><br>&nbsp; std::chrono::duration&lt;double&gt; dur= std::chrono::system_clock::now() - start;<br>&nbsp; std::cout &lt;&lt; "time: " &lt;&lt; dur.count() &lt;&lt; " seconds" &lt;&lt; std::endl;<br><br>}<br></div>
<div class="text">Das Programm fordert und gibt 100.000.000 ints dynamisch an. Dazu kommen nackte Zeiger und die Smart Pointer <i>std::shared_ptr</i> und <i>std::unique_ptr</i> in zwei Variationen zum Einsatz. Ich übersetzte dann noch das Programm auf Windows und Linux mit maximaler beziehungsweise ohne Optimierung und führe es aus. Hier sind die überzeugenden Zahlen:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_150943570_6942a1d9db.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Die Zahlen zeigen es schwarz auf blau. Die zwei Variationen des <i>std::unique_ptr</i> sind auf Linux und Windows so schnell wie nackte Zeiger. Die Details zu den Zahlen gibt es auf meinem Artikel "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22Speicher%20und%20Performanz%20Overhead%20von%20Smart%20Pointern%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fspeicher-performanz-overhead-von-smart-pointern%22%7D" href="https://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern" class="">Speicher und Performanz Overhead von Smart Pointern</a>".</div>
<div class="ztitel">Art von Besitzverhältnissen<br></div>
<div class="text">Ehrlich gesagt verwenden wir Zeiger und insbesondere nackte Zeiger viel zu häufig. Die Frage, ob du einen Zeiger verwenden solltest, lässt sich auf eine einfache Frage reduzieren: Wer ist der Besitzer? Glücklicherweise können wir mit modernem C++ unsere Besitzverhältnisse direkt im Sourcecode ausdrücken. </div>
<div class="text"><ul><li> <b>Lokale Objekte</b>: Die C++-Laufzeit als Besitzer verwaltet automatisch den Lebenszyklus seiner Ressourcen. Dasselbe gilt für globale Objekte oder Mitglieder einer Klasse. Die Guidelines nennen diese lokalen Objekte scoped objects.</li><li><b>Referenzen</b>: Ich bin nicht der Besitzer. Ich habe mir die Ressource, die nicht null sein kann, nur ausgeliehen.</li><li><b>Nackte Zeiger</b>: Ich bin nicht der Besitzer. Ich habe mir die Ressource nur ausgeliehen. Ich darf die Ressource nicht freigeben.</li><li><b>std::unique_ptr</b>: Ich bin der exklusive Besitzer der Ressource. Ich darf die Ressource freigeben.</li><li><b>std::shared_ptr</b>: Ich teile mir die Ressource mit anderen Besitzern. Ich darf meine Besitzverhältnisse explizit freigeben.</li><li><b>std::weak_ptr</b>: Ich bin nicht der Besitzer der Ressource, aber ich kann zeitweise zum geteilten Besitzer werden, indem ich die Methode <i>std::weak_ptr::lock </i>verwende.</li></ul></div>
<div class="text">Daher müssen wir unsere Art zu programmieren nur in einem von sechs Anwendungsfällen ändern, und wir sind bereits auf der nächsten Evolutionsstufe von C++. </div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Sorry für diesen Ausflug von meinem ursprünglichen Plan, mich mit den C++ Core Guidelines zu befassen, aber die Entscheidung in Jacksonville ist einfach zu wichtig. Mein nächster Artikel wird sich wieder mit den Guidelines beschäftigen. Die verbleibenden Regeln zur Performanz stehen an. </div>
<div class="ztitel">Weitere Informationen</div>
<div class="text">Die Entscheidung zum nächsten PDF-Päckchen ist gefallen. Ungefähr eine Woche werde ich benötigen, um beide PDF-Päckchen zu veröffentlichen. Zuerst muss ich sie allerdings noch überarbeiten.</div>
<div class="text"><ul><li>Deutsch: <a title="Link auf https://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-3" alt="%7B%22custom%22%3A%7B%7D%2C%22text%22%3A%22Charakteristiken%20der%20funktionalen%20Programmierung%22%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-3%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fwelches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-3%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D" class="" href="https://www.grimm-jaud.de/index.php/blog/welches-pdf-paeckchen-soll-ich-zusammenstellen-mache-dein-kreuz-3">Charakteristiken der funktionalen Programmierung</a> </li><li>Englisch: <a alt="%7B%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice-2%22%2C%22version%22%3A1%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fwhich-pdf-bundle-should-i-provide-make-your-choice-2%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Functional%20Features%20in%20C%2B%2B%22%2C%22type%22%3A%22E%22%7D" class="" href="http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice-2" title="Link auf http://www.modernescpp.com/index.php/which-pdf-bundle-should-i-provide-make-your-choice-2">Functional Features in C++</a></li></ul></div>
