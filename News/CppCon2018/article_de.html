<div class="vorspann">Dieses Jahr war ich das erste Mal auf der CppCon in Bellevue (Seattle). Hier sind meine Eindrücke.</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159702412_6326ae12a1.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="ztitel">2 Tages Workshops</div>
<div class="text">Ich hielt einen der 2-Tages-Workshops, die vor der Konferenz stattgefunden haben. Andere Workshops wurden unter anderem von Nicolai Josuttis, Alexandrei Alexandrescu und Scott Meyers gehalten. Mein Workshop "Concurrency with Modern C++" wurde sehr gut angenommen, sodass ich mehr als 30 Teilnehmer hatte. Am ersten Tag ging es um die Grundlagen wie Threads, Tasks, Locks und Bedingungsvariablen. Der zweite Tage war deutlich experimenteller, denn nach der Suche in die Breite stand die in die Tiefe an. Es ging um atomare Variablen und das Speichermodell. Darüber hinaus führte ich das interaktive Werkzeug <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fsvr-pes20-cppmem.cl.cam.ac.uk%2Fcppmem%2F%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22CppMem%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fsvr-pes20-cppmem.cl.cam.ac.uk%2Fcppmem%2F%22%2C%22anchor%22%3A%22%22%7D" href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/" title="Link auf http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/">CppMem</a> ein, mit dem sich lock-freier Code verifizieren lässt. Zum Abschluss ging ich noch auf die Parallele Standard Template Library ein und gab einen Ausblick auf die concurrent-Zukunft (C++20/23) von C++.</div>
<div class="text">Nun aber zur Konferenz. Dies sind die Eindrücke der Vorträge, die mich am meisten beeindruckt haben. In ein paar Wochen werden sie auf <a title="Link auf https://www.youtube.com/user/CppCon" class="" alt="%7B%22target%22%3A%22_blank%22%2C%22text%22%3A%22YouTube%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fuser%2FCppCon%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fuser%2FCppCon%22%7D" href="https://www.youtube.com/user/CppCon">YouTube</a> verfügbar sein. <br></div>
<div class="ztitel">Keynote: Concepts: The Future of Generic Programming by Bjarne Stroustrup (MD, MorganStanley)</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159702405_fe74c84505.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Bjarne präsentierte in seiner Keynote die zentralen Ideen zum Design von Concepts. Los ging es mit ein wenig Geschichte und Motivation zu Concepts. Concepts besitzen eine lange Geschichte in C++. Den stärksten Einfluss besitzt Alexander Stepanovs' Buch <a title="Link auf http://elementsofprogramming.com/book.html" href="http://elementsofprogramming.com/book.html" class="" alt="%7B%22href%22%3A%22http%3A%2F%2Felementsofprogramming.com%2Fbook.html%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Elements%20of%20Programmin%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Felementsofprogramming.com%2Fbook.html%22%2C%22type%22%3A%22E%22%7D">Elements of Programmin</a>g. Alexander Stepanov ist der Vater der Standard Template Library. </div>
<div class="text">Natürlich ging Bjarne auf die Vorteile von Concepts ein. Hier sind seine Punkte: </div>
<div class="text"><ul><li>spezifischere Fehlermeldungen</li><li>selbsterklärende Interfaces</li><li>besser lesbarer Code</li><li>zusätzliches Optimierungspotential für den Compiler</li></ul></div>
<div class="text">Concepts sind Prädikate, die zur Compilezeit ausgewertet werden. Sie sollten nicht minimale Anforderungen wie <span class="tx_code">HasAdd</span> modellieren, sondern auf Interoperabilität ausgerichtet sein. Concepts sind keine Typklassen wie in Haskell, denn sie können sowohl Typen als auch Werte annehmen. Bleibt die Frage: Wie können Concepts konkret aussehen? Sie können mathematische Ideen wie Gruppen oder Ringe oder aber konkrete Ideen wie Zahlen oder Sortable abbilden. Natürlich kannst du auch eigene Concepts oder neue Concepts auf der Grundlage bestehender Concepts definieren. </div>
<div class="text">Darüber hinaus beantwortete Bjarne die Fragen, die ihren Designprinzipien zugrunde liegen:</div>
<div class="text"><ul><li>Provide good interfaces.</li><li>Look for semantic coherence.</li><li>Don't force users to do what machines do better.</li><li>Keep simple things simple.</li></ul></div>
<div class="text">Gerne wiederhole ich mich. Dies war ein großartiger Überblick zu den zentralen Ideen von Concepts.<br></div>
<div class="ztitel">The C++ Execution Model from Bryce Adelstein Lelbach (Senior Software Engineer, NVIDIA)</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159702417_989ec33987.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Im Gegensatz zur Keynote, war Bryce' Talk sehr technisch und relativ anspruchsvoll. Bryce erklärt in seinem Vortrag Begriffe, die für das Verständnis eines single-threaded und insbesondere eines multithreaded Programms wesentlich sind. Dabei schloss er explizit die berühmt-berüchtigte Speicherordnung <span class="tx_code">std::memory_order consume</span> aus. </div>
<div class="text">Zuerst einmal gibt es die <i>as-if rule</i>. Diese besagt, dass das System (Compiler, Prozessor und Speicher) alle Optimierungen durchführen darf, die das beobachtbare Verhalten eines single-threaded Programms nicht ändern. Bryce stellte das Speichermodell als eine abstrakte Maschine vor, ging auf Threads genauer ein und definierte dabei die Begriffe <i>expression</i>, <i>evaluation</i>, <i>side-effect</i>, <i>sequenced-before</i>, <i>execution step</i> und <i>forward progress</i>. Gerne will ich tiefer auf den zentralen Begriff <i>sequenced-before</i> eingehen. Im single-threaded Programm bewirkt eine <i>sequence-before-</i>Relation eine <i>happens-before-</i>Relation. Im multithreaded Fall, wird eine <i>happens-before-</i>Relation durch eine&nbsp; <i>synchronize-with-</i>Relation etabliert. Im Wesentlichen bedeutet dies, dass ein multithreaded Programm ohne <i>happens-before-</i>Relation ein <i>data-race</i> besitzt. </div>
<div class="text">Bryce' Talk war zwar anspruchsvoll, jedoch gut verständlich für mich, da ich diese Begriffe in meinen Präsentationen oder auch Workshops zum Speichermodell verwende.</div>
<div class="ztitel">Why and How to Roll Your Own std::function Implementation by Tom Poole (Senior Software Developer, ROL)</div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159702423_3c28f1f579.png" title="<ir_inline itemname=bilder_mvp_bild_var2:6 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Um mich kurz zu halten. Toms' Präsentation war nach meinem Geschmack. Zuerst einmal war der Talk anspruchsvoll aber nicht zu anspruchsvoll. Darüber hinaus lernte ich Einiges zur Implementierung von <span class="tx_code">std::function. std::function</span> ist ein polymorpher Funktionswrapper für aufrufbare Einheiten wie Funktionen, Funktionsobjekte und Lambda-Funktionen. </div>
<div class="text">Tom Poole ist ein Maintainer für das <a href="https://juce.com" alt="%7B%22href%22%3A%22https%3A%2F%2Fjuce.com%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22JUCE%22%2C%22target%22%3A%22_blank%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fjuce.com%22%2C%22type%22%3A%22E%22%7D" class="" title="Link auf https://juce.com">JUCE</a> Open Source, ein Cross-Platform-C++-Framework für Audio-Applikationen. Aufgrund der besonderen Performanz- und Speicheranforderungen und der Tatsache, dass <span class="tx_code">std::function</span> nicht auf allen von JUCE unterstützten Plattformen zur Verfügung steht, bietet JUCE eine eigene Implementierung an. Tom stellt die Herausforderungen vor, die es bei einer eigenen Implementierung zu bewältigen gilt. Diese Herausforderungen umfassen die Vermeidung von Speicherallokationen, Locks, aber auch <i>type erasure</i>. Letztendlich besitzt JUCE eine Implementierung, die ähnliche Performanzcharakteristiken wie<span class="tx_code"> std::function</span> aufweist.<br></div>
<div class="ztitel">Sane and Safe C++ Class Types from Peter Sommerlad (Professor, HSR Rapperswill)<br></div>
<div class="ztitel"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_159702430_ba97cebc4c.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Mithilfe der Begriffe <i>sane</i> und <i>safe</i> unterteilte Peter Datentypen in vier Kategorien.</div>
<div class="ztitel">Sane und safe<br></div>
<div class="text">Mit leeren Datentypen (<i>empty types</i>) oder <i>value-</i>Datentypen (<i>value types</i> oder <i><a href="https://stackoverflow.com/questions/13998945/what-is-a-regular-type-in-the-context-of-move-semantics" class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fstackoverflow.com%2Fquestions%2F13998945%2Fwhat-is-a-regular-type-in-the-context-of-move-semantics%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fstackoverflow.com%2Fquestions%2F13998945%2Fwhat-is-a-regular-type-in-the-context-of-move-semantics%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22regular%20types%22%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://stackoverflow.com/questions/13998945/what-is-a-regular-type-in-the-context-of-move-semantics">regular types</a></i>), befinden wir uns in der Kategorie <i>sane</i> und <i>safe</i>. Dies gilt aber nicht für Zeiger, polymorphe Typen oder <i>built-in</i>-Datentypen wie <i>bool</i>, <i>int</i> oder <i>double</i>. Diese sind in der Kategorie <i>in-sane</i> und <i>in-safe</i>.<br></div>
<div class="ztitel_kleiner">In-sane und in-safe</div>
<div class="text">Natürlich gehören Zeiger in diese Schublade. Ich denke aber, du wunderst dich, dass <i>built-in</i>-Datentypen dazu gehören. Der Grund ist einfach. Sie können Opfer von integral promotion oder numerischen Konvertierungen sein und besitzen viele spezielle Werte wie <span class="tx_code">+Inf, -Inf</span> oder <span class="tx_code">NaN</span>. Damit die <i>built-in</i>-Datentypen <i>sane</i> und <i>safe</i> werden, solltest du das <a alt="%7B%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fc2.com%2Fppr%2Fchecks.html%22%2C%22subject%22%3A%22%22%2C%22text%22%3A%22Whole%20Value%20Pattern%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22anchor%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fc2.com%2Fppr%2Fchecks.html%22%7D" class="" href="http://c2.com/ppr/checks.html" title="Link auf http://c2.com/ppr/checks.html">Whole Value Pattern</a> von Ward Cunningham anwenden. Nun ist die Frage: Welche Datentypen sind <i>sane</i> und <i>in-safe</i>. </div>
<div class="ztitel_kleiner">Sane und in-safe</div>
<div class="text">Zum Beispiel sind Zeiger-Typen wie Iteratoren, Smart Pointer, Referenzen, Referenz-Wrapper oder auch Views (<span class="tx_code">std::string_view</span>) <i>sane</i> und <i>in-safe</i>. </div>
<div class="text">Mein Resümee zu Peters Vortrag ist kurz und bündig: Dieser Vortrag sollte Bestandteil jeder C++-Schulung sein. </div>
<div class="ztitel">Trainer Panel</div>
<div class="text">Dank einer Einladung von Jon Kalb war ich am Donnerstag zusammen mit Jason Turner und Dan Saks <br>Gastgeber einer Diskussionsrunde. In dieser 60-Minuten-Runde beantworteten wir viele Fragen der Zuhörer zu unseren Schulungen.<br></div>
<div class="ztitel">What do you mean thread-safe? by Geoffrey Romer (Software Engineer, Google)<br></div>
<div class="text">Warum bin ich auf diesen sehr theorielastigen Talk gegangen? Der Grund ist, dass eine wohl-definierte Begrifflichkeit ein Schlüsselelement für Mulithreading-Programme darstellt. Oft entstehen Probleme mit Multithreading-Programmen dann, wenn Entwickler ein unterschiedliches Verständnis von den gleichen Begriffen besitzen.<br></div>
<div class="text">Zuerst einmal verwendete Geoffrey den Begriff API race anstelle von data race, der vom C++-Standard verwendet wird.</div>
<div class="text"><ul><li><b>API race</b>: The program performs two concurrent operations on the same object when the object's API doesn't permit those operations to be concurrent.</li></ul></div>
<div class="text">Ein API race tritt dann auf, wenn zwei Operationen auf einem Objekt zeitgleich ausgeführt werden, obwohl dies nicht erlaubt ist. Diese Definition unterscheidet sich deutlich von der Definition eines data race, denn bei einem data race darf zu einem Zeitpunkt keine Lese- und Schreiboperation gleichzeitig auf einer Speicherstelle ausgeführt werden. Dies schließt zwei Schreiboperationen zum gleichen Zeitpunkt ein.<br></div>
<div class="text">Der Fokus seiner Vorstellung lag hauptsächlich auf Datentypen und nicht auf Funktionen. Jeder Datentyp gehört in eine der drei Kategorien.</div>
<div class="text"><ol><li>If a live object has a thread-safe type, it can't be the site of an API race.</li><li>If a live object has a thread-compatible type, it can't be the site of an API race if it's not being mutated.</li><li>The remaining objects are not thread-compatible.</li></ol></div>
<div class="text">Objekte, die in die erste Kategorie fallen, sind zum Beispiel atomare Variablen. Objekte der zweiten Kategorie unveränderliche Daten. </div>
<div class="text">An dieser Stelle wird Geoffrey konkret in seinem Vortrag: Du sollst thread-safe-Datentypen oder unveränderliche Datentypen verwenden, falls dies notwendig ist.<br></div>
<div class="text">Obwohl meine Zusammenfassung des 30-Minuten-Vortrags relativ kurz ist, fand ich den Talk sehr interessant, denn mir wurde deutlich klar: Wir benötigen eine wohl-definierte Begrifflichkeit für unsere Datentypen, wenn wir die Korrektheit von Multithreading-Programmen analysieren wollen.&nbsp; </div>
<div class="ztitel">Mein Fazit<br> </div>
<div class="text">Meinen 2-Tages-Workshop vor der Konferenz zu halten und die 5-tägige Konferenz zu besuchen, dies war sehr beeindruckend und um ehrlich zu sein auch sehr anstrengend. Klar, viele der Vorträge waren großartig und ich lernte sehr viel, aber das ist nicht mein Fazit. Vor allem genoss ich die vielen Diskussionen, die ich während und nach der Konferenz geführte habe. Dies vor allem, da ich zum ersten Mal persönlichen Kontakt mit meinen Diskussionspartnern hatte. Dafür bin ich Jon sehr dankbar, der mich zu CppCon eingeladen hat.</div>
<div class="ztitel">Meine Schulung: Multithreading mit modernem C++</div>
<div class="text">Am 12.11 und 13.11 dieses Jahres halte ich den selben Workshop, den ich auf der CppCon 2018 gehalten haben, als Schulung in deutscher Sprache in Rottenburg. Es sind noch Plätze frei und ich freue mich auf diese anspruchsvolle Schulung. </div>
<div class="text">Hier gibt es mehr Details: <a title="Link auf https://www.modernescpp.de/index.php/c" class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22text%22%3A%22Multithreading%20mit%20modernem%20C%2B%2B%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22anchor%22%3A%22%22%2C%22type%22%3A%22E%22%7D" href="https://www.modernescpp.de/index.php/c">Multithreading mit modernem C++</a>.<br></div>