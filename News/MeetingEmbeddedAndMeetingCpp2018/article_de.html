<div class="vorspann">Letzte Woche war ich auf zwei Konferenzen in Berlin: Meeting Embedded und Meeting C++. Hier sind meine frischen Impressionen von beiden Konferenzen.</div><div class="text">Meeting C++ ist neben der <a alt="%7B%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fcppcon-2018%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22CppCon%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.com%2Findex.php%2Fcppcon-2018%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="https://www.modernescpp.com/index.php/cppcon-2018" title="Link auf https://www.modernescpp.com/index.php/cppcon-2018">CppCon</a> die wichtigste C++-Konferenz weltweit. Meeting C++ gibt es seit 2012. Sie ging von Donnerstag bis Samstag. Am Mittwoch vor der Konferenz fand Jens Wellers neue Konferenz Meeting Embedded statt. </div><div class="ztitel">Meeting Embedded<br> </div><div class="text">Alle Vorträge der Konferenz waren in einem Track. Mit Ausnahme der Keynote gingen die Vorträge über 35 Minuten.</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_162297069_7064e78750.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div><div class="ztitel_kleiner">Keynote von Dan Saks: Writing Better Embedded Software</div><div class="text">Dan Saks ist als First Secretary des C++-Standardisierungskomitee und Autor von mehr als 400 Artikeln zu C++ im Embedded-Umfeld sehr bekannt. Seit den 80ern ist er bereits als Berater und Trainer tätig. <br></div><div class="text">Dans Vortrag beschäftigte sich vor allem mit seiner Erfahrung, C-Programmieren C++ zu vermitteln. Seine erste Beobachtung war, dass die meisten Embedded-Programmierer keine ausgebildeten Softwareentwickler, sondern Elektroingenieure mit C-Hintergrund sind. Das mag der Grund sein, dass ihr primärer Fokus darauf liegt, ihr Projekt irgendwie zum Laufen zu bringen. Ist dies vollbracht, steht erst die richtige Arbeit an: Debuggen. Diese Einstellung unterscheidet sich vollkommen von der eines C++-Programmierers: Ihm geht es darum, dass Programm fehlerfrei zu kompilieren, sodass es ausgeführt werden kann. Dies heißt, C++-Entwickler legen mehr Wert darauf, typsicheren Code zu entwickeln. Fehler werden bei dieser Strategie durch den Compiler erkannt.<br></div><div class="ztitel_kleiner"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_162297078_8bc5351771.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=1>" style="max-height: 25px; max-width: 25px;"></div><div class="text">Wenn C-Programmierer von C nach C++ wechseln, liegt ihr Fokus nicht darauf, was sie hinzugewinnen (Templates, Objekt-Orientation), sondern was sie verlieren. Dank dieser Erfahrung änderte Dan seine Strategie, C++ zu lehren, und versucht nun, behutsam vorzugehen. Das heißt zum Beispiel, dass er die Vorteile benutzerdefinierter Typen und typsichererer Zeiger zu Funktionen des Interrupt Pointer Tables in den Vordergrund stellt.<br></div><div class="text">Hier sind seine "Pearls of Wisdom": Embedded-Programmierer legen sehr viel Wert auf Hardware und sind sich ihrer Hardwareeinschränkungen bewusst. Daher sollte man permanenten, aber sanften Druck ausüben, um ihre Software zu verbessern. Der Fokus sollte darauf ausgerichtet sein, Laufzeitfehler in Compilezeitfehler zu transformieren.</div><div class="text">Für mich war dies ein sehr wertvoller Vortrag, besteht doch gerade mein tagtäglicher Job darin, Embedded-Entwickler C++ zu lehren. Falls du daher ähnliche Herausforderungen hast, ist für dich dieser Vortrag ein Muss.</div><div class="text">Um eine bessere Vorstellung zur Meeting Embedded zu erhalten, sind hier die weiteren Vorträge gelistet:</div><div class="text"><ul><li>"Continuous Integration of C/C++ for embedded and IoT with Jenkins, Docker and Conan" von Diego Rodriguez-Losada und Daniel Manzaneque</li><li>"We stopped teaching C" von Wouter van Ooijen</li><li> <a title="Link auf https://www.grimm-jaud.de/index.php/oeffentliche-vortraege" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Foeffentliche-vortraege%22%2C%22text%22%3A%22%5C%22The%20Core%20Guidelines%20for%20Safer%20Code%5C%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Foeffentliche-vortraege%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/oeffentliche-vortraege">"The Core Guidelines for Safer Code"</a> von mir selbst<br></li><li>"std::map&lt;code,performance&gt; myMCU{?}" von Daniel Penning</li><li>"Remoteprocs in Rust" von Jonathan Pallant</li><li>"How to mock in the 21st Century" von Paul Targosz</li><li>"Spread the Love for IoT [--] How I Created a Full-Day IoT Workshop" von Dafna Mordechai</li><li>"A Possible Future of Embedded Software Development" von Odin Holmes</li><li>"Turning MQTT v5 inside out" von Maurice Kalinowski</li></ul></div><div class="ztitel">Meeting C++<br></div><div class="text">Meeting C++ fand von Donnerstag bis Freitag statt. Insgesamt waren es 44 Vorträge, auf vier Tracks verteilt und drei Keynotes von Andrei Alexandrescu, Lisa Lippincot und Nicolai Josuttis. Nicolai gab unmittelbar vor der Konferenz einen Workshop zu Templates. Hier ist der genaue Zeitplan: </div><div><a href="https://meetingcpp.com/2018/Schedule.html" alt="%7B%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fmeetingcpp.com%2F2018%2FSchedule.html%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Schedule%20of%20Meeting%20C%2B%2B2018%22%2C%22alias%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fmeetingcpp.com%2F2018%2FSchedule.html%22%2C%22custom%22%3A%7B%7D%2C%22version%22%3A1%2C%22type%22%3A%22E%22%7D" title="Link auf https://meetingcpp.com/2018/Schedule.html">Schedule of Meeting C++2018</a>.</div><div class="text">Dies sind meine Eindrücke: </div><div class="text">Über die Keynote von Andrei möchte ich gerne mehr Worte verlieren. Vor allem dank seines Buchs "Modern C++ Design" ist Andrei ist sehr bekannt in der C++-Community. Dieses Buch wurde 2001 veröffentlicht und machte Poliy-Based Design in C++ populär. </div><div class="ztitel_kleiner">The Next Big Thing von Andrei Alexandrescu</div><div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_162297083_570eff56cf.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"><br></div><div class="text">Disclaimer: Ich stimme nicht zu 100 Prozent den Vorhersagen zu, die Andrei über die Zukunft der Programmierung, vor allem in C++ gibt. Ich habe aber seine Art und Weise sehr genossen, wie er die Werkzeuge hinterfragt, die wir zur Lösung unserer (Software-)Probleme einsetzen.</div><div class="text">Andrei machte Vorhnersage über die C++-Zukunft: Seine erste Beobachtung war, dass die Codegröße permanent wächst. Das ist ein Problem, denn pro 1000 Zeilen Code gibt es circa 10 bis 15 Fehler. Dies ist unabhängig von der verwendeten Programmiersprache. Daher sind viele Codezeilen per se schlecht. Nun ist natürlich die Frage. Wie lässt sich die Codegröße verringern? </div><div class="text">Drei Antworten bietet modernes C++ an:</div><div class="text"><ol><li>Concepts</li><li>Metaklassen</li><li>Introspection<br></li></ol></div><div class="text">Andreis Beobachtung ist es, dass weder Concepts noch Metaklassen die Codegröße signifikant reduzieren. Daher sind sie nicht Teil der Lösung, sondern Teil des Problems. Instrospection oder genauer gesagt Design by Introspection (DbI) ist die einzige Lösung. Sie ist eine Technik, bei der das Gesamtsystem auf anpassbaren Komponenten zusammengesetzt wird. Das heißt, das du die kombinatorische Komplexität der Welt mit beliebig zusammensetzbaren Komponenten begegnest. <br></div><div class="text">Design by Introspektion besitzt bereits Vorläufer:<br></div><div class="text"><ol><li>Interfaces, wie sie in der Objektorientierung verwendet werden, helfen, die kombinatorische Explosion zu beantworten. Interface können aber nicht wiederverwendet werden. Design Patterns setzen diese Idee bereits um.</li><li>Policy-Based Design, das von Andrei in seinem bereits zitieren Buch "Modern C++ Design" in C++ eingeführt wurde. Sie stellen eine Art halbautomatische Design Patterns dar und werden zur Compilezeit aus Templates zusammengestellt werden. Sie bieten die Wiederverwendung von Code an.</li></ol></div><div class="text">Anschließend beantwortete Andrei die Frage: Was sind die Voraussetzung von Design by Introspection?<br></div><div class="text"><ul><li>Eingabe</li><ul><li>Welche Methoden bietet ein Objekt an? Oder: Unterstützt ein Objekt die Methode xyz?</li><li>Lässt sich der Code übersetzen?</li></ul><li>Code prozessieren</li><ul><li>Werte einen beliebigen Ausdruck zru Compilezeit aus.</li></ul><li>Ausgabe</li><ul><li>Erzeuge beliebigen Code zur Compilezeit.<br></li></ul></ul></div><div class="text">Zum Abschluss stelle Andrei Checked Integrals vor, die er in der <a title="Link auf https://en.wikipedia.org/wiki/D_(programming_language)" alt="%7B%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FD_%28programming_language%29%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FD_%28programming_language%29%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22text%22%3A%22Programmiersprache%20D%22%2C%22anchor%22%3A%22%22%7D" href="https://en.wikipedia.org/wiki/D_(programming_language)">Programmiersprache D</a> mit Design by Introspection implementiert hat. </div><div class="text">Ich möchte es gerne betonen. Andreis Keynote war mit Abstand mein Lieblingsvortrag. Dieser war sehr unterhaltsam und darüber hinaus sehr informativ. </div><div class="ztitel_kleiner">Pflichtvorträge<br></div><div class="text">Nun mache ich es kurz: Hier sind die Vorträge, die du dir anschauen solltest, sobald sie zur Verfügung stehen. All Vorträge des Meeting Embedded und dem Meeting C++ wurden aufgenommen und werden auf dem YouTube-Kanal "<a title="Link auf https://www.youtube.com/user/MeetingCPP" alt="%7B%22anchor%22%3A%22%22%2C%22text%22%3A%22Meeting%20Cpp%22%2C%22alias%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22href%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fuser%2FMeetingCPP%22%2C%22user_params%22%3A%22%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.youtube.com%2Fuser%2FMeetingCPP%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%7D" href="https://www.youtube.com/user/MeetingCPP">Meeting Cpp</a>" veröffentlicht: </div><div class="text"><ul><li>"Regular Types and Why Do I Care?" von Victor Ciura: In meinem nächsten Blogartikel geht es um reguläre und semireguläre Datentypen. Du musst dich daher noch eine Woche gedulden.</li><li>"Taming Dynamic Memory [--] An Introduction to Custom Allocators" von Andreas Weis: Andreas stellte sehr strukturiert alles vor, was du zu Allokatoren wissen solltest. Dies beinhaltet im Wesentlichen deren Vor- und Nachteile. Um ehrlich zu sein, ich lerne noch einiges zu Allokatoren hinzu.</li><li>"Coroutine TS: A new way of thinking" von Andreas Reischuck: Andreas gab eine sehr unterhaltsame und relativ einfach zu verstehende Einführung in Coroutinen. Seine Einführung ging auf Generatoren, Zustandsmaschinen und asynchrone Aufrufe ein.</li><li>Keynote "50 shades of C++" von Nicolai Josuttis. C++ ist eine erfolgreiche Programmiersprache, die mehr als 40 Jahre auf dem Buckel hat und von einer Kommunity von Freiwilligen getragen wird. Nicolai präsentierte sehr eindrucksvoll, welche Herausforderungen diese Konstellation mit sich bringt.&nbsp; <br></li></ul></div><div class="text">Wie immer, war Meeting C++ eine große, aber doch sehr familiäre Konferenz. Am meisten genoss ich die vielen Gespräche zwischen und nach den Vorträgen. Mein Dank geht daher an Jens und sein Team. <br></div><div class="ztitel">Wie geht's weiter?</div><div class="text">Ich denke, du weißt es bereits. In meinen nächsten Artikel beschäftige ich mir mit regulären und semiregulären Datentypen.&nbsp; </div>
