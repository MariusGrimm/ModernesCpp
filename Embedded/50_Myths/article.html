<p>As I started working in the embedded environment I was astonished that there were so much prejudice against the usage of C++ in the embedded programming. The most are based on a wrong understanding of the programming language C++.</p>
<p>&nbsp;</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<h2>The Myths</h2>
<p><img src="images/blog/EmbeddedProgrammierung/Myths/lagerfeuer.jpeg" alt="lagerfeuer" /></p>
<p>First, I have to say a few words about the myths around C++ I often heard. Of course this post reflects my perception. Examples?</p>
<ul>
	<li>Templates inflate the code.</li>
	<li>Objects must live on the heap</li>
	<li>Exceptions are expensive.</li>
	<li>C++ is too slow and needs too much memory.</li>
	<li>C++ is too dangerous in safety critical systems.</li>
	<li>You have to program object-oriented in C++.</li>
	<li>C++ can only be used for applications.</li>
	<li>The iostream library is too big; the Standard Template Library to slow.</li>
</ul>
<p>Or to say it in one statement.</p>
<p><span style="font-size: 14pt;"><strong><span style="color: #ff0000;">=&gt;</span></strong>
	</span> C++ is a nice toy but we are dealing with the serious challenges.</p>
<p>The list of (pre)judice is long consisting partially of half truth and untruth statements often stated by experienced C programmer. I will only refer to the untruth statements. The half truth statements are to a large extent questions due to the right usage of C++ and to a small extent questions of the implementation of the core and the libraries of C++.&nbsp;</p>
<ul>
	<li>Objects must live on the heap.
		<ul>
			<li>Objects can be created on the stack or at an arbitrary position with the help of <a href="http://en.cppreference.com/w/cpp/language/new">placement new.</a><span style="font-family: courier new,courier;"></span></li>
		</ul>
	</li>
	<li>C++ is to dangerous in safety critical systems.<br />
		<ul>
			<li>Of course, it depends on the experience of the developer. But whoever uses C strings instead of C++ strings;&nbsp;uses C arrays instead of C++ arrays; uses macros instead of constant expressions or templates, can not argue that C++ is not well suited for safety critical systems. Honestly, the contrary holds. C++ has a lot to offer in safety critical systems.&nbsp;</li>
		</ul>
	</li>
	<li>You have to program object-oriented in C++.<br />
		<ul>
			<li>C++&nbsp; is a <a href="https://en.wikipedia.org/wiki/Programming_paradigm">multi-paradigm language</a>. <span id="transmark"></span>Therefore, you can solve your problem in an object-oriented, structured, functional, generic, or generative style.</li>
		</ul>
	</li>
	<li>C++ can only be used for applications.
		<ul>
			<li>C++ is for example used for fire extinguisher, for defibrillators, and cars. ARM maintains with&nbsp; <a href="https://launchpad.net/gcc-arm-embedded">ARM GCC&nbsp;</a> the current GCC collection together with the <a href="https://de.wikipedia.org/wiki/GNU_Toolchain">gnu toolchain</a>. Therefore, the current g++ compiler is available. The packages that is very frequently used is maintained by ARM for their processors that are the default architecture for the embedded world.</li>
		</ul>
	</li>
</ul>
<p>What's the reason for the half truth? I think, there are more reasons.</p>
<ul>
	<li>Old C++ compilers
		<ul>
			<li>Knowledge that is based on old C++ compilers of the last millennium. They implement the C++98 standard but they have a large potential for optimization.</li>
		</ul>
	</li>
	<li>Training deficit<br />
		<ul>
			<li>On on hand many embedded programmer learned only C, on the other hand there is no time to experiment with new technologies.</li>
		</ul>
	</li>
	<li>Loss of expert state<br />
		<ul>
			<li>You have to be brave to leave your area as C expert and continue the next day as a C++ novice.</li>
		</ul>
	</li>
	<li>Legacy code base in C
		<ul>
			<li>The existing code base is in C therefore is the obvious decision to fix a bug or implement a feature in the first place in C.</li>
		</ul>
	</li>
	<li>Many C experts<br />
		<ul>
			<li>There are many C experts. They are training the novices and becoming the leaders.</li>
		</ul>
	</li>
	<li>Curse of the mono culture<br />
		<ul>
			<li>I perceive the embedded world often as mono culture. I worked 15 years as a consultant in the auto mobile area and used about 10 languages. On the contrary, I used only 3 languages in the embedded area.&nbsp;</li>
		</ul>
	</li>
	<li>Pressure of the standard<br />
		<ul>
			<li>There are a lot of standards that you have to fulfil. The courage to use new technologies seems to be indirectly proportional to the pressure of the standards.&nbsp;</li>
		</ul>
	</li>
	<li>Insufficient knowledge about C++
		<ul>
			<li>Many developers have not the sufficient knowledge of the classical C++ and no knowledge of modern C++.</li>
		</ul>
		<p>&nbsp;</p>
	</li>
</ul>
<p>Maybe, I will polarize with this post. But If it helps to make the great features of modern C++ better known in the embedded world than I want to do it voluntarily. In the next post I compare the myths with the facts. In particular I will write about the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">Technical Report on C++ Performance.</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;Do you want to get the source code? <a href="index.php/source-code-repository">Source code repository</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>