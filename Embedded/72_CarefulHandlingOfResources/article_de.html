<p>Der sorgfältige Umgang mit Ressourcen, sei es Speicher, Dateien oder Sockets, ist zentral für die Programmierung in C++. Das gilt insbesondere für die embedded Programmierung, da sich diese gerne durch eingeschränkte Ressourcen auszeichnet. Daher will ich mir diesem vielschichtigen und anspruchsvollen Thema in mehreren Artikeln widmen.</p>
<hr id="system-readmore" />
<p>&nbsp;</p>
<p>In meiner ersten Naivität wollte ich in diesem Artikel sofort mit der Speicherallokation mit den Operator new loslegen. Gott sei Dank habe ich mich eines besseren besonnen. Speicherallokation ist nur ein, wenn auch ein wichtiger Aspekt von Ressourcenmanagement in C++. Die Geschichte ist aber deutlich vielseitiger. Daher werde ich einen Schritt zurücktreten und mich drei Bereichen von Ressourcenmanagement in C++ widmen.</p>
<p>Da gibt es die automatische Speicherverwaltung in C++, in der der Anwender die Mechanismen von C++ relativ naiv nutzen kann, da kommen die bekannten C++-Idiome zum Einsatz, auf denen zum Teil die automatische Speicherverwaltung basiert und letztendlich gibt es noch die explizite Speicherverwaltung, in der der Entwickler als Experte die Speicherverwaltung in die eigene Hand nimmt. Genau dieser Abstufung von der einfachen Anwendung zur Expertendomäne werde ich in meiner Gliederung folgen. Denn, was ich nicht will, ist, dass er Eindruck entsteht, explizite Speicherverwaltung ist notwendiges Wissen für einen C++-Entwickler.</p>
<p><img src="images/blog/EmbeddedProgrammierung/SorgfaeltigerUmgangMitRessourcen/Ressourcenmanagement.png" alt="Ressourcenmanagement" width="650" height="599" style="margin: 15px;" /></p>
<h2>Automatische Speicherverwaltung</h2>
<p>Log geht es auf der elementarsten Ebene mit den Smart Pointern.</p>
<h3>Smart Pointer</h3>
<p>C++ bietet vier verschiedene Smart Pointer an. Jeder besitzt die Aufgabe, den Lebenszyklus seiner zugrundeliegenden Ressource automatisch zu verwalten. Während der <span style="font-family: courier new,courier;">std::unique_ptr</span> den Lebenszyklus genau einer Ressource verwaltet, teilt sich der <span style="font-family: courier new,courier;">std::shared_ptr</span> seine Ressource mit einem anderen<span style="font-family: courier new,courier;"> std::shared_ptr</span>. Dabei können beim<span style="font-family: courier new,courier;"> std::shared_ptr</span> Zyklen auftreten, so dass der Speicher nicht automatisch freigegeben werden kann. Diese Zyklen zu brechen ist genau die Aufgabe von <span style="font-family: courier new,courier;">std::weak_ptr</span>. Der Vierte im Bunde ist der<span style="font-family: courier new,courier;"> std::auto_ptr</span>. <span style="font-family: courier new,courier;">std::auto_ptr</span> ist mit C++11 deprecated. Warum?. Das werde ich in einem späteren Artikel klären.&nbsp;</p>
<h3>STL-Container</h3>
<p>STL-Container <span style="font-family: courier new,courier;">cont</span> wie<span style="font-family: courier new,courier;"> std::vector</span> oder auch <span style="font-family: courier new,courier;">std::string</span> verwalten automatisch ihren Speicher. So besitzen sie zum Beispiel eine Methode<span style="font-family: courier new,courier;"> cont.push_back</span>, um ein neues Element an den Container anzuhängen. Dabei wird automatisch die Größe des Containers angepasst. Es geht auch anders herum. Mit der Methode <span style="font-family: courier new,courier;">cont.shrink_to_fit</span> wird ihre Größe auf ihren tatsächlichen Inhalt reduziert.</p>
<h2>C++-Idiome</h2>
<p>Jede moderne STL-Implementierung verwendet die drei C++-Idiome Move-Semantik, Perfekt-Forwarding und das RAII-Idiom exzessiv. Um die Mechanismen darunter zu verstehen, bewegen wir uns aber schon auf anspruchsvollerem Terrain als bei der automatischen Speicherverwaltung. Bevor ich auf die Details eingehe, zuerst ein kleiner Appetitanreger.</p>
<h3>Move-Semantik</h3>
<p>Die zentrale Idee der Move-Semantik ist es, das es besser ist, große Objekte billig zu verschieben statt teuer zu kopieren. Das trifft umso mehr zu, da es Objekte gibt, die gar nicht kopiert werden können. Ein typisches Beispiel ist ein Mutex oder kürzlich vorgestellte Smart Pointer <span style="font-family: courier new,courier;">std::unique_ptr</span>.</p>
<h3>Perfekt-Forwarding</h3>
<p>Perfekt-Forwarding verwendet unter der Decke ähnliche Mechanismen wie die Move-Semantik. Die zentrale Idee von Perfekt-Forwarding ist aber eine andere. Bei Perfekt-Forwarding geht es darum, Objekte in einem Funktions-Template anzunehmen und sie mit ihren identischen Eigenschaften weiterzureichen. Typische Beispiel sind Konstruktoren, die ihre Argumente annehmen und an einen Basisklassenkonstruktor weiterreichen oder auch Fabrikfunktionen, die als Ergebnis ein neu erzeugtes Objekt zurückgeben.&nbsp;</p>
<h3>RAII-Idiom</h3>
<p>Das Prinzip des RAII-Idiom ist sehr einfach. Bei ihr wird die Ressourcenbelegung und -freigabe an den Lebenszyklus eines auf dem Stack angelegten Objekts gebunden. So wird im Konstruktor des Objekts die Ressource initialisiert und im Destruktor wieder freigegeben. Damit verwaltet die C++-Laufzeit automatisch den Lebenszyklus des Objekts und somit der Ressource. Das Akronym RAII steht für <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization. Smart Pointer wenden dieses beliebten C++-Idiom an.</p>
<h2>Explizite Speicherverwaltung</h2>
<p>Mit der expliziten Speicherverwaltung betreten wir die Domäne der Experten. Dank der expliziten Spiecherverwaltung ist es möglich, auf Klassenebene oder auch global die Speicherverwaltung- und freigabe für Objekt oder Arrays von Objekten in die Hand zu nehmen. Selbst eigene Speicherallokatoren lassen sich mit Hilfe von <span style="font-family: courier new,courier;">placement new</span> verwenden und die Objekte in speziellen Speicherbereichen erzeugen.</p>
<h2>Wie geht's weiter?</h2>
<p>Wie versprochen, arbeite ich mit von unten nach oben durch die verschiedenen Ebenen im Umgang mit Ressourcen. Los geht es im <a href="https://www.grimm-jaud.de/index.php/blog/speicher-performanz-overhead-von-smart-pointern">nächsten Artikel </a>mit der automatischen Speicherverwaltung mit Smart Pointern.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>{tooltip} <img src="images/books/title_page_small.png" alt="title page small" width="166" height="212" />{end-texte}<img src="images/books/title_page_small.png" alt="title page small" style="margin: 3px;" /> Go to <a href="https://leanpub.com/cpplibrary"> </a><a href="https://leanpub.com/cpplibrary">Leanpub/cpplibrary</a> <a href="https://leanpub.com/cpplibrary"> </a><strong>"What every professional C++ programmer should know about the C++ standard library".</strong> <a href="https://leanpub.com/cpplibrary"></a>{end-tooltip} &nbsp; <strong><span class="h3">Hole dir dein E-Book. Unterstütze meinen Blog.</span></strong></p>
<p>&nbsp;</p>