<div class="vorspann">Vor ein paar Wochen sendete mir Felix Petriconi, Mitglied des C++-Standardisierungskomitees, eine E-Mail. Er schrieb, dass mein Artikel zu <a href="https://www.grimm-jaud.de/index.php/blog/std-future-erweiterungen" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-future-erweiterungen" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-future-erweiterungen%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22std%3A%3Afuture-Erweiterungen%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-future-erweiterungen%22%2C%22custom%22%3A%7B%7D%7D">std::future-Erweiterungen</a> bereits veraltet sei. Leider hat er Recht. Die Zukunft der Futures hat sich deutlich mit dem neuen Erstarken der Executors verändert. </div>
<div class="text">Bevor ich über die Zukunft der Futures schreibe, muss ich erst auf das Konzept der Executors eingehen. Sie besitzen eine lange Geschichte in C++, die mindestens acht Jahre alt. Der Vortrag "<a alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Finally%20Executors%20for%20C%2B%2B%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.vollmann.ch%2Fen%2Fpresentations%2Fexecutors2018.pdf%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.vollmann.ch%2Fen%2Fpresentations%2Fexecutors2018.pdf%22%2C%22version%22%3A1%7D" href="http://www.vollmann.ch/en/presentations/executors2018.pdf" class="" title="Link auf http://www.vollmann.ch/en/presentations/executors2018.pdf">Finally Executors for C++</a>" von Detlef Vollmann gibt einen sehr schönen Überblick dazu. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_154108065_e2b442fcaa.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Dieser Artikel basiert zu großen Teilen auf dem Proposal <a alt="%7B%22user_params%22%3A%22%22%2C%22text%22%3A%22P0761%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0761r2.pdf%22%2C%22custom%22%3A%7B%7D%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0761r2.pdf%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0761r2.pdf" class="" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0761r2.pdf">P0761</a> zum Design von Executors und deren formaler Beschreibung im Proposal <a class="" href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0443r7.html" title="Link auf http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0443r7.html" alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2018%2Fp0443r7.html%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22P0441%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2018%2Fp0443r7.html%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D">P0441</a>. Dieser Artikel bezieht sich auch auf das relativ neue Proposal <a alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2018%2Fp1055r0.pdf%22%2C%22text%22%3A%22P1055%3A%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2018%2Fp1055r0.pdf%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" title="Link auf http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1055r0.pdf" class="" href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1055r0.pdf">P1055:</a> Modest Executor Proposal.</div>
<div class="text">Zuerst einmal. Was ist ein Executor?</div>
<div class="ztitel">Executors</div>
<div class="text">Sie sind der Grundbaustein, um etwas in C++ auszuführen. Sie nehmen eine ähnliche Rolle wie die Allokatoren für die Container in C++ ein. Zu diesem Zeitpunkt sind bereits einige Proposals zu Executors verfasst worden, und viele Entscheidungen sind noch offen. Die Erwartung ist, dass sie mit C++23 Bestandteil des Standards sind, sie aber als Erweiterung des C++-Standards schon deutlich früher zur Verfügung stehen.</div>
<div class="text">Ein Executor besteht aus einer Menge von Regeln, <b>wo</b>, <b>wann</b> und <b>wie </b>eine aufrufbare Einheit ausgeführt werden soll. Eine aufrufbare Einheit kann eine Funktion, ein Funktionsobjekt oder auch eine Lambda-Funktion sein.</div>
<div class="text"><ul><li><b>Wo: </b>Die aufrufbare Einheit kann auf einem internen oder externen Prozessor laufen und das Ergebnis von diesem Prozessor auslesen.</li><li><b>Wann</b>: Die aufrufbare Einheit kann sofort starten oder nur vorgemerkt werden.</li><li><b>Wie:</b> Die aufrufbare Einheit kann auf einer CPU, einer GPU oder auch vektorisiert ausgeführt werden.&nbsp;</li></ul></div>
<div class="text">Da Executors der Grundbaustein sind, um etwas auszuführen, hängen die Features zur Concurrency und zur Parallelität in C++ sehr stark von ihnen ab. Das gilt für die neuen Feature zur Concurreny in <a alt="%7B%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fmultithreading-c-17-und-c-20%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22C%2B%2B20%2F23%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fcategory%2Fmultithreading-c-17-und-c-20%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/category/multithreading-c-17-und-c-20" href="https://www.grimm-jaud.de/index.php/blog/category/multithreading-c-17-und-c-20" class="">C++20/23</a> wie erweiterte Futures, Latches und Barriers, Coroutinen, Transaktional Memory und Task-Blöcke. Dies gilt aber auch für die Erweiterung zur Netzwerk-Programmierung <a alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fn4734.pdf%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22P4734%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fn4734.pdf%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4734.pdf" class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4734.pdf">P4734</a> in C++ und die <a alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fparallele-algorithmen-der-stl%22%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22parallelen%20Algorithmen%20der%20STL%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fparallele-algorithmen-der-stl%22%2C%22custom%22%3A%7B%7D%7D" class="" href="https://www.grimm-jaud.de/index.php/blog/parallele-algorithmen-der-stl" title="Link auf https://www.grimm-jaud.de/index.php/blog/parallele-algorithmen-der-stl">parallelen Algorithmen der STL</a>. </div>
<div class="ztitel">Einen Executor anwenden<br></div>
<div class="text">Hier sind ein paar Codebeispiele zur Anwendung des Executors <i>my_executor.</i><br></div>
<div class="text"><ul><li>Der Promise <i>std::async:</i></li></ul></div>
<div class="pre">// get an executor through some means<br>my_executor_type my_executor = ...<br><br>// launch an async using my executor<br>auto future = std::async(my_executor, [] {<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "Hello world, from a new execution agent!" &lt;&lt; std::endl;<br>});</div>
<div class="text"><ul><li>Der STL-Algorithmus <i>std::for_each:</i></li></ul></div>
<div class="pre">// get an executor through some means<br>my_executor_type my_executor = ...<br><br>// execute a parallel for_each "on" my executor<br>std::for_each(std::execution::par.on(my_executor),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.begin(), data.end(), func);<br></div>
<div class="ztitel">Einen Executor erhalten</div>
<div class="text">Es gibt viele Wege, einen Executor zu erhalten:</div>
<div class="text"><ul><li>Vom Execution-Kontext <i>static_thread_pool</i>:</li></ul></div>
<div class="pre">// create a thread pool with 4 threads<br>static_thread_pool pool(4);<br><br>// get an executor from the thread pool<br>auto exec = pool.executor();<br><br>// use the executor on some long-running task<br>auto task1 = long_running_task(exec);<br></div>
<div class="text"><ul><li>Der System-Executor: Dies ist der Default-Executor, der in der Regel einen Thread verwendet. Dieser Executor wird verwendet, wenn kein anderer angegeben wurde.</li></ul></div>
<div class="text"><ul><li>Von einem Executor-Adapter<b>:<br></b></li></ul></div>
<div class="pre">// get an executor from a thread pool<br>auto exec = pool.executor();<br><br>// wrap the thread pool's executor in a logging_executor<br>logging_executor&lt;decltype(exec)&gt; logging_exec(exec);<br><br>// use the logging executor in a parallel sort<br>std::sort(std::execution::par.on(logging_exec), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_data.begin(), my_data.end());<br></div>
<div class="text">Der logging-Executor ist in dem Codebeispiel ein Wrapper für den <i>pool</i>-Executor.</div>
<div class="ztitel">Ziele eines Executor Concept<br></div>
<div class="text">Was sind gemäß dem Proposal <a title="Link auf http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1055r0.pdf" href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1055r0.pdf" class="" alt="%7B%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2018%2Fp1055r0.pdf%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22P1055%22%2C%22anchor%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2018%2Fp1055r0.pdf%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%7D">P1055</a> die Ziele eines Executor Concept?<br></div>
<div class="text"><ul><li><b>Batchable: </b>kontrolliert den Kompromiss zwischen dem Übertagen der Funktion und seiner Größe.</li><li><b>Heterogenous: </b>erlaubt es, die aufrufbare Einheit auf verschiedenen Kontexten laufen zu lassen und das Ergebnis des Aufrufs zu erhalten.</li><li><b>Orderable: </b>erlaubt die Reihenfolge anzugeben, in der die aufrufbare Einheiten aufgerufen werden. Dieses Ziel schließt Garantien wie <a class="" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" title="Link auf https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FStack_%28abstract_data_type%29%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FStack_%28abstract_data_type%29%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22LIFO%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D">LIFO</a>- (<b>L</b>ast <b>I</b>n, <b>F</b>irst <b>O</b>ut), <a title="Link auf https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" class="" alt="%7B%22version%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFIFO_%28computing_and_electronics%29%22%2C%22ir_link%22%3A1%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22FIFO%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFIFO_%28computing_and_electronics%29%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%7D">FIFO</a>- (<b>F</b>irst <b>I</b>n, <b>F</b>irst <b>O</b>ut) Ausführungen, aber auch Prioritätsvergaben, zeitliche Einschränkungen oder die sequenzielle Ausführung ein.</li><li><b>Controllable: </b>Die ausführbare Einheit muss sich auf einer bestimmen Rechenressource sofort oder verzögert ausführen lassen. Selbst der Abbruch einer Ausführung soll möglich sein.</li><li><b>Continuable: </b>Um eine asynchrone ausführbare Einheit auszuführen, sind Signale notwendig. Diese sollen anzeigen, ob das Ergebnis zur Verfügung steht, ob ein Fehler aufgetreten ist, ob die ausführbare Einheit fertig ist oder ob diese abgebrochen werden soll. Das explizite Starten oder Anhalten soll auch möglich sein.</li><li><b>Layerable: </b>Hierarchien erlauben es, die Executors mit mehr Funktionalität auszustatten, ohne deren Komplexität zu erhöhen.</li><li><b>Usable: </b>Die einfache Anwendung und die einfache Implementierung soll im Fokus der Executors stehen.</li><li><b>Composable: </b>erlaubt die Executors mit Funktionalität zu erweitern, die nicht Teil des Standards sind.</li><li><b>Minimal: </b>Das Executor Concept sollte nur enthalten, was sich nicht durch Bibliotheken implementieren lässt.</li></ul></div>
<div class="ztitel">Ausführungsfunktionen (Execution Function)<br></div>
<div class="text">Ein Executor bietet mindestens eine der sechs Ausführungsfunktionen an, um aus einer ausführbaren Einheit einen Execution Agent zu erzeugen. Jede Ausführungsfunktion besitzt zwei Eigenschaften: Kardinalität und Richtung:</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_154108071_41b74ee37f.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text"><ul><li>Kardinalität:</li><ul><li>single: erzeugt einen Execution Agent.</li><li>bulk: erzeugt eine Gruppe von Execution Agents.</li></ul><li>Richtung:</li><ul><li>oneway: erzeugt einen Execution Agent, der kein Ergebnis zurückgibt.</li><li>twoway: erzeugt einen Execution Agent, der einen Future zurückgibt, um auf das Ergebnis der Ausführung zu warten.<br></li><li>then: erzeugt einen Execution Agent, er einen Future zurückgibt, um auf das Ergebnis der Ausführung zu warten. Der Execution Agent beginnt mit seiner Ausführung, nachdem der übergebenen Future fertig ist.</li></ul></ul></div>
<div class="text">Gerne gehe ich nochmals weniger formal auf die Ausführungsfunktionen ein. </div>
<div class="text">Zuerst beziehe ich mich auf den single-Kardinalität-Fall.</div>
<div class="text"><ul><li>Eine oneway-Ausführungsfunktion ist ein "fire and forget"-Job. Dieser ist einem <a class="" href="https://www.grimm-jaud.de/index.php/blog/std-async-warten-im-destruktor" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-async-warten-im-destruktor" alt="%7B%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-async-warten-im-destruktor%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22fire%20and%20forget%20Future%22%2C%22user_params%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-async-warten-im-destruktor%22%7D">fire and forget Future</a> ziemlich ähnlich. Dieser blockiert aber nicht automatisch in seinem Destruktor.</li><li>Eine twoway-Ausführungsfunktion gibt einen Future zurück. Damit lässt sich das Ergebnis abfragen. So verhält sich diese Ausführungsfunktion wie ein <a alt="%7B%22subject%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22std%3A%3Apromise%22%2C%22user_params%22%3A%22%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fpromise-und-future%22%2C%22custom%22%3A%7B%7D%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fpromise-und-future%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/promise-und-future" class="" href="https://www.grimm-jaud.de/index.php/blog/promise-und-future">std::promise</a>, der einen Handle auf sein Ergebnis mit dem assoziierten <a class="" href="https://www.grimm-jaud.de/index.php/blog/promise-und-future" title="Link auf https://www.grimm-jaud.de/index.php/blog/promise-und-future" alt="%7B%22version%22%3A1%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fpromise-und-future%22%2C%22type%22%3A%22E%22%2C%22target%22%3A%22_blank%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fpromise-und-future%22%2C%22custom%22%3A%7B%7D%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22std%3A%3Afuture%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%7D">std::future</a> zurückgibt.</li><li>Eine then-Ausführungsfunktion ist eine Art Fortsetzung. Sie gibt einen Future zurück. Der Execution Agent wird nur dann ausgeführt, wenn der Future fertig ist.</li></ul></div>
<div class="text">Der bulk-Kardinalität-Fall ist komplizierter. Diese Ausführungsfunktionen erzeugen eine Gruppe von Execution Agents, und jeder dieser Execution Agent ruft die gleiche aufrufbare Einheit auf. Sie geben das Ergebnis einer Fabrik zurück und nicht das Ergebnis der einzelnen Execution Agent. Es liegt in der Verantwortung des Anwenders, das richtige Ergebnis mit Hilfe der Fabrik zu erzeugen.</div>
<div class="ztitel"><i>execution::require</i><br></div>
<div class="text">Wie kannst du dir sicher sein, dass dein Executor die gewünschte Ausführungsfunktion unterstützt? Im konkreten Fall weißt du es:</div>
<div class="pre">void concrete_context(const my_oneway_single_executor&amp; ex)<br>{<br>&nbsp;&nbsp;&nbsp; auto task = ...;<br>&nbsp;&nbsp;&nbsp; ex.execute(task);<br>}<br></div>
<div class="text">Im allgemeinen Fall kannst du die Funkton <i>execution::require</i> verwenden:<br></div>
<div class="pre">template &lt;typename Executor&gt; <br>void generic_context(const Executor&amp; ex) <br>{ <br>&nbsp;&nbsp;&nbsp; auto task = ...; <br><br>&nbsp;&nbsp;&nbsp; // ensure .twoway_execute() is available with execution::require() <br>&nbsp;&nbsp;&nbsp; execution::require(ex, execution::single, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execution::twoway).twoway_execute(task); <br>}</div>
<div class="text">In diesem Fall muss der Executor <i>ex</i> die Kardinalität <i>single </i>und die Richtung <i>twoway </i>unterstützten.</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">In meinem nächsten Artikel geht mein Exkurs von den "C++ Core Guidelines" weiter. Die Zukunft der Futures ändert sich hauptsächlich wegen der Executoren. Daher geht es im nächsten Artikel um die Futures.</div>
<div class="ztitel">Weitere Informationen:</div>
<div class="text">Falls du die ganzen Details zu Concurrency von C++11 bis C++20 wissen willst. Mein Buch "Concurrency with Modern C++" gibt es seit heute auch auf Deutsch bei Hanser: "<a alt="%7B%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22https%3A%2F%2Fwww.hanser-fachbuch.de%2Fautor%2FRainer%2BGrimm%22%2C%22text%22%3A%22Modernes%20C%2B%2B%3A%20Concurrency%20meistern%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22type%22%3A%22E%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.hanser-fachbuch.de%2Fautor%2FRainer%2BGrimm%22%2C%22ir_link%22%3A1%2C%22version%22%3A1%7D" title="Link auf https://www.hanser-fachbuch.de/autor/Rainer+Grimm" href="https://www.hanser-fachbuch.de/autor/Rainer+Grimm" class="">Modernes C++: Concurrency meistern</a>".</div>
