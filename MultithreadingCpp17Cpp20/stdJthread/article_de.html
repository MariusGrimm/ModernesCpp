<div class="vorspann">Ein Teilnehmer meines CppCon-2018-Workshops fragte mich: "Kann ein Thread unterbrochen werden?" Nein, war meine Antwort, doch dies ist nicht mehr richtig. Mit C++20 werden wir wohl <i>std::jthread</i> erhalten. </div>
<div class="text">Gerne möchte ich meine <a class="" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22%22%2C%22type%22%3A%22B%22%2C%22alias%22%3A%22%22%2C%22version%22%3A1%2C%22text%22%3A%22Geschichte%20von%20der%20CppCon%202018%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dbf27f509f30a27ecefdc7cd67c967b10%26rm%3Dopen_article_id%26bid%3D2509468%22%2C%22subject%22%3A%22%22%2C%22destination%22%3A2509468%7D" href="/exec/mainmenu.pl?sid=bf27f509f30a27ecefdc7cd67c967b10&amp;rm=open_article_id&amp;bid=2509468" title="Link auf Beitrag 2509468">Geschichte von der CppCon 2018</a> fortsetzen. Während einer Pause meines Concurrency-Workshops hatte ich ein kurzes Gespräch mit Nicolai (Josuttis). Er fragte mich, was ich über das Proposal "<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0660r5.pdf" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0660r5.pdf" class="" alt="%7B%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22P0660%3A%20Cooperatively%20Interruptible%20Joining%20Thread%22%2C%22custom%22%3A%7B%7D%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0660r5.pdf%22%2C%22ir_link%22%3A1%2C%22subject%22%3A%22%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0660r5.pdf%22%7D">P0660: Cooperatively Interruptible Joining Thread</a>" denke. Zu diesem Zeitpunkt war mir das Proposal noch nicht bekannt. Nicolai ist zusammen mit Herb Sutter und Anthony Williams einer seiner Autoren. Heute geht es um die Concurrent-Zukunft. Hier ist der erste Überblick zur Concurrency in aktuellem und zukünftigem C++. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160768551_69fe4e753d.png" title="<ir_inline itemname=bilder_mvp_bild_var2:1 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Aufgrund des Titel des Artikels "<a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0660r5.pdf" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0660r5.pdf" alt="%7B%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0660r5.pdf%22%2C%22subject%22%3A%22%22%2C%22ir_link%22%3A1%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0660r5.pdf%22%2C%22custom%22%3A%7B%7D%2C%22text%22%3A%22Cooperatively%20Interruptible%20Joining%20Thread%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22alias%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22user_params%22%3A%22%22%2C%22target%22%3A%22_blank%22%7D" class="">Cooperatively Interruptible Joining Thread</a>" ahnst du es vermutlich schon. Der neue Thread besitzt zwei zusätzliche Fähigkeiten. Er ist unterbrechbar und ruft <i>join</i> automatisch auf. Zuerst will ich mich mit der zweiten Verbesserung befassen.</div>
<div class="ztitel">Automatischer <i>join</i>-Aufruf</div>
<div class="text">Hier ist das nicht so intuitive Verhalten des <i>std::thread</i>. Wenn ein <i>std::thread</i> noch joinable ist, wird automatisch <i>std::terminate</i> in seinem Destruktor aufgerufen. Ein Thread <i>thr</i> ist joinable, wenn auf ihm noch nicht <i>thr.join()</i> oder<i> thr.detach() </i>ausgeführt wurde: </div>
<div class="pre">// threadJoinable.cpp<br><br>#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::thread thr{[]{ std::cout &lt;&lt; "Joinable std::thread" &lt;&lt; std::endl; }};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "thr.joinable(): " &lt;&lt; thr.joinable() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Wenn das Programm ausgeführt wird, beendet es sich abrupt.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160768557_1b5e5541e9.png" title="<ir_inline itemname=bilder_mvp_bild_var2:2 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="text">Beide Threads beenden sich abrupt. Im zweiten Fall besitzt der Thread noch genügend Zeit, seine Nachricht auszugeben: "Joinable std::thread".</div>
<div class="text">Im nächsten Beispiel ersetze ich den Header<i> &lt;thread&gt; </i>mit dem Header <i>"jthread.hpp"</i> und verwende den <i>std::jthread</i> aus dem zukünftigen C++-Standard: </div>
<div class="pre">// jthreadJoinable.cpp<br><br>#include &lt;iostream&gt;<br>#include "jthread.hpp"<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::boolalpha;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::jthread thr{[]{ std::cout &lt;&lt; "Joinable std::thread" &lt;&lt; std::endl; }};<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; "thr.joinable(): " &lt;&lt; thr.joinable() &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Nun ruft der Thread <i>thr</i> automatisch <i>join </i>in seinem Destruktor auf, wenn er noch joinable ist. </div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160768565_4c22ea3312.png" title="<ir_inline itemname=bilder_mvp_bild_var2:3 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="ztitel">Unterbrechen eines <i>std::jthread</i></div>
<div class="text">Das folgende Beispiel stellt die Unterbrechung eines <i>std::jthread</i> genauer vor: </div>
<div class="pre">// interruptJthread.cpp<br><br>#include "jthread.hpp"<br>#include &lt;chrono&gt;<br>#include &lt;iostream&gt;<br><br>using namespace::std::literals;<br><br>int main(){<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::jthread nonInterruptable([]{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int counter{0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (counter &lt; 10){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(0.2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "nonInterruptable: " &lt;&lt; counter &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::jthread interruptable([](std::interrupt_token itoken){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int counter{0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (counter &lt; 10){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(0.2s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itoken.is_interrupted()) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "interruptable: " &lt;&lt; counter &lt;&lt; std::endl; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(1s);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; "Main thread interrupts both jthreads" &lt;&lt; std:: endl;<br>&nbsp;&nbsp;&nbsp; nonInterruptable.interrupt();<br>&nbsp;&nbsp;&nbsp; interruptable.interrupt();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (4)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;<br>&nbsp;&nbsp;&nbsp; <br>}</div>
<div class="text">Ich starte im <i>main</i>-Programm die zwei Threads <i> nonInterruptable</i> und <i>interruptable</i> (Zeilen 1 and 2). Im Gegensatz zum Thread <i>nonInterruptable</i> erhält der Thread <i>interruptable</i> ein <i>std::interrupt_token</i> und verwendet diesen, um in Zeile 3 zu prüfen, ob er unterbrochen wurde:<i> itoken.is_interrupted().</i> Im Fall einer Unterbrechung wird die Lambda-Funktion einfach beendet, sodass der Thread mit seiner Ausführung fertig ist. Der Aufruf <i>interruptable.interrupt()</i> in Zeile 4 stößt die Beendigung des Threads an. Dies gilt nicht für den vorherigen Aufruf <i>nonInterruptable.interrupt()</i>, der keinen Effekt besitzt.<br></div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160768571_4d91a7b965.png" title="<ir_inline itemname=bilder_mvp_bild_var2:4 type=2>" style="max-height: 25px; max-width: 25px;"></div>
<div class="text">Jetzt gehe ich auf die weiteren Details zu Interrupt Tokens, Joining Threads und Bedingungsvariablen ein.<br></div>
<div class="ztitel_kleiner">Interrupt Tokens</div>
<div class="text">Ein Interrupt Token <i>std::interrupt_token</i> bietet geteilte Besitzverhältnisse an und kann dazu verwendet werden, einmalig ein Signal zu schicken, wenn der Token gültig ist. Es besitzt die drei Methoden <i>valid</i>, <i>is_interrupted</i> und <i>interrupt</i>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160768574_76e6e171cb.png" title="<ir_inline itemname=bilder_mvp_bild_var2:5 type=2>" style="max-height: 25px; max-width: 25px;"><br></div>
<div class="text">Wenn der Interrupt Token temporär disabled werden soll, kannst du ihm mit einem per Default erzeugten Interrupt Token austauschen. Ein Default erzeugtes Interrupt Token ist nicht gültig. Der folgende Codeschnipsel zeigt, wie die Fähigkeit, einen Thread zu unterbrechen, disabled und enabled werden kann:</div>
<div class="pre">std::jthread jthr([](std::interrupt_token itoken){<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; std::interrupt_token interruptDisabled; <br>&nbsp;&nbsp;&nbsp; std::swap(itoken, interruptDisabled);&nbsp;&nbsp;&nbsp;&nbsp; // (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; std::swap(itoken, interruptDisabled);&nbsp;&nbsp;&nbsp;&nbsp; // (2)<br>&nbsp;&nbsp;&nbsp; ...<br>}<br></div>
<div class="text"><i>std::interrupt_token</i> <i>interruptDisabled </i>ist nicht gültig. Das heißt, dass der Thread von Zeile (1) bis (2) keine Unterbrechung annehmen kann. Ab Zeile (2) ist es wieder möglich.</div>
<div class="ztitel_kleiner"><i>std::jthread</i></div>
<div class="text">Ein <i>std::jthread </i>ist ein <i>std::thread </i>mit der zusätzlichen Möglichkeit, eine Unterbrechung zu schicken und automatisch in seinem Destruktor <i>join() </i>auszuführen. Um diese Funktionalität anzubieten, besitzt er einen <i>std::interrupt_token</i>.</div>
<div class="text"><img class="rteInlinetag" src="https://heise-cms.de/thumbs//TN_160768587_63e0325434.png" title="<ir_inline itemname=bilder_mvp_bild_var2:7 type=2>" style="max-height: 25px; max-width: 25px;"> </div>
<div class="ztitel_kleiner">Neue wait-Überladungen für Bedingungsvariablen.</div>
<div class="text">Die zwei wait-Varianten <i>wait_for</i> und <i>wait_until</i> der <i>std::condition_variable</i> erhält neue Überladungen. Diese können ein <i>std::interrupt_token</i> annehmen: </div>
<div class="pre">template &lt;class Predicate&gt;<br>bool wait_until(unique_lock&lt;mutex&gt;&amp; lock, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Predicate pred, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interrupt_token itoken);<br><br>template &lt;class Rep, class Period, class Predicate&gt;<br>bool wait_for(unique_lock&lt;mutex&gt;&amp; lock, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Predicate pred, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interrupt_token itoken);<br><br>template &lt;class Clock, class Duration, class Predicate&gt;<br>bool wait_until(unique_lock&lt;mutex&gt;&amp; lock, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Predicate pred, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interrupt_token itoken);</div>
<div class="text">Die neuen Überladungen benötigen ein Prädikat. Die Varianten stellen sicher, benachrichtigt zu werden, wenn eine Unterbrechung an den übergebenen<i> std::interrupt_token itoken</i> geschickt wurde. Nach dem wait-Aufruf lässt sich dann prüfen, ob eine Unterbrechung vorliegt:<br></div>
<div class="pre">cv.wait_until(lock, predicate, itoken);<br>if (itoken.is_interrupted()){<br>&nbsp;&nbsp;&nbsp; // interrupt occurred<br>}</div>
<div class="ztitel">Wie geht's weiter?</div>
<div class="text">Wie ich bereits in meinem letzten Artikel angekündigt habe, geht es in meinen nächsten Artikel um die verbleibenden Regeln zur Definition von Concepts.</div>
<div class="ztitel">Meine Schulung: Multithreading mit modernem C++</div>
<div class="text">Am 12. und 13. November dieses Jahres halte ich denselben Workshop, den ich auf der CppCon 2018 gehalten haben, als Schulung in deutscher Sprache in Rottenburg. Es sind noch Plätze frei und ich freue mich auf diese anspruchsvolle Schulung. </div>
<div class="text">Hier gibt es mehr Details: <a class="" alt="%7B%22href%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.modernescpp.de%2Findex.php%2Fc%22%2C%22subject%22%3A%22%22%2C%22type%22%3A%22E%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22user_params%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22Multithreading%20mit%20modernem%20C%2B%2B%22%2C%22version%22%3A1%7D" href="https://www.modernescpp.de/index.php/c" title="Link auf https://www.modernescpp.de/index.php/c">Multithreading mit modernem C++</a>. </div>
