<div class="vorspann">Nach meinem letzten Artikel zu <a href="/exec/mainmenu.pl?sid=bdc23808f2e7c036e73b1d2ed90d783e&amp;rm=open_article_id&amp;bid=2440950" alt="%7B%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A2440950%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Executors%22%2C%22href%22%3A%22%2Fexec%2Fmainmenu.pl%3Fsid%3Dbdc23808f2e7c036e73b1d2ed90d783e%26rm%3Dopen_article_id%26bid%3D2440950%22%2C%22type%22%3A%22B%22%7D" class="" title="Link auf Beitrag 2440950">Executors</a> schreibe ich heute abschließend über Unified Futures schreiben. Ganz genau beschäftige ich mich mit der langen Geschichte der Futures und beende damit meinen Ausflug von den "C++ Core Guidelines".</div>
<div class="text">Die lange Geschichte der Promise und Futures begann mit C++11.</div>
<div class="ztitel">C++11: Die standardisierten Futures</div>
<div class="text">Tasks in der Gestalt von Promisen und Futures haben einen ambivalenten Ruf in C++. Einerseits sind sie deutlich einfacher zu verwenden als Threads oder Bedingungsvariablen, andererseits besitzen sie eine große Schwäche: Ihre Aufrufe können nicht verknüpft werden. C++20/23 soll diese Schwächen überwinden. Zu Tasks in der Gestalt von <i>std::async</i>, <i>std::packaged_task</i> oder <i>std::promise </i>und <i>std::future</i> habe ich bereits einige Artikel geschrieben: <a alt="%7B%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftasks%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22text%22%3A%22Tasks%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Ftag%2Ftasks%22%2C%22type%22%3A%22E%22%7D" href="https://www.grimm-jaud.de/index.php/blog/tag/tasks" class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/tag/tasks">Tasks</a>. Mit C++20/23 werden wir wohl erweiterte Futures erhalten. </div>
<div class="text">Aufgrund der Schwächen der in C++11 standardisierten Futures,erweiterte <a class="" title="Link auf http://en.cppreference.com/w/cpp/experimental/concurrency" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fexperimental%2Fconcurrency%22%2C%22text%22%3A%22ISO%2FIEC%20TS%2019571%3A2016%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fexperimental%2Fconcurrency%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" href="http://en.cppreference.com/w/cpp/experimental/concurrency">ISO/IEC TS 19571:2016</a> die Futures. Aus der Vogelperspektive betrachtet, können sie nun verknüpft werden. Ein erweiterter Future ist fertig <i>(ready),</i> wenn sein Vorgänger (<i>then</i>), wenn einer seiner Vorgänger (<i>when_any</i>) fertig ist oder wenn alle seiner Vorgänger (<i>when_all</i>) fertig sind. Die erweiterten Futures befinden sich im Namensraum <i>std::experimental</i>. Falls du neugierig bist, hier sind die Details: <a class="" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-future-erweiterungen" alt="%7B%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-future-erweiterungen%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22target%22%3A%22_blank%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22text%22%3A%22%5Bi%5Dstd%3A%3Afuture%5B%2Fi%5D-Erweiterungen%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-future-erweiterungen%22%2C%22type%22%3A%22E%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%7D" href="https://www.grimm-jaud.de/index.php/blog/std-future-erweiterungen">[i]std::future[/i]-Erweiterungen</a>.</div>
<div class="text">Dies war aber noch nicht der Endpunkt einer intensiven Diskussion. Mit der Renaissance von Executors änderte sich auch die "Future" der Futures.</div>
<div class="text">Das Dokument "<a class="" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0701r1.html" alt="%7B%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2017%2Fp0701r1.html%22%2C%22version%22%3A1%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2017%2Fp0701r1.html%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%22P0701r1%3A%20Back%20to%20the%20std2%3A%3Afuture%20Part%20II%22%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0701r1.html">P0701r1: Back to the std2::future Part II</a>"&nbsp; gibt einen großartigen Überblick zu den Nachteilen der standardisierten und der erweiterten Futures.</div>
<div class="ztitel">Nachteile der standardisierten und erweiterten Futures</div>
<div class="text"><b>Futures und Promise sollten nicht mit dem Executor <i>std::thread</i> fest verknüpft sein</b></div>
<div class="text">C++11 besitzt nur einen Executor: <i>std::thread</i>. Konsequenterweise sind daher Futures und <i>std::thread</i> fest verknüpft. Dies änderte sich das erst Mal mit den parallelen Algorithmen der STL. Dies wird sich noch mehr mit den Executors ändern, die es erlauben, den Future zu konfigurieren. Zum Beispiel kann der Future in einem separaten Thread, auf einem Threadpool oder schlicht sequenziell ausgeführt werden.</div>
<div class="ztitel_kleiner">Wo wird die <i>.then</i>-Fortsetzung aufgerufen?</div>
<div class="text">Stelle dir vor, du verwendest eine einfache Fortsetzung wie in dem folgenden Beispiel:</div>
<div class="pre">future f1 = async([]() { return 123; }); <br>future f2 = f1.then([](future f) { <br>&nbsp;&nbsp;&nbsp; return to_string(f.get()); <br>});</div>
<div class="text">Die Frage ist: Wo soll die Fortsetzung ausgeführt werden? Gegenwärtig gibt es ein paar Möglichkeiten.</div>
<div class="text"><ol><li><b>Der Konsument</b>: Der Execution Agent des Konsumenten führt die Fortsetzung aus.</li><li><b>Der Produzent</b>: Der Execution Agent des Produzenten führt die Fortsetzung aus.</li><li><b><i>inline_executor</i>-Semantik</b>: Falls der gemeinsame Zustand fertig ist, wenn die Fortsetzung gesetzt wird, wird die Fortsetzung vom Konsument ausgeführt; falls der gemeinsame Zustand nicht fertig ist, vom Produzenten.</li><li><b><i>thread_executor</i>-Semantik</b>: Ein neuer Thread <i>std::thread</i> führt die Fortsetzung aus.<br></li></ol></div>
<div class="text">Insbesondere die ersten zwei Möglichkeiten besitzen einen deutlichen Nachteil: Sie blockieren. Im ersten Fall wartet der Konsument, bis der gemeinsame Zustand fertig ist; im zweiten Fall wartet der Produzent, bis der gemeinsame Zustand fertig ist. </div>
<div class="text">Das Dokument P0701r184 enthält ein paar Beispiele für die Fortsetzung der Ausführung:<br></div>
<div class="pre">auto i = std::async(thread_pool, f).then(g).then(h);<br>// f, g and h are executed on thread_pool.<br><br>auto i = std::async(thread_pool, f).then(g, gpu).then(h);<br>// f is executed on thread_pool, g and h are executed on gpu.<br><br>auto i = std::async(inline_executor, f).then(g).then(h);<br>// h(g(f())) are invoked in the calling execution agent.<br></div>
<div class="ztitel_kleiner">Die Übergabe des futures an <i>.then</i> ist kompliziert</div>
<div class="text">Da der Future und nicht sein Wert an die Fortsetzung übergeben wird, ist die Syntax recht kompliziert:<br></div>
<div class="pre">std::future f1 = std::async([]() { return 123; });<br>std::future f2 = f1.then([](std::future f) {<br>&nbsp;&nbsp;&nbsp; return std::to_string(f.get());<br>});</div>
<div class="text">Nun nehme ich an, dass der Wert direkt übergeben werden kann, da <i>to_string</i> für <i>std::future</i> überladen ist:</div>
<div class="pre">std::future f1 = std::async([]() { return 123; });<br>std::future f2 = f1.then(std::to_string);<br></div>
<div class="ztitel_kleiner">Die Rückgabetypen von when_all und when_any sind zu kompliziert<br></div>
<div class="text">Mein Artikel <a href="https://www.grimm-jaud.de/index.php/blog/std-future-erweiterungen" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-future-erweiterungen%22%2C%22text%22%3A%22std%3A%3Afuture%20Erweiterungen%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-future-erweiterungen%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D" title="Link auf https://www.grimm-jaud.de/index.php/blog/std-future-erweiterungen" class="">std::future Erweiterungen</a> stellt die aufwendige Verwendung von<i> when_all</i> und <i>when_any </i>genauer vor.<br></div>
<div class="ztitel_kleiner">Futures können im Destruktor blockieren<br></div>
<div class="text">"Fire and Forget"-Futures hören sich sehr vielversprechend an, besitzen aber einen großen Nachteil. Ein Future, der durch [i]std::async[/i] erzeugt wird, wartet in seinem Destruktor, bis der Promise fertig ist. Was nach Concurrency ausschaut, wird daher tatsächlich sequenziell ausgeführt. Das Dokument P0701r1 bringt es auf den Punkt: das ist nicht tolerierbar und fehleranfällig.</div>
<div class="text">Ich gehe auf dieses besondere Verhalten der "Fire and Forget"-Futures bereits in dem Artikel "<a title="Link auf https://www.grimm-jaud.de/index.php/blog/std-async-warten-im-destruktor" class="" href="https://www.grimm-jaud.de/index.php/blog/std-async-warten-im-destruktor" alt="%7B%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%2C%22destination%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-async-warten-im-destruktor%22%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22version%22%3A1%2C%22type%22%3A%22E%22%2C%22href%22%3A%22https%3A%2F%2Fwww.grimm-jaud.de%2Findex.php%2Fblog%2Fstd-async-warten-im-destruktor%22%2C%22text%22%3A%22Besondere%20Futures%20mit%20std%3A%3Aasync%22%7D">Besondere Futures mit std::async</a>" ein. </div>
<div class="ztitel_kleiner">Werte und die Werte der Futures sollten sich einfach zusammen verwenden lassen<br></div>
<div class="text">In C++11 gibt keinen einfachen Weg, einen Future zu erzeugen. Dazu ist immer ein Promise notwendig: <br></div>
<div class="pre">std::promise&lt;std::string&gt; p;<br>std::future&lt;std::string&gt; fut = p.get_future();<br>p.set_value("hello");</div>
<div class="text">Dies wird sich wohl mit der Funktion [i]std::make_ready_future[/i] der erweiterten Futures ändern.</div>
<div class="pre">std::future&lt;std::string&gt; fut = make_ready_future("hello");</div>
<div class="text">Durch die gleichzeitige Verwendung von Futures und Werten als Argumente ist der Aufruf von <i>when_all</i> deutlich einfacher: <b><br></b></div>
<div class="pre">bool f(std::string, double, int);<br><br>std::future&lt;std::string&gt; a = /* ... */;<br>std::future&lt;int&gt; c = /* ... */;<br><br>std::future&lt;bool&gt; d1 = when_all(a, make_ready_future(3.14), c).then(f);<br>// f(a.get(), 3.14, c.get())<br><br>std::future&lt;bool&gt; d2 = when_all(a, 3.14, c).then(f);<br>// f(a.get(), 3.14, c.get())<br></div>
<div class="text">Leider ist weder die syntaktische Form <i>d1</i> noch <i>d2 </i>mit den erweiterten Futures möglich.</div>
<div class="ztitel">Fünf neue Konzepte</div>
<div class="text">Er gibt fünf neue Konzepte für Futures und Promise in dem Proposal <a alt="%7B%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp1054r0.html%22%2C%22type%22%3A%22E%22%2C%22text%22%3A%221054R085%22%2C%22version%22%3A1%2C%22subject%22%3A%22%22%2C%22user_params%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22anchor%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp1054r0.html%22%2C%22custom%22%3A%7B%7D%2C%22ir_link%22%3A1%7D" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1054r0.html" title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1054r0.html" class="">1054R085</a> zu Unfied Futures.</div>
<div class="text"><ul><li><b>i][FutureContinuation[/i]</b>: aufrufbare Objekte, die als Argument einen Future mit einem Wert oder einer Ausnahme annehmen können.</li><li><b>[i]SemiFuture/i]</b>: diese können an einen Executor gebunden werden, sodass ein [i]ContinuableFuture[/i] (<i>f = sf.via(exec)</i>) entsteht.</li><li><b>[i]ContinuableFuture[/i]</b>: ist eine Verfeinerung eines <b>[i]SemiFuture[/i]</b>, an den sich eine <b>[i]FutureContinuation[/i] </b>anheften lässt: <i>f.then(c)</i>. Die <b>FutureContinuation</b> <i>c</i> wird ausgeführt, wenn der Executor des Future <i>f</i> fertig ist. <br></li><li><b>[i]SharedFuture[/i]</b>: stellt eine Verfeinerung eines [i]<b>ContinuableFuture</b>[/i] dar, der mehrere <b>[i]FutureContinuation[/i]s</b> besitzen kann.</li><li><b>Promise:</b> Jeder Promise ist mit einem Future assoziiert. Der Promise stellt den Future mit einem Wert oder einer Ausnahme fertig.</li></ul></div>
<div class="text">Das Dokument bietet bereits eine Deklaration der neuen Konzepte an:<br></div>
<div class="pre">template &lt;typename T&gt;<br>struct FutureContinuation<br>{<br>&nbsp; // At least one of these two overloads exists:<br>&nbsp; auto operator()(T value);<br>&nbsp; auto operator()(exception_arg_t, exception_ptr exception);<br>};<br><br>template &lt;typename T&gt;<br>struct SemiFuture<br>{<br>&nbsp; template &lt;typename Executor&gt;<br>&nbsp; ContinuableFuture&lt;Executor, T&gt; via(Executor&amp;&amp; exec) &amp;&amp;;<br>};<br><br>template &lt;typename Executor, typename T&gt;<br>struct ContinuableFuture<br>{<br>&nbsp; template &lt;typename RExecutor&gt;<br>&nbsp; ContinuableFuture&lt;RExecutor, T&gt; via(RExecutor&amp;&amp; exec) &amp;&amp;;<br><br>&nbsp; template &lt;typename Continuation&gt;<br>&nbsp; ContinuableFuture&lt;Executor, auto&gt; then(Continuation&amp;&amp; c) &amp;&amp;;<br>};<br><br>template &lt;typename Executor, typename T&gt;<br>struct SharedFuture<br>{<br>&nbsp; template &lt;typename RExecutor&gt;<br>&nbsp; ContinuableFuture&lt;RExecutor, auto&gt; via(RExecutor&amp;&amp; exec);<br><br>&nbsp; template &lt;typename Continuation&gt;<br>&nbsp; SharedFuture&lt;Executor, auto&gt; then(Continuation&amp;&amp; c);<br>};<br><br>template &lt;typename T&gt;<br>struct Promise<br>{<br>&nbsp; void set_value(T value) &amp;&amp;;<br><br>&nbsp; template &lt;typename Error&gt;<br>&nbsp; void set_exception(Error exception) &amp;&amp;;<br>&nbsp; bool valid() const;<br>};<br></div>
<div class="text">Der Einfachheit halber will ich die fünf Konzepte kurz zusammenfassen.<br></div>
<div class="text"><ul><li>Eine <b>[i]FutureContinuation</b>[/i] kann mit einem Value oder einer Ausnahme aufgerufen werden.</li><li>Alle Futures <b>([i]SemiFuture[/i],</b> [i]<b>ContinuableFuture</b>[/i] und [i]<b>SharedFuture[/i])</b> besitzen eine Methode <i>via,</i> die einen Executor annimmt, der ein <b>[i]ContinuableFuture[/i]</b> zurückgibt. Die Methode <i>via</i> erlaubt eine Konvertierung von einem in einen anderen Future-Typ, indem ein anderer Executor zum Einsatz kommt.</li><li>Nur eine <b>[i]ContinuableFuture[/i]</b> und eine [i]<b>SharedFuture[/i]</b> besitzen die <i>then</i>-Methode für die Fortsetzung. Die Methode benötigt eine [i]<b>FutureContinuation</b>[/i] und gibt einen <b>[i]ContinuableFuture[/i]</b> zurück.</li><li>Ein <b>Promise</b> kann einen Wert oder eine Ausnahme setzen. <br></li></ul></div>
<div class="ztitel">Zukünftige Arbeit<br></div>
<div class="text">Das Proposal <a title="Link auf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1054r0.html" class="" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1054r0.html" alt="%7B%22type%22%3A%22E%22%2C%22href%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp1054r0.html%22%2C%22text%22%3A%221054R085%22%2C%22user_params%22%3A%22%22%2C%22subject%22%3A%22%22%2C%22version%22%3A1%2C%22anchor%22%3A%22%22%2C%22alias%22%3A%22%22%2C%22target%22%3A%22_blank%22%2C%22destination%22%3A%22http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp1054r0.html%22%2C%22ir_link%22%3A1%2C%22custom%22%3A%7B%7D%7D">1054R085</a> lässt ein paar Fragen offen:</div>
<div class="text"><ul><li> Forward-Progress-Garantien für Futures und Promise.</li><li>Anforderungen an die Synchronisation von Futures und Promise an Ausführungen, die nicht concurrent sind.</li><li>Das Zusammenspiel mit den standardisierten <i>std::future</i> und <i>std::promise</i>.</li><li>Future unwrapping für [i]future&lt;future&gt;&gt;[/i] oder noch kompliziertere Ausdrücke. Future unwrapping soll in dem konkreten Fall den äußeren Future entfernen.<br></li><li>Umsetzung von [i]when_al[/i]l, [i]when_any[/i] oder [i]when_n[/i].<br></li><li>Zusammenspiel mit [i]sys::async[/i].<br></li></ul></div>
<div class="utitel">Wie geht's weiter?<br></div>
<div class="text">Mein nächster Artikel setzt die Reise durch die "C++ Core Guidelines" fort. In ihm werde ich mich mit der lock-freien Programmierung beschäftigen.</div>